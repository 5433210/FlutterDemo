import 'dart:async';
import 'dart:convert';
import 'dart:io';

import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:http/http.dart' as http;
import 'package:image/image.dart' as img;
import 'package:uuid/uuid.dart';

import '../../../application/providers/service_providers.dart';
import '../../../application/services/character/character_service.dart';
import '../../../infrastructure/logging/edit_page_logger_extension.dart';
import '../../../infrastructure/logging/logger.dart';
import '../../../infrastructure/logging/practice_edit_logger.dart';
import '../../../infrastructure/providers/cache_providers.dart';
import '../../../l10n/app_localizations.dart';
import '../../../utils/image_path_converter.dart';
import '../../dialogs/practice_save_dialog.dart';
import '../../providers/persistent_panel_provider.dart';
import '../../widgets/common/persistent_resizable_panel.dart';
import '../../widgets/common/persistent_sidebar_toggle.dart';
import '../../widgets/page_layout.dart';
import '../../widgets/practice/file_operations.dart';
import '../../widgets/practice/guideline_alignment/guideline_types.dart';
import '../../widgets/practice/m3_edit_toolbar.dart';
import '../../widgets/practice/m3_page_thumbnail_strip.dart';
import '../../widgets/practice/m3_practice_layer_panel.dart';
import '../../widgets/practice/m3_top_navigation_bar.dart';
import '../../widgets/practice/practice_edit_controller.dart';
import '../../widgets/practice/property_panels/m3_practice_property_panels.dart';
import '../../widgets/practice/undo_operations.dart';
import 'handlers/keyboard_handler.dart';
import 'utils/practice_edit_utils.dart';
import 'widgets/m3_practice_edit_canvas.dart';
import 'widgets/practice_title_edit_dialog.dart';

/// Material 3 version of the Practice Edit page
class M3PracticeEditPage extends ConsumerStatefulWidget {
  final String? practiceId;

  const M3PracticeEditPage({super.key, this.practiceId});

  @override
  ConsumerState<M3PracticeEditPage> createState() => _M3PracticeEditPageState();
}

class _M3PracticeEditPageState extends ConsumerState<M3PracticeEditPage>
    with WidgetsBindingObserver {
  // üîç[TRACKING] ÈùôÊÄÅÈáçÂª∫ËÆ°Êï∞Âô®
  static int _propertyPanelBuildCount = 0;
  static int _lastSelectedCount = -1;
  static String? _lastSelectedLayerId;
  static DateTime _lastPropertyPanelLogTime = DateTime.now();

  // Controller
  late final PracticeEditController _controller;

  // Drag optimization flag to prevent unnecessary rebuilds

  // Current tool
  String _currentTool = '';

  // Clipboard monitoring timer
  Timer? _clipboardMonitoringTimer;
  // Clipboard
  Map<String, dynamic>? _clipboardElement;
  bool _clipboardHasContent = false; // Track if clipboard has valid content
  // ValueNotifier for clipboard state to avoid setState during drag operations
  final ValueNotifier<bool> _clipboardNotifier = ValueNotifier<bool>(false);

  // Preview mode
  bool _isPreviewMode = false;
  // Add a GlobalKey for screenshots
  // final GlobalKey canvasKey = GlobalKey();

  // Add a GlobalKey for canvas reference (without type parameter)
  final GlobalKey _canvasKey = GlobalKey();

  // Keyboard focus node
  late FocusNode _focusNode;

  // Zoom controller
  late TransformationController _transformationController;

  // Control page thumbnails display state
  bool _showThumbnails = false;
  // Control toolbar visibility
  bool _showToolbar = true;
  // Control panel visibility - will be initialized from persistent state
  bool _isLeftPanelOpen = false; // Default to closed as requested
  bool _isRightPanelOpen = true;

  // Keyboard handler
  late KeyboardHandler _keyboardHandler;
  // È°µÈù¢ÂàáÊç¢Ë∑üË∏™ÂèòÈáè
  int _lastPageIndex = -1;
  Map<String, dynamic>? _formatBrushStyles;
  bool _isFormatBrushActive = false;
  // Track whether the practice has been loaded to prevent multiple loads
  // This prevents the "Practice loaded successfully" message from appearing
  // every time didChangeDependencies is called (e.g., on viewport size changes)
  bool _practiceLoaded = false;

  // ‰øùÂ≠òUIÁõëÂê¨Âô®ÂõûË∞ÉÂºïÁî®ÔºåÁî®‰∫éÊ≠£Á°ÆÊ≥®ÈîÄ
  VoidCallback? _propertyPanelListener;

  @override
  Widget build(BuildContext context) {
    _controller.l10n = AppLocalizations.of(context); // Set l10n for controller
    // Remove unused l10n variable
    return PopScope(
      canPop: false,
      onPopInvokedWithResult: (didPop, result) async {
        if (didPop) return;
        final shouldPop = await _onWillPop();
        if (shouldPop && context.mounted) {
          Navigator.of(context).pop();
        }
      },
      child: PageLayout(
        toolbar: AnimatedBuilder(
          animation: _controller,
          builder: (context, child) {
            return M3TopNavigationBar(
              controller: _controller,
              practiceId: widget.practiceId,
              isPreviewMode: _isPreviewMode,
              onTogglePreviewMode: () {
                setState(() {
                  _isPreviewMode = !_isPreviewMode; // Toggle preview mode
                  _controller
                      .togglePreviewMode(_isPreviewMode); // Notify controller
                });

                // Reset view position when toggling preview mode
                // Âª∂ËøüÈáçÁΩÆËßÜÂõæ‰ΩçÁΩÆÔºåÁ°Æ‰øùÈ¢ÑËßàÊ®°ÂºèUIÂÆåÂÖ®Êõ¥Êñ∞ÂÆåÊàê
                Future.delayed(const Duration(milliseconds: 100), () {
                  if (mounted) {
                    _controller.resetViewPosition();
                  }
                });
              },
              showThumbnails: _showThumbnails,
              onThumbnailToggle: (bool value) {
                setState(() {
                  _showThumbnails = value; // Update thumbnails display state
                });
              },
              showToolbar: _showToolbar,
              onToggleToolbar: () {
                setState(() {
                  _showToolbar = !_showToolbar; // Toggle toolbar visibility
                });
              },
            );
          },
        ),
        body: _buildBody(context),
      ),
    );
  }

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();

    // Load practice in didChangeDependencies instead of initState
    // This way we can safely use context
    // Only load once to prevent repeated loading when dependencies change (e.g., viewport size)
    if (widget.practiceId != null && !_practiceLoaded) {
      _practiceLoaded = true;
      _loadPractice(widget.practiceId!);
    }
  }

  @override
  void didChangeMetrics() {
    super.didChangeMetrics();
    // When window size changes (maximize/restore), automatically reset view position
    // Use a small delay to ensure the UI has finished updating
    Future.delayed(const Duration(milliseconds: 100), () {
      if (mounted) {
        _controller.resetViewPosition();
      }
    });
  }

  @override
  void dispose() {
    // ‚úÖ Ê≥®ÈîÄÂ±ûÊÄßÈù¢ÊùøÁöÑÊô∫ËÉΩÁä∂ÊÄÅÁõëÂê¨Âô®
    _unregisterPropertyPanelFromIntelligentDispatcher();

    // Remove window observer
    WidgetsBinding.instance.removeObserver(this);

    // Clear undo/redo stack
    _controller.clearUndoRedoHistory();

    // Remove keyboard listeners
    HardwareKeyboard.instance.removeHandler(_keyboardHandler.handleKeyEvent);
    _focusNode.dispose();

    // Remove controller listener
    _controller.removeListener(_syncToolState);

    // Release zoom controller
    _transformationController.dispose();

    _controller.dispose(); // Cancel clipboard monitoring timer
    _clipboardMonitoringTimer?.cancel();

    // Dispose of the clipboard ValueNotifier
    _clipboardNotifier.dispose();

    super.dispose();
  }

  /// Go to previous page
  void _goToPreviousPage() {
    final currentIndex = _controller.state.currentPageIndex;
    if (currentIndex > 0) {
      _controller.switchToPage(currentIndex - 1);
    }
  }

  /// Go to next page
  void _goToNextPage() {
    final currentIndex = _controller.state.currentPageIndex;
    if (currentIndex < _controller.state.pages.length - 1) {
      _controller.switchToPage(currentIndex + 1);
    }
  }

  /// ÁîüÊàêÈöèÊú∫Â≠óÁ¨¶‰∏≤
  String getRandomString(int length) {
    const chars = 'abcdefghijklmnopqrstuvwxyz0123456789';
    final random = DateTime.now().millisecondsSinceEpoch.toString();
    return String.fromCharCodes(
      Iterable.generate(
        length,
        (_) => chars.codeUnitAt((random.hashCode + _) % chars.length),
      ),
    );
  }

  @override
  void initState() {
    super.initState();

    // Add window observer to monitor window changes
    WidgetsBinding.instance.addObserver(this);

    // Create or get the PracticeService instance
    final practiceService = ref.read(practiceServiceProvider);
    _controller = PracticeEditController(practiceService);
    _controller.setCanvasKey(_canvasKey);

    // Set preview mode callback
    _controller.setPreviewModeCallback((isPreview) {
      setState(() {
        _isPreviewMode = isPreview;
      });
    });

    // Add listener to synchronize local _currentTool with controller's state.currentTool
    _controller.addListener(_syncToolState);

    // Initialize keyboard focus node
    _focusNode = FocusNode();

    // Initialize zoom controller
    _transformationController = TransformationController();

    // Initialize keyboard handler
    _initKeyboardHandler();
    _controller.state.currentTool = _currentTool;

    // Initialize panel states from persistent storage
    _initializePanelStates();

    // Schedule a callback to connect the canvas after build
    WidgetsBinding.instance.addPostFrameCallback((_) {
      _setupCanvasReference();
      _registerPropertyPanelToIntelligentDispatcher();
    });

    // Start clipboard monitoring
    _checkClipboardContent().then((hasContent) {
      _clipboardHasContent = hasContent;
      _clipboardNotifier.value = hasContent;

      if (mounted) {
        setState(() {});
      }
    });

    // Start periodic clipboard monitoring
    _startClipboardMonitoring();
  }

  /// Add a new page
  void _addNewPage() {
    EditPageLogger.editPageInfo(
      'üÜï M3PracticeEditPage._addNewPage Ë¢´Ë∞ÉÁî®',
      data: {
        'currentPagesCount': _controller.state.pages.length,
        'timestamp': DateTime.now().toIso8601String(),
      },
    );

    // Use enhanced version with template inheritance from previous page
    PracticeEditUtils.addNewPage(_controller, context);

    EditPageLogger.editPageInfo(
      '‚úÖ PracticeEditUtils.addNewPage Ë∞ÉÁî®ÂÆåÊàê',
      data: {
        'finalPagesCount': _controller.state.pages.length,
        'timestamp': DateTime.now().toIso8601String(),
      },
    );

    // üÜï Ê†πÊçÆÈ°µÈù¢Êï∞ÈáèËá™Âä®Êõ¥Êñ∞Áº©Áï•ÂõæÊòæÁ§∫Áä∂ÊÄÅ
    _updateThumbnailVisibilityBasedOnPageCount();

    // The controller will notify listeners automatically through intelligent notification
  }

  /// Â∫îÁî®Ê†ºÂºèÂà∑Ê†∑ÂºèÂà∞ÈÄâ‰∏≠ÂÖÉÁ¥†
  void _applyFormatBrush() {
    if (!_isFormatBrushActive || _formatBrushStyles == null) return;
    final selectedElements = _controller.state.getSelectedElements();
    if (selectedElements.isEmpty) return;
    final stopwatch = Stopwatch()..start();
    // ÂáÜÂ§áÊ†ºÂºèÂà∑Êìç‰ΩúÊâÄÈúÄÁöÑÊï∞ÊçÆ
    final List<String> targetElementIds = [];
    final List<Map<String, dynamic>> oldPropertiesList = [];
    final List<Map<String, dynamic>> newPropertiesList = []; // ÂØπÊØè‰∏™ÈÄâ‰∏≠ÁöÑÂÖÉÁ¥†ËÆ°ÁÆóÊñ∞ÊóßÂ±ûÊÄß
    for (final element in selectedElements) {
      final elementId = element['id'] as String;
      final elementType = element['type'];

      // Ê∑±Êã∑Ë¥ùÂéüÂßãÂÖÉÁ¥†‰Ωú‰∏∫ÊóßÂ±ûÊÄß
      final oldProperties = _deepCopyElement(element);

      // Ê∑±Êã∑Ë¥ùÂéüÂßãÂÖÉÁ¥†Âπ∂Â∫îÁî®Ê†ºÂºèÂà∑Ê†∑Âºè‰Ωú‰∏∫Êñ∞Â±ûÊÄß
      final newProperties = _deepCopyElement(element);

      // Â∫îÁî®ÈÄöÁî®Ê†∑Âºè - Â§ñÂ±ÇÂ±ûÊÄß
      if (_formatBrushStyles!.containsKey('rotation')) {
        newProperties['rotation'] = _formatBrushStyles!['rotation'];
      }
      if (_formatBrushStyles!.containsKey('opacity')) {
        newProperties['opacity'] = _formatBrushStyles!['opacity'];
      }
      if (_formatBrushStyles!.containsKey('width')) {
        newProperties['width'] = _formatBrushStyles!['width'];
      }
      if (_formatBrushStyles!.containsKey('height')) {
        newProperties['height'] = _formatBrushStyles!['height'];
      }

      // Â∫îÁî®ÁâπÂÆöÁ±ªÂûãÁöÑÊ†∑Âºè
      if (elementType == 'text') {
        // ÂÖºÂÆπÊóßÁâàÊú¨ÁöÑÊñáÊú¨ÂÖÉÁ¥†ÁªìÊûÑ
        if (_formatBrushStyles!.containsKey('fontSize')) {
          newProperties['fontSize'] = _formatBrushStyles!['fontSize'];
        }
        if (_formatBrushStyles!.containsKey('fontWeight')) {
          newProperties['fontWeight'] = _formatBrushStyles!['fontWeight'];
        }
        if (_formatBrushStyles!.containsKey('fontStyle')) {
          newProperties['fontStyle'] = _formatBrushStyles!['fontStyle'];
        }
        if (_formatBrushStyles!.containsKey('textColor')) {
          newProperties['textColor'] = _formatBrushStyles!['textColor'];
        }
        if (_formatBrushStyles!.containsKey('textAlign')) {
          newProperties['textAlign'] = _formatBrushStyles!['textAlign'];
        }

        // Êñ∞ÁâàÊú¨ÊñáÊú¨ÂÖÉÁ¥†ÁªìÊûÑÂ§ÑÁêÜ - contentÂ±ûÊÄß
        if (newProperties.containsKey('content') &&
            newProperties['content'] is Map) {
          Map<String, dynamic> content =
              Map<String, dynamic>.from(newProperties['content'] as Map);

          // Â∫îÁî®ÊñáÊú¨ÂÖÉÁ¥†ÁöÑcontentÂ±ûÊÄß
          final propertiesToApply = [
            'backgroundColor',
            'fontColor',
            'fontFamily',
            'fontSize',
            'fontStyle',
            'fontWeight',
            'letterSpacing',
            'lineHeight',
            'padding',
            'textAlign',
            'verticalAlign',
            'writingMode'
          ];

          // Â∫îÁî®ÊâÄÊúâÊåáÂÆöÁöÑÊ†∑ÂºèÂ±ûÊÄß
          for (final property in propertiesToApply) {
            final brushKey = 'content_$property';
            if (_formatBrushStyles!.containsKey(brushKey)) {
              content[property] = _formatBrushStyles![brushKey];
            }
          }

          // Êõ¥Êñ∞ÂÖÉÁ¥†ÁöÑcontentÂ±ûÊÄß
          newProperties['content'] = content;
        }
      } else if (elementType == 'image') {
        // ÂõæÂÉèÂÖÉÁ¥†ÁöÑcontentÂ±ûÊÄßÂ§ÑÁêÜ
        if (newProperties.containsKey('content') &&
            newProperties['content'] is Map) {
          Map<String, dynamic> content =
              Map<String, dynamic>.from(newProperties['content'] as Map);

          // Â∫îÁî®ÂõæÂÉèÂÖÉÁ¥†ÁöÑcontentÂ±ûÊÄß
          final propertiesToApply = [
            'backgroundColor',
            'fit',
            'isFlippedHorizontally',
            'isFlippedVertically',
            'rotation',
            // üÜï Ê∑ªÂä†‰∫åÂÄºÂåñÂ§ÑÁêÜÂèÇÊï∞ÔºàÂè™Â∫îÁî®ËÆæÁΩÆÔºå‰∏çÂ∫îÁî®Êï∞ÊçÆÔºâ
            'isBinarizationEnabled',
            'binaryThreshold',
            'isNoiseReductionEnabled',
            'noiseReductionLevel',
            // Ê≥®ÊÑèÔºö‰∏çÂ∫îÁî® binarizedImageDataÔºåÂõ†‰∏∫ËøôÊòØÂ§ÑÁêÜÂêéÁöÑÊï∞ÊçÆÔºå‰∏çÊòØÊ†ºÂºèËÆæÁΩÆ
            // üÜï Ê∑ªÂä†ÂÖ∂‰ªñÂõæÂÉèÂ§ÑÁêÜÂèÇÊï∞
            'fitMode',
            'alignment',
            'cropX',
            'cropY',
            'cropWidth',
            'cropHeight',
            'cropTop',
            'cropBottom',
            'cropLeft',
            'cropRight',
          ];

          // Â∫îÁî®ÊâÄÊúâÊåáÂÆöÁöÑÊ†∑ÂºèÂ±ûÊÄß
          for (final property in propertiesToApply) {
            final brushKey = 'content_$property';
            if (_formatBrushStyles!.containsKey(brushKey)) {
              content[property] = _formatBrushStyles![brushKey];
            }
          }

          // Êõ¥Êñ∞ÂÖÉÁ¥†ÁöÑcontentÂ±ûÊÄß
          newProperties['content'] = content;
        }
      } else if (elementType == 'collection') {
        // ÈõÜÂ≠óÂÖÉÁ¥†ÁâπÊúâÊ†∑ÂºèÂ§ÑÁêÜ

        // Â∫îÁî®content‰∏≠ÁöÑÊâÄÊúâÊ†∑ÂºèÂ±ûÊÄßÔºàÈô§‰∫ÜcharactersÔºâ
        if (newProperties.containsKey('content') &&
            newProperties['content'] is Map) {
          Map<String, dynamic> content =
              Map<String, dynamic>.from(newProperties['content'] as Map);

          // ‰øùÂ≠òÂéüÊúâÁöÑcharacters
          final originalCharacters =
              content.containsKey('characters') ? content['characters'] : null;

          // Ê†πÊçÆÈúÄÊ±Ç‰∏≠ÁöÑÂ±ûÊÄßÂàóË°®Â∫îÁî®ÊâÄÊúâÈúÄË¶ÅÊîØÊåÅÁöÑÂ±ûÊÄß
          final propertiesToApply = [
            'fontSize',
            'fontColor',
            'backgroundColor',
            'backgroundTexture',
            'charSpacing',
            'direction',
            'gridLines',
            'letterSpacing',
            'lineSpacing',
            'padding',
            'showBackground',
            'textureApplicationRange',
            'textureFillMode',
            'textureOpacity',
            'enableSoftLineBreak', // Ê∑ªÂä†Ëá™Âä®Êç¢Ë°åÂ±ûÊÄß
          ];

          // Â∫îÁî®ÊâÄÊúâÊåáÂÆöÁöÑÊ†∑ÂºèÂ±ûÊÄß
          for (final property in propertiesToApply) {
            final brushKey = 'content_$property';
            if (_formatBrushStyles!.containsKey(brushKey)) {
              content[property] = _formatBrushStyles![brushKey];
            }
          }

          // Â¶ÇÊûúÂ≠òÂú®charactersÔºåÊÅ¢Â§çÂéüÊù•ÁöÑÂÄº
          if (originalCharacters != null) {
            content['characters'] = originalCharacters;
          } // Êõ¥Êñ∞ÂÖÉÁ¥†ÁöÑcontentÂ±ûÊÄßÔºå‰ΩÜ‰øùÁïôÂéüÊúâÁöÑcharacters
          newProperties['content'] = content;
        }
      } else if (elementType == 'group') {
        // ÁªÑÂêàÂÖÉÁ¥†Ê†∑ÂºèÂ§ÑÁêÜ - ‰∏ªË¶ÅÊòØÈÄèÊòéÂ∫¶ÂíåÂü∫Êú¨Â±ûÊÄß
        // ÁªÑÂêàÂÖÉÁ¥†ÈÄöÂ∏∏Âè™Â∫îÁî®Âü∫Êú¨ÁöÑÂèòÊç¢Â±ûÊÄßÔºåÂ∑≤Âú®ÈÄöÁî®Ê†∑ÂºèÈÉ®ÂàÜÂ§ÑÁêÜ

        // Â∫îÁî®content‰∏≠ÁöÑÊ†∑ÂºèÂ±ûÊÄßÔºàÂ¶ÇÊûúÂ≠òÂú®Ôºâ
        if (newProperties.containsKey('content') &&
            newProperties['content'] is Map) {
          Map<String, dynamic> content =
              Map<String, dynamic>.from(newProperties['content'] as Map);

          // Â∫îÁî®ÁªÑÂêàÂÖÉÁ¥†ÂèØËÉΩÁöÑÊ†∑ÂºèÂ±ûÊÄß
          final propertiesToApply = [
            'backgroundColor',
            'borderColor',
            'borderWidth',
            'cornerRadius',
            'shadowColor',
            'shadowOpacity',
            'shadowOffset',
            'shadowBlur',
          ];

          // Â∫îÁî®ÊâÄÊúâÊåáÂÆöÁöÑÊ†∑ÂºèÂ±ûÊÄß
          for (final property in propertiesToApply) {
            final brushKey = 'content_$property';
            if (_formatBrushStyles!.containsKey(brushKey)) {
              content[property] = _formatBrushStyles![brushKey];
            }
          }

          // Êõ¥Êñ∞ÂÖÉÁ¥†ÁöÑcontentÂ±ûÊÄß
          newProperties['content'] = content;
        }
      }

      // Ê∑ªÂä†Âà∞Êìç‰ΩúÂàóË°®
      targetElementIds.add(elementId);
      oldPropertiesList.add(oldProperties);
      newPropertiesList.add(newProperties);
    }

    // ‰ΩøÁî®FormatPainterOperation‰∏éÊí§ÈîÄ/ÈáçÂÅöÁ≥ªÁªüÈõÜÊàê
    final formatPainterOperation = FormatPainterOperation(
      targetElementIds: targetElementIds,
      oldPropertiesList: oldPropertiesList,
      newPropertiesList: newPropertiesList,
      pageIndex: _controller.state.currentPageIndex,
      pageId: _controller.state.currentPage?['id'] ?? 'unknown',
      updateElement: (elementId, properties) {
        // Êõ¥Êñ∞ÊåáÂÆöÂÖÉÁ¥†ÁöÑÂ±ûÊÄß
        if (_controller.state.currentPageIndex >= 0 &&
            _controller.state.currentPageIndex <
                _controller.state.pages.length) {
          final page =
              _controller.state.pages[_controller.state.currentPageIndex];
          final elements = page['elements'] as List<dynamic>;
          final elementIndex = elements.indexWhere((e) => e['id'] == elementId);

          if (elementIndex >= 0) {
            // Êõ¥Êñ∞ÂÖÉÁ¥†Â±ûÊÄß
            elements[elementIndex] = properties;

            // üÜï ÂØπÂõæÂÉèÂÖÉÁ¥†Ëß¶ÂèëÂõæÂÉèÂ§ÑÁêÜÁÆ°ÈÅì
            if (properties['type'] == 'image') {
              final content = properties['content'] as Map<String, dynamic>?;
              if (content != null) {
                // Ê£ÄÊü•ÊòØÂê¶Êúâ‰∫åÂÄºÂåñÁõ∏ÂÖ≥ÁöÑÂèÇÊï∞ÂèòÂåñ
                final hasBinarizationSettings =
                    content.containsKey('isBinarizationEnabled') ||
                        content.containsKey('binaryThreshold') ||
                        content.containsKey('isNoiseReductionEnabled') ||
                        content.containsKey('noiseReductionLevel');

                // Ê£ÄÊü•ÊòØÂê¶ÊúâÁøªËΩ¨ÂèÇÊï∞ÂèòÂåñ
                final hasFlipSettings =
                    content.containsKey('isFlippedHorizontally') ||
                        content.containsKey('isFlippedVertically');

                if (hasBinarizationSettings || hasFlipSettings) {
                  // Ê†áËÆ∞ÈúÄË¶ÅÈáçÊñ∞Â§ÑÁêÜÂõæÂÉè
                  content['needsReprocessing'] = true;
                  content['triggerImageProcessing'] = true; // üÜï Ê∑ªÂä†ÁâπÊÆäÊ†áËÆ∞

                  // Ê∏ÖÈô§Áé∞ÊúâÁöÑÂ§ÑÁêÜÂêéÊï∞ÊçÆÔºåÂº∫Âà∂ÈáçÊñ∞Â§ÑÁêÜ
                  content.remove('binarizedImageData');
                  content.remove('processedImageData');
                  content.remove('cachedProcessedImage');

                  PracticeEditLogger.debugDetail('Ê†ºÂºèÂà∑Ëß¶ÂèëÂõæÂÉèÂ§ÑÁêÜ', data: {
                    'elementId': elementId,
                    'hasBinarizationSettings': hasBinarizationSettings,
                    'hasFlipSettings': hasFlipSettings,
                  });

                  // Áõ¥Êé•ÊâßË°åÂõæÂÉèÂ§ÑÁêÜ
                  // ‰ΩøÁî®ÂæÆ‰ªªÂä°Á°Æ‰øùÂ±ûÊÄßÊõ¥Êñ∞ÂÆåÊàêÂêéÂÜçÂ§ÑÁêÜ
                  Future.microtask(() async {
                    try {
                      // Áõ¥Êé•ÊâßË°åÂõæÂÉè‰∫åÂÄºÂåñÂ§ÑÁêÜ
                      if (content['isBinarizationEnabled'] == true) {
                        await _executeDirectImageBinarization(
                            elementId, content);
                      }
                    } catch (e) {
                      PracticeEditLogger.logError('Ê†ºÂºèÂà∑ÂõæÂÉèÂ§ÑÁêÜÂ§±Ë¥•', e,
                          context: {'elementId': elementId});
                    }
                  });
                }
              }
            }

            // Â¶ÇÊûúÊòØÂΩìÂâçÈÄâ‰∏≠ÁöÑÂÖÉÁ¥†ÔºåÂêåÊó∂Êõ¥Êñ∞selectedElement
            if (_controller.state.selectedElementIds.contains(elementId)) {
              _controller.state.selectedElement = properties;
            }

            // Ê†áËÆ∞ÊúâÊú™‰øùÂ≠òÁöÑÊõ¥Êîπ
            _controller.state.hasUnsavedChanges = true;

            // ÈÄöÁü•ÁõëÂê¨Âô®Â∑≤Áî±setCurrentToolÂ§ÑÁêÜ
          }
        }
      },
    );

    // Ê∑ªÂä†Âà∞Êí§ÈîÄ/ÈáçÂÅöÁÆ°ÁêÜÂô®
    _controller.undoRedoManager.addOperation(formatPainterOperation);

    // üÜï Ëß¶ÂèëÊô∫ËÉΩÁä∂ÊÄÅÂàÜÂèëÔºåÁ°Æ‰øùÁîªÂ∏ÉÈáçÊñ∞Ê∏≤Êüì
    _controller.intelligentNotify(
      changeType: 'format_brush_applied',
      eventData: {
        'targetElementIds': targetElementIds,
        'elementCount': selectedElements.length,
        'hasImageElements': targetElementIds.any((id) {
          final element = _controller.state.currentPageElements.firstWhere(
            (e) => e['id'] == id,
            orElse: () => <String, dynamic>{},
          );
          return element['type'] == 'image';
        }),
        'operation': 'apply_format_brush',
        'timestamp': DateTime.now().toIso8601String(),
      },
      operation: 'apply_format_brush',
      affectedElements: targetElementIds,
      affectedLayers: ['content', 'rendering'],
      affectedUIComponents: ['canvas', 'property_panel'],
    );

    stopwatch.stop();
    PracticeEditLogger.logPerformanceOperation(
        'ÊâπÈáèÊ†ºÂºèÂà∑Â∫îÁî®', stopwatch.elapsedMilliseconds,
        data: {
          'elementCount': selectedElements.length,
          'hasImageProcessing': true,
        });
    // ÈáçÁΩÆÊ†ºÂºèÂà∑Áä∂ÊÄÅ
    setState(() {
      _isFormatBrushActive = false;
      _formatBrushStyles = null;
    });
  }

  /// Bring element to front
  void _bringElementToFront() {
    // Use controller directly without setState since it will notify listeners
    PracticeEditUtils.bringElementToFront(_controller);
    // Only trigger a rebuild if we're not in a drag operation
    if (_canvasKey.currentState == null ||
        !_canvasKey.currentState!.context.mounted) {
      setState(() {});
    }
  }

  /// Build the body of the page
  Widget _buildBody(BuildContext context) {
    return Row(
      children: [
        // Left panel - wrapped in AnimatedBuilder since it needs to react to controller changes
        if (!_isPreviewMode && _isLeftPanelOpen)
          AnimatedBuilder(
            animation: _controller,
            builder: (context, child) => _buildLeftPanel(),
          ),

        // Left panel toggle
        if (!_isPreviewMode)
          PersistentSidebarToggle(
            sidebarId: 'practice_edit_left_panel',
            defaultIsOpen: false,
            onToggle: (isOpen) => setState(() {
              _isLeftPanelOpen = isOpen;
            }),
            alignRight: false,
          ),

        // Central edit area - isolated from controller notifications to prevent canvas rebuilds
        Expanded(
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.stretch,
            children: [
              // Toolbar - wrapped in AnimatedBuilder since it needs to react to controller changes
              if (!_isPreviewMode && _showToolbar)
                AnimatedBuilder(
                  animation: _controller,
                  builder: (context, child) => _buildEditToolbar(),
                ),

              // Edit canvas - NOT wrapped in AnimatedBuilder to prevent rebuilds
              Expanded(
                child: ProviderScope(
                  child: M3PracticeEditCanvas(
                    key: _canvasKey,
                    controller: _controller,
                    isPreviewMode: _isPreviewMode,
                    transformationController: _transformationController,
                  ),
                ),
              ),

              // Page thumbnails - wrapped in AnimatedBuilder since it needs to react to page changes
              if (_showThumbnails && !_isPreviewMode)
                AnimatedBuilder(
                  animation: _controller,
                  builder: (context, child) => _buildPageThumbnails(),
                ),
            ],
          ),
        ),

        // Right panel toggle
        if (!_isPreviewMode)
          PersistentSidebarToggle(
            sidebarId: 'practice_edit_right_panel',
            defaultIsOpen: true,
            onToggle: (isOpen) => setState(() {
              _isRightPanelOpen = isOpen;
            }),
            alignRight: true,
          ),

        // Right properties panel - wrapped in AnimatedBuilder since it needs to react to selection changes
        if (!_isPreviewMode && _isRightPanelOpen)
          AnimatedBuilder(
            animation: _controller,
            builder: (context, child) => _buildRightPanel(),
          ),
      ],
    );
  }

  /// Build the edit toolbar
  Widget _buildEditToolbar() {
    return Column(
      children: [
        // üÜï ‰ΩøÁî®AnimatedBuilderÁõ¥Êé•ÁõëÂê¨controllerÁä∂ÊÄÅÂèòÂåñÔºåÁ°Æ‰øùÈ°µÈù¢ÂàáÊç¢Êó∂ËÉΩÂèäÊó∂Êõ¥Êñ∞Ââ™Ë¥¥ÊùøÁä∂ÊÄÅ
        AnimatedBuilder(
          animation: _controller,
          builder: (context, child) {
            // Ê£ÄÊü•Ââ™Ë¥¥ÊùøÁä∂ÊÄÅÔºåÁ°Æ‰øù‰∏éÂΩìÂâçÁä∂ÊÄÅ‰∏ÄËá¥
            final shouldHaveClipboard = _clipboardElement != null;
            if (shouldHaveClipboard != _clipboardHasContent) {
              // ÂºÇÊ≠•Êõ¥Êñ∞Ââ™Ë¥¥ÊùøÁä∂ÊÄÅÔºåÈÅøÂÖçÂú®buildÊúüÈó¥Ë∞ÉÁî®setState
              Future.microtask(() async {
                final hasContent = await _checkClipboardContent();
                if (mounted && hasContent != _clipboardHasContent) {
                  _clipboardHasContent = hasContent;
                  _clipboardNotifier.value = hasContent;
                  setState(() {});

                  EditPageLogger.clipboardState(hasContent ? 'ÊúâÂÜÖÂÆπ' : 'Êó†ÂÜÖÂÆπ',
                      data: {
                        'correctedByToolbar': true,
                      });
                }
              });
            }

            return ValueListenableBuilder<bool>(
              valueListenable: _clipboardNotifier,
              builder: (context, canPaste, _) {
                return M3EditToolbar(
                  controller: _controller,
                  gridVisible: _controller.state.gridVisible,
                  snapEnabled: _controller.state.snapEnabled,
                  alignmentMode: _controller.state.alignmentMode,
                  onToggleGrid: _toggleGrid,
                  onToggleSnap: _toggleSnap,
                  onToggleAlignmentMode: _toggleAlignmentMode,
                  onCopy: _copySelectedElement,
                  onPaste: _pasteElement,
                  canPaste: canPaste,
                  onGroupElements: _groupSelectedElements,
                  onUngroupElements: _ungroupElements,
                  onBringToFront: _bringElementToFront,
                  onSendToBack: _sendElementToBack,
                  onMoveUp: _moveElementUp,
                  onMoveDown: _moveElementDown,
                  onDelete: _deleteSelectedElements,
                  onCopyFormatting: _copyElementFormatting,
                  onApplyFormatBrush: _applyFormatBrush,
                  // ÈÄâÊã©Êìç‰ΩúÁõ∏ÂÖ≥ÂõûË∞É
                  onSelectAll: _selectAllElements,
                  onDeselectAll: _deselectAllElements,
                  // Ê∑ªÂä†ÂÖÉÁ¥†Â∑•ÂÖ∑ÊåâÈíÆÁõ∏ÂÖ≥ÂèÇÊï∞
                  currentTool: _currentTool,
                  onSelectTool: (tool) {
                    setState(() {
                      // Â¶ÇÊûúÂΩìÂâçÂ∑≤ÁªèÊòØselectÊ®°ÂºèÔºåÂÜçÊ¨°ÁÇπÂáªselectÊåâÈíÆÂàôÈÄÄÂá∫selectÊ®°Âºè
                      if (_currentTool == 'select' && tool == 'select') {
                        _currentTool = '';
                        _controller.exitSelectMode();
                      } else {
                        _currentTool = tool;
                        // ÂêåÊ≠•Âà∞controllerÁöÑÁä∂ÊÄÅ
                        _controller.setCurrentTool(tool);
                        PracticeEditLogger.logUserAction('Â∑•ÂÖ∑ÂàáÊç¢', data: {
                          'newTool': tool,
                          'previousTool': _currentTool,
                        });
                      }
                    });
                  },
                  onDragElementStart: (context, elementType) {
                    // ÊãñÊãΩÂºÄÂßãÊó∂ÁöÑÂ§ÑÁêÜÈÄªËæëÂèØ‰ª•‰∏∫Á©∫ÔºåÂõ†‰∏∫DraggableÂÜÖÈÉ®Â∑≤ÁªèÂ§ÑÁêÜ‰∫ÜÊãñÊãΩÂäüËÉΩ
                  },
                  // ÂÖÉÁ¥†ÂàõÂª∫ÂõûË∞É
                  onCreateTextElement: () => _createTextElement(),
                  onCreateImageElement: () => _createImageElement(),
                  onCreateCollectionElement: () => _createCollectionElement(),
                );
              },
            );
          },
        ),
        // // Debug button
        // if (kDebugMode) // Only show in debug mode
        //   ElevatedButton(
        //     onPressed: () async {
        //       // ÊâãÂä®Ê£ÄÊü•Ââ™Ë¥¥ÊùøÁä∂ÊÄÅ
        //       await _inspectClipboard();
        //       // Âº∫Âà∂Âà∑Êñ∞Ââ™Ë¥¥ÊùøÁä∂ÊÄÅ
        //       final hasContent = await _checkClipboardContent();
        //       setState(() {
        //         _clipboardHasContent = hasContent;
        //         ScaffoldMessenger.of(context).showSnackBar(
        //           SnackBar(
        //               content: Text('Ââ™Ë¥¥ÊùøÁä∂ÊÄÅ: ${hasContent ? 'ÊúâÂÜÖÂÆπ' : 'Êó†ÂÜÖÂÆπ'}')),
        //         );
        //       });
        //     },
        //     child: const Text('Ë∞ÉËØïÔºöÊ£ÄÊü•Ââ™Ë¥¥Êùø'),
        //   ),
      ],
    );
  }

  /// Build the left panel
  Widget _buildLeftPanel() {
    return PersistentResizablePanel(
      panelId: 'practice_edit_left_panel',
      initialWidth: 250,
      minWidth: 250,
      maxWidth: 400,
      isLeftPanel: true,
      child: Column(
        children: [
          // Removed content tools area as requested - it's now in the toolbar

          // Layer management area - now takes full height
          Expanded(
            child: M3PracticeLayerPanel(
              controller: _controller,
              onLayerSelect: (layerId) {
                // Handle layer selection
                _controller.selectLayer(layerId);
              },
              onLayerVisibilityToggle: (layerId, isVisible) {
                // Handle layer visibility toggle
                _controller.toggleLayerVisibility(layerId, isVisible);
              },
              onLayerLockToggle: (layerId, isLocked) {
                // Handle layer lock toggle
                _controller.toggleLayerLock(layerId, isLocked);
              },
              onAddLayer: _controller.addNewLayer,
              onDeleteLayer: _controller.deleteLayer,
              onReorderLayer: _controller.reorderLayer,
            ),
          ),
        ],
      ),
    );
  }

  /// Build the page thumbnails area
  Widget _buildPageThumbnails() {
    EditPageLogger.editPageInfo(
      'üèóÔ∏è _buildPageThumbnails Ë¢´Ë∞ÉÁî®',
      data: {
        'pagesCount': _controller.state.pages.length,
        'currentPageIndex': _controller.state.currentPageIndex,
        'timestamp': DateTime.now().toIso8601String(),
      },
    );

    return AnimatedBuilder(
      animation: _controller,
      builder: (context, _) {
        EditPageLogger.editPageInfo(
          'üîÑ M3PageThumbnailStrip AnimatedBuilder ÈáçÂª∫',
          data: {
            'pagesCount': _controller.state.pages.length,
            'currentPageIndex': _controller.state.currentPageIndex,
            'hasUnsavedChanges': _controller.state.hasUnsavedChanges,
            'timestamp': DateTime.now().toIso8601String(),
          },
        );

        return M3PageThumbnailStrip(
          pages: _controller.state.pages,
          currentPageIndex: _controller.state.currentPageIndex,
          onPageSelected: (index) {
            EditPageLogger.editPageInfo(
              'üëÜ È°µÈù¢Áº©Áï•ÂõæË¢´ÁÇπÂáª',
              data: {
                'selectedIndex': index,
                'currentIndex': _controller.state.currentPageIndex,
                'timestamp': DateTime.now().toIso8601String(),
              },
            );
            _controller.switchToPage(index);
          },
          onAddPage: _addNewPage,
          onDeletePage: _deletePage,
          onReorderPages: _reorderPages,
        );
      },
    );
  }

  /// Build the right properties panel
  Widget _buildRightPanel() {
    return AnimatedBuilder(
      animation: _controller,
      builder: (context, _) {
        // üîç[TRACKING] Â±ûÊÄßÈù¢ÊùøÈáçÂª∫Ë∑üË∏™
        _propertyPanelBuildCount++;

        final selectedElementsCount =
            _controller.state.selectedElementIds.length;
        final selectedLayerId = _controller.state.selectedLayerId;

        // üöÄ ‰ºòÂåñÔºöÂáèÂ∞ëÂ±ûÊÄßÈù¢ÊùøÈáçÂª∫ÁöÑÈáçÂ§çÊó•Âøó
        final now = DateTime.now();
        final hasSignificantChange =
            selectedElementsCount != _lastSelectedCount ||
                selectedLayerId != _lastSelectedLayerId;
        final isTimeForLog =
            now.difference(_lastPropertyPanelLogTime).inSeconds >= 2;
        final isMilestone = _propertyPanelBuildCount % 10 == 0;

        if (hasSignificantChange || isTimeForLog || isMilestone) {
          EditPageLogger.propertyPanelDebug(
            'Â±ûÊÄßÈù¢ÊùøÈáçÂª∫',
            data: {
              'buildNumber': _propertyPanelBuildCount,
              'selectedElementsCount': selectedElementsCount,
              'selectedLayerId': selectedLayerId,
              'changeType': hasSignificantChange
                  ? 'selection_changed'
                  : isMilestone
                      ? 'milestone'
                      : 'time_based',
              'trigger': hasSignificantChange
                  ? 'ÈÄâÊã©Áä∂ÊÄÅÂèòÂåñ'
                  : isMilestone
                      ? 'ÈáåÁ®ãÁ¢ëËÆ∞ÂΩï'
                      : 'ÂÆöÊó∂ËÆ∞ÂΩï',
              'optimization': 'property_panel_rebuild_optimized',
            },
          );

          _lastSelectedCount = selectedElementsCount;
          _lastSelectedLayerId = selectedLayerId;
          _lastPropertyPanelLogTime = now;
        }

        Widget panel;

        // Check if a layer is selected
        if (_controller.state.selectedLayerId != null) {
          // Show layer properties when layer is selected
          final layerId = _controller.state.selectedLayerId!;
          final layer = _controller.state.getLayerById(layerId);
          if (layer != null) {
            panel = M3PracticePropertyPanel.forLayer(
              controller: _controller,
              layer: layer,
              onLayerPropertiesChanged: (properties) {
                // Update layer properties
                _controller.updateLayerProperties(layerId, properties);
              },
            ); // Return resizable panel
            return PersistentResizablePanel(
              panelId: 'practice_edit_right_panel_character',
              initialWidth: 400,
              minWidth: 300,
              maxWidth: 800,
              isLeftPanel: false,
              child: panel,
            );
          }
        }

        // Show different property panels based on selected element type
        if (_controller.state.selectedElementIds.isEmpty) {
          // Show page properties when no element is selected
          panel = M3PracticePropertyPanel.forPage(
            controller: _controller,
            page: _controller.state.currentPage,
            onPagePropertiesChanged: (properties) {
              if (_controller.state.currentPageIndex >= 0) {
                // Check if view-affecting properties are changing
                final currentPage = _controller.state.currentPage;
                final shouldResetView = currentPage != null &&
                    (properties.containsKey('orientation') ||
                        properties.containsKey('width') ||
                        properties.containsKey('height') ||
                        properties.containsKey('dpi'));

                _controller.updatePageProperties(properties);
                // Auto reset view position after page size/orientation changes
                if (shouldResetView) {
                  WidgetsBinding.instance.addPostFrameCallback((_) {
                    _controller.resetViewPosition();
                  });
                }
              }
            },
          );
        } else if (_controller.state.selectedElementIds.length == 1) {
          // Show element-specific properties when one element is selected
          final id = _controller.state.selectedElementIds.first;
          final element = _controller.state.currentPageElements.firstWhere(
            (e) => e['id'] == id,
            orElse: () => <String, dynamic>{},
          );

          if (element.isNotEmpty) {
            switch (element['type']) {
              case 'text':
                panel = M3PracticePropertyPanel.forText(
                  controller: _controller,
                  element: element,
                  onElementPropertiesChanged: (properties) {
                    _controller.updateElementProperties(id, properties);
                  },
                );
                break;
              case 'image':
                panel = M3PracticePropertyPanel.forImage(
                  controller: _controller,
                  element: element,
                  onElementPropertiesChanged: (properties) {
                    _controller.updateElementProperties(id, properties);
                  },
                  onSelectImage: () async {
                    // Implement image selection logic
                    await _showImageUrlDialog(context);
                  },
                  ref: ref,
                );
                break;
              case 'collection':
                panel = M3PracticePropertyPanel.forCollection(
                  controller: _controller,
                  element: element,
                  onElementPropertiesChanged: (properties) {
                    _controller.updateElementProperties(id, properties);
                  },
                  onUpdateChars: (chars) {
                    // Get the current content map
                    final content = Map<String, dynamic>.from(
                        element['content'] as Map<String, dynamic>);
                    // Update the characters property
                    content['characters'] = chars;
                    // Update the element with the modified content map
                    final updatedProps = {'content': content};
                    _controller.updateElementProperties(id, updatedProps);
                  },
                  ref: ref,
                );
                break;
              case 'group':
                panel = M3PracticePropertyPanel.forGroup(
                  controller: _controller,
                  element: element,
                  onElementPropertiesChanged: (properties) {
                    _controller.updateElementProperties(id, properties);
                  },
                );
                break;
              default:
                panel = const Center(child: Text('Unsupported element type'));
            }
          } else {
            panel = Center(
                child:
                    Text(AppLocalizations.of(context).selectedElementNotFound));
          }
        } else {
          // Show multi-selection properties when multiple elements are selected
          panel = M3PracticePropertyPanel.forMultiSelection(
            controller: _controller,
            selectedIds: _controller.state.selectedElementIds,
            onElementPropertiesChanged: (properties) {
              // Apply properties to all selected elements
              for (final id in _controller.state.selectedElementIds) {
                _controller.updateElementProperties(id, properties);
              }
            },
          );
        }
        return PersistentResizablePanel(
          panelId: 'practice_edit_right_panel_properties',
          initialWidth: 400,
          minWidth: 300,
          maxWidth: 800,
          isLeftPanel: false,
          child: panel,
        );
      },
    );
  }

  /// Check if clipboard has valid content for pasting
  /// Returns true if clipboard has content that can be pasted
  Future<bool> _checkClipboardContent() async {
    // Check internal clipboard first (handled by app)
    if (_clipboardElement != null) {
      final type = _clipboardElement?['type'];
      EditPageLogger.clipboardState('ÂÜÖÈÉ®Ââ™Ë¥¥ÊùøÊ£ÄÊü•', data: {'type': type});

      // üîß ‰øÆÂ§çÔºöÊ≠£Á°ÆÂå∫ÂàÜ‰∏çÂêåÁ±ªÂûãÁöÑÂâ™Ë¥¥ÊùøÂÜÖÂÆπ
      if (type == 'text' || type == 'collection' || type == 'group') {
        // Áõ¥Êé•Â§çÂà∂ÁöÑÊñáÊú¨„ÄÅÈõÜÂ≠ó„ÄÅÁªÑÂêàÂÖÉÁ¥† - Ê£ÄÊü•ID
        final hasId = _clipboardElement!.containsKey('id') &&
            _clipboardElement!['id'] != null &&
            _clipboardElement!['id'].toString().isNotEmpty;
        PracticeEditLogger.debugDetail('Áõ¥Êé•Â§çÂà∂ÂÖÉÁ¥†È™åËØÅ', data: {
          'type': type,
          'hasId': hasId,
          'elementId': _clipboardElement!['id'],
        });
        return hasId;
      } else if (type == 'image') {
        // ÂõæÂÉèÂÖÉÁ¥†ÈúÄË¶ÅÁâπÊÆäÂà§Êñ≠ÔºöÂèØËÉΩÊòØÁõ¥Êé•Â§çÂà∂ÁöÑÂÖÉÁ¥†Ôºå‰πüÂèØËÉΩÊòØÂõæÂ∫ìÈ°πÁõÆ

        // 1. Ê£ÄÊü•ÊòØÂê¶ÊòØÁõ¥Êé•Â§çÂà∂ÁöÑÂõæÂÉèÂÖÉÁ¥†ÔºàÊúâÂÆåÊï¥ÁöÑÂÖÉÁ¥†ÁªìÊûÑÔºâ
        if (_clipboardElement!.containsKey('id') &&
            _clipboardElement!.containsKey('content') &&
            _clipboardElement!.containsKey('x') &&
            _clipboardElement!.containsKey('y')) {
          final hasId = _clipboardElement!['id'] != null &&
              _clipboardElement!['id'].toString().isNotEmpty;
          PracticeEditLogger.debugDetail('Áõ¥Êé•Â§çÂà∂ÂõæÂÉèÂÖÉÁ¥†È™åËØÅ', data: {
            'type': type,
            'hasId': hasId,
            'elementId': _clipboardElement!['id'],
            'hasContent': _clipboardElement!.containsKey('content'),
          });
          return hasId;
        }

        // 2. Ê£ÄÊü•ÊòØÂê¶ÊòØÂõæÂ∫ìÈ°πÁõÆÔºàÂè™ÊúâimageUrlÊàñitemIdsÔºâ
        else if (_clipboardElement!.containsKey('imageUrl') ||
            _clipboardElement!.containsKey('itemIds')) {
          final hasImageUrl = _clipboardElement!.containsKey('imageUrl') &&
              _clipboardElement!['imageUrl'] != null;
          final hasItemIds = _clipboardElement!.containsKey('itemIds') &&
              _clipboardElement!['itemIds'] is List &&
              (_clipboardElement!['itemIds'] as List).isNotEmpty;

          PracticeEditLogger.debugDetail('ÂõæÂ∫ìÈ°πÁõÆÂÜÖÂÆπÈ™åËØÅ', data: {
            'type': type,
            'hasImageUrl': hasImageUrl,
            'hasItemIds': hasItemIds,
            'imageUrl': hasImageUrl ? _clipboardElement!['imageUrl'] : null,
            'itemCount':
                hasItemIds ? (_clipboardElement!['itemIds'] as List).length : 0,
          });
          return hasImageUrl || hasItemIds;
        }

        // 3. ÂÖ∂‰ªñÊÉÖÂÜµÔºåÂèØËÉΩÊòØ‰∏çÂÆåÊï¥ÁöÑÊï∞ÊçÆ
        else {
          PracticeEditLogger.logError(
              'ÂõæÂÉèÂÖÉÁ¥†ÁªìÊûÑ‰∏çÂÆåÊï¥', Exception('Incomplete image element structure'),
              context: {
                'type': type,
                'keys': _clipboardElement!.keys.toList(),
              });
          return false;
        }
      } else if (type == 'characters' || type == 'character') {
        // Â≠óÁ¨¶Á±ªÂûã - Ê£ÄÊü•Â≠óÁ¨¶IDs
        final hasIds = _clipboardElement!.containsKey('characterIds') ||
            (_clipboardElement!.containsKey('data') &&
                _clipboardElement!['data'] is Map &&
                _clipboardElement!['data'].containsKey('characterId'));
        PracticeEditLogger.debugDetail('Â≠óÁ¨¶ÂÜÖÂÆπÈ™åËØÅ', data: {'hasIds': hasIds});
        return hasIds;
      } else if (type == 'library_items') {
        // ÂõæÂ∫ìÈ°πÁõÆÁ±ªÂûã - Ê£ÄÊü•È°πÁõÆIDs
        final hasIds = _clipboardElement!.containsKey('itemIds') &&
            _clipboardElement!['itemIds'] is List &&
            (_clipboardElement!['itemIds'] as List).isNotEmpty;
        PracticeEditLogger.debugDetail('ÂõæÂ∫ìÈ°πÁõÆÈ™åËØÅ', data: {
          'hasIds': hasIds,
          'itemCount':
              hasIds ? (_clipboardElement!['itemIds'] as List).length : 0,
        });
        return hasIds;
      } else if (type == 'multi_elements') {
        // Â§öÂÖÉÁ¥†Á±ªÂûã - Ê£ÄÊü•ÂÖÉÁ¥†ÂàóË°®
        final elements = _clipboardElement!['elements'];
        final hasElements =
            elements != null && elements is List && elements.isNotEmpty;
        PracticeEditLogger.debugDetail('Â§öÂÖÉÁ¥†ÂÜÖÂÆπÈ™åËØÅ', data: {
          'hasElements': hasElements,
          'elementCount': hasElements ? elements.length : 0
        });
        return hasElements;
      }

      // For other types, just check if it exists
      PracticeEditLogger.debugDetail('ÂÖ∂‰ªñÁ±ªÂûãÈªòËÆ§ÊúâÊïà', data: {'type': type});
      return true;
    }

    // Then check system clipboard
    try {
      // Check for text data
      final clipboardData = await Clipboard.getData(Clipboard.kTextPlain);
      final hasText = clipboardData != null &&
          clipboardData.text != null &&
          clipboardData.text!.isNotEmpty;
      // if (hasText) ...
      if (hasText) {
        try {
          final text = clipboardData.text!.trim();

          // Ê£ÄÊü•ÊñáÊú¨ÊòØÂê¶ÂèØËÉΩÊòØJSONÊ†ºÂºèÔºàÁÆÄÂçïÈ¢ÑÊ£ÄÊü•Ôºâ
          if (!text.startsWith('{') && !text.startsWith('[')) {
            // ‰∏çÊòØJSONÊ†ºÂºèÔºåÊåâÊôÆÈÄöÊñáÊú¨Â§ÑÁêÜ - Â±èËîΩÊó•ÂøóËæìÂá∫
            // AppLogger.debug(
            //   'Ê£ÄÊü•Ââ™Ë¥¥Êùø: ÊñáÊú¨‰∏çÊòØJSONÊ†ºÂºèÔºåÊåâÊôÆÈÄöÊñáÊú¨Â§ÑÁêÜ',
            //   tag: 'PracticeEdit',
            //   data: {
            //     'textPreview':
            //         text.length > 50 ? '${text.substring(0, 50)}...' : text
            //   },
            // );
            return true;
          }

          final json = jsonDecode(text);
          if (json is Map<String, dynamic> && json.containsKey('type')) {
            final type = json['type'];
            AppLogger.debug(
              'Ê£ÄÊü•Ââ™Ë¥¥Êùø: ËØÜÂà´Âà∞JSONÂÜÖÂÆπ',
              tag: 'PracticeEdit',
              data: {'type': type},
            );
            if (type == 'characters') {
              final characterIds = json['characterIds'];
              final hasIds = characterIds != null &&
                  characterIds is List &&
                  characterIds.isNotEmpty;
              AppLogger.debug(
                'Ê£ÄÊü•Ââ™Ë¥¥Êùø: Â≠óÁ¨¶IDs',
                tag: 'PracticeEdit',
                data: {'characterIds': characterIds, 'hasIds': hasIds},
              );
              return hasIds;
            } else if (type == 'library_items') {
              final itemIds = json['itemIds'];
              final hasIds =
                  itemIds != null && itemIds is List && itemIds.isNotEmpty;
              PracticeEditLogger.debugDetail('ÂõæÂ∫ìÈ°πÁõÆIDsÈ™åËØÅ',
                  data: {'itemIds': itemIds, 'hasIds': hasIds});
              return hasIds;
            } else if (type == 'practice_elements') {
              // üÜï Â§ÑÁêÜË∑®È°µÈù¢Â§çÂà∂ÁöÑÂ≠óÂ∏ñÁºñËæëÂÖÉÁ¥†
              final data = json['data'];
              if (data != null && data is Map<String, dynamic>) {
                PracticeEditLogger.debugDetail('Ë∑®È°µÈù¢Â≠óÂ∏ñÂÖÉÁ¥†Ê£ÄÊµã', data: {
                  'elementType': data['type'],
                  'source': json['source'],
                });
                return true;
              }
            } else if (json.containsKey('id') &&
                (type == 'text' || type == 'image' || type == 'collection')) {
              PracticeEditLogger.debugDetail('ÂèØÁ≤òË¥¥ÂÖÉÁ¥†Á±ªÂûãÊ£ÄÊµã', data: {'type': type});
              return true;
            }
          }
        } catch (e) {
          // JSONËß£ÊûêÂ§±Ë¥•ÔºåËÆ∞ÂΩïËØ¶ÁªÜ‰ø°ÊÅØ‰ΩÜ‰∏çÂΩ±ÂìçÂäüËÉΩ
          AppLogger.debug(
            'Ê£ÄÊü•Ââ™Ë¥¥Êùø: JSONËß£ÊûêÂ§±Ë¥•ÔºåÊåâÊôÆÈÄöÊñáÊú¨Â§ÑÁêÜ',
            tag: 'PracticeEdit',
            data: {
              'error': e.toString(),
              'textLength': clipboardData.text!.length,
              'textPreview': clipboardData.text!.length > 100
                  ? '${clipboardData.text!.substring(0, 100)}...'
                  : clipboardData.text!,
            },
          );
        }
        // Plain text can always be pasted
        return true;
      }
      // Check for image data in clipboard (different formats)
      try {
        for (final format in ['image/png', 'image/jpeg', 'image/gif']) {
          final imageClipboardData = await Clipboard.getData(format);
          if (imageClipboardData != null) {
            AppLogger.debug(
              'Ê£ÄÊü•Ââ™Ë¥¥Êùø: Á≥ªÁªüÂâ™Ë¥¥ÊùøÊúâÂõæÁâáÊï∞ÊçÆ',
              tag: 'PracticeEdit',
              data: {'format': format},
            );
            return true;
          }
        }
      } catch (e) {
        // Â±èËîΩË≠¶ÂëäÊó•Âøó
        // AppLogger.warning(
        //   'Ê£ÄÊü•Á≥ªÁªüÂâ™Ë¥¥ÊùøÂõæÁâáÊï∞ÊçÆÈîôËØØ',
        //   tag: 'PracticeEdit',
        //   error: e,
        // );
      }
      return hasText;
    } catch (e) {
      AppLogger.error(
        'Ê£ÄÊü•Ââ™Ë¥¥ÊùøÈîôËØØ',
        tag: 'PracticeEdit',
        error: e,
      );
      return false;
    }
  }

  /// Â§çÂà∂ÈÄâ‰∏≠ÂÖÉÁ¥†ÁöÑÊ†∑ÂºèÔºàÊ†ºÂºèÂà∑ÂäüËÉΩÔºâ
  void _copyElementFormatting() {
    final selectedElements = _controller.state.getSelectedElements();
    if (selectedElements.isEmpty) return;

    // ‰ªéÁ¨¨‰∏Ä‰∏™ÈÄâ‰∏≠ÂÖÉÁ¥†Ëé∑ÂèñÊ†∑Âºè
    final element = selectedElements.first;
    _formatBrushStyles = {};

    // Ê†πÊçÆÂÖÉÁ¥†Á±ªÂûãËé∑Âèñ‰∏çÂêåÁöÑÊ†∑ÂºèÂ±ûÊÄß
    if (element['type'] == 'text') {
      // ÊñáÊú¨ÂÖÉÁ¥†Ê†∑Âºè - Â§ñÂ±ÇÂ±ûÊÄß
      _formatBrushStyles!['opacity'] = element['opacity'];
      _formatBrushStyles!['rotation'] = element['rotation'];
      _formatBrushStyles!['width'] = element['width'];
      _formatBrushStyles!['height'] = element['height'];

      // Â§çÂà∂content‰∏≠ÁöÑÊâÄÊúâÊ†∑ÂºèÂ±ûÊÄß
      if (element.containsKey('content') &&
          element['content'] is Map<String, dynamic>) {
        final content = element['content'] as Map<String, dynamic>;

        // ÊñáÊú¨ÂÖÉÁ¥†ÁöÑcontentÂ±ûÊÄß
        final propertiesToCopy = [
          'backgroundColor',
          'fontColor',
          'fontFamily',
          'fontSize',
          'fontStyle',
          'fontWeight',
          'letterSpacing',
          'lineHeight',
          'padding',
          'textAlign',
          'verticalAlign',
          'writingMode'
        ];

        // Â§çÂà∂ÊâÄÊúâÊåáÂÆöÁöÑÊ†∑ÂºèÂ±ûÊÄß
        for (final property in propertiesToCopy) {
          if (content.containsKey(property)) {
            _formatBrushStyles!['content_$property'] = content[property];
          }
        }
      } else {
        // ÂÖºÂÆπÊóßÁâàÊú¨ÊñáÊú¨ÂÖÉÁ¥†ÁªìÊûÑ
        if (element.containsKey('fontSize')) {
          _formatBrushStyles!['fontSize'] = element['fontSize'];
        }
        if (element.containsKey('fontWeight')) {
          _formatBrushStyles!['fontWeight'] = element['fontWeight'];
        }
        if (element.containsKey('fontStyle')) {
          _formatBrushStyles!['fontStyle'] = element['fontStyle'];
        }
        if (element.containsKey('textColor')) {
          _formatBrushStyles!['textColor'] = element['textColor'];
        }
        if (element.containsKey('textAlign')) {
          _formatBrushStyles!['textAlign'] = element['textAlign'];
        }
      }
    } else if (element['type'] == 'image') {
      // ÂõæÁâáÂÖÉÁ¥†Ê†∑Âºè - Â§ñÂ±ÇÂ±ûÊÄß
      _formatBrushStyles!['opacity'] = element['opacity'];
      _formatBrushStyles!['rotation'] = element['rotation'];
      _formatBrushStyles!['width'] = element['width'];
      _formatBrushStyles!['height'] = element['height'];

      // Â§çÂà∂content‰∏≠ÁöÑÊâÄÊúâÊ†∑ÂºèÂ±ûÊÄß
      if (element.containsKey('content') &&
          element['content'] is Map<String, dynamic>) {
        final content = element['content'] as Map<String, dynamic>;

        // ÂõæÂÉèÂÖÉÁ¥†ÁöÑcontentÂ±ûÊÄß
        final propertiesToCopy = [
          'backgroundColor',
          'fit',
          'isFlippedHorizontally',
          'isFlippedVertically',
          'rotation',
          // üÜï Ê∑ªÂä†‰∫åÂÄºÂåñÂ§ÑÁêÜÂèÇÊï∞ÔºàÂè™Â§çÂà∂ËÆæÁΩÆÔºå‰∏çÂ§çÂà∂Êï∞ÊçÆÔºâ
          'isBinarizationEnabled',
          'binaryThreshold',
          'isNoiseReductionEnabled',
          'noiseReductionLevel',
          // Ê≥®ÊÑèÔºö‰∏çÂ§çÂà∂ binarizedImageDataÔºåÂõ†‰∏∫ËøôÊòØÂ§ÑÁêÜÂêéÁöÑÊï∞ÊçÆÔºå‰∏çÊòØÊ†ºÂºèËÆæÁΩÆ
          // üÜï Ê∑ªÂä†ÂÖ∂‰ªñÂõæÂÉèÂ§ÑÁêÜÂèÇÊï∞
          'fitMode',
          'alignment',
          'cropX',
          'cropY',
          'cropWidth',
          'cropHeight',
          'cropTop',
          'cropBottom',
          'cropLeft',
          'cropRight',
        ];

        // Â§çÂà∂ÊâÄÊúâÊåáÂÆöÁöÑÊ†∑ÂºèÂ±ûÊÄß
        for (final property in propertiesToCopy) {
          if (content.containsKey(property)) {
            _formatBrushStyles!['content_$property'] = content[property];
          }
        }
      }
    } else if (element['type'] == 'collection') {
      // ÈõÜÂ≠óÂÖÉÁ¥†Ê†∑Âºè - ÂåÖÂê´Èô§‰∫ÜCharacterÂíåPosition‰ª•Â§ñÁöÑÊâÄÊúâÂ±ûÊÄß
      _formatBrushStyles!['opacity'] = element['opacity'];
      _formatBrushStyles!['width'] = element['width'];
      _formatBrushStyles!['height'] = element['height'];
      _formatBrushStyles!['rotation'] = element['rotation'];

      // Â§çÂà∂content‰∏≠ÁöÑÊâÄÊúâÊ†∑ÂºèÂ±ûÊÄß
      if (element.containsKey('content') &&
          element['content'] is Map<String, dynamic>) {
        final content = element['content'] as Map<String, dynamic>;

        // Ê†πÊçÆÈúÄÊ±Ç‰∏≠ÁöÑÂ±ûÊÄßÂàóË°®Ê∑ªÂä†ÊâÄÊúâÈúÄË¶ÅÊîØÊåÅÁöÑÂ±ûÊÄß
        final propertiesToCopy = [
          'fontSize',
          'fontColor',
          'backgroundColor',
          'backgroundTexture',
          'charSpacing',
          'direction',
          'gridLines',
          'letterSpacing',
          'lineSpacing',
          'padding',
          'showBackground',
          'textureApplicationRange',
          'textureFillMode',
          'textureOpacity',
          'enableSoftLineBreak', // Ê∑ªÂä†Ëá™Âä®Êç¢Ë°åÂ±ûÊÄß
        ];

        // Â§çÂà∂ÊâÄÊúâÊåáÂÆöÁöÑÊ†∑ÂºèÂ±ûÊÄß
        for (final property in propertiesToCopy) {
          if (content.containsKey(property)) {
            _formatBrushStyles!['content_$property'] = content[property];
          }
        } // ‰∏çÂ§çÂà∂charactersÂ±ûÊÄßÔºåÂõ†‰∏∫ËøôÊòØÂÜÖÂÆπËÄåÈùûÊ†∑Âºè
      }
    } else if (element['type'] == 'group') {
      // ÁªÑÂêàÂÖÉÁ¥†Ê†∑Âºè - ‰∏ªË¶ÅÊòØÈÄèÊòéÂ∫¶Â±ûÊÄß
      _formatBrushStyles!['opacity'] = element['opacity'];
      _formatBrushStyles!['rotation'] = element['rotation'];

      // ÁªÑÂêàÂÖÉÁ¥†ÁöÑÂÖ∂‰ªñÂèØËÉΩÊ†∑ÂºèÂ±ûÊÄß
      if (element.containsKey('width')) {
        _formatBrushStyles!['width'] = element['width'];
      }
      if (element.containsKey('height')) {
        _formatBrushStyles!['height'] = element['height'];
      }

      // Â§çÂà∂content‰∏≠ÁöÑÊ†∑ÂºèÂ±ûÊÄßÔºàÂ¶ÇÊûúÂ≠òÂú®Ôºâ
      if (element.containsKey('content') &&
          element['content'] is Map<String, dynamic>) {
        final content = element['content'] as Map<String, dynamic>;

        // ÁªÑÂêàÂÖÉÁ¥†ÂèØËÉΩÁöÑÊ†∑ÂºèÂ±ûÊÄß
        final propertiesToCopy = [
          'backgroundColor',
          'borderColor',
          'borderWidth',
          'cornerRadius',
          'shadowColor',
          'shadowOpacity',
          'shadowOffset',
          'shadowBlur',
        ];

        // Â§çÂà∂ÊâÄÊúâÊåáÂÆöÁöÑÊ†∑ÂºèÂ±ûÊÄß
        for (final property in propertiesToCopy) {
          if (content.containsKey(property)) {
            _formatBrushStyles!['content_$property'] = content[property];
          }
        }
      }
    }

    // Â¶ÇÊûúÊòØ‰ªéÂ≠óÁ¨¶ÁÆ°ÁêÜÈ°µÈù¢Â§çÂà∂ÁöÑÂ≠óÁ¨¶ÂÖÉÁ¥†ÔºåËÆæÁΩÆÂ≠ó‰ΩìÂ§ßÂ∞è‰∏∫200px
    if (element['type'] == 'collection' &&
        element.containsKey('isFromCharacterManagement') &&
        element['isFromCharacterManagement'] == true) {
      _formatBrushStyles!['content_fontSize'] = 200.0;
    } // ÊøÄÊ¥ªÊ†ºÂºèÂà∑
    setState(() {
      _isFormatBrushActive = true;
      // ÊòæÁ§∫ÊèêÁ§∫‰ø°ÊÅØ
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
            content: Text(AppLocalizations.of(context).formatBrushActivated)),
      );
    });
  }

  /// Copy selected elements with enhanced image preloading optimization
  void _copySelectedElement() async {
    AppLogger.info(
      'ÂºÄÂßãÂ§çÂà∂ÈÄâ‰∏≠ÂÖÉÁ¥†ÔºàÂ¢ûÂº∫ÂõæÂÉèÈ¢ÑÂä†ËΩΩÔºâ',
      tag: 'PracticeEdit',
      data: {'timestamp': DateTime.now().toIso8601String()},
    );
    // Capture context reference before async operations
    final currentContext = context;
    final scaffoldMessenger = ScaffoldMessenger.of(currentContext);
    try {
      // Get services for image preloading
      final characterImageService = ref.read(characterImageServiceProvider);
      final imageCacheService = ref.read(imageCacheServiceProvider);
      // Use enhanced copy method with comprehensive image preloading
      _clipboardElement =
          await PracticeEditUtils.copySelectedElementsWithPreloading(
        _controller,
        currentContext,
        characterImageService: characterImageService,
        imageCacheService: imageCacheService,
      );
      AppLogger.info(
        'Â§çÂà∂ÁªìÊûú',
        tag: 'PracticeEdit',
        data: {
          'result': _clipboardElement != null ? 'ÊàêÂäü' : 'Â§±Ë¥•',
          'type': _clipboardElement != null ? _clipboardElement!['type'] : null,
        },
      );

      // üÜï Â∞ÜÂ§çÂà∂ÁöÑÂÖÉÁ¥†Êï∞ÊçÆ‰πü‰øùÂ≠òÂà∞Á≥ªÁªüÂâ™Ë¥¥ÊùøÔºåÊîØÊåÅË∑®È°µÈù¢Â§çÂà∂Á≤òË¥¥
      if (_clipboardElement != null) {
        try {
          // ‰∏∫Ë∑®È°µÈù¢Â§çÂà∂ÂàõÂª∫ÂÆåÊï¥ÁöÑÊï∞ÊçÆÂåÖ
          final crossPageData = {
            'type': 'practice_elements', // Ê†áËØÜËøôÊòØÂ≠óÂ∏ñÁºñËæëÂÖÉÁ¥†
            'source': 'practice_edit_page', // Êù•Ê∫êÊ†áËØÜ
            'timestamp': DateTime.now().millisecondsSinceEpoch,
            'data': _clipboardElement,
          };

          final jsonString = jsonEncode(crossPageData);
          await Clipboard.setData(ClipboardData(text: jsonString));

          AppLogger.info(
            'ÂÖÉÁ¥†Êï∞ÊçÆÂ∑≤‰øùÂ≠òÂà∞Á≥ªÁªüÂâ™Ë¥¥ÊùøÔºåÊîØÊåÅË∑®È°µÈù¢Â§çÂà∂Á≤òË¥¥',
            tag: 'PracticeEdit',
            data: {
              'dataSize': jsonString.length,
              'elementType': _clipboardElement!['type'],
            },
          );
        } catch (e) {
          AppLogger.warning(
            '‰øùÂ≠òÂà∞Á≥ªÁªüÂâ™Ë¥¥ÊùøÂ§±Ë¥•Ôºå‰ªÖÊîØÊåÅÂΩìÂâçÈ°µÈù¢ÂÜÖÂ§çÂà∂Á≤òË¥¥',
            tag: 'PracticeEdit',
            error: e,
          );
        }
      }

      if (mounted) {
        _clipboardHasContent = _clipboardElement != null;
        _clipboardNotifier.value = _clipboardElement != null;
        setState(() {});
        AppLogger.debug(
          'ËÆæÁΩÆÁ≤òË¥¥ÊåâÈíÆÁä∂ÊÄÅ',
          tag: 'PracticeEdit',
          data: {'status': _clipboardHasContent ? 'ÊøÄÊ¥ª' : 'Á¶ÅÁî®'},
        );
        if (_clipboardElement != null) {
          scaffoldMessenger.showSnackBar(SnackBar(
              content:
                  Text(AppLocalizations.of(context).elementCopiedToClipboard)));
        }
      }
    } catch (e) {
      AppLogger.error(
        'Â§çÂà∂ÂÖÉÁ¥†Êó∂ÂèëÁîüÈîôËØØ',
        tag: 'PracticeEdit',
        error: e,
      );
      if (mounted) {
        _clipboardElement =
            PracticeEditUtils.copySelectedElements(_controller, context);
        setState(() {
          _clipboardHasContent = _clipboardElement != null;
        });
        if (_clipboardElement != null) {
          ScaffoldMessenger.of(context).showSnackBar(SnackBar(
              content:
                  Text(AppLocalizations.of(context).elementCopiedToClipboard)));
        }
      }
    }
  }

  // _buildElementButton ÊñπÊ≥ïÂ∑≤ÁßªÈô§ÔºåÁõ∏ÂÖ≥ÂäüËÉΩÁßªËá≥ M3EditToolbar

  /// ÂàõÂª∫ÊñáÊú¨ÂÖÉÁ¥†ÔºàÂ∑•ÂÖ∑Ê†èÊåâÈíÆË∞ÉÁî®Ôºâ
  void _createTextElement() {
    _controller.addTextElement();

    AppLogger.info(
      'ÈÄöËøáÂ∑•ÂÖ∑Ê†èÂàõÂª∫ÊñáÊú¨ÂÖÉÁ¥†',
      tag: 'PracticeEdit',
      data: {
        'action': 'create_text_element',
        'source': 'toolbar_button',
        'timestamp': DateTime.now().toIso8601String(),
      },
    );
  }

  /// ÂàõÂª∫ÂõæÁâáÂÖÉÁ¥†ÔºàÂ∑•ÂÖ∑Ê†èÊåâÈíÆË∞ÉÁî®Ôºâ
  void _createImageElement() {
    // ‰ΩøÁî®ÈªòËÆ§ÂõæÁâáURLÂàõÂª∫ÂõæÁâáÂÖÉÁ¥†ÔºåÁî®Êà∑‰πãÂêéÂèØ‰ª•Êõ¥Êç¢
    const defaultImageUrl = 'assets/images/transparent_bg.png';
    _controller.addImageElement(defaultImageUrl);

    AppLogger.info(
      'ÈÄöËøáÂ∑•ÂÖ∑Ê†èÂàõÂª∫ÂõæÁâáÂÖÉÁ¥†',
      tag: 'PracticeEdit',
      data: {
        'action': 'create_image_element',
        'source': 'toolbar_button',
        'defaultImageUrl': defaultImageUrl,
        'timestamp': DateTime.now().toIso8601String(),
      },
    );
  }

  /// ÂàõÂª∫ÈááÈõÜÂÖÉÁ¥†ÔºàÂ∑•ÂÖ∑Ê†èÊåâÈíÆË∞ÉÁî®Ôºâ
  void _createCollectionElement() {
    // ‰ΩøÁî®ÈªòËÆ§Â≠óÁ¨¶ÂàõÂª∫ÈááÈõÜÂÖÉÁ¥†ÔºåÁî®Êà∑‰πãÂêéÂèØ‰ª•‰øÆÊîπ
    const defaultCharacters = 'Â≠ó';
    _controller.addCollectionElement(defaultCharacters);

    AppLogger.info(
      'ÈÄöËøáÂ∑•ÂÖ∑Ê†èÂàõÂª∫ÈááÈõÜÂÖÉÁ¥†',
      tag: 'PracticeEdit',
      data: {
        'action': 'create_collection_element',
        'source': 'toolbar_button',
        'defaultCharacters': defaultCharacters,
        'timestamp': DateTime.now().toIso8601String(),
      },
    );
  }

  /// ÂàõÂª∫ÊñáÊú¨ÂÖÉÁ¥†ÔºàÁî®‰∫éÁ≤òË¥¥Á∫ØÊñáÊú¨Êó∂Ë∞ÉÁî®Ôºâ
  void _createTextElementFromText(String text) {
    if (text.isEmpty) return;

    // ÂàõÂª∫Êñ∞ÂÖÉÁ¥†ID
    final newId = const Uuid().v4();

    // Ëé∑ÂèñÊú¨Âú∞ÂåñÊñáÊú¨
    final l10n = AppLocalizations.of(context);

    // ÂàõÂª∫ÊñáÊú¨ÂÖÉÁ¥†
    final newElement = {
      'id': newId,
      'type': 'text',
      'x': 100.0,
      'y': 100.0,
      'width': 200.0,
      'height': 100.0,
      'rotation': 0.0,
      'opacity': 1.0,
      'layerId': _controller.state.selectedLayerId ??
          _controller.state.layers.first['id'],
      'isLocked': false,
      'isHidden': false,
      'name': l10n.textElement, // üåç ‰ΩøÁî®Â§öËØ≠Ë®ÄÊîØÊåÅ
      'content': {
        'text': text,
        'fontSize': 24.0,
        'fontWeight': 'normal',
        'fontStyle': 'normal',
        'fontColor': '#000000',
        'textAlign': 'left',
        'verticalAlign': 'top',
        'fontFamily': 'System',
        'letterSpacing': 0.0,
        'lineHeight': 1.2,
        'padding': 8.0,
        'backgroundColor': 'transparent',
        'writingMode': 'horizontal-tb',
      },
    };

    // Ê∑ªÂä†Âà∞ÂΩìÂâçÈ°µÈù¢
    setState(() {
      _controller.state.currentPageElements.add(newElement);
      _controller.selectElement(newId);
      _controller.state.hasUnsavedChanges = true;
    });

    AppLogger.info(
      'ÈÄöËøáÁ≤òË¥¥ÊñáÊú¨ÂàõÂª∫ÊñáÊú¨ÂÖÉÁ¥†',
      tag: 'PracticeEdit',
      data: {
        'action': 'create_text_element_from_paste',
        'textLength': text.length,
        'elementId': newId,
        'timestamp': DateTime.now().toIso8601String(),
      },
    );
  }

  /// Ê∑±Êã∑Ë¥ùÂÖÉÁ¥†ÔºåÁ°Æ‰øùÂµåÂ•óÁöÑMap‰πüË¢´Ê≠£Á°ÆÊã∑Ë¥ù
  Map<String, dynamic> _deepCopyElement(Map<String, dynamic> element) {
    final copy = Map<String, dynamic>.from(element);

    // ÁâπÂà´Â§ÑÁêÜcontentÂ±ûÊÄßÔºåÁ°Æ‰øùÂÆÉ‰πüË¢´Ê∑±Êã∑Ë¥ù
    if (copy.containsKey('content') && copy['content'] is Map) {
      copy['content'] = Map<String, dynamic>.from(copy['content'] as Map);
    }

    return copy;
  }

  /// Delete a page
  void _deletePage(int index) {
    // Use controller's mixin method which includes proper state management
    _controller.deletePage(index);

    // üÜï Ê†πÊçÆÈ°µÈù¢Êï∞ÈáèËá™Âä®Êõ¥Êñ∞Áº©Áï•ÂõæÊòæÁ§∫Áä∂ÊÄÅ
    _updateThumbnailVisibilityBasedOnPageCount();

    // The controller will notify listeners automatically through intelligent notification
  }

  /// Delete selected elements
  void _deleteSelectedElements() {
    final l10n = AppLocalizations.of(context);

    if (_controller.state.selectedElementIds.isEmpty) return;

    AppLogger.info(
      'Áî®Êà∑ËØ∑Ê±ÇÂà†Èô§ÈÄâ‰∏≠ÂÖÉÁ¥†',
      tag: 'PracticeEdit',
      data: {
        'selectedCount': _controller.state.selectedElementIds.length,
        'elementIds': _controller.state.selectedElementIds,
      },
    );

    // Show confirmation dialog
    showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        title: Text(l10n.confirmDelete),
        content: Text(l10n.deleteElementConfirmMessage),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context, false),
            child: Text(l10n.cancel),
          ),
          FilledButton(
            onPressed: () => Navigator.pop(context, true),
            child: Text(l10n.confirm),
          ),
        ],
      ),
    ).then((confirmed) {
      if (confirmed == true) {
        // Create a copy to avoid ConcurrentModificationError
        final idsToDelete =
            List<String>.from(_controller.state.selectedElementIds);
        AppLogger.info(
          'Á°ÆËÆ§Âà†Èô§ÂÖÉÁ¥†',
          tag: 'PracticeEdit',
          data: {
            'deletedCount': idsToDelete.length,
            'elementIds': idsToDelete,
          },
        );
        for (final id in idsToDelete) {
          _controller.deleteElement(id);
        }
      } else {
        AppLogger.debug(
          'Áî®Êà∑ÂèñÊ∂àÂà†Èô§Êìç‰Ωú',
          tag: 'PracticeEdit',
        );
      }
    });
  }

  /// Deselect all elements on the current page
  void _deselectAllElements() {
    _controller.clearSelection();
  }

  /// Edit title
  Future<void> _editTitle() async {
    if (!mounted) return;
    final l10n = AppLocalizations.of(context);

    final newTitle = await showDialog<String>(
      context: context,
      builder: (context) => PracticeTitleEditDialog(
        initialTitle: _controller.practiceTitle,
        checkTitleExists: _controller.checkTitleExists,
      ),
    );

    if (newTitle != null && newTitle.isNotEmpty) {
      _controller.updatePracticeTitle(newTitle);
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text(l10n.titleUpdated(newTitle))),
        );
      }
    }
  }

  /// Group selected elements
  void _groupSelectedElements() {
    if (_controller.state.selectedElementIds.length > 1) {
      AppLogger.info(
        'ÂàÜÁªÑÈÄâ‰∏≠ÂÖÉÁ¥†',
        tag: 'PracticeEdit',
        data: {
          'elementCount': _controller.state.selectedElementIds.length,
          'elementIds': _controller.state.selectedElementIds,
        },
      );
      _controller.groupSelectedElements();
    }
  }

  /// Â§ÑÁêÜ‰ªéÂ≠óÁ¨¶ÁÆ°ÁêÜÈ°µÈù¢Â§çÂà∂ÁöÑÂ≠óÁ¨¶
  Future<void> _handleCharacterClipboardData(Map<String, dynamic> json) async {
    AppLogger.debug(
      'Â§ÑÁêÜÂ≠óÁ¨¶Ââ™Ë¥¥ÊùøÊï∞ÊçÆ',
      tag: 'PracticeEdit',
      data: {'json': json},
    );

    final characterIds = List<String>.from(json['characterIds']);
    AppLogger.debug(
      'Â≠óÁ¨¶IDs',
      tag: 'PracticeEdit',
      data: {
        'characterIds': characterIds,
        'count': characterIds.length,
      },
    );

    if (characterIds.isEmpty) {
      AppLogger.warning(
        'Ê≤°ÊúâÂ≠óÁ¨¶IDÔºåÊó†Ê≥ïÂàõÂª∫ÈõÜÂ≠óÂÖÉÁ¥†',
        tag: 'PracticeEdit',
      );
      return;
    }

    // Ëé∑ÂèñÂ≠óÁ¨¶ÊúçÂä°ÂíåÂõæÂÉèÊúçÂä°
    final characterService = ref.read(characterServiceProvider);
    final characterImageService = ref.read(characterImageServiceProvider);
    AppLogger.debug(
      'Â∑≤Ëé∑ÂèñÂ≠óÁ¨¶ÊúçÂä°ÂíåÂõæÂÉèÊúçÂä°',
      tag: 'PracticeEdit',
    );

    // ÂØπ‰∫éÊØè‰∏™Â≠óÁ¨¶IDÔºåÂàõÂª∫‰∏Ä‰∏™ÈõÜÂ≠óÂÖÉÁ¥†
    for (int i = 0; i < characterIds.length; i++) {
      final characterId = characterIds[i];
      AppLogger.debug(
        'Â§ÑÁêÜÂ≠óÁ¨¶ID',
        tag: 'PracticeEdit',
        data: {'characterId': characterId},
      );

      try {
        // Ëé∑ÂèñÂ≠óÁ¨¶Êï∞ÊçÆ
        AppLogger.debug(
          'Ëé∑ÂèñÂ≠óÁ¨¶ËØ¶ÊÉÖ',
          tag: 'PracticeEdit',
          data: {'characterId': characterId},
        );
        final character =
            await characterService.getCharacterDetails(characterId);
        if (character == null) {
          AppLogger.warning(
            'Êó†Ê≥ïËé∑ÂèñÂ≠óÁ¨¶ËØ¶ÊÉÖÔºåË∑≥Ëøá',
            tag: 'PracticeEdit',
            data: {'characterId': characterId},
          );
          continue;
        }

        AppLogger.debug('ÊàêÂäüËé∑ÂèñÂ≠óÁ¨¶ËØ¶ÊÉÖ', tag: 'PracticeEdit');
        // debugPrint('ÊàêÂäüËé∑ÂèñÂ≠óÁ¨¶ËØ¶ÊÉÖ: $character');

        // Ëé∑ÂèñÂ≠óÁ¨¶ÂõæÂÉè - ‰ΩøÁî®defaultÁ±ªÂûãÂíåpngÊ†ºÂºè
        AppLogger.debug(
          'Ëé∑ÂèñÂ≠óÁ¨¶ÂõæÂÉè',
          tag: 'PracticeEdit',
          data: {
            'characterId': characterId,
            'type': 'default',
            'format': 'png'
          },
        );
        final imageBytes = await characterImageService.getCharacterImage(
            characterId, 'default', 'png');
        if (imageBytes == null) {
          AppLogger.warning(
            'Êó†Ê≥ïËé∑ÂèñÂ≠óÁ¨¶ÂõæÂÉèÔºåË∑≥ËøáÊ≠§Â≠óÁ¨¶',
            tag: 'PracticeEdit',
            data: {'characterId': characterId},
          );
          continue;
        }
        AppLogger.debug(
          'ÊàêÂäüËé∑ÂèñÂ≠óÁ¨¶ÂõæÂÉè',
          tag: 'PracticeEdit',
          data: {
            'characterId': characterId,
            'imageSize': imageBytes.length,
          },
        ); // ÂàõÂª∫Êñ∞ÂÖÉÁ¥†ID
        final newId = const Uuid().v4();
        AppLogger.debug(
          'ÂàõÂª∫Êñ∞ÂÖÉÁ¥†ID',
          tag: 'PracticeEdit',
          data: {'newId': newId, 'characterId': characterId},
        );

        // ËÆ°ÁÆóÊîæÁΩÆ‰ΩçÁΩÆÔºàÊåâÈ°∫Â∫èÊéíÂàóÔºâ
        final x = 100.0 + (i * 20);
        final y = 100.0 + (i * 20); // ÂàõÂª∫ÈõÜÂ≠óÂÖÉÁ¥†
        final newElement = {
          'id': newId,
          'type': 'collection',
          'x': x,
          'y': y,
          'width': 400.0, // Êõ¥Â§ßÁöÑÂ∞∫ÂØ∏‰ª•‰æø‰∫éÊü•Áúã
          'height': 200.0,
          'rotation': 0.0,
          'layerId': _controller.state.selectedLayerId ??
              _controller.state.layers.first['id'],
          'opacity': 1.0,
          'isLocked': false,
          'isHidden': false,
          'name': 'ÈõÜÂ≠óÂÖÉÁ¥†',
          'characterId': characterId,
          // Ê∑ªÂä†ÂøÖË¶ÅÁöÑcontentÂ±ûÊÄßÁªìÊûÑ
          'content': {
            // ‰ΩøÁî®Â≠óÁ¨¶ÂêçÁß∞‰Ωú‰∏∫ÈªòËÆ§ÊòæÁ§∫ÂÜÖÂÆπ
            'characters': character.character as String? ?? 'ÈõÜ',
            'fontSize': 50.0, // Áªü‰∏ÄÂ≠ó‰ΩìÂ§ßÂ∞è
            'fontColor': '#000000',
            'backgroundColor': 'transparent',
            'writingMode': 'horizontal-l',
            'letterSpacing': 10.0,
            'lineSpacing': 10.0,
            'padding': 0.0,
            'textAlign': 'center',
            'verticalAlign': 'middle',
            'enableSoftLineBreak': false,
            // Ê∑ªÂä†‰∏éÂ≠óÁ¨¶Áõ∏ÂÖ≥ÁöÑÂõæÂÉèÊï∞ÊçÆ - ‰ΩøÁî®‰ΩçÁΩÆÁ¥¢ÂºïÊ†ºÂºè
            'characterImages': {
              '0': {
                'characterId': characterId,
                'type': 'square-binary',
                'format': 'png-binary',
                'drawingType': 'square-binary',
                'drawingFormat': 'png-binary',
                'transform': {
                  'scale': 1.0,
                  'rotation': 0.0,
                  'color': '#000000',
                  'opacity': 1.0,
                  'invert': false,
                },
              },
            },
          },
        };

        AppLogger.debug(
          'ÂàõÂª∫Êñ∞ÁöÑÈõÜÂ≠óÂÖÉÁ¥†',
          tag: 'PracticeEdit',
          data: {
            'elementId': newId,
            'type': 'collection',
            'characterId': characterId,
            'x': newElement['x'],
            'y': newElement['y'],
          },
        ); // Ê∑ªÂä†Âà∞ÂΩìÂâçÈ°µÈù¢

        setState(() {
          // ‰ªéelement‰∏≠ÊèêÂèñÊñáÊú¨ÂÜÖÂÆπÁî®‰∫éÂàõÂª∫ÈõÜÂ≠óÂÖÉÁ¥†
          final characters =
              (newElement['content'] as Map)['characters'] as String? ?? 'ÈõÜ';
          final x = newElement['x'] as double;
          final y =
              newElement['y'] as double; // ‰ΩøÁî®ÊéßÂà∂Âô®ÁöÑÂÖ¨ÂÖ±ÊñπÊ≥ïaddCollectionElementAtÊ∑ªÂä†ÂÖÉÁ¥†
          // Ëøô‰∏™ÊñπÊ≥ï‰ºöÊ≠£Á°ÆÂú∞Êõ¥Êñ∞Â∫ïÂ±ÇÁöÑÊï∞ÊçÆÁªìÊûÑÔºåÁ°Æ‰øùÈõÜÂ≠óÂÖÉÁ¥†Ë¢´‰øùÂ≠ò
          // Ê†áËÆ∞ËØ•ÂÖÉÁ¥†Êù•Ëá™Â≠óÁ¨¶ÁÆ°ÁêÜÈ°µÈù¢ÔºåÂ≠ó‰ΩìÂ§ßÂ∞èÂ∞ÜËá™Âä®ËÆæÁΩÆ‰∏∫200px
          _controller.addCollectionElementAt(x, y, characters,
              isFromCharacterManagement: true,
              elementFromCharacterManagement: newElement);

          // ÈÄâÊã©Êñ∞Ê∑ªÂä†ÁöÑÂÖÉÁ¥†
          // Ê≥®ÊÑèÔºöÊàë‰ª¨‰∏çÁü•ÈÅìÊñ∞Ê∑ªÂä†ÂÖÉÁ¥†ÁöÑIDÔºåÂõ†‰∏∫ÂÆÉÊòØÂú®controllerÂÜÖÈÉ®ÁîüÊàêÁöÑ
          // ÊâÄ‰ª•Êàë‰ª¨‰∏çËÉΩÁõ¥Êé•ÈÄâÊã©ÂÆÉ
          AppLogger.info(
            'ÊàêÂäüÊ∑ªÂä†ÈõÜÂ≠óÂÖÉÁ¥†Âà∞È°µÈù¢',
            tag: 'PracticeEdit',
            data: {
              'position': {'x': x, 'y': y},
              'content': characters,
              'characterId': characterId,
            },
          );
        });
      } catch (e, stackTrace) {
        AppLogger.error(
          'Â§ÑÁêÜÂ≠óÁ¨¶Êï∞ÊçÆÂ§±Ë¥•',
          tag: 'PracticeEdit',
          error: e,
          stackTrace: stackTrace,
          data: {'characterId': characterId},
        );
      }
    }
    AppLogger.info(
      'Â≠óÁ¨¶Ââ™Ë¥¥ÊùøÊï∞ÊçÆÂ§ÑÁêÜÂÆåÊàê',
      tag: 'PracticeEdit',
      data: {'processedCount': characterIds.length},
    );
  }

  /// Â§ÑÁêÜÂõæÂ∫ìÈ°πÁõÆÂâ™Ë¥¥ÊùøÊï∞ÊçÆ
  Future<void> _handleLibraryItemClipboardData(
      Map<String, dynamic> json) async {
    AppLogger.debug(
      'ÂºÄÂßãÂ§ÑÁêÜÂõæÂ∫ìÈ°πÁõÆÂâ™Ë¥¥ÊùøÊï∞ÊçÆ',
      tag: 'PracticeEdit',
      data: {'jsonKeys': json.keys.toList()},
    );
    final itemIds = List<String>.from(json['itemIds']);
    AppLogger.debug(
      'Ëß£ÊûêÂõæÂ∫ìÈ°πÁõÆIDs',
      tag: 'PracticeEdit',
      data: {'itemIds': itemIds, 'count': itemIds.length},
    );

    if (itemIds.isEmpty) {
      AppLogger.warning(
        'Ê≤°ÊúâÂõæÂ∫ìÈ°πÁõÆIDÔºåÊó†Ê≥ïÂàõÂª∫ÂõæÁâáÂÖÉÁ¥†',
        tag: 'PracticeEdit',
      );
      return;
    }

    // Ëé∑ÂèñÂõæÂ∫ìÊúçÂä°
    final libraryService = ref.read(libraryServiceProvider);
    AppLogger.debug(
      'Â∑≤Ëé∑ÂèñÂõæÂ∫ìÊúçÂä°',
      tag: 'PracticeEdit',
    );

    // ÂØπ‰∫éÊØè‰∏™ÂõæÂ∫ìÈ°πÁõÆIDÔºåÂàõÂª∫‰∏Ä‰∏™ÂõæÁâáÂÖÉÁ¥†
    for (int i = 0; i < itemIds.length; i++) {
      final itemId = itemIds[i];
      AppLogger.debug(
        'Â§ÑÁêÜÂõæÂ∫ìÈ°πÁõÆID',
        tag: 'PracticeEdit',
        data: {'itemId': itemId, 'index': i},
      );

      try {
        // Ëé∑ÂèñÂõæÂ∫ìÈ°πÁõÆÊï∞ÊçÆ
        AppLogger.debug(
          'Ëé∑ÂèñÂõæÂ∫ìÈ°πÁõÆÊï∞ÊçÆ',
          tag: 'PracticeEdit',
          data: {'itemId': itemId},
        );
        final item = await libraryService.getItem(itemId);
        if (item == null) {
          AppLogger.warning(
            'Êó†Ê≥ïËé∑ÂèñÂõæÂ∫ìÈ°πÁõÆÊï∞ÊçÆÔºåË∑≥ËøáÊ≠§È°πÁõÆ',
            tag: 'PracticeEdit',
            data: {'itemId': itemId},
          );
          continue;
        }
        AppLogger.debug(
          'ÊàêÂäüËé∑ÂèñÂõæÂ∫ìÈ°πÁõÆÊï∞ÊçÆ',
          tag: 'PracticeEdit',
          data: {'itemId': itemId, 'path': item.path},
        );

        // ÂàõÂª∫Êñ∞ÂÖÉÁ¥†ID
        final newId = const Uuid().v4();
        AppLogger.debug(
          'ÂàõÂª∫Êñ∞ÂÖÉÁ¥†ID',
          tag: 'PracticeEdit',
          data: {'newId': newId, 'itemId': itemId},
        );

        // ËÆ°ÁÆóÊîæÁΩÆ‰ΩçÁΩÆÔºàÊåâÈ°∫Â∫èÊéíÂàóÔºâ
        final x = 100.0 + (i * 20);
        final y = 100.0 + (i * 20);

        AppLogger.debug(
          'ÂàõÂª∫Êñ∞ÁöÑÂõæÁâáÂÖÉÁ¥†',
          tag: 'PracticeEdit',
          data: {
            'elementId': newId,
            'type': 'image',
            'itemId': itemId,
            'x': x,
            'y': y,
          },
        ); // Ê∑ªÂä†Âà∞ÂΩìÂâçÈ°µÈù¢

        setState(() {
          // ‰ΩøÁî®ÊéßÂà∂Âô®ÁöÑÂÖ¨ÂÖ±ÊñπÊ≥ïÊ∑ªÂä†ÂõæÁâáÂÖÉÁ¥†
          // Â∞ÜÊñá‰ª∂Ë∑ØÂæÑËΩ¨Êç¢‰∏∫Áõ∏ÂØπË∑ØÂæÑÂ≠òÂÇ®
          final absoluteImageUrl = 'file://${item.path.replaceAll("\\", "/")}';
          final relativeImageUrl =
              ImagePathConverter.toRelativePath(absoluteImageUrl);
          _controller.addImageElementAt(x, y, relativeImageUrl);
          AppLogger.info(
            'ÊàêÂäüÊ∑ªÂä†ÂõæÁâáÂÖÉÁ¥†Âà∞È°µÈù¢',
            tag: 'PracticeEdit',
            data: {
              'position': {'x': x, 'y': y},
              'imageUrl': relativeImageUrl,
              'itemId': itemId,
            },
          );
        });
      } catch (e) {
        AppLogger.error(
          'Â§ÑÁêÜÂõæÂ∫ìÈ°πÁõÆÊó∂Âá∫Èîô',
          tag: 'PracticeEdit',
          error: e,
          data: {'itemId': itemId},
        );
      }
    }
    AppLogger.info(
      'ÂõæÂ∫ìÈ°πÁõÆÂâ™Ë¥¥ÊùøÊï∞ÊçÆÂ§ÑÁêÜÂÆåÊàê',
      tag: 'PracticeEdit',
      data: {'processedCount': itemIds.length},
    );
  }

  /// Initialize panel states from persistent storage
  void _initializePanelStates() {
    // Get persistent states for both panels
    final leftPanelState = ref.read(sidebarStateProvider((
      sidebarId: 'practice_edit_left_panel',
      defaultState: false, // Default to closed as requested
    )));

    final rightPanelState = ref.read(sidebarStateProvider((
      sidebarId: 'practice_edit_right_panel',
      defaultState: true, // Default to open
    )));

    // Update local state to match persistent state
    setState(() {
      _isLeftPanelOpen = leftPanelState;
      _isRightPanelOpen = rightPanelState;
    });
  }

  void _initKeyboardHandler() {
    _keyboardHandler = KeyboardHandler(
      controller: _controller,
      onTogglePreviewMode: () {
        setState(() {
          _isPreviewMode = !_isPreviewMode;
          _controller.togglePreviewMode(_isPreviewMode);
        });
      },
      onToggleThumbnails: () {
        setState(() {
          _showThumbnails = !_showThumbnails;
        });
      },
      onToggleToolbar: () {
        setState(() {
          _showToolbar = !_showToolbar;
        });
      },
      editTitle: _editTitle,
      savePractice: _savePractice,
      saveAsNewPractice: _saveAsNewPractice,
      selectAllElements: _selectAllElements,
      copySelectedElement: _copySelectedElement,
      pasteElement: _pasteElement,
      deleteSelectedElements: _deleteSelectedElements,
      groupSelectedElements: _groupSelectedElements,
      ungroupElements: _ungroupElements,
      bringToFront: _bringElementToFront,
      sendToBack: _sendElementToBack,
      moveElementUp: _moveElementUp,
      moveElementDown: _moveElementDown,
      toggleGrid: _toggleGrid,
      toggleSnap: _toggleSnap,
      toggleSelectedElementsVisibility: _toggleSelectedElementsVisibility,
      toggleSelectedElementsLock: _toggleSelectedElementsLock,
      showExportDialog: _showExportDialog,
      toggleLeftPanel: () {
        setState(() {
          _isLeftPanelOpen = !_isLeftPanelOpen;
        });
      },
      toggleRightPanel: () {
        setState(() {
          _isRightPanelOpen = !_isRightPanelOpen;
        });
      },
      moveSelectedElements: _moveSelectedElements,
      copyElementFormatting: _copyElementFormatting,
      applyFormatBrush: _applyFormatBrush,
      resetViewPosition: () => _controller.resetViewPosition(),
      goToPreviousPage: _goToPreviousPage,
      goToNextPage: _goToNextPage,
      // Add tool selection callback to connect keyboard shortcuts with toolbar
      onSelectTool: (tool) {
        setState(() {
          // Â¶ÇÊûúÂΩìÂâçÂ∑≤ÁªèÊòØselectÊ®°ÂºèÔºåÂÜçÊ¨°ÁÇπÂáªselectÊåâÈíÆÂàôÈÄÄÂá∫selectÊ®°Âºè
          if (_currentTool == 'select' && tool == 'select') {
            _currentTool = '';
            _controller.exitSelectMode();
          } else {
            _currentTool = tool;
            // ÂêåÊ≠•Âà∞controllerÁöÑÁä∂ÊÄÅ
            _controller.setCurrentTool(tool);
            PracticeEditLogger.logUserAction('Â∑•ÂÖ∑ÂàáÊç¢', data: {
              'newTool': tool,
              'previousTool': _currentTool,
            });
          }
        });
      },
    );

    // Ê∑ªÂä†ÈîÆÁõò‰∫ã‰ª∂Â§ÑÁêÜÂô®
    HardwareKeyboard.instance.addHandler(_keyboardHandler.handleKeyEvent);
  }

  /// Load practice
  Future<void> _loadPractice(String practiceId) async {
    if (!mounted) return;

    try {
      EditPageLogger.editPageInfo(
        'ÂºÄÂßãÂä†ËΩΩÂ≠óÂ∏ñ',
        data: {
          'practiceId': practiceId,
        },
      );

      final practice =
          await _controller.practiceService.getPractice(practiceId);
      if (!mounted) return;

      if (practice == null) {
        if (!mounted) return;
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
              content:
                  Text(AppLocalizations.of(context).practiceSheetNotExists)),
        );
        return;
      }

      // Êõ¥Êñ∞ÊéßÂà∂Âô®Áä∂ÊÄÅ
      _controller.updatePractice(practice);

      // üÜï Ê†πÊçÆÈ°µÈù¢Êï∞ÈáèËá™Âä®ÂÜ≥ÂÆöÊòØÂê¶ÊòæÁ§∫Áº©Áï•ÂõæÈù¢Êùø
      _updateThumbnailVisibilityBasedOnPageCount();

      // üÜï Â≠óÂ∏ñÂä†ËΩΩÂÆåÊàêÂêéËá™Âä®ÈáçÁΩÆÁîªÂ∏ÉËßÜÂõæ‰ΩçÁΩÆ
      // Âª∂ËøüÊâßË°å‰ª•Á°Æ‰øùUIÂÆåÂÖ®Êõ¥Êñ∞ÂÆåÊàê
      WidgetsBinding.instance.addPostFrameCallback((_) {
        if (mounted) {
          EditPageLogger.editPageInfo(
            'Â≠óÂ∏ñÂä†ËΩΩÂÆåÊàêÔºåËá™Âä®ÈáçÁΩÆËßÜÂõæ‰ΩçÁΩÆ',
            data: {
              'practiceId': practiceId,
              'practiceTitle': practice.title,
              'operation': 'auto_reset_view_after_load',
            },
          );
          _controller.resetViewPosition();
        }
      });
    } catch (e, stackTrace) {
      if (!mounted) return;

      EditPageLogger.editPageError(
        'Âä†ËΩΩÂ≠óÂ∏ñÂ§±Ë¥•',
        error: e,
        stackTrace: stackTrace,
        data: {
          'practiceId': practiceId,
        },
      );

      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
            content:
                Text(AppLocalizations.of(context).loadPracticeSheetFailed)),
      );
    }
  }

  /// Move element down one layer
  void _moveElementDown() {
    // Use controller directly without setState since it will notify listeners
    PracticeEditUtils.moveElementDown(_controller);
    // Only trigger a rebuild if we're not in a drag operation
    if (_canvasKey.currentState == null ||
        !_canvasKey.currentState!.context.mounted) {
      setState(() {});
    }
  }

  /// Move element up one layer
  void _moveElementUp() {
    // Use controller directly without setState since it will notify listeners
    PracticeEditUtils.moveElementUp(_controller);
    // Only trigger a rebuild if we're not in a drag operation
    if (_canvasKey.currentState == null ||
        !_canvasKey.currentState!.context.mounted) {
      setState(() {});
    }
  }

  /// Move selected elements
  void _moveSelectedElements(double dx, double dy) {
    if (_controller.state.selectedElementIds.isEmpty) return;

    final elements = _controller.state.currentPageElements;
    bool hasChanges = false;
    int movedCount = 0;

    for (final id in _controller.state.selectedElementIds) {
      final elementIndex = elements.indexWhere((e) => e['id'] == id);
      if (elementIndex >= 0) {
        final element = elements[elementIndex];

        // Check if element's layer is locked
        final layerId = element['layerId'] as String?;
        if (layerId != null && _controller.state.isLayerLocked(layerId)) {
          continue; // Skip elements on locked layers
        }

        // Update element position
        element['x'] = (element['x'] as num).toDouble() + dx;
        element['y'] = (element['y'] as num).toDouble() + dy;
        hasChanges = true;
        movedCount++;
      }
    }

    if (hasChanges) {
      AppLogger.debug(
        'ÁßªÂä®ÈÄâ‰∏≠ÂÖÉÁ¥†',
        tag: 'PracticeEdit',
        data: {
          'movedCount': movedCount,
          'totalSelected': _controller.state.selectedElementIds.length,
          'deltaX': dx,
          'deltaY': dy,
        },
      );
      _controller.state.hasUnsavedChanges = true;
      setState(() {});
    }
  }

  /// Handle back button
  Future<bool> _onWillPop() async {
    final l10n = AppLocalizations.of(context);

    // Check for unsaved changes
    if (_controller.state.hasUnsavedChanges) {
      // Show confirmation dialog
      final bool? result = await showDialog<bool>(
        context: context,
        builder: (BuildContext context) {
          return AlertDialog(
            title: Text(l10n.unsavedChanges),
            content: Text(l10n.unsavedChanges),
            actions: <Widget>[
              TextButton(
                child: Text(l10n.cancel),
                onPressed: () {
                  Navigator.of(context).pop(false);
                },
              ),
              TextButton(
                child: Text(l10n.exit),
                onPressed: () {
                  Navigator.of(context).pop(true);
                },
              ),
            ],
          );
        },
      );

      // If user cancels, don't leave
      return result ?? false;
    }

    // No unsaved changes, can leave
    return true;
  }

  /// Paste element(s)
  void _pasteElement() async {
    AppLogger.info(
      'ÂºÄÂßãÁ≤òË¥¥Êìç‰Ωú',
      tag: 'PracticeEdit',
    );

    // È¶ñÂÖàÂ∞ùËØï‰ªéÂÜÖÈÉ®Ââ™Ë¥¥ÊùøÁ≤òË¥¥
    if (_clipboardElement != null) {
      AppLogger.debug(
        '‰ΩøÁî®ÂÜÖÈÉ®Ââ™Ë¥¥ÊùøÂÜÖÂÆπÁ≤òË¥¥',
        tag: 'PracticeEdit',
        data: {'type': _clipboardElement!['type']},
      );

      try {
        // Get services for cache warming
        final characterImageService = ref.read(characterImageServiceProvider);
        final imageCacheService = ref.read(imageCacheServiceProvider);

        // Use enhanced paste with cache warming
        await PracticeEditUtils.pasteElementWithCacheWarming(
          _controller,
          _clipboardElement,
          characterImageService: characterImageService,
          imageCacheService: imageCacheService,
        );

        setState(() {
          // UI state will be updated by the paste operation
        });
      } catch (e) {
        AppLogger.warning(
          'Â¢ûÂº∫Á≤òË¥¥Â§±Ë¥•ÔºåÂõûÈÄÄÂà∞Â∏∏ËßÑÁ≤òË¥¥',
          tag: 'PracticeEdit',
          error: e,
        );
        // Fallback to regular paste
        setState(() {
          PracticeEditUtils.pasteElement(_controller, _clipboardElement);
        });
      }
      return;
    }

    // Â¶ÇÊûúÂÜÖÈÉ®Ââ™Ë¥¥Êùø‰∏∫Á©∫ÔºåÂàôÂ∞ùËØï‰ªéÁ≥ªÁªüÂâ™Ë¥¥ÊùøËØªÂèñ
    try {
      AppLogger.debug(
        'ÂÜÖÈÉ®Ââ™Ë¥¥Êùø‰∏∫Á©∫ÔºåÂ∞ùËØïËØªÂèñÁ≥ªÁªüÂâ™Ë¥¥Êùø',
        tag: 'PracticeEdit',
      );
      final clipboardData = await Clipboard.getData(Clipboard.kTextPlain);

      if (clipboardData == null || clipboardData.text == null) {
        // Ââ™Ë¥¥Êùø‰∏∫Á©∫ÔºåÊó†Ê≥ïÁ≤òË¥¥
        AppLogger.debug(
          'Á≥ªÁªüÂâ™Ë¥¥Êùø‰∏∫Á©∫ÊàñÊ≤°ÊúâÊñáÊú¨ÂÜÖÂÆπ',
          tag: 'PracticeEdit',
        );
        return;
      }

      final text = clipboardData.text!;
      AppLogger.debug(
        'Á≥ªÁªüÂâ™Ë¥¥ÊùøÊúâÊñáÊú¨ÂÜÖÂÆπ',
        tag: 'PracticeEdit',
        data: {'length': text.length},
      );

      // Ê£ÄÊü•ÊòØÂê¶ÊòØJSONÊ†ºÂºè
      try {
        AppLogger.debug(
          'Â∞ùËØïËß£Êûê‰∏∫JSON',
          tag: 'PracticeEdit',
        );
        final json = jsonDecode(text);
        AppLogger.debug(
          'ÊàêÂäüËß£Êûê‰∏∫JSON',
          tag: 'PracticeEdit',
        );

        // Âà§Êñ≠ÊòØÂì™ÁßçÁ±ªÂûãÁöÑÊï∞ÊçÆ
        final type = json['type'];
        AppLogger.debug(
          'JSONÁ±ªÂûã',
          tag: 'PracticeEdit',
          data: {'type': type},
        );

        if (type == 'characters') {
          // Â§ÑÁêÜ‰ªéÂ≠óÁ¨¶ÁÆ°ÁêÜÈ°µÈù¢Â§çÂà∂ÁöÑÂ≠óÁ¨¶
          AppLogger.debug(
            'Â§ÑÁêÜÂ≠óÁ¨¶Á±ªÂûãÊï∞ÊçÆ',
            tag: 'PracticeEdit',
          );
          await _handleCharacterClipboardData(json);
          AppLogger.info(
            'Â≠óÁ¨¶Êï∞ÊçÆÂ§ÑÁêÜÂÆåÊàê',
            tag: 'PracticeEdit',
          );
        } else if (type == 'library_items') {
          // Â§ÑÁêÜ‰ªéÂõæÂ∫ìÁÆ°ÁêÜÈ°µÈù¢Â§çÂà∂ÁöÑÂõæÁâá
          AppLogger.debug(
            'Â§ÑÁêÜÂõæÂ∫ìÈ°πÁõÆÁ±ªÂûãÊï∞ÊçÆ',
            tag: 'PracticeEdit',
          );
          await _handleLibraryItemClipboardData(json);
          AppLogger.info(
            'ÂõæÂ∫ìÈ°πÁõÆÊï∞ÊçÆÂ§ÑÁêÜÂÆåÊàê',
            tag: 'PracticeEdit',
          );
        } else if (type == 'practice_elements') {
          // üÜï Â§ÑÁêÜ‰ªéÂÖ∂‰ªñÂ≠óÂ∏ñÁºñËæëÈ°µÈù¢Â§çÂà∂ÁöÑÂÖÉÁ¥†ÔºàË∑®È°µÈù¢Â§çÂà∂Á≤òË¥¥Ôºâ
          AppLogger.debug(
            'Â§ÑÁêÜÂ≠óÂ∏ñÁºñËæëÂÖÉÁ¥†Á±ªÂûãÊï∞ÊçÆÔºàË∑®È°µÈù¢Â§çÂà∂Á≤òË¥¥Ôºâ',
            tag: 'PracticeEdit',
            data: {
              'source': json['source'],
              'timestamp': json['timestamp'],
            },
          );

          final elementData = json['data'];
          if (elementData != null) {
            try {
              // Get services for cache warming
              final characterImageService =
                  ref.read(characterImageServiceProvider);
              final imageCacheService = ref.read(imageCacheServiceProvider);

              // Use enhanced paste with cache warming for cross-page elements
              await PracticeEditUtils.pasteElementWithCacheWarming(
                _controller,
                elementData,
                characterImageService: characterImageService,
                imageCacheService: imageCacheService,
              );

              setState(() {
                // UI state will be updated by the paste operation
              });

              AppLogger.info(
                'Ë∑®È°µÈù¢Â≠óÂ∏ñÂÖÉÁ¥†Á≤òË¥¥ÊàêÂäü',
                tag: 'PracticeEdit',
                data: {
                  'elementType': elementData['type'],
                  'source': json['source'],
                },
              );

              // ÊòæÁ§∫ÊàêÂäüÊèêÁ§∫
              if (mounted) {
                ScaffoldMessenger.of(context).showSnackBar(
                  SnackBar(
                    content: Text(
                        AppLocalizations.of(context).crossPagePasteSuccess),
                    duration: const Duration(seconds: 2),
                  ),
                );
              }
            } catch (e) {
              AppLogger.warning(
                'Ë∑®È°µÈù¢Â≠óÂ∏ñÂÖÉÁ¥†Á≤òË¥¥Â§±Ë¥•',
                tag: 'PracticeEdit',
                error: e,
              );
              // Fallback to regular paste
              PracticeEditUtils.pasteElement(_controller, elementData);
              setState(() {});
            }
          }

          AppLogger.info(
            'Ë∑®È°µÈù¢Â≠óÂ∏ñÂÖÉÁ¥†Êï∞ÊçÆÂ§ÑÁêÜÂÆåÊàê',
            tag: 'PracticeEdit',
          );
        } else {
          // Â∞ùËØï‰Ωú‰∏∫ÈÄöÁî® JSON ÂÖÉÁ¥†Â§ÑÁêÜ
          AppLogger.debug(
            'Â§ÑÁêÜÈÄöÁî®JSONÂÖÉÁ¥†',
            tag: 'PracticeEdit',
          );
          try {
            // Get services for cache warming
            final characterImageService =
                ref.read(characterImageServiceProvider);
            final imageCacheService = ref.read(imageCacheServiceProvider);

            // Use enhanced paste with cache warming
            await PracticeEditUtils.pasteElementWithCacheWarming(
              _controller,
              json,
              characterImageService: characterImageService,
              imageCacheService: imageCacheService,
            );
            setState(() {
              // UI state will be updated by the paste operation
            });

            // After paste operation, check and update clipboard state
            final hasContent = await _checkClipboardContent();
            _clipboardHasContent = hasContent;
            _clipboardNotifier.value = hasContent;
            AppLogger.debug(
              'Á≤òË¥¥ÂêéÊõ¥Êñ∞Ââ™Ë¥¥ÊùøÁä∂ÊÄÅ',
              tag: 'PracticeEdit',
              data: {'hasContent': _clipboardHasContent},
            );
          } catch (e) {
            AppLogger.warning(
              'Â¢ûÂº∫JSONÁ≤òË¥¥Â§±Ë¥•ÔºåÂõûÈÄÄÂà∞Â∏∏ËßÑÁ≤òË¥¥',
              tag: 'PracticeEdit',
              error: e,
            );
            // Fallback to regular paste
            setState(() {
              PracticeEditUtils.pasteElement(_controller, json);
            });

            // After paste operation, check and update clipboard state
            final hasContent = await _checkClipboardContent();
            _clipboardHasContent = hasContent;
            _clipboardNotifier.value = hasContent;
          }
        }
      } catch (e) {
        // ‰∏çÊòØÊúâÊïàÁöÑ JSONÔºå‰Ωú‰∏∫Á∫ØÊñáÊú¨Â§ÑÁêÜ
        AppLogger.warning(
          '‰∏çÊòØÊúâÊïàÁöÑJSONÔºå‰Ωú‰∏∫Á∫ØÊñáÊú¨Â§ÑÁêÜ',
          tag: 'PracticeEdit',
          error: e,
        );
        _createTextElementFromText(text);
      }

      // Refresh clipboard state after pasting
      _checkClipboardContent().then((hasContent) {
        setState(() {
          _clipboardHasContent = hasContent;
          AppLogger.debug(
            'Á≤òË¥¥ÂêéÊõ¥Êñ∞Ââ™Ë¥¥ÊùøÁä∂ÊÄÅ',
            tag: 'PracticeEdit',
            data: {'hasContent': _clipboardHasContent},
          );
        });
      });
    } catch (e) {
      AppLogger.error(
        'Á≤òË¥¥Êìç‰ΩúÂá∫Èîô',
        tag: 'PracticeEdit',
        error: e,
      );
    }
  }

  /// Ê≥®ÂÜåÂ±ûÊÄßÈù¢ÊùøÂà∞Êô∫ËÉΩÁä∂ÊÄÅÂàÜÂèëÂô®
  void _registerPropertyPanelToIntelligentDispatcher() {
    final intelligentDispatcher = _controller.intelligentDispatcher;
    if (intelligentDispatcher != null) {
      // ÂàõÂª∫Âπ∂‰øùÂ≠òÂõûË∞ÉÂºïÁî®
      _propertyPanelListener = () {
        if (mounted) {
          setState(() {
            // ÈáçÂª∫Â±ûÊÄßÈù¢Êùø
          });
        }
      };

      // Ê≥®ÂÜåÂ±ûÊÄßÈù¢Êùø‰Ωú‰∏∫UIÁªÑ‰ª∂ÁõëÂê¨Âô®
      intelligentDispatcher.registerUIListener(
          'property_panel', _propertyPanelListener!);
    }
  }

  /// Reorder pages
  void _reorderPages(int oldIndex, int newIndex) {
    // Use controller's mixin method which includes proper state management
    _controller.reorderPages(oldIndex, newIndex);
    // The controller will notify listeners automatically through intelligent notification
  }

  /// Save as new practice
  Future<void> _saveAsNewPractice() async {
    final l10n = AppLocalizations.of(context);

    if (_controller.state.pages.isEmpty) {
      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text(l10n.cannotSaveNoPages)),
      );
      return;
    }

    // Save ScaffoldMessenger reference to avoid using context after async operation
    final scaffoldMessenger = ScaffoldMessenger.of(context);

    // ‰ΩøÁî®PracticeSaveDialogËé∑ÂèñÊ†áÈ¢ò
    final title = await showDialog<String>(
      context: context,
      builder: (context) => PracticeSaveDialog(
        initialTitle: _controller.practiceTitle,
        isSaveAs: true,
        checkTitleExists: _controller.checkTitleExists,
      ),
    );

    if (title == null || title.isEmpty) return;

    // Save practice
    AppLogger.info(
      'ÂºÄÂßã‰øùÂ≠òÊñ∞Â≠óÂ∏ñ',
      tag: 'PracticeEdit',
      data: {'title': title},
    );

    try {
      final result = await _controller.saveAsNewPractice(title);

      if (!mounted) return;

      // Ê†πÊçÆËøîÂõûÂÄºÁ±ªÂûãËøõË°å‰∏çÂêåÂ§ÑÁêÜ
      if (result == true) {
        AppLogger.info(
          'Êñ∞Â≠óÂ∏ñ‰øùÂ≠òÊàêÂäü',
          tag: 'PracticeEdit',
          data: {'title': title},
        );
        scaffoldMessenger.showSnackBar(
          SnackBar(content: Text(l10n.practiceEditPracticeLoaded(title))),
        );
      } else if (result is String && result == 'title_exists') {
        // Title already exists, ask whether to overwrite
        final shouldOverwrite = await showDialog<bool>(
          context: context,
          builder: (context) => AlertDialog(
            title: Text(l10n.titleExists),
            content: Text(l10n.titleExistsMessage),
            actions: [
              TextButton(
                onPressed: () => Navigator.of(context).pop(false),
                child: Text(l10n.cancel),
              ),
              FilledButton(
                onPressed: () => Navigator.of(context).pop(true),
                child: Text(l10n.overwrite),
              ),
            ],
          ),
        );

        if (!mounted) return;

        if (shouldOverwrite == true) {
          final saveResult =
              await _controller.saveAsNewPractice(title, forceOverwrite: true);

          if (!mounted) return;

          if (saveResult == true) {
            scaffoldMessenger.showSnackBar(
              SnackBar(content: Text(l10n.practiceEditPracticeLoaded(title))),
            );
          } else {
            scaffoldMessenger.showSnackBar(
              SnackBar(content: Text(l10n.saveFailure)),
            );
          }
        }
      } else {
        // Â§ÑÁêÜÂÖ∂‰ªñÂ§±Ë¥•ÊÉÖÂÜµ
        scaffoldMessenger.showSnackBar(
          SnackBar(content: Text(l10n.saveFailure)),
        );
      }
    } catch (e) {
      // Â§ÑÁêÜÂºÇÂ∏∏ÊÉÖÂÜµ
      AppLogger.error(
        '‰øùÂ≠òÂ≠óÂ∏ñÊó∂ÂèëÁîüÂºÇÂ∏∏',
        tag: 'PracticeEdit',
        error: e,
      );

      if (mounted) {
        scaffoldMessenger.showSnackBar(
          SnackBar(content: Text('${l10n.saveFailure}: ${e.toString()}')),
        );
      }
    }
  }

  /// Save practice
  /// Returns true if save was successful, false otherwise
  Future<bool> _savePractice() async {
    final l10n = AppLocalizations.of(context);

    if (_controller.state.pages.isEmpty) {
      if (!mounted) return false;
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text(l10n.cannotSaveNoPages)),
      );
      return false;
    }

    // Save ScaffoldMessenger reference to avoid using context after async operation
    final scaffoldMessenger = ScaffoldMessenger.of(context);

    // Â¶ÇÊûú‰ªéÊú™‰øùÂ≠òËøáÔºåÊòæÁ§∫‰øùÂ≠òÂØπËØùÊ°ÜËÆ©Áî®Êà∑ËæìÂÖ•Ê†áÈ¢ò
    if (!_controller.isSaved) {
      await _saveAsNewPractice();
      return true; // ËÆ§‰∏∫‰øùÂ≠òÂ∞ùËØïÊàêÂäüÔºåÂç≥‰ΩøË¢´ÂèñÊ∂à
    }

    try {
      // Save practice
      AppLogger.info(
        'ÂºÄÂßã‰øùÂ≠òÂ≠óÂ∏ñ',
        tag: 'PracticeEdit',
        data: {'practiceId': _controller.practiceId},
      );
      final result = await _controller.savePractice();

      if (!mounted) return false;

      // Ê†πÊçÆËøîÂõûÂÄºÁ±ªÂûãËøõË°å‰∏çÂêåÂ§ÑÁêÜ
      if (result == true) {
        AppLogger.info(
          'Â≠óÂ∏ñ‰øùÂ≠òÊàêÂäü',
          tag: 'PracticeEdit',
          data: {'practiceId': _controller.practiceId},
        );
        scaffoldMessenger.showSnackBar(
          SnackBar(content: Text(l10n.saveSuccess)),
        );
        return true;
      } else if (result is String && result == 'title_exists') {
        // Ê†áÈ¢òÂ∑≤Â≠òÂú®ÔºåËØ¢ÈóÆÊòØÂê¶Ë¶ÜÁõñ
        final shouldOverwrite = await showDialog<bool>(
          context: context,
          builder: (context) => AlertDialog(
            title: Text(l10n.titleExists),
            content: Text(l10n.titleExistsMessage),
            actions: [
              TextButton(
                onPressed: () => Navigator.of(context).pop(false),
                child: Text(l10n.cancel),
              ),
              FilledButton(
                onPressed: () => Navigator.of(context).pop(true),
                child: Text(l10n.overwrite),
              ),
            ],
          ),
        );

        if (!mounted) return false;

        if (shouldOverwrite == true) {
          final saveResult =
              await _controller.savePractice(forceOverwrite: true);

          if (!mounted) return false;

          if (saveResult == true) {
            scaffoldMessenger.showSnackBar(
              SnackBar(content: Text(l10n.saveSuccess)),
            );
            return true;
          } else {
            scaffoldMessenger.showSnackBar(
              SnackBar(content: Text(l10n.saveFailure)),
            );
            return false;
          }
        }
        return false;
      } else {
        // Â§ÑÁêÜÂÖ∂‰ªñÂ§±Ë¥•ÊÉÖÂÜµ
        scaffoldMessenger.showSnackBar(
          SnackBar(content: Text(l10n.saveFailure)),
        );
        return false;
      }
    } catch (e) {
      // Â§ÑÁêÜÂºÇÂ∏∏ÊÉÖÂÜµ
      AppLogger.error(
        '‰øùÂ≠òÂ≠óÂ∏ñÊó∂ÂèëÁîüÂºÇÂ∏∏',
        tag: 'PracticeEdit',
        error: e,
      );

      if (mounted) {
        scaffoldMessenger.showSnackBar(
          SnackBar(content: Text('${l10n.saveFailure}: ${e.toString()}')),
        );
      }
      return false;
    }
  }

  /// Select all elements on current page
  void _selectAllElements() {
    if (_controller.state.currentPageIndex < 0 ||
        _controller.state.currentPageIndex >= _controller.state.pages.length) {
      return;
    }

    final elements = _controller.state.currentPageElements;
    if (elements.isEmpty) return;

    // Collect IDs of all elements on unlocked layers
    final ids = <String>[];
    for (final element in elements) {
      final id = element['id'] as String;
      final layerId = element['layerId'] as String?;

      // If element's layer is not locked, add to selection list
      if (layerId == null || !_controller.state.isLayerLocked(layerId)) {
        ids.add(id);
      }
    }

    // üîß ‰øÆÂ§çÔºö‰ΩøÁî®controllerÁöÑselectElementsÊñπÊ≥ïÔºåÁ°Æ‰øùnotifyListenersË¢´Ë∞ÉÁî®
    _controller.selectElements(ids);
  }

  /// Send element to back
  void _sendElementToBack() {
    // Use controller directly without setState since it will notify listeners
    PracticeEditUtils.sendElementToBack(_controller);
    // Only trigger a rebuild if we're not in a drag operation
    if (_canvasKey.currentState == null ||
        !_canvasKey.currentState!.context.mounted) {
      setState(() {});
    }
  }

  /// Set up the reference to the canvas in the controller
  void _setupCanvasReference() {
    // Canvas will register itself with the controller in its initState
    AppLogger.debug(
      'ÁîªÂ∏ÉÂºïÁî®Â∞ÜÁî±ÁîªÂ∏ÉÁªÑ‰ª∂Ëá™Ë∫´ËÆæÁΩÆ',
      tag: 'PracticeEdit',
    );
  }

  /// Show export dialog
  Future<void> _showExportDialog() async {
    if (!mounted) return;

    // Get default filename
    final defaultFileName = _controller.practiceTitle ?? 'Untitled Practice';

    // Call FileOperations.exportPractice method, consistent with export button behavior
    await FileOperations.exportPractice(
      context,
      _controller.state.pages,
      _controller,
      defaultFileName,
    );
  }

  /// Select local image
  Future<void> _showImageUrlDialog(BuildContext context) async {
    await PracticeEditUtils.showImageUrlDialog(context, _controller);
  }

  /// Start monitoring clipboard contents periodically
  void _startClipboardMonitoring() {
    // Cancel any existing timer
    _clipboardMonitoringTimer?.cancel();

    // Create a periodic timer that checks clipboard every 2 seconds
    _clipboardMonitoringTimer =
        Timer.periodic(const Duration(seconds: 2), (timer) async {
      if (!mounted) {
        timer.cancel();
        return;
      }

      try {
        // Periodically check clipboard content
        final hasContent = await _checkClipboardContent();
        if (hasContent != _clipboardHasContent) {
          // Check if drag operation is active to avoid setState during dragging
          final isDragging = _canvasKey.currentState != null &&
              _canvasKey.currentState!.context.mounted;

          // Always update the ValueNotifier (doesn't trigger rebuild)
          _clipboardNotifier.value = hasContent;

          // Update local variable too for backward compatibility
          _clipboardHasContent = hasContent;

          // Only use setState if we're not in a drag operation
          if (!isDragging && mounted) {
            setState(() {
              // Empty setState to trigger rebuild - local variable already updated
            });
          }
        }
      } catch (e) {
        AppLogger.error(
          'Ââ™Ë¥¥ÊùøÁõëÊéßÈîôËØØ',
          tag: 'PracticeEdit',
          error: e,
        );
      }
    });
  }

  /// üÜï Ê†πÊçÆÈ°µÈù¢Êï∞ÈáèËá™Âä®ÂÜ≥ÂÆöÊòØÂê¶ÊòæÁ§∫È°µÈù¢Áº©Áï•ÂõæÊ†è
  /// Â§öÈ°µÂ≠óÂ∏ñÊòæÁ§∫ÔºåÂçïÈ°µÂ≠óÂ∏ñÈöêËóè
  void _updateThumbnailVisibilityBasedOnPageCount() {
    if (!mounted) return;

    final pageCount = _controller.state.pages.length;
    final shouldShowThumbnails = pageCount > 1;

    // Âè™ÊúâÂΩìÁä∂ÊÄÅÁúüÊ≠£ÊîπÂèòÊó∂ÊâçÊõ¥Êñ∞UI
    if (_showThumbnails != shouldShowThumbnails) {
      setState(() {
        _showThumbnails = shouldShowThumbnails;
      });

      EditPageLogger.editPageInfo(
        'Ê†πÊçÆÈ°µÈù¢Êï∞ÈáèËá™Âä®Êõ¥Êñ∞Áº©Áï•ÂõæÊòæÁ§∫Áä∂ÊÄÅ',
        data: {
          'pageCount': pageCount,
          'shouldShowThumbnails': shouldShowThumbnails,
          'previousState': _showThumbnails,
          'operation': 'auto_update_thumbnail_visibility',
        },
      );

      AppLogger.info(
        'Áº©Áï•ÂõæÊòæÁ§∫Áä∂ÊÄÅÂ∑≤Ëá™Âä®Êõ¥Êñ∞',
        tag: 'PracticeEdit',
        data: {
          'pageCount': pageCount,
          'isMultiPage': pageCount > 1,
          'thumbnailsVisible': shouldShowThumbnails,
        },
      );
    }
  }

  /// Synchronize local _currentTool with controller's state.currentTool
  void _syncToolState() {
    // üîß ‰øÆÂ§çÔºöÁ°Æ‰øùÊâÄÊúâÁä∂ÊÄÅÊõ¥Êñ∞ÈÉΩÂú®‰∏ã‰∏ÄÂ∏ßÊâßË°åÔºåÈÅøÂÖçÂú®ÊûÑÂª∫ÊúüÈó¥‰øÆÊîπÁä∂ÊÄÅ
    WidgetsBinding.instance.addPostFrameCallback((_) {
      if (!mounted) return;

      // Âè™Êõ¥Êñ∞Êú¨Âú∞ÂèòÈáèÔºå‰∏çËß¶ÂèëÈ°µÈù¢ÈáçÂª∫
      // Â∑•ÂÖ∑Áä∂ÊÄÅÂèòÂåñÁöÑUIÊõ¥Êñ∞Â∫îËØ•ÈÄöËøáÊô∫ËÉΩÁä∂ÊÄÅÂàÜÂèëÂô®ÂíåÂ±ÄÈÉ®ÁªÑ‰ª∂Â§ÑÁêÜ
      final controllerTool = _controller.state.currentTool;
      if (_currentTool != controllerTool) {
        _currentTool = controllerTool;
      }

      // üÜï Ê£ÄÊµãÈ°µÈù¢ÂàáÊç¢Âπ∂Êõ¥Êñ∞Ââ™Ë¥¥ÊùøÁä∂ÊÄÅ
      final currentPageIndex = _controller.state.currentPageIndex;

      if (_lastPageIndex != currentPageIndex) {
        final oldPageIndex = _lastPageIndex;
        _lastPageIndex = currentPageIndex;

        AppLogger.debug(
          'Ê£ÄÊµãÂà∞È°µÈù¢ÂàáÊç¢ÔºåÁ´ãÂç≥Êõ¥Êñ∞Ââ™Ë¥¥ÊùøÁä∂ÊÄÅ',
          tag: 'PracticeEdit',
          data: {
            'oldPageIndex': oldPageIndex,
            'newPageIndex': currentPageIndex,
          },
        );

        // Âú®‰∏ã‰∏ÄÂ∏ßÂºÇÊ≠•ÊâßË°åÂâ™Ë¥¥ÊùøÁä∂ÊÄÅÊõ¥Êñ∞
        _updateClipboardStateAfterPageSwitch(currentPageIndex);
      }

      // üÜï Ê£ÄÊµãÈ°µÈù¢Êï∞ÈáèÂèòÂåñÂπ∂Êõ¥Êñ∞Áº©Áï•ÂõæÊòæÁ§∫Áä∂ÊÄÅ
      // ËøôÁî®‰∫éÂ§ÑÁêÜÈÄöËøáÂÖ∂‰ªñÊñπÂºèÔºàÂ¶ÇÊí§ÈîÄ/ÈáçÂÅöÔºâÊîπÂèòÈ°µÈù¢Êï∞ÈáèÁöÑÊÉÖÂÜµ
      _updateThumbnailVisibilityBasedOnPageCount();
    });
  }

  /// È°µÈù¢ÂàáÊç¢ÂêéÊõ¥Êñ∞Ââ™Ë¥¥ÊùøÁä∂ÊÄÅ
  void _updateClipboardStateAfterPageSwitch(int pageIndex) async {
    if (!mounted) return;

    try {
      final hasContent = await _checkClipboardContent();

      AppLogger.debug(
        'È°µÈù¢ÂàáÊç¢Ââ™Ë¥¥ÊùøÊ£ÄÊü•ÁªìÊûú',
        tag: 'PracticeEdit',
        data: {
          'hasContent': hasContent,
          'oldState': _clipboardHasContent,
          'pageIndex': pageIndex,
          'clipboardElement':
              _clipboardElement != null ? _clipboardElement!['type'] : 'null',
        },
      );

      if (mounted) {
        // Âº∫Âà∂Êõ¥Êñ∞Áä∂ÊÄÅÔºåÊó†ËÆ∫ÊòØÂê¶ÊúâÂèòÂåñ
        _clipboardHasContent = hasContent;
        _clipboardNotifier.value = hasContent;

        AppLogger.info(
          'È°µÈù¢ÂàáÊç¢ÂêéÂº∫Âà∂Êõ¥Êñ∞Ââ™Ë¥¥ÊùøÁä∂ÊÄÅ',
          tag: 'PracticeEdit',
          data: {
            'hasContent': hasContent,
            'pageIndex': pageIndex,
            'forceUpdate': true,
            'notifierValue': _clipboardNotifier.value,
          },
        );

        // ÂÆâÂÖ®Âú∞‰ΩøÁî®setStateÊõ¥Êñ∞UI
        setState(() {});
      }
    } catch (e) {
      AppLogger.error(
        'È°µÈù¢ÂàáÊç¢Êó∂Ê£ÄÊü•Ââ™Ë¥¥ÊùøÁä∂ÊÄÅÂ§±Ë¥•',
        tag: 'PracticeEdit',
        error: e,
      );
    }
  }

  /// ÂàáÊç¢ÂØπÈΩêÊ®°Âºè (‰∏âÊÄÅÂàáÊç¢)
  void _toggleAlignmentMode() {
    // Âè™‰ΩøÁî®controller‰∏≠ÁöÑÊñπÊ≥ïËøõË°å‰∏âÊÄÅÂàáÊç¢ÔºåÈÅøÂÖçÈáçÂ§çË∞ÉÁî®
    _controller.toggleAlignmentMode();

    EditPageLogger.editPageInfo('ÂØπÈΩêÊ®°ÂºèÂàáÊç¢', data: {
      'alignmentMode': _controller.state.alignmentMode.name,
      'snapEnabled': _controller.state.snapEnabled,
      'gridSize': _controller.state.gridSize,
      'snapThreshold': _controller.state.snapThreshold,
      'operation': 'toggle_alignment_mode',
    });

    // Âº∫Âà∂Êõ¥Êñ∞UI
    setState(() {});
  }

  /// Toggle grid visibility
  void _toggleGrid() {
    final oldValue = _controller.state.gridVisible;
    _controller.state.gridVisible = !_controller.state.gridVisible;

    debugPrint('üé® ÁΩëÊ†ºÊòæÁ§∫ÂàáÊç¢: $oldValue ‚Üí ${_controller.state.gridVisible}');
    debugPrint('üé® ÁΩëÊ†ºÂ§ßÂ∞è: ${_controller.state.gridSize}');
    debugPrint(
        'üé® ÂΩìÂâçÈ°µÈù¢: ${_controller.state.currentPage != null ? "Â≠òÂú®" : "null"}');

    // üîß Ëß¶ÂèëÁΩëÊ†ºËÆæÁΩÆÂèòÂåñ‰∫ã‰ª∂ÔºåÁ°Æ‰øùstaticBackgroundÂ±ÇÊõ¥Êñ∞
    debugPrint('üé® Ë∞ÉÁî® triggerGridSettingsChange()');
    _controller.triggerGridSettingsChange();

    // Âº∫Âà∂ÈáçÂª∫UI
    debugPrint('üé® Ë∞ÉÁî® setState() Âº∫Âà∂ÈáçÂª∫UI');
    setState(() {});

    debugPrint('üé® ÁΩëÊ†ºÂàáÊç¢ÂÆåÊàê');
  }

  /// Toggle lock state of selected elements
  void _toggleSelectedElementsLock() {
    setState(() {
      PracticeEditUtils.toggleSelectedElementsLock(_controller);
    });
  }

  /// Toggle visibility of selected elements
  void _toggleSelectedElementsVisibility() {
    setState(() {
      PracticeEditUtils.toggleSelectedElementsVisibility(_controller);
    });
  }

  /// Toggle snap to grid (ÂÖºÂÆπÊÄßÊñπÊ≥ïÔºåÈÄêÊ≠•ËøáÊ∏°Âà∞Êñ∞ÁöÑÂØπÈΩêÊ®°Âºè)
  void _toggleSnap() {
    final oldValue = _controller.state.snapEnabled;
    _controller.state.snapEnabled = !_controller.state.snapEnabled;

    // ÂêåÊ≠•Êñ∞ÁöÑÂØπÈΩêÊ®°Âºè
    if (_controller.state.snapEnabled) {
      _controller.state.alignmentMode = AlignmentMode.gridSnap;
    } else {
      _controller.state.alignmentMode = AlignmentMode.none;
    }

    // üîß Ëß¶ÂèëÁΩëÊ†ºËÆæÁΩÆÂèòÂåñ‰∫ã‰ª∂ÔºåÁ°Æ‰øùÁä∂ÊÄÅÂêåÊ≠•
    _controller.triggerGridSettingsChange();

    EditPageLogger.editPageInfo(
      'ÁΩëÊ†ºÂê∏ÈôÑÂàáÊç¢',
      data: {
        'oldValue': oldValue,
        'newValue': _controller.state.snapEnabled,
        'alignmentMode': _controller.state.alignmentMode.name,
        'operation': 'toggle_snap',
      },
    );

    // Âº∫Âà∂Êõ¥Êñ∞UI
    setState(() {});
  }

  /// Ungroup elements
  void _ungroupElements() {
    if (_controller.state.selectedElementIds.length == 1) {
      final id = _controller.state.selectedElementIds.first;
      final element = _controller.state.currentPageElements.firstWhere(
        (e) => e['id'] == id,
        orElse: () => <String, dynamic>{},
      );

      if (element.isNotEmpty && element['type'] == 'group') {
        AppLogger.info(
          'Ëß£ÁªÑÈÄâ‰∏≠ÂÖÉÁ¥†',
          tag: 'PracticeEdit',
          data: {
            'groupId': id,
            'groupType': element['type'],
          },
        );
        // Use the safe ungroup method to prevent ID conflicts
        PracticeEditUtils.safeUngroupSelectedElement(_controller);
      }
    }
  }

  /// ‚úÖ Ê≥®ÈîÄÂ±ûÊÄßÈù¢ÊùøÁöÑÊô∫ËÉΩÁä∂ÊÄÅÁõëÂê¨Âô®
  void _unregisterPropertyPanelFromIntelligentDispatcher() {
    final intelligentDispatcher = _controller.intelligentDispatcher;
    if (intelligentDispatcher != null && _propertyPanelListener != null) {
      try {
        // ‰ΩøÁî®Ê≠£Á°ÆÁöÑÊñπÊ≥ïÂêçÂèäÂ∑≤‰øùÂ≠òÁöÑÂõûË∞ÉÂºïÁî®
        intelligentDispatcher.removeUIListener(
            'property_panel', _propertyPanelListener!);
        _propertyPanelListener = null;

        EditPageLogger.editPageDebug(
          'Â±ûÊÄßÈù¢ÊùøÂ∑≤‰ªéÊô∫ËÉΩÁä∂ÊÄÅÂàÜÂèëÂô®Ê≥®ÈîÄ',
          data: {
            'operation': 'cleanup_property_panel_listeners',
          },
        );
      } catch (e) {
        // Ê∑ªÂä†ÈîôËØØÂ§ÑÁêÜÔºåÈò≤Ê≠¢Â∫îÁî®Â¥©Ê∫É
        EditPageLogger.editPageError(
          'Â±ûÊÄßÈù¢ÊùøÊ≥®ÈîÄÂ§±Ë¥•',
          error: e,
          data: {
            'operation': 'cleanup_property_panel_listeners_failed',
          },
        );
      }
    }
  }

  /// üî• Áõ¥Êé•ÊâßË°åÂõæÂÉè‰∫åÂÄºÂåñÂ§ÑÁêÜ
  Future<void> _executeDirectImageBinarization(
      String elementId, Map<String, dynamic> content) async {
    try {
      final imageUrl = content['imageUrl'] as String?;
      if (imageUrl == null || imageUrl.isEmpty) {
        AppLogger.warning('ÂõæÂÉèURL‰∏∫Á©∫ÔºåÊó†Ê≥ïÊâßË°å‰∫åÂÄºÂåñÂ§ÑÁêÜ', tag: 'PracticeEdit');
        return;
      }

      // Ëé∑ÂèñÂõæÂÉèÂ§ÑÁêÜÂô®
      final imageProcessor = ref.read(imageProcessorProvider);

      // Ëé∑Âèñ‰∫åÂÄºÂåñÂèÇÊï∞
      final threshold =
          (content['binaryThreshold'] as num?)?.toDouble() ?? 128.0;
      final isNoiseReductionEnabled =
          content['isNoiseReductionEnabled'] as bool? ?? false;
      final noiseReductionLevel =
          (content['noiseReductionLevel'] as num?)?.toDouble() ?? 3.0;

      AppLogger.info(
        'ÂºÄÂßãÁõ¥Êé•‰∫åÂÄºÂåñÂ§ÑÁêÜ',
        tag: 'PracticeEdit',
        data: {
          'elementId': elementId,
          'imageUrl': imageUrl,
          'threshold': threshold,
          'noiseReduction': isNoiseReductionEnabled,
          'noiseLevel': noiseReductionLevel,
        },
      );

      // Âä†ËΩΩÂéüÂßãÂõæÂÉè
      Uint8List? imageData;
      if (imageUrl.startsWith('file://')) {
        final filePath = imageUrl.substring(7);
        final file = File(filePath);
        if (await file.exists()) {
          imageData = await file.readAsBytes();
        }
      } else {
        final response = await http.get(Uri.parse(imageUrl));
        if (response.statusCode == 200) {
          imageData = response.bodyBytes;
        }
      }

      if (imageData == null) {
        AppLogger.error('Êó†Ê≥ïÂä†ËΩΩÂõæÂÉèÊï∞ÊçÆ', tag: 'PracticeEdit');
        return;
      }

      // Ëß£Á†ÅÂõæÂÉè
      final img.Image? sourceImage = img.decodeImage(imageData);
      if (sourceImage == null) {
        AppLogger.error('Êó†Ê≥ïËß£Á†ÅÂõæÂÉè', tag: 'PracticeEdit');
        return;
      }

      AppLogger.info(
        'ÊàêÂäüÂä†ËΩΩÂõæÂÉèÔºåÂºÄÂßã‰∫åÂÄºÂåñÂ§ÑÁêÜ',
        tag: 'PracticeEdit',
        data: {
          'imageSize': '${sourceImage.width}x${sourceImage.height}',
          'threshold': threshold,
        },
      );

      // ÊâßË°å‰∫åÂÄºÂåñÂ§ÑÁêÜ
      img.Image processedImage = sourceImage;

      // ÈôçÂô™Â§ÑÁêÜÔºàÂ¶ÇÊûúÂêØÁî®Ôºâ
      if (isNoiseReductionEnabled && noiseReductionLevel > 0) {
        processedImage =
            imageProcessor.denoiseImage(processedImage, noiseReductionLevel);
      }

      // ‰∫åÂÄºÂåñÂ§ÑÁêÜ
      processedImage =
          imageProcessor.binarizeImage(processedImage, threshold, false);

      // ÁºñÁ†Å‰∏∫PNG
      final binarizedImageData =
          Uint8List.fromList(img.encodePng(processedImage));

      AppLogger.info(
        '‰∫åÂÄºÂåñÂ§ÑÁêÜÂÆåÊàê',
        tag: 'PracticeEdit',
        data: {
          'elementId': elementId,
          'resultSize': '${processedImage.width}x${processedImage.height}',
          'dataSize': binarizedImageData.length,
        },
      );

      // Êõ¥Êñ∞ÂÖÉÁ¥†content
      setState(() {
        content['binarizedImageData'] = binarizedImageData;
        _controller.state.hasUnsavedChanges = true;
      });

      AppLogger.info('‰∫åÂÄºÂåñÊï∞ÊçÆÂ∑≤Êõ¥Êñ∞Âà∞ÂÖÉÁ¥†', tag: 'PracticeEdit');
    } catch (e, stackTrace) {
      AppLogger.error(
        'Áõ¥Êé•‰∫åÂÄºÂåñÂ§ÑÁêÜÂ§±Ë¥•',
        tag: 'PracticeEdit',
        error: e,
        stackTrace: stackTrace,
        data: {'elementId': elementId},
      );
    }
  }
}
