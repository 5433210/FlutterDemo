import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../domain/entities/library_item.dart';
import '../../../l10n/app_localizations.dart';
import '../../providers/library/library_management_provider.dart';
import 'm3_library_browsing_panel.dart';

/// 图库选择对话框静态方法类
class M3LibraryPickerDialog {
  /// 显示图库选择对话框的静态方法 (单选)
  static Future<LibraryItem?> show(BuildContext context,
      {String? title}) async {
    // 使用 showDialog 而不是 showRootDialog 确保在当前对话框上下文中打开
    final result = await showDialog<_PickerResult>(
      context: context,
      useRootNavigator: false, // 重要：使用false确保只使用当前对话框的Navigator，不会关闭父对话框
      barrierDismissible: true, // 允许点击背景关闭对话框
      builder: (dialogContext) {
        return _LibraryPickerDialogView(
          enableMultiSelect: false,
          title: title,
        );
      },
    );

    if (result == null || !result.confirmed || result.items.isEmpty) {
      return null;
    }

    return result.items.first;
  }

  /// 显示图库选择对话框的静态方法 (多选)
  static Future<List<LibraryItem>?> showMulti(BuildContext context,
      {String? title}) async {
    // 使用 showDialog 而不是 showRootDialog 确保在当前对话框上下文中打开
    print('【M3LibraryPickerDialog】准备显示多选对话框: $title');

    final result = await showDialog<_PickerResult>(
      context: context,
      useRootNavigator: false, // 重要：使用false确保只使用当前对话框的Navigator，不会关闭父对话框
      barrierDismissible: true, // 允许点击背景关闭对话框
      barrierColor:
          Theme.of(context).colorScheme.scrim.withOpacity(0.5), // 使用半透明背景
      builder: (dialogContext) {
        print(
            '【M3LibraryPickerDialog】构建多选对话框 - 是否相同上下文: ${identical(context, dialogContext)}');
        return _LibraryPickerDialogView(
          enableMultiSelect: true,
          title: title,
        );
      },
    );

    print(
        '【M3LibraryPickerDialog】多选对话框关闭: ${result?.confirmed}, 选择项: ${result?.items.length ?? 0}');

    if (result == null || !result.confirmed || result.items.isEmpty) {
      return null;
    }

    return result.items;
  }
}

/// 图库选择对话框视图实现
class _LibraryPickerDialogView extends ConsumerStatefulWidget {
  final bool enableMultiSelect;
  final String? title;

  const _LibraryPickerDialogView({
    Key? key,
    required this.enableMultiSelect,
    this.title,
  }) : super(key: key);

  @override
  ConsumerState<_LibraryPickerDialogView> createState() =>
      _LibraryPickerDialogViewState();
}

class _LibraryPickerDialogViewState
    extends ConsumerState<_LibraryPickerDialogView> {
  List<LibraryItem> _selectedItems = [];

  @override
  void initState() {
    super.initState();
    // 组件初始化时不直接清空选择，而是使用Future延迟执行
    // 这样可以避免在构建阶段修改状态
    Future.microtask(() {
      if (mounted) {
        ref.read(libraryManagementProvider.notifier).clearSelection();
        print('【M3LibraryPickerDialogView】initState.microtask - 已重置所有选择状态');
      }
    });
  }

  @override
  Widget build(BuildContext context) {
    final l10n = AppLocalizations.of(context);
    final theme = Theme.of(context);

    return Dialog(
      insetPadding: const EdgeInsets.all(16.0),
      child: ClipRRect(
        borderRadius: BorderRadius.circular(28.0),
        child: SizedBox(
          width: 1200,
          height: 800,
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.stretch,
            children: [
              // 标题栏
              Container(
                padding: const EdgeInsets.all(16.0),
                color: theme.colorScheme.surface,
                child: Row(
                  children: [
                    Text(
                      widget.title ?? l10n.imagePropertyPanelSelectFromLibrary,
                      style: theme.textTheme.titleLarge,
                    ),
                    const Spacer(),
                    IconButton(
                      icon: const Icon(Icons.close),
                      onPressed: () {
                        // 直接使用 Navigator.pop 而不是 Navigator.of
                        print('【M3LibraryPickerDialog】关闭按钮被点击');
                        Navigator.pop(context, _PickerResult(items: []));
                      },
                      tooltip: l10n.windowButtonClose,
                    ),
                  ],
                ),
              ),

              // 图库检索面板
              Expanded(
                child: M3LibraryBrowsingPanel(
                  enableFileDrop: true,
                  enableMultiSelect: widget.enableMultiSelect,
                  showConfirmButtons: true,
                  onItemSelected: (item) {
                    setState(() {
                      _selectedItems = [item];
                    });
                    if (!widget.enableMultiSelect) {
                      // 使用 rootNavigator: false 来确保只关闭当前的图库选择对话框
                      // 使用 Navigator.pop(context) 而不是 Navigator.of(context).pop()
                      // 避免可能的导航器混淆
                      if (mounted) {
                        Navigator.pop(
                            context,
                            _PickerResult(
                              items: [item],
                              confirmed: true,
                            ));
                      }
                    }
                  },
                  onItemsSelected: (items) {
                    setState(() {
                      _selectedItems = items;
                    });
                    if (items.isNotEmpty && mounted) {
                      // 使用 rootNavigator: false 来确保只关闭当前的图库选择对话框
                      // 使用 Navigator.pop(context) 而不是 Navigator.of(context).pop()
                      // 避免可能的导航器混淆
                      Navigator.pop(
                          context,
                          _PickerResult(
                            items: items,
                            confirmed: true,
                          ));
                    }
                  },
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}

/// 选择结果
class _PickerResult {
  final List<LibraryItem> items;
  final bool confirmed;

  _PickerResult({
    required this.items,
    this.confirmed = false,
  });
}
