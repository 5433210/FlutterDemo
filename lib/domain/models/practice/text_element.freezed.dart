// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'text_element.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

TextElement _$TextElementFromJson(Map<String, dynamic> json) {
  return _TextElement.fromJson(json);
}

/// @nodoc
mixin _$TextElement {
  /// 文本内容
  String get text => throw _privateConstructorUsedError;

  /// 字体名称
  String get fontFamily => throw _privateConstructorUsedError;

  /// 字体大小
  double get fontSize => throw _privateConstructorUsedError;

  /// 字体颜色
  String get color => throw _privateConstructorUsedError;

  /// 文本对齐方式
  TextAlign get textAlign => throw _privateConstructorUsedError;

  /// 是否加粗
  bool get bold => throw _privateConstructorUsedError;

  /// 是否斜体
  bool get italic => throw _privateConstructorUsedError;

  /// 是否下划线
  bool get underline => throw _privateConstructorUsedError;

  /// 行高
  double get lineHeight => throw _privateConstructorUsedError;

  /// 字间距
  double get letterSpacing => throw _privateConstructorUsedError;

  /// 自定义样式属性
  Map<String, dynamic> get customStyle => throw _privateConstructorUsedError;

  /// Serializes this TextElement to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of TextElement
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $TextElementCopyWith<TextElement> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TextElementCopyWith<$Res> {
  factory $TextElementCopyWith(
          TextElement value, $Res Function(TextElement) then) =
      _$TextElementCopyWithImpl<$Res, TextElement>;
  @useResult
  $Res call(
      {String text,
      String fontFamily,
      double fontSize,
      String color,
      TextAlign textAlign,
      bool bold,
      bool italic,
      bool underline,
      double lineHeight,
      double letterSpacing,
      Map<String, dynamic> customStyle});
}

/// @nodoc
class _$TextElementCopyWithImpl<$Res, $Val extends TextElement>
    implements $TextElementCopyWith<$Res> {
  _$TextElementCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of TextElement
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? text = null,
    Object? fontFamily = null,
    Object? fontSize = null,
    Object? color = null,
    Object? textAlign = null,
    Object? bold = null,
    Object? italic = null,
    Object? underline = null,
    Object? lineHeight = null,
    Object? letterSpacing = null,
    Object? customStyle = null,
  }) {
    return _then(_value.copyWith(
      text: null == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as String,
      fontFamily: null == fontFamily
          ? _value.fontFamily
          : fontFamily // ignore: cast_nullable_to_non_nullable
              as String,
      fontSize: null == fontSize
          ? _value.fontSize
          : fontSize // ignore: cast_nullable_to_non_nullable
              as double,
      color: null == color
          ? _value.color
          : color // ignore: cast_nullable_to_non_nullable
              as String,
      textAlign: null == textAlign
          ? _value.textAlign
          : textAlign // ignore: cast_nullable_to_non_nullable
              as TextAlign,
      bold: null == bold
          ? _value.bold
          : bold // ignore: cast_nullable_to_non_nullable
              as bool,
      italic: null == italic
          ? _value.italic
          : italic // ignore: cast_nullable_to_non_nullable
              as bool,
      underline: null == underline
          ? _value.underline
          : underline // ignore: cast_nullable_to_non_nullable
              as bool,
      lineHeight: null == lineHeight
          ? _value.lineHeight
          : lineHeight // ignore: cast_nullable_to_non_nullable
              as double,
      letterSpacing: null == letterSpacing
          ? _value.letterSpacing
          : letterSpacing // ignore: cast_nullable_to_non_nullable
              as double,
      customStyle: null == customStyle
          ? _value.customStyle
          : customStyle // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$TextElementImplCopyWith<$Res>
    implements $TextElementCopyWith<$Res> {
  factory _$$TextElementImplCopyWith(
          _$TextElementImpl value, $Res Function(_$TextElementImpl) then) =
      __$$TextElementImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String text,
      String fontFamily,
      double fontSize,
      String color,
      TextAlign textAlign,
      bool bold,
      bool italic,
      bool underline,
      double lineHeight,
      double letterSpacing,
      Map<String, dynamic> customStyle});
}

/// @nodoc
class __$$TextElementImplCopyWithImpl<$Res>
    extends _$TextElementCopyWithImpl<$Res, _$TextElementImpl>
    implements _$$TextElementImplCopyWith<$Res> {
  __$$TextElementImplCopyWithImpl(
      _$TextElementImpl _value, $Res Function(_$TextElementImpl) _then)
      : super(_value, _then);

  /// Create a copy of TextElement
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? text = null,
    Object? fontFamily = null,
    Object? fontSize = null,
    Object? color = null,
    Object? textAlign = null,
    Object? bold = null,
    Object? italic = null,
    Object? underline = null,
    Object? lineHeight = null,
    Object? letterSpacing = null,
    Object? customStyle = null,
  }) {
    return _then(_$TextElementImpl(
      text: null == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as String,
      fontFamily: null == fontFamily
          ? _value.fontFamily
          : fontFamily // ignore: cast_nullable_to_non_nullable
              as String,
      fontSize: null == fontSize
          ? _value.fontSize
          : fontSize // ignore: cast_nullable_to_non_nullable
              as double,
      color: null == color
          ? _value.color
          : color // ignore: cast_nullable_to_non_nullable
              as String,
      textAlign: null == textAlign
          ? _value.textAlign
          : textAlign // ignore: cast_nullable_to_non_nullable
              as TextAlign,
      bold: null == bold
          ? _value.bold
          : bold // ignore: cast_nullable_to_non_nullable
              as bool,
      italic: null == italic
          ? _value.italic
          : italic // ignore: cast_nullable_to_non_nullable
              as bool,
      underline: null == underline
          ? _value.underline
          : underline // ignore: cast_nullable_to_non_nullable
              as bool,
      lineHeight: null == lineHeight
          ? _value.lineHeight
          : lineHeight // ignore: cast_nullable_to_non_nullable
              as double,
      letterSpacing: null == letterSpacing
          ? _value.letterSpacing
          : letterSpacing // ignore: cast_nullable_to_non_nullable
              as double,
      customStyle: null == customStyle
          ? _value._customStyle
          : customStyle // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$TextElementImpl extends _TextElement {
  const _$TextElementImpl(
      {required this.text,
      this.fontFamily = 'Arial',
      this.fontSize = 14.0,
      this.color = '#000000',
      this.textAlign = TextAlign.left,
      this.bold = false,
      this.italic = false,
      this.underline = false,
      this.lineHeight = 1.2,
      this.letterSpacing = 0.0,
      final Map<String, dynamic> customStyle = const {}})
      : _customStyle = customStyle,
        super._();

  factory _$TextElementImpl.fromJson(Map<String, dynamic> json) =>
      _$$TextElementImplFromJson(json);

  /// 文本内容
  @override
  final String text;

  /// 字体名称
  @override
  @JsonKey()
  final String fontFamily;

  /// 字体大小
  @override
  @JsonKey()
  final double fontSize;

  /// 字体颜色
  @override
  @JsonKey()
  final String color;

  /// 文本对齐方式
  @override
  @JsonKey()
  final TextAlign textAlign;

  /// 是否加粗
  @override
  @JsonKey()
  final bool bold;

  /// 是否斜体
  @override
  @JsonKey()
  final bool italic;

  /// 是否下划线
  @override
  @JsonKey()
  final bool underline;

  /// 行高
  @override
  @JsonKey()
  final double lineHeight;

  /// 字间距
  @override
  @JsonKey()
  final double letterSpacing;

  /// 自定义样式属性
  final Map<String, dynamic> _customStyle;

  /// 自定义样式属性
  @override
  @JsonKey()
  Map<String, dynamic> get customStyle {
    if (_customStyle is EqualUnmodifiableMapView) return _customStyle;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_customStyle);
  }

  @override
  String toString() {
    return 'TextElement(text: $text, fontFamily: $fontFamily, fontSize: $fontSize, color: $color, textAlign: $textAlign, bold: $bold, italic: $italic, underline: $underline, lineHeight: $lineHeight, letterSpacing: $letterSpacing, customStyle: $customStyle)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$TextElementImpl &&
            (identical(other.text, text) || other.text == text) &&
            (identical(other.fontFamily, fontFamily) ||
                other.fontFamily == fontFamily) &&
            (identical(other.fontSize, fontSize) ||
                other.fontSize == fontSize) &&
            (identical(other.color, color) || other.color == color) &&
            (identical(other.textAlign, textAlign) ||
                other.textAlign == textAlign) &&
            (identical(other.bold, bold) || other.bold == bold) &&
            (identical(other.italic, italic) || other.italic == italic) &&
            (identical(other.underline, underline) ||
                other.underline == underline) &&
            (identical(other.lineHeight, lineHeight) ||
                other.lineHeight == lineHeight) &&
            (identical(other.letterSpacing, letterSpacing) ||
                other.letterSpacing == letterSpacing) &&
            const DeepCollectionEquality()
                .equals(other._customStyle, _customStyle));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      text,
      fontFamily,
      fontSize,
      color,
      textAlign,
      bold,
      italic,
      underline,
      lineHeight,
      letterSpacing,
      const DeepCollectionEquality().hash(_customStyle));

  /// Create a copy of TextElement
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$TextElementImplCopyWith<_$TextElementImpl> get copyWith =>
      __$$TextElementImplCopyWithImpl<_$TextElementImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$TextElementImplToJson(
      this,
    );
  }
}

abstract class _TextElement extends TextElement {
  const factory _TextElement(
      {required final String text,
      final String fontFamily,
      final double fontSize,
      final String color,
      final TextAlign textAlign,
      final bool bold,
      final bool italic,
      final bool underline,
      final double lineHeight,
      final double letterSpacing,
      final Map<String, dynamic> customStyle}) = _$TextElementImpl;
  const _TextElement._() : super._();

  factory _TextElement.fromJson(Map<String, dynamic> json) =
      _$TextElementImpl.fromJson;

  /// 文本内容
  @override
  String get text;

  /// 字体名称
  @override
  String get fontFamily;

  /// 字体大小
  @override
  double get fontSize;

  /// 字体颜色
  @override
  String get color;

  /// 文本对齐方式
  @override
  TextAlign get textAlign;

  /// 是否加粗
  @override
  bool get bold;

  /// 是否斜体
  @override
  bool get italic;

  /// 是否下划线
  @override
  bool get underline;

  /// 行高
  @override
  double get lineHeight;

  /// 字间距
  @override
  double get letterSpacing;

  /// 自定义样式属性
  @override
  Map<String, dynamic> get customStyle;

  /// Create a copy of TextElement
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$TextElementImplCopyWith<_$TextElementImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
