// filepath: lib/canvas/interaction/keyboard_shortcut_manager.dart
/// 快捷键系统管理器 - Phase 2.4 快捷键系统实现
/// 
/// 职责：
/// 1. 全局快捷键注册和管理
/// 2. 快捷键冲突检测与解决
/// 3. 上下文相关的快捷键
/// 4. 快捷键可配置性
library;

import 'package:flutter/foundation.dart';
import 'package:flutter/services.dart';

import '../core/canvas_state_manager.dart';
import 'multi_selection_manager.dart';

/// 快捷键动作类型
enum ShortcutAction {
  // 编辑操作
  undo,
  redo,
  copy,
  paste,
  cut,
  delete,
  selectAll,
  
  // 视图操作
  zoomIn,
  zoomOut,
  zoomToFit,
  zoomToActual,
  
  // 工具操作
  selectTool,
  moveTool,
  drawTool,
  textTool,
  
  // 元素操作
  groupElements,
  ungroupElements,
  bringToFront,
  sendToBack,
  bringForward,
  sendBackward,
  
  // 对齐操作
  alignLeft,
  alignCenter,
  alignRight,
  alignTop,
  alignMiddle,
  alignBottom,
  
  // 自定义操作
  custom,
}

/// 快捷键定义
class ShortcutDefinition {
  final LogicalKeySet keySet;
  final ShortcutAction action;
  final String description;
  final String? context; // 上下文标识
  final VoidCallback? callback;
  final Map<String, dynamic>? parameters;

  const ShortcutDefinition({
    required this.keySet,
    required this.action,
    required this.description,
    this.context,
    this.callback,
    this.parameters,
  });

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    return other is ShortcutDefinition && other.keySet == keySet;
  }

  @override
  int get hashCode => keySet.hashCode;
}

/// 快捷键上下文
enum ShortcutContext {
  global,     // 全局上下文
  canvas,     // Canvas焦点时
  editing,    // 编辑模式
  selection,  // 有选择时
  drawing,    // 绘制模式
}

/// 快捷键执行结果
class ShortcutResult {
  final bool handled;
  final String? message;
  final dynamic result;

  const ShortcutResult({
    required this.handled,
    this.message,
    this.result,
  });

  static const ShortcutResult notHandled = ShortcutResult(handled: false);
  static const ShortcutResult handled = ShortcutResult(handled: true);
}

/// 快捷键系统管理器
class KeyboardShortcutManager extends ChangeNotifier {
  final CanvasStateManager _stateManager;
  final MultiSelectionManager _selectionManager;
  
  // 快捷键注册表
  final Map<LogicalKeySet, ShortcutDefinition> _shortcuts = {};
  
  // 上下文状态
  Set<ShortcutContext> _activeContexts = {ShortcutContext.global};
  
  // 快捷键历史记录
  final List<ShortcutDefinition> _recentShortcuts = [];
  
  // 性能统计
  int _shortcutExecutionCount = 0;
  final Map<ShortcutAction, int> _actionUsageStats = {};

  KeyboardShortcutManager(this._stateManager, this._selectionManager) {
    _registerDefaultShortcuts();
  }

  /// 获取当前活动上下文
  Set<ShortcutContext> get activeContexts => Set.unmodifiable(_activeContexts);

  /// 获取所有注册的快捷键
  Map<LogicalKeySet, ShortcutDefinition> get registeredShortcuts => 
      Map.unmodifiable(_shortcuts);

  /// 注册快捷键
  bool registerShortcut(ShortcutDefinition shortcut) {
    // 检查快捷键冲突
    if (_shortcuts.containsKey(shortcut.keySet)) {
      final existing = _shortcuts[shortcut.keySet]!;
      if (existing.action != shortcut.action) {
        debugPrint('Shortcut conflict detected: ${shortcut.keySet} already mapped to ${existing.action}');
        return false;
      }
    }

    _shortcuts[shortcut.keySet] = shortcut;
    notifyListeners();
    return true;
  }

  /// 注销快捷键
  bool unregisterShortcut(LogicalKeySet keySet) {
    final removed = _shortcuts.remove(keySet);
    if (removed != null) {
      notifyListeners();
      return true;
    }
    return false;
  }

  /// 设置活动上下文
  void setActiveContexts(Set<ShortcutContext> contexts) {
    if (!setEquals(_activeContexts, contexts)) {
      _activeContexts = contexts;
      notifyListeners();
    }
  }

  /// 添加上下文
  void addContext(ShortcutContext context) {
    if (_activeContexts.add(context)) {
      notifyListeners();
    }
  }

  /// 移除上下文
  void removeContext(ShortcutContext context) {
    if (_activeContexts.remove(context)) {
      notifyListeners();
    }
  }

  /// 处理快捷键事件
  ShortcutResult handleKeyEvent(KeyEvent event) {
    if (event is! KeyDownEvent) {
      return ShortcutResult.notHandled;
    }

    // 构建当前按键组合
    final pressedKeys = <LogicalKeyboardKey>{
      ...HardwareKeyboard.instance.logicalKeysPressed,
      event.logicalKey,
    };
    
    final keySet = LogicalKeySet.fromSet(pressedKeys);

    // 查找匹配的快捷键
    final shortcut = _shortcuts[keySet];
    if (shortcut == null) {
      return ShortcutResult.notHandled;
    }

    // 检查上下文是否匹配
    if (!_isShortcutValidInCurrentContext(shortcut)) {
      return ShortcutResult.notHandled;
    }

    // 执行快捷键动作
    final result = _executeShortcut(shortcut);
    
    if (result.handled) {
      // 记录使用统计
      _recordShortcutUsage(shortcut);
      
      // 添加到最近使用列表
      _addToRecentShortcuts(shortcut);
    }

    return result;
  }

  /// 执行快捷键动作
  ShortcutResult _executeShortcut(ShortcutDefinition shortcut) {
    try {
      // 如果有自定义回调，优先执行
      if (shortcut.callback != null) {
        shortcut.callback!();
        return const ShortcutResult(handled: true, message: 'Custom shortcut executed');
      }

      // 执行内置动作
      return _executeBuiltinAction(shortcut.action, shortcut.parameters ?? {});
    } catch (e) {
      debugPrint('Error executing shortcut ${shortcut.action}: $e');
      return ShortcutResult(handled: false, message: 'Error: $e');
    }
  }

  /// 执行内置动作
  ShortcutResult _executeBuiltinAction(ShortcutAction action, Map<String, dynamic> parameters) {
    switch (action) {
      // 编辑操作
      case ShortcutAction.undo:
        if (_stateManager.canUndo) {
          _stateManager.undo();
          return const ShortcutResult(handled: true, message: 'Undo executed');
        }
        return const ShortcutResult(handled: false, message: 'Nothing to undo');

      case ShortcutAction.redo:
        if (_stateManager.canRedo) {
          _stateManager.redo();
          return const ShortcutResult(handled: true, message: 'Redo executed');
        }
        return const ShortcutResult(handled: false, message: 'Nothing to redo');

      case ShortcutAction.selectAll:
        final allElementIds = _stateManager.elementState.sortedElements
            .where((e) => _stateManager.isElementSelectable(e.id))
            .map((e) => e.id)
            .toList();
        _selectionManager.selectElements(allElementIds);
        return ShortcutResult(handled: true, message: 'Selected ${allElementIds.length} elements');

      case ShortcutAction.delete:
        if (_selectionManager.selectedCount > 0) {
          _selectionManager.deleteSelectedElements();
          return ShortcutResult(handled: true, message: 'Deleted ${_selectionManager.selectedCount} elements');
        }
        return const ShortcutResult(handled: false, message: 'No elements selected');

      case ShortcutAction.copy:
        if (_selectionManager.selectedCount > 0) {
          _copySelectedElements();
          return ShortcutResult(handled: true, message: 'Copied ${_selectionManager.selectedCount} elements');
        }
        return const ShortcutResult(handled: false, message: 'No elements selected');

      case ShortcutAction.paste:
        final pastedCount = _pasteElements();
        if (pastedCount > 0) {
          return ShortcutResult(handled: true, message: 'Pasted $pastedCount elements');
        }
        return const ShortcutResult(handled: false, message: 'Nothing to paste');

      case ShortcutAction.cut:
        if (_selectionManager.selectedCount > 0) {
          _copySelectedElements();
          _selectionManager.deleteSelectedElements();
          return ShortcutResult(handled: true, message: 'Cut ${_selectionManager.selectedCount} elements');
        }
        return const ShortcutResult(handled: false, message: 'No elements selected');

      // 对齐操作
      case ShortcutAction.alignLeft:
        return _alignSelectedElements('left');
      case ShortcutAction.alignCenter:
        return _alignSelectedElements('center');
      case ShortcutAction.alignRight:
        return _alignSelectedElements('right');
      case ShortcutAction.alignTop:
        return _alignSelectedElements('top');
      case ShortcutAction.alignMiddle:
        return _alignSelectedElements('middle');
      case ShortcutAction.alignBottom:
        return _alignSelectedElements('bottom');

      // 图层操作
      case ShortcutAction.bringToFront:
        return _changeElementsZIndex('front');
      case ShortcutAction.sendToBack:
        return _changeElementsZIndex('back');
      case ShortcutAction.bringForward:
        return _changeElementsZIndex('forward');
      case ShortcutAction.sendBackward:
        return _changeElementsZIndex('backward');

      default:
        return ShortcutResult(handled: false, message: 'Action ${action.name} not implemented');
    }
  }

  /// 注册默认快捷键
  void _registerDefaultShortcuts() {
    // 编辑操作
    registerShortcut(ShortcutDefinition(
      keySet: LogicalKeySet(LogicalKeyboardKey.controlLeft, LogicalKeyboardKey.keyZ),
      action: ShortcutAction.undo,
      description: 'Undo',
    ));

    registerShortcut(ShortcutDefinition(
      keySet: LogicalKeySet(LogicalKeyboardKey.controlLeft, LogicalKeyboardKey.keyY),
      action: ShortcutAction.redo,
      description: 'Redo',
    ));

    registerShortcut(ShortcutDefinition(
      keySet: LogicalKeySet(LogicalKeyboardKey.controlLeft, LogicalKeyboardKey.keyA),
      action: ShortcutAction.selectAll,
      description: 'Select All',
    ));

    registerShortcut(ShortcutDefinition(
      keySet: LogicalKeySet(LogicalKeyboardKey.delete),
      action: ShortcutAction.delete,
      description: 'Delete Selected',
    ));

    registerShortcut(ShortcutDefinition(
      keySet: LogicalKeySet(LogicalKeyboardKey.controlLeft, LogicalKeyboardKey.keyC),
      action: ShortcutAction.copy,
      description: 'Copy',
    ));

    registerShortcut(ShortcutDefinition(
      keySet: LogicalKeySet(LogicalKeyboardKey.controlLeft, LogicalKeyboardKey.keyV),
      action: ShortcutAction.paste,
      description: 'Paste',
    ));

    registerShortcut(ShortcutDefinition(
      keySet: LogicalKeySet(LogicalKeyboardKey.controlLeft, LogicalKeyboardKey.keyX),
      action: ShortcutAction.cut,
      description: 'Cut',
    ));

    // 对齐快捷键
    registerShortcut(ShortcutDefinition(
      keySet: LogicalKeySet(LogicalKeyboardKey.controlLeft, LogicalKeyboardKey.shiftLeft, LogicalKeyboardKey.keyL),
      action: ShortcutAction.alignLeft,
      description: 'Align Left',
    ));

    registerShortcut(ShortcutDefinition(
      keySet: LogicalKeySet(LogicalKeyboardKey.controlLeft, LogicalKeyboardKey.shiftLeft, LogicalKeyboardKey.keyC),
      action: ShortcutAction.alignCenter,
      description: 'Align Center',
    ));

    registerShortcut(ShortcutDefinition(
      keySet: LogicalKeySet(LogicalKeyboardKey.controlLeft, LogicalKeyboardKey.shiftLeft, LogicalKeyboardKey.keyR),
      action: ShortcutAction.alignRight,
      description: 'Align Right',
    ));

    // 图层快捷键
    registerShortcut(ShortcutDefinition(
      keySet: LogicalKeySet(LogicalKeyboardKey.controlLeft, LogicalKeyboardKey.shiftLeft, LogicalKeyboardKey.bracketRight),
      action: ShortcutAction.bringToFront,
      description: 'Bring to Front',
    ));

    registerShortcut(ShortcutDefinition(
      keySet: LogicalKeySet(LogicalKeyboardKey.controlLeft, LogicalKeyboardKey.shiftLeft, LogicalKeyboardKey.bracketLeft),
      action: ShortcutAction.sendToBack,
      description: 'Send to Back',
    ));
  }

  /// 检查快捷键在当前上下文中是否有效
  bool _isShortcutValidInCurrentContext(ShortcutDefinition shortcut) {
    if (shortcut.context == null) return true;

    // 检查上下文匹配逻辑
    switch (shortcut.context) {
      case 'selection':
        return _activeContexts.contains(ShortcutContext.selection) || _selectionManager.selectedCount > 0;
      case 'editing':
        return _activeContexts.contains(ShortcutContext.editing);
      case 'canvas':
        return _activeContexts.contains(ShortcutContext.canvas);
      default:
        return true;
    }
  }

  /// 复制选中元素（简化实现）
  void _copySelectedElements() {
    // 这里应该实现真正的复制逻辑
    // 暂时只是记录动作
    debugPrint('Copying ${_selectionManager.selectedCount} elements');
  }

  /// 粘贴元素（简化实现）
  int _pasteElements() {
    // 这里应该实现真正的粘贴逻辑
    // 暂时返回0表示没有粘贴任何内容
    debugPrint('Pasting elements');
    return 0;
  }

  /// 对齐选中元素
  ShortcutResult _alignSelectedElements(String alignment) {
    if (_selectionManager.selectedCount < 2) {
      return const ShortcutResult(handled: false, message: 'Need at least 2 elements to align');
    }

    // 这里应该实现真正的对齐逻辑
    debugPrint('Aligning ${_selectionManager.selectedCount} elements to $alignment');
    return ShortcutResult(handled: true, message: 'Aligned elements to $alignment');
  }

  /// 改变元素Z轴顺序
  ShortcutResult _changeElementsZIndex(String direction) {
    if (_selectionManager.selectedCount == 0) {
      return const ShortcutResult(handled: false, message: 'No elements selected');
    }

    // 这里应该实现真正的Z轴调整逻辑
    debugPrint('Moving ${_selectionManager.selectedCount} elements $direction');
    return ShortcutResult(handled: true, message: 'Moved elements $direction');
  }

  /// 记录快捷键使用统计
  void _recordShortcutUsage(ShortcutDefinition shortcut) {
    _shortcutExecutionCount++;
    _actionUsageStats[shortcut.action] = (_actionUsageStats[shortcut.action] ?? 0) + 1;
  }

  /// 添加到最近使用的快捷键
  void _addToRecentShortcuts(ShortcutDefinition shortcut) {
    _recentShortcuts.remove(shortcut);
    _recentShortcuts.insert(0, shortcut);
    if (_recentShortcuts.length > 10) {
      _recentShortcuts.removeLast();
    }
  }

  /// 获取使用统计
  Map<String, dynamic> getUsageStats() {
    return {
      'totalExecutions': _shortcutExecutionCount,
      'actionStats': Map.from(_actionUsageStats),
      'recentShortcuts': _recentShortcuts.map((s) => s.description).toList(),
    };
  }

  /// 导出快捷键配置
  Map<String, dynamic> exportConfiguration() {
    return {
      'shortcuts': _shortcuts.entries.map((entry) => {
        'keys': entry.key.keys.map((k) => k.keyLabel).toList(),
        'action': entry.value.action.name,
        'description': entry.value.description,
        'context': entry.value.context,
      }).toList(),
    };
  }

  /// 导入快捷键配置
  void importConfiguration(Map<String, dynamic> config) {
    final shortcuts = config['shortcuts'] as List<dynamic>?;
    if (shortcuts == null) return;

    _shortcuts.clear();
    
    for (final shortcutMap in shortcuts) {
      try {
        final keys = (shortcutMap['keys'] as List<dynamic>)
            .map((k) => LogicalKeyboardKey.findKeyByKeyId(k as int))
            .where((k) => k != null)
            .cast<LogicalKeyboardKey>()
            .toList();
        
        if (keys.isNotEmpty) {
          final keySet = LogicalKeySet.fromSet(keys.toSet());
          final actionName = shortcutMap['action'] as String;
          final action = ShortcutAction.values.firstWhere(
            (a) => a.name == actionName,
            orElse: () => ShortcutAction.custom,
          );
          
          final shortcut = ShortcutDefinition(
            keySet: keySet,
            action: action,
            description: shortcutMap['description'] as String? ?? '',
            context: shortcutMap['context'] as String?,
          );
          
          _shortcuts[keySet] = shortcut;
        }
      } catch (e) {
        debugPrint('Error importing shortcut: $e');
      }
    }
    
    notifyListeners();
  }
}
