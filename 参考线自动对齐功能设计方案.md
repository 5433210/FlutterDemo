# å‚è€ƒçº¿è‡ªåŠ¨å¯¹é½åŠŸèƒ½è®¾è®¡æ–¹æ¡ˆ

## 1. åŠŸèƒ½æ¦‚è¿°

### 1.1 åŠŸèƒ½æè¿°
ä¸ºå­—å¸–ç¼–è¾‘å™¨å¢åŠ å‚è€ƒçº¿è‡ªåŠ¨å¯¹é½åŠŸèƒ½ï¼Œé€šè¿‡å·¥å…·æ å¼€å…³æ§åˆ¶ï¼Œæ”¯æŒå…ƒç´ ä¹‹é—´çš„æ™ºèƒ½å¯¹é½ã€‚è¯¥åŠŸèƒ½ä¸ç°æœ‰çš„ç½‘æ ¼è´´é™„åŠŸèƒ½äº’æ–¥ï¼Œæä¾›æ›´ç²¾ç¡®å’Œçµæ´»çš„å…ƒç´ å¯¹é½æ–¹å¼ã€‚

### 1.2 æ ¸å¿ƒç‰¹æ€§
- **æ™ºèƒ½å‚è€ƒçº¿æ£€æµ‹**: è‡ªåŠ¨æ£€æµ‹å…ƒç´ çš„ä¸­çº¿å’Œè¾¹çº¿
- **å®æ—¶é¢„è§ˆæç¤º**: æ‹–æ‹½è¿‡ç¨‹ä¸­æ˜¾ç¤ºå‚è€ƒçº¿å’Œå¯¹é½é¢„è§ˆ
- **å¤šç§å¯¹é½æ–¹å¼**: æ”¯æŒä¸­çº¿å¯¹ä¸­çº¿ã€ä¸­çº¿å¯¹è¾¹çº¿ã€è¾¹çº¿å¯¹è¾¹çº¿ç­‰6ç§å¯¹é½ç»„åˆ
- **äº’æ–¥æ¨¡å¼åˆ‡æ¢**: ä¸ç½‘æ ¼è´´é™„ã€æ— è¾…åŠ©æ¨¡å¼å½¢æˆä¸‰æ€åˆ‡æ¢
- **æ€§èƒ½ä¼˜åŒ–**: é‡‡ç”¨ç©ºé—´ç´¢å¼•å’Œç¼“å­˜ç­–ç•¥ï¼Œæ”¯æŒå¤§é‡å…ƒç´ åœºæ™¯

## 2. åŠŸèƒ½éœ€æ±‚

### 2.1 å‚è€ƒçº¿ç±»å‹
æ”¯æŒä»¥ä¸‹6ç§å‚è€ƒçº¿ï¼š

| ç±»å‹ | è¯´æ˜ | ç”¨é€” |
|------|------|------|
| æ¨ªå‘ä¸­çº¿ | å…ƒç´ æ°´å¹³ä¸­å¿ƒçº¿ | æ°´å¹³å±…ä¸­å¯¹é½ |
| çºµå‘ä¸­çº¿ | å…ƒç´ å‚ç›´ä¸­å¿ƒçº¿ | å‚ç›´å±…ä¸­å¯¹é½ |
| æ¨ªå‘ä¸Šè¾¹çº¿ | å…ƒç´ é¡¶éƒ¨è¾¹ç•Œ | é¡¶éƒ¨å¯¹é½ |
| æ¨ªå‘ä¸‹è¾¹çº¿ | å…ƒç´ åº•éƒ¨è¾¹ç•Œ | åº•éƒ¨å¯¹é½ |
| çºµå‘å·¦è¾¹çº¿ | å…ƒç´ å·¦ä¾§è¾¹ç•Œ | å·¦å¯¹é½ |
| çºµå‘å³è¾¹çº¿ | å…ƒç´ å³ä¾§è¾¹ç•Œ | å³å¯¹é½ |

### 2.2 å¯¹é½ç»„åˆ
æ”¯æŒç›¸åŒæ–¹å‘çš„å‚è€ƒçº¿ä¹‹é—´å¯¹é½ï¼š

**æ¨ªå‘å¯¹é½ (4ç§ç»„åˆ)**:
- ä¸­çº¿å¯¹ä¸­çº¿ï¼šä¸¤å…ƒç´ æ°´å¹³å±…ä¸­å¯¹é½
- ä¸­çº¿å¯¹è¾¹çº¿ï¼šå…ƒç´ ä¸­çº¿ä¸å…¶ä»–å…ƒç´ ä¸Š/ä¸‹è¾¹çº¿å¯¹é½
- è¾¹çº¿å¯¹ä¸­çº¿ï¼šå…ƒç´ ä¸Š/ä¸‹è¾¹çº¿ä¸å…¶ä»–å…ƒç´ ä¸­çº¿å¯¹é½
- è¾¹çº¿å¯¹è¾¹çº¿ï¼šå…ƒç´ ä¸Š/ä¸‹è¾¹çº¿ä¸å…¶ä»–å…ƒç´ ä¸Š/ä¸‹è¾¹çº¿å¯¹é½

**çºµå‘å¯¹é½ (4ç§ç»„åˆ)**:
- ä¸­çº¿å¯¹ä¸­çº¿ï¼šä¸¤å…ƒç´ å‚ç›´å±…ä¸­å¯¹é½
- ä¸­çº¿å¯¹è¾¹çº¿ï¼šå…ƒç´ ä¸­çº¿ä¸å…¶ä»–å…ƒç´ å·¦/å³è¾¹çº¿å¯¹é½
- è¾¹çº¿å¯¹ä¸­çº¿ï¼šå…ƒç´ å·¦/å³è¾¹çº¿ä¸å…¶ä»–å…ƒç´ ä¸­çº¿å¯¹é½
- è¾¹çº¿å¯¹è¾¹çº¿ï¼šå…ƒç´ å·¦/å³è¾¹çº¿ä¸å…¶ä»–å…ƒç´ å·¦/å³è¾¹çº¿å¯¹é½

### 2.3 è§¦å‘æ¡ä»¶
- ä»…åœ¨å•ä¸ªå…ƒç´ é€‰ä¸­çŠ¶æ€ä¸‹ç”Ÿæ•ˆ
- æ”¯æŒå…ƒç´ å¹³ç§» (drag) å’Œè°ƒæ•´å¤§å° (resize) æ“ä½œ
- é€šè¿‡å·¥å…·æ å¼€å…³æ§åˆ¶å¯ç”¨/ç¦ç”¨
- å¯¹é½é˜ˆå€¼è®¾ç½®ä¸ºç½‘æ ¼å¤§å°çš„ä¸€åŠ (é»˜è®¤5åƒç´ )

### 2.4 äº¤äº’æ–¹å¼
é‡‡ç”¨**é¢„è§ˆæç¤ºæ¨¡å¼**è€Œéå®æ—¶å¸é™„ï¼š
1. æ‹–æ‹½è¿‡ç¨‹ä¸­å…ƒç´ å§‹ç»ˆè·Ÿéšé¼ æ ‡
2. æ£€æµ‹åˆ°å¯¹é½æœºä¼šæ—¶æ˜¾ç¤ºçº¢è‰²å‚è€ƒçº¿
3. åœ¨å¯¹é½ç‚¹æ˜¾ç¤ºè§†è§‰æ ‡è®°
4. é‡Šæ”¾é¼ æ ‡æ—¶æ‰§è¡Œæœ€ç»ˆå¯¹é½è°ƒæ•´

## 3. å·¥å…·æ è®¾è®¡

### 3.1 å¸ƒå±€è°ƒæ•´
å°†åŸæœ‰çš„ç‹¬ç«‹"ç½‘æ ¼æ˜¾ç¤º"å’Œ"ç½‘æ ¼å¸é™„"æŒ‰é’®é‡æ–°è®¾è®¡ä¸ºï¼š

```
å¯¹é½è¾…åŠ©ç»„ (Alignment Assist Group)
â”œâ”€â”€ ğŸ”² ç½‘æ ¼æ˜¾ç¤º (Grid Display) - ç‹¬ç«‹æ§åˆ¶ç½‘æ ¼å¯è§æ€§
â”œâ”€â”€ ğŸ”„ğŸ“ å¯¹é½æ¨¡å¼ (Alignment Mode) - ä¸‰æ€åˆ‡æ¢æŒ‰é’®
â””â”€â”€ ğŸ¨ æ ¼å¼åˆ· (Format Brush)
```

### 3.2 å¯¹é½æ¨¡å¼ä¸‰æ€åˆ‡æ¢

| æ¨¡å¼ | å›¾æ ‡ | èƒŒæ™¯è‰² | åŠŸèƒ½æè¿° |
|------|------|--------|----------|
| ç½‘æ ¼è´´é™„ | ğŸ”„ğŸ“ğŸ§² | Primaryè“è‰² | å…ƒç´ ç§»åŠ¨å’Œè°ƒæ•´å¤§å°æ—¶è‡ªåŠ¨å¸é™„åˆ°ç½‘æ ¼ç‚¹ |
| å‚è€ƒçº¿å¯¹é½ | ğŸ”„ğŸ“ğŸ“ | Orangeæ©™è‰² | å…ƒç´ ä¸å…¶ä»–å…ƒç´ çš„å‚è€ƒçº¿è‡ªåŠ¨å¯¹é½ |
| æ— è¾…åŠ© | ğŸ”„ğŸ“ğŸš« | Surfaceç°è‰² | å®Œå…¨è‡ªç”±çš„ç§»åŠ¨å’Œè°ƒæ•´ï¼Œæ— ä»»ä½•è‡ªåŠ¨å¯¹é½ |

### 3.3 äº¤äº’é€»è¾‘
- ç‚¹å‡»å¯¹é½æ¨¡å¼æŒ‰é’®å¾ªç¯åˆ‡æ¢ä¸‰ç§çŠ¶æ€
- çŠ¶æ€åˆ‡æ¢æ—¶è‡ªåŠ¨ç¦ç”¨å…¶ä»–æ¨¡å¼ï¼Œç¡®ä¿åŠŸèƒ½äº’æ–¥
- é€šè¿‡ä¸åŒçš„èƒŒæ™¯è‰²å’Œå›¾æ ‡ç»„åˆæä¾›æ¸…æ™°çš„è§†è§‰åé¦ˆ

## 4. ç®—æ³•è®¾è®¡

### 4.1 æ ¸å¿ƒæ•°æ®ç»“æ„

```dart
enum GuidelineType {
  horizontalCenterLine,  // æ¨ªå‘ä¸­çº¿
  verticalCenterLine,    // çºµå‘ä¸­çº¿
  horizontalTopEdge,     // æ¨ªå‘ä¸Šè¾¹çº¿
  horizontalBottomEdge,  // æ¨ªå‘ä¸‹è¾¹çº¿
  verticalLeftEdge,      // çºµå‘å·¦è¾¹çº¿
  verticalRightEdge,     // çºµå‘å³è¾¹çº¿
}

enum AlignmentDirection {
  horizontal,  // æ°´å¹³æ–¹å‘
  vertical,    // å‚ç›´æ–¹å‘
}

class Guideline {
  final String id;
  final GuidelineType type;
  final double position;  // åœ¨åæ ‡è½´ä¸Šçš„ä½ç½®
  final AlignmentDirection direction;
  final String sourceElementId;  // äº§ç”Ÿæ­¤å‚è€ƒçº¿çš„å…ƒç´ ID
  final Rect sourceElementBounds;  // æºå…ƒç´ çš„è¾¹ç•Œ
}
```

### 4.2 æ£€æµ‹ç®—æ³•

**æ—¶é—´å¤æ‚åº¦**: O(n log n)
- å‚è€ƒçº¿ç”Ÿæˆ: O(n) - nä¸ªå…ƒç´  Ã— 6æ¡å‚è€ƒçº¿
- è·ç¦»è®¡ç®—: O(n) - 6næ¬¡è·ç¦»è®¡ç®—
- æ’åºç­›é€‰: O(n log n) - æŒ‰è·ç¦»æ’åºé€‰æ‹©æœ€è¿‘å‚è€ƒçº¿

**ç®—æ³•æµç¨‹**:
```dart
List<Guideline> detectNearestGuidelines(
  Rect targetBounds,
  List<Element> allElements,
  String targetElementId,
  double snapThreshold,
) {
  // 1. ä¸ºæ‰€æœ‰å…¶ä»–å…ƒç´ ç”Ÿæˆå‚è€ƒçº¿
  final guidelines = generateAllGuidelines(allElements, targetElementId);
  
  // 2. è®¡ç®—ç›®æ ‡å…ƒç´ åˆ°æ¯æ¡å‚è€ƒçº¿çš„è·ç¦»
  final candidates = guidelines
      .map((g) => GuidelineCandidate(g, g.distanceTo(targetBounds)))
      .where((c) => c.distance <= snapThreshold)
      .toList();
  
  // 3. åˆ†æ–¹å‘é€‰æ‹©æœ€è¿‘çš„å‚è€ƒçº¿
  final result = <Guideline>[];
  
  // æ°´å¹³æ–¹å‘æœ€è¿‘å‚è€ƒçº¿
  final horizontalCandidate = candidates
      .where((c) => c.guideline.direction == AlignmentDirection.horizontal)
      .fold<GuidelineCandidate?>(null, (prev, curr) => 
          prev == null || curr.distance < prev.distance ? curr : prev);
  
  // å‚ç›´æ–¹å‘æœ€è¿‘å‚è€ƒçº¿
  final verticalCandidate = candidates
      .where((c) => c.guideline.direction == AlignmentDirection.vertical)
      .fold<GuidelineCandidate?>(null, (prev, curr) => 
          prev == null || curr.distance < prev.distance ? curr : prev);
  
  if (horizontalCandidate != null) result.add(horizontalCandidate.guideline);
  if (verticalCandidate != null) result.add(verticalCandidate.guideline);
  
  return result;
}
```

### 4.3 å¯¹é½è®¡ç®—

```dart
Map<String, double> calculateSnappedProperties(
  Map<String, dynamic> elementProperties,
  List<Guideline> activeGuidelines,
) {
  final result = <String, double>{};
  final bounds = getBoundsFromProperties(elementProperties);
  
  for (final guideline in activeGuidelines) {
    switch (guideline.type) {
      case GuidelineType.horizontalCenterLine:
        result['y'] = guideline.position - bounds.height / 2;
        break;
      case GuidelineType.verticalCenterLine:
        result['x'] = guideline.position - bounds.width / 2;
        break;
      case GuidelineType.horizontalTopEdge:
        result['y'] = guideline.position;
        break;
      case GuidelineType.horizontalBottomEdge:
        result['y'] = guideline.position - bounds.height;
        break;
      case GuidelineType.verticalLeftEdge:
        result['x'] = guideline.position;
        break;
      case GuidelineType.verticalRightEdge:
        result['x'] = guideline.position - bounds.width;
        break;
    }
  }
  
  return result;
}
```

### 4.4 æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

**ä¼˜åŒ–æ–¹æ¡ˆ1: ç©ºé—´ç´¢å¼•**
```dart
class SpatialIndex {
  // ä½¿ç”¨å››å‰æ ‘æˆ–ç½‘æ ¼ç´¢å¼•ï¼Œåªæ£€æŸ¥é‚»è¿‘åŒºåŸŸå…ƒç´ 
  // æ—¶é—´å¤æ‚åº¦: O(k log k), k << n
  List<Element> getNearbyElements(Rect targetBounds, double threshold);
}
```

**ä¼˜åŒ–æ–¹æ¡ˆ2: ç¼“å­˜ç­–ç•¥**
```dart
class GuidelineCache {
  Map<String, List<Guideline>> _cache = {};
  
  // å‚è€ƒçº¿é¢„è®¡ç®—å’Œç¼“å­˜ï¼Œå¢é‡æ›´æ–°
  // æ—¶é—´å¤æ‚åº¦: O(k), kä¸ºå˜åŒ–å…ƒç´ æ•°
  List<Guideline> getOrGenerate(String elementId);
}
```

**ä¼˜åŒ–æ–¹æ¡ˆ3: åˆ†å±‚è®¡ç®—**
```dart
// æŒ‰è·ç¦»åˆ†å±‚ç­›é€‰ï¼Œå…ˆç²—ç­›é€‰å†ç²¾ç¡®è®¡ç®—
// æ—¶é—´å¤æ‚åº¦: O(k), kä¸ºå€™é€‰æ•°
List<Guideline> layeredDetection(Rect targetBounds, double threshold);
```

## 5. æŠ€æœ¯å®ç°

### 5.1 æ¶æ„è®¾è®¡

#### 5.1.1 æ ¸å¿ƒç»„ä»¶
```
lib/presentation/widgets/practice/guideline_alignment/
â”œâ”€â”€ guideline_manager.dart          // å‚è€ƒçº¿ç®¡ç†å™¨ï¼Œæ ¸å¿ƒç®—æ³•
â”œâ”€â”€ guideline_renderer.dart         // å‚è€ƒçº¿å¯è§†åŒ–æ¸²æŸ“
â”œâ”€â”€ guideline_types.dart           // æ•°æ®ç»“æ„å®šä¹‰
â”œâ”€â”€ guideline_extension.dart       // æ§åˆ¶å™¨æ‰©å±•
â””â”€â”€ spatial_index.dart             // ç©ºé—´ç´¢å¼•ä¼˜åŒ–
```

#### 5.1.2 é›†æˆæ¶æ„
```
Canvaså±‚çº§ç»“æ„
â”œâ”€â”€ BackgroundLayer (ç½‘æ ¼)
â”œâ”€â”€ ContentLayer (å…ƒç´ å†…å®¹)
â”œâ”€â”€ GuidelineLayer (å‚è€ƒçº¿) â† æ–°å¢
â”œâ”€â”€ DragPreviewLayer (æ‹–æ‹½é¢„è§ˆ)
â”œâ”€â”€ InteractionLayer (æ§åˆ¶ç‚¹)
â””â”€â”€ SelectionLayer (é€‰æ‹©æ¡†)
```

### 5.2 ä»£ç é›†æˆæ–¹æ¡ˆ

#### 5.2.1 çŠ¶æ€ç®¡ç†é›†æˆ

**PracticeEditState.dart** - æ·»åŠ çŠ¶æ€å®šä¹‰:
```dart
enum AlignmentMode {
  none,        // æ— è¾…åŠ©
  gridSnap,    // ç½‘æ ¼è´´é™„
  guideline,   // å‚è€ƒçº¿å¯¹é½
}

class PracticeEditState {
  // å¯¹é½æ¨¡å¼ (æ›¿ä»£åŸæœ‰çš„snapEnabled)
  AlignmentMode alignmentMode = AlignmentMode.none;
  
  // ç½‘æ ¼æ˜¾ç¤º (ä¸å¯¹é½æ¨¡å¼åˆ†ç¦»)
  bool gridVisible = false;
  
  // å‚è€ƒçº¿ç›¸å…³çŠ¶æ€
  List<Guideline> activeGuidelines = [];
  bool isGuidelinePreviewActive = false;
  
  // å‘åå…¼å®¹
  bool get snapEnabled => alignmentMode == AlignmentMode.gridSnap;
  bool get guidelineAlignEnabled => alignmentMode == AlignmentMode.guideline;
}
```

**ToolManagementMixin.dart** - æ·»åŠ æ¨¡å¼åˆ‡æ¢é€»è¾‘:
```dart
mixin ToolManagementMixin {
  void setAlignmentMode(AlignmentMode mode) {
    checkDisposed();
    if (state.alignmentMode != mode) {
      state.alignmentMode = mode;
      
      // æ¸…ç†ä¹‹å‰æ¨¡å¼çš„çŠ¶æ€
      if (mode != AlignmentMode.guideline) {
        state.activeGuidelines.clear();
        state.isGuidelinePreviewActive = false;
      }
      
      EditPageLogger.controllerInfo('å¯¹é½æ¨¡å¼å˜æ›´', 
        data: {'mode': mode.name});
      
      intelligentNotify(
        changeType: 'alignment_mode_change',
        operation: 'setAlignmentMode',
        eventData: {'mode': mode.name},
        affectedUIComponents: ['toolbar', 'canvas'],
        affectedLayers: ['interaction', 'guideline'],
      );
    }
  }
  
  void toggleAlignmentMode() {
    final nextMode = switch (state.alignmentMode) {
      AlignmentMode.none => AlignmentMode.gridSnap,
      AlignmentMode.gridSnap => AlignmentMode.guideline,
      AlignmentMode.guideline => AlignmentMode.none,
    };
    setAlignmentMode(nextMode);
  }
}
```

#### 5.2.2 å·¥å…·æ UIé›†æˆ

**M3EditToolbar.dart** - å·¥å…·æ æŒ‰é’®æ›´æ–°:
```dart
// æ›¿æ¢åŸæœ‰çš„ç½‘æ ¼å’Œå¸é™„æŒ‰é’®
Widget _buildAlignmentModeButton(BuildContext context) {
  final mode = controller.state.alignmentMode;
  
  final (icon, label, color) = switch (mode) {
    AlignmentMode.gridSnap => (
      'ğŸ”„ğŸ“ğŸ§²', 
      'Grid Snap', 
      colorScheme.primary
    ),
    AlignmentMode.guideline => (
      'ğŸ”„ğŸ“ğŸ“', 
      'Guideline', 
      const Color(0xFFFF9800)  // Orange
    ),
    AlignmentMode.none => (
      'ğŸ”„ğŸ“ğŸš«', 
      'No Assist', 
      colorScheme.surface
    ),
  };
  
  return Tooltip(
    message: '$label Mode',
    child: Material(
      color: color,
      borderRadius: BorderRadius.circular(8.0),
      child: InkWell(
        onTap: () {
          EditPageLogger.editPageDebug('å¯¹é½æ¨¡å¼åˆ‡æ¢', data: {
            'currentMode': mode.name,
            'operation': 'alignment_mode_toggle',
          });
          controller.toggleAlignmentMode();
        },
        borderRadius: BorderRadius.circular(8.0),
        child: Padding(
          padding: const EdgeInsets.symmetric(horizontal: 8.0, vertical: 6.0),
          child: Row(
            mainAxisSize: MainAxisSize.min,
            children: [
              Text(icon, style: const TextStyle(fontSize: 16)),
              const SizedBox(width: 4),
              Text(label, style: const TextStyle(fontSize: 12)),
            ],
          ),
        ),
      ),
    ),
  );
}
```

#### 5.2.3 æ‹–æ‹½å¤„ç†é›†æˆ

**CanvasControlPointHandlers.dart** - Liveé˜¶æ®µé›†æˆ:
```dart
void handleControlPointLiveUpdate(Map<String, double> liveState) {
  if (controller.state.selectedElementIds.isEmpty || _originalElementProperties == null) {
    return;
  }

  final elementId = controller.state.selectedElementIds.first;
  final originalElement = _originalElementProperties!;

  // åº”ç”¨ç½‘æ ¼å¸é™„
  var processedState = controller.state.alignmentMode == AlignmentMode.gridSnap 
      ? applyGridSnapToProperties(liveState)
      : liveState;

  // ğŸ”§ æ–°å¢ï¼šåº”ç”¨å‚è€ƒçº¿å¯¹é½
  if (controller.state.alignmentMode == AlignmentMode.guideline) {
    final alignmentResult = GuidelineManager.detectAndAlign(
      elementId: elementId,
      currentProperties: {
        ...originalElement,
        ...processedState.map((k, v) => MapEntry(k, v as dynamic)),
      },
      allElements: controller.state.currentPageElements,
      snapThreshold: controller.state.gridSize / 2,
    );
    
    if (alignmentResult.hasAlignment) {
      processedState = alignmentResult.alignedProperties;
      
      // æ›´æ–°æ´»åŠ¨å‚è€ƒçº¿çŠ¶æ€ï¼Œç”¨äºæ¸²æŸ“
      controller.updateActiveGuidelines(alignmentResult.activeGuidelines);
    } else {
      controller.clearActiveGuidelines();
    }
  }

  // å¤„ç†é¢„è§ˆæ›´æ–°
  if (originalElement['type'] == 'group') {
    _handleGroupElementLiveUpdate(originalElement, processedState);
  } else {
    _handleSingleElementLiveUpdate(elementId, originalElement, processedState);
  }
}
```

**SmartCanvasGestureHandler.dart** - æ‰‹åŠ¿å±‚é›†æˆ:
```dart
void _handleElementDragUpdate(Offset currentPosition) {
  try {
    final dx = currentPosition.dx - _dragStart.dx;
    final dy = currentPosition.dy - _dragStart.dy;
    
    var finalOffset = Offset(dx, dy);
    
    // ğŸ”§ æ–°å¢ï¼šå‚è€ƒçº¿å¯¹é½æ£€æµ‹
    if (controller.state.alignmentMode == AlignmentMode.guideline &&
        controller.state.selectedElementIds.length == 1) {
      
      final elementId = controller.state.selectedElementIds.first;
      final element = controller.state.currentPageElements.firstWhere(
        (e) => e['id'] == elementId,
        orElse: () => <String, dynamic>{},
      );
      
      if (element.isNotEmpty) {
        final currentBounds = Rect.fromLTWH(
          (element['x'] as num).toDouble() + dx,
          (element['y'] as num).toDouble() + dy,
          (element['width'] as num).toDouble(),
          (element['height'] as num).toDouble(),
        );
        
        final alignmentResult = GuidelineManager.detectAlignment(
          targetBounds: currentBounds,
          allElements: controller.state.currentPageElements,
          targetElementId: elementId,
          snapThreshold: controller.state.gridSize / 2,
        );
        
        if (alignmentResult.hasAlignment) {
          // è®¡ç®—å¯¹é½åçš„åç§»
          final alignedX = alignmentResult.alignedBounds.left - (element['x'] as num).toDouble();
          final alignedY = alignmentResult.alignedBounds.top - (element['y'] as num).toDouble();
          finalOffset = Offset(alignedX, alignedY);
          
          // æ›´æ–°æ´»åŠ¨å‚è€ƒçº¿ç”¨äºæ¸²æŸ“
          controller.updateActiveGuidelines(alignmentResult.activeGuidelines);
        } else {
          controller.clearActiveGuidelines();
        }
      }
    }
    
    dragStateManager.updateDragOffset(finalOffset);
    onDragUpdate();
    
  } catch (e, stackTrace) {
    EditPageLogger.canvasError('å…ƒç´ æ‹–æ‹½æ›´æ–°å¼‚å¸¸', error: e, stackTrace: stackTrace);
  }
}
```

#### 5.2.4 æ¸²æŸ“å±‚é›†æˆ

**CanvasLayerBuilders.dart** - æ·»åŠ å‚è€ƒçº¿æ¸²æŸ“å±‚:
```dart
/// æ„å»ºå‚è€ƒçº¿å±‚
Widget buildGuidelineLayer(LayerConfig config) {
  // åªåœ¨å‚è€ƒçº¿å¯¹é½æ¨¡å¼ä¸”æœ‰æ´»åŠ¨å‚è€ƒçº¿æ—¶æ¸²æŸ“
  if (controller.state.alignmentMode != AlignmentMode.guideline ||
      controller.state.activeGuidelines.isEmpty ||
      isPreviewMode) {
    return const SizedBox.shrink();
  }

  EditPageLogger.canvasDebug('æ„å»ºå‚è€ƒçº¿å±‚', data: {
    'guidelinesCount': controller.state.activeGuidelines.length,
    'isPreviewMode': isPreviewMode,
  });

  return RepaintBoundary(
    child: GuidelineRenderer(
      guidelines: controller.state.activeGuidelines,
      canvasBounds: config.canvasBounds,
      scale: transformationController.value.getMaxScaleOnAxis(),
    ),
  );
}
```

**GuidelineRenderer.dart** - å‚è€ƒçº¿å¯è§†åŒ–ç»„ä»¶:
```dart
class GuidelineRenderer extends StatelessWidget {
  final List<Guideline> guidelines;
  final Rect canvasBounds;
  final double scale;
  
  const GuidelineRenderer({
    super.key,
    required this.guidelines,
    required this.canvasBounds,
    required this.scale,
  });

  @override
  Widget build(BuildContext context) {
    return CustomPaint(
      painter: GuidelinePainter(
        guidelines: guidelines,
        canvasBounds: canvasBounds,
        scale: scale,
      ),
      size: Size.infinite,
    );
  }
}

class GuidelinePainter extends CustomPainter {
  final List<Guideline> guidelines;
  final Rect canvasBounds;
  final double scale;
  
  GuidelinePainter({
    required this.guidelines,
    required this.canvasBounds,
    required this.scale,
  });

  @override
  void paint(Canvas canvas, Size size) {
    final paint = Paint()
      ..color = const Color(0xFFFF5722)  // çº¢è‰²å‚è€ƒçº¿
      ..strokeWidth = 1.0 / scale  // æ ¹æ®ç¼©æ”¾è°ƒæ•´çº¿å®½
      ..style = PaintingStyle.stroke;

    final dashPaint = Paint()
      ..color = const Color(0xFFFF5722).withOpacity(0.8)
      ..strokeWidth = 1.0 / scale
      ..style = PaintingStyle.stroke;

    for (final guideline in guidelines) {
      _drawGuideline(canvas, guideline, paint, dashPaint, size);
    }
  }

  void _drawGuideline(Canvas canvas, Guideline guideline, Paint paint, Paint dashPaint, Size size) {
    switch (guideline.direction) {
      case AlignmentDirection.horizontal:
        // ç»˜åˆ¶æ°´å¹³å‚è€ƒçº¿
        final y = guideline.position;
        _drawDashedLine(
          canvas, 
          Offset(0, y), 
          Offset(size.width, y), 
          dashPaint
        );
        break;
        
      case AlignmentDirection.vertical:
        // ç»˜åˆ¶å‚ç›´å‚è€ƒçº¿
        final x = guideline.position;
        _drawDashedLine(
          canvas, 
          Offset(x, 0), 
          Offset(x, size.height), 
          dashPaint
        );
        break;
    }
    
    // åœ¨å¯¹é½ç‚¹ç»˜åˆ¶å°åœ†ç‚¹
    _drawAlignmentPoint(canvas, guideline, paint);
  }

  void _drawDashedLine(Canvas canvas, Offset start, Offset end, Paint paint) {
    const dashWidth = 5.0;
    const dashSpace = 3.0;
    
    final distance = (end - start).distance;
    final dashCount = (distance / (dashWidth + dashSpace)).floor();
    
    final unitVector = (end - start) / distance;
    
    for (int i = 0; i < dashCount; i++) {
      final dashStart = start + unitVector * (i * (dashWidth + dashSpace));
      final dashEnd = dashStart + unitVector * dashWidth;
      canvas.drawLine(dashStart, dashEnd, paint);
    }
  }

  void _drawAlignmentPoint(Canvas canvas, Guideline guideline, Paint paint) {
    // åœ¨å¯¹é½ç‚¹ç»˜åˆ¶å°åœ†åœˆæ ‡è®°
    final pointPaint = Paint()
      ..color = const Color(0xFFFF5722)
      ..style = PaintingStyle.fill;
    
    final center = switch (guideline.direction) {
      AlignmentDirection.horizontal => Offset(
        guideline.sourceElementBounds.center.dx,
        guideline.position,
      ),
      AlignmentDirection.vertical => Offset(
        guideline.position,
        guideline.sourceElementBounds.center.dy,
      ),
    };
    
    canvas.drawCircle(center, 3.0 / scale, pointPaint);
  }

  @override
  bool shouldRepaint(covariant GuidelinePainter oldDelegate) {
    return guidelines != oldDelegate.guidelines ||
           canvasBounds != oldDelegate.canvasBounds ||
           scale != oldDelegate.scale;
  }
}
```

### 5.3 æ ¸å¿ƒç®—æ³•å®ç°

**GuidelineManager.dart** - å‚è€ƒçº¿ç®¡ç†å™¨:
```dart
class GuidelineManager {
  static const double DEFAULT_SNAP_THRESHOLD = 5.0;
  
  /// æ£€æµ‹å¹¶åº”ç”¨å¯¹é½
  static AlignmentResult detectAndAlign({
    required String elementId,
    required Map<String, dynamic> currentProperties,
    required List<Map<String, dynamic>> allElements,
    required double snapThreshold,
  }) {
    final targetBounds = _getBoundsFromProperties(currentProperties);
    final guidelines = _generateGuidelines(allElements, elementId);
    
    final activeGuidelines = _findNearestGuidelines(
      targetBounds, 
      guidelines, 
      snapThreshold
    );
    
    if (activeGuidelines.isEmpty) {
      return AlignmentResult.noAlignment();
    }
    
    final alignedProperties = _calculateAlignedProperties(
      currentProperties, 
      activeGuidelines
    );
    
    return AlignmentResult(
      hasAlignment: true,
      alignedProperties: alignedProperties,
      activeGuidelines: activeGuidelines,
      alignedBounds: _getBoundsFromProperties(alignedProperties),
    );
  }
  
  /// ç”Ÿæˆæ‰€æœ‰å‚è€ƒçº¿
  static List<Guideline> _generateGuidelines(
    List<Map<String, dynamic>> elements, 
    String excludeElementId
  ) {
    final guidelines = <Guideline>[];
    
    for (final element in elements) {
      final id = element['id'] as String;
      if (id == excludeElementId) continue;
      
      final bounds = _getBoundsFromProperties(element);
      
      guidelines.addAll([
        // æ¨ªå‘å‚è€ƒçº¿
        Guideline(
          id: '${id}_h_center',
          type: GuidelineType.horizontalCenterLine,
          position: bounds.center.dy,
          direction: AlignmentDirection.horizontal,
          sourceElementId: id,
          sourceElementBounds: bounds,
        ),
        Guideline(
          id: '${id}_h_top',
          type: GuidelineType.horizontalTopEdge,
          position: bounds.top,
          direction: AlignmentDirection.horizontal,
          sourceElementId: id,
          sourceElementBounds: bounds,
        ),
        Guideline(
          id: '${id}_h_bottom',
          type: GuidelineType.horizontalBottomEdge,
          position: bounds.bottom,
          direction: AlignmentDirection.horizontal,
          sourceElementId: id,
          sourceElementBounds: bounds,
        ),
        
        // çºµå‘å‚è€ƒçº¿
        Guideline(
          id: '${id}_v_center',
          type: GuidelineType.verticalCenterLine,
          position: bounds.center.dx,
          direction: AlignmentDirection.vertical,
          sourceElementId: id,
          sourceElementBounds: bounds,
        ),
        Guideline(
          id: '${id}_v_left',
          type: GuidelineType.verticalLeftEdge,
          position: bounds.left,
          direction: AlignmentDirection.vertical,
          sourceElementId: id,
          sourceElementBounds: bounds,
        ),
        Guideline(
          id: '${id}_v_right',
          type: GuidelineType.verticalRightEdge,
          position: bounds.right,
          direction: AlignmentDirection.vertical,
          sourceElementId: id,
          sourceElementBounds: bounds,
        ),
      ]);
    }
    
    return guidelines;
  }
  
  /// æŸ¥æ‰¾æœ€è¿‘çš„å‚è€ƒçº¿
  static List<Guideline> _findNearestGuidelines(
    Rect targetBounds,
    List<Guideline> guidelines,
    double threshold,
  ) {
    final candidates = guidelines
        .map((g) => _GuidelineCandidate(g, g.distanceTo(targetBounds)))
        .where((c) => c.distance <= threshold)
        .toList();
    
    // åˆ†æ–¹å‘é€‰æ‹©æœ€è¿‘çš„å‚è€ƒçº¿
    final result = <Guideline>[];
    
    // æ°´å¹³æ–¹å‘æœ€è¿‘
    final horizontalCandidate = candidates
        .where((c) => c.guideline.direction == AlignmentDirection.horizontal)
        .fold<_GuidelineCandidate?>(null, (prev, curr) => 
            prev == null || curr.distance < prev.distance ? curr : prev);
    
    // å‚ç›´æ–¹å‘æœ€è¿‘
    final verticalCandidate = candidates
        .where((c) => c.guideline.direction == AlignmentDirection.vertical)
        .fold<_GuidelineCandidate?>(null, (prev, curr) => 
            prev == null || curr.distance < prev.distance ? curr : prev);
    
    if (horizontalCandidate != null) result.add(horizontalCandidate.guideline);
    if (verticalCandidate != null) result.add(verticalCandidate.guideline);
    
    return result;
  }
  
  /// è®¡ç®—å¯¹é½åçš„å±æ€§
  static Map<String, double> _calculateAlignedProperties(
    Map<String, dynamic> properties,
    List<Guideline> guidelines,
  ) {
    final result = <String, double>{};
    final bounds = _getBoundsFromProperties(properties);
    
    for (final guideline in guidelines) {
      switch (guideline.type) {
        case GuidelineType.horizontalCenterLine:
          result['y'] = guideline.position - bounds.height / 2;
          break;
        case GuidelineType.verticalCenterLine:
          result['x'] = guideline.position - bounds.width / 2;
          break;
        case GuidelineType.horizontalTopEdge:
          result['y'] = guideline.position;
          break;
        case GuidelineType.horizontalBottomEdge:
          result['y'] = guideline.position - bounds.height;
          break;
        case GuidelineType.verticalLeftEdge:
          result['x'] = guideline.position;
          break;
        case GuidelineType.verticalRightEdge:
          result['x'] = guideline.position - bounds.width;
          break;
      }
    }
    
    return result;
  }
  
  static Rect _getBoundsFromProperties(Map<String, dynamic> properties) {
    final x = (properties['x'] as num?)?.toDouble() ?? 0.0;
    final y = (properties['y'] as num?)?.toDouble() ?? 0.0;
    final width = (properties['width'] as num?)?.toDouble() ?? 0.0;
    final height = (properties['height'] as num?)?.toDouble() ?? 0.0;
    
    return Rect.fromLTWH(x, y, width, height);
  }
}

class _GuidelineCandidate {
  final Guideline guideline;
  final double distance;
  
  _GuidelineCandidate(this.guideline, this.distance);
}

class AlignmentResult {
  final bool hasAlignment;
  final Map<String, double> alignedProperties;
  final List<Guideline> activeGuidelines;
  final Rect? alignedBounds;
  
  AlignmentResult({
    required this.hasAlignment,
    required this.alignedProperties,
    required this.activeGuidelines,
    this.alignedBounds,
  });
  
  factory AlignmentResult.noAlignment() {
    return AlignmentResult(
      hasAlignment: false,
      alignedProperties: {},
      activeGuidelines: [],
    );
  }
}
```

### 5.4 æ‰©å±•æ–¹æ³•

**GuidelineExtension.dart** - æ§åˆ¶å™¨æ‰©å±•:
```dart
extension GuidelineExtension on PracticeEditController {
  /// æ›´æ–°æ´»åŠ¨å‚è€ƒçº¿
  void updateActiveGuidelines(List<Guideline> guidelines) {
    state.activeGuidelines = guidelines;
    state.isGuidelinePreviewActive = guidelines.isNotEmpty;
    
    EditPageLogger.editPageDebug('æ›´æ–°æ´»åŠ¨å‚è€ƒçº¿', data: {
      'count': guidelines.length,
      'types': guidelines.map((g) => g.type.name).toList(),
    });
    
    intelligentNotify(
      changeType: 'guideline_update',
      operation: 'updateActiveGuidelines',
      eventData: {
        'guidelinesCount': guidelines.length,
        'isActive': guidelines.isNotEmpty,
      },
      affectedLayers: ['guideline'],
      affectedUIComponents: ['canvas'],
    );
  }
  
  /// æ¸…é™¤æ´»åŠ¨å‚è€ƒçº¿
  void clearActiveGuidelines() {
    if (state.activeGuidelines.isNotEmpty) {
      state.activeGuidelines.clear();
      state.isGuidelinePreviewActive = false;
      
      EditPageLogger.editPageDebug('æ¸…é™¤æ´»åŠ¨å‚è€ƒçº¿');
      
      intelligentNotify(
        changeType: 'guideline_clear',
        operation: 'clearActiveGuidelines',
        eventData: {'cleared': true},
        affectedLayers: ['guideline'],
        affectedUIComponents: ['canvas'],
      );
    }
  }
}
```

## 6. æ€§èƒ½åˆ†æ

### 6.1 ç®—æ³•å¤æ‚åº¦

| åœºæ™¯ | åŸºç¡€ç®—æ³• | ä¼˜åŒ–ç®—æ³• | è¯´æ˜ |
|------|----------|----------|------|
| å…ƒç´ æ•° < 50 | O(n log n) â‰ˆ 1ms | - | å®Œå…¨å¯æ¥å— |
| å…ƒç´ æ•° = 100 | O(n log n) â‰ˆ 3ms | O(k log k) â‰ˆ 1ms | ä½¿ç”¨ç©ºé—´ç´¢å¼• |
| å…ƒç´ æ•° > 200 | O(n log n) > 5ms | O(k) â‰ˆ 1ms | ç©ºé—´ç´¢å¼•+ç¼“å­˜ |

### 6.2 å†…å­˜æ¶ˆè€—

| ç»„ä»¶ | å†…å­˜å ç”¨ | è¯´æ˜ |
|------|----------|------|
| å‚è€ƒçº¿ç¼“å­˜ | n Ã— 6 Ã— 80B | æ¯ä¸ªå…ƒç´ 6æ¡å‚è€ƒçº¿ï¼Œæ¯æ¡çº¦80å­—èŠ‚ |
| ç©ºé—´ç´¢å¼• | n Ã— 40B | å››å‰æ ‘èŠ‚ç‚¹ï¼Œæ¯ä¸ªå…ƒç´ çº¦40å­—èŠ‚ |
| æ´»åŠ¨çŠ¶æ€ | 2 Ã— 80B | æœ€å¤š2æ¡æ´»åŠ¨å‚è€ƒçº¿ |

### 6.3 æ€§èƒ½ä¼˜åŒ–å®ç°

**SpatialIndex.dart** - ç©ºé—´ç´¢å¼•ä¼˜åŒ–:
```dart
class SpatialIndex {
  final Map<String, Rect> _elementBounds = {};
  final double _threshold;
  
  SpatialIndex(this._threshold);
  
  void updateElement(String elementId, Rect bounds) {
    _elementBounds[elementId] = bounds;
  }
  
  void removeElement(String elementId) {
    _elementBounds.remove(elementId);
  }
  
  List<String> getNearbyElementIds(Rect targetBounds) {
    final expanded = targetBounds.inflate(_threshold);
    
    return _elementBounds.entries
        .where((entry) => entry.value.overlaps(expanded))
        .map((entry) => entry.key)
        .toList();
  }
}
```

## 7. æµ‹è¯•æ–¹æ¡ˆ

### 7.1 åŠŸèƒ½æµ‹è¯•

**åŸºç¡€åŠŸèƒ½æµ‹è¯•**:
1. å·¥å…·æ ä¸‰æ€åˆ‡æ¢åŠŸèƒ½
2. å„ç§å¯¹é½ç±»å‹çš„å‡†ç¡®æ€§
3. é˜ˆå€¼è·ç¦»çš„æœ‰æ•ˆæ€§
4. é¢„è§ˆæç¤ºçš„æ˜¾ç¤ºæ•ˆæœ

**äº¤äº’æµ‹è¯•**:
1. æ‹–æ‹½è¿‡ç¨‹ä¸­çš„å®æ—¶é¢„è§ˆ
2. é‡Šæ”¾é¼ æ ‡æ—¶çš„æœ€ç»ˆå¯¹é½
3. å¤šå…ƒç´ åœºæ™¯ä¸‹çš„å¯¹é½é€‰æ‹©
4. ä¸ç½‘æ ¼è´´é™„çš„äº’æ–¥åŠŸèƒ½

**è¾¹ç•Œæµ‹è¯•**:
1. å•å…ƒç´ åœºæ™¯ï¼ˆæ— å…¶ä»–å…ƒç´ å¯¹é½ï¼‰
2. å¤§é‡å…ƒç´ åœºæ™¯ï¼ˆ>100ä¸ªå…ƒç´ ï¼‰
3. å…ƒç´ é‡å åœºæ™¯
4. æå°å…ƒç´ åœºæ™¯

### 7.2 æ€§èƒ½æµ‹è¯•

**ç®—æ³•æ€§èƒ½**:
```dart
void testGuidelinePerformance() {
  final elements = generateTestElements(100); // ç”Ÿæˆ100ä¸ªæµ‹è¯•å…ƒç´ 
  final stopwatch = Stopwatch()..start();
  
  for (int i = 0; i < 100; i++) {
    GuidelineManager.detectAndAlign(
      elementId: 'test',
      currentProperties: elements[0],
      allElements: elements,
      snapThreshold: 5.0,
    );
  }
  
  stopwatch.stop();
  final avgTime = stopwatch.elapsedMicroseconds / 100;
  
  expect(avgTime, lessThan(3000)); // æœŸæœ›å¹³å‡æ—¶é—´ < 3ms
}
```

**å†…å­˜æ€§èƒ½**:
```dart
void testMemoryUsage() {
  final elements = generateTestElements(200);
  final initialMemory = ProcessInfo.currentRss;
  
  // åˆ›å»ºå‚è€ƒçº¿ç¼“å­˜
  final cache = GuidelineCache();
  for (final element in elements) {
    cache.getOrGenerate(element['id']);
  }
  
  final finalMemory = ProcessInfo.currentRss;
  final memoryIncrease = finalMemory - initialMemory;
  
  expect(memoryIncrease, lessThan(1024 * 1024)); // æœŸæœ›å†…å­˜å¢åŠ  < 1MB
}
```

### 7.3 é›†æˆæµ‹è¯•

**UIé›†æˆæµ‹è¯•**:
```dart
testWidgets('å‚è€ƒçº¿å¯¹é½UIé›†æˆæµ‹è¯•', (WidgetTester tester) async {
  await tester.pumpWidget(TestApp());
  
  // 1. åˆ‡æ¢åˆ°å‚è€ƒçº¿å¯¹é½æ¨¡å¼
  await tester.tap(find.text('ğŸ”„ğŸ“ğŸš«'));
  await tester.pump();
  expect(find.text('ğŸ”„ğŸ“ğŸ“'), findsOneWidget);
  
  // 2. æ‹–æ‹½å…ƒç´ è§¦å‘å¯¹é½
  await tester.drag(find.byKey(Key('element_1')), Offset(10, 10));
  await tester.pump();
  
  // 3. éªŒè¯å‚è€ƒçº¿æ˜¾ç¤º
  expect(find.byType(GuidelineRenderer), findsOneWidget);
  
  // 4. é‡Šæ”¾é¼ æ ‡éªŒè¯å¯¹é½ç»“æœ
  await tester.pumpAndSettle();
  // éªŒè¯å…ƒç´ ä½ç½®å·²å¯¹é½...
});
```

## 8. éƒ¨ç½²è®¡åˆ’

### 8.1 å¼€å‘é˜¶æ®µ

**é˜¶æ®µ1: æ ¸å¿ƒç®—æ³•å®ç° (1-2å‘¨)**
- GuidelineManageræ ¸å¿ƒç®—æ³•
- GuidelineTypesæ•°æ®ç»“æ„
- åŸºç¡€å¯¹é½æ£€æµ‹åŠŸèƒ½
- å•å…ƒæµ‹è¯•è¦†ç›–

**é˜¶æ®µ2: UIé›†æˆ (1å‘¨)**
- å·¥å…·æ ä¸‰æ€æŒ‰é’®
- çŠ¶æ€ç®¡ç†é›†æˆ
- åŸºç¡€äº¤äº’åŠŸèƒ½

**é˜¶æ®µ3: æ¸²æŸ“é›†æˆ (1å‘¨)**
- GuidelineRendererå®ç°
- æ¸²æŸ“å±‚é›†æˆ
- è§†è§‰æ•ˆæœä¼˜åŒ–

**é˜¶æ®µ4: æ‹–æ‹½é›†æˆ (1-2å‘¨)**
- ControlPointHandlersé›†æˆ
- GestureHandleré›†æˆ
- å®æ—¶é¢„è§ˆåŠŸèƒ½

**é˜¶æ®µ5: æ€§èƒ½ä¼˜åŒ– (1å‘¨)**
- ç©ºé—´ç´¢å¼•å®ç°
- ç¼“å­˜ç­–ç•¥ä¼˜åŒ–
- æ€§èƒ½æµ‹è¯•éªŒè¯

### 8.2 æµ‹è¯•é˜¶æ®µ

**å•å…ƒæµ‹è¯•** (ä¸å¼€å‘å¹¶è¡Œ):
- ç®—æ³•å‡†ç¡®æ€§æµ‹è¯•
- è¾¹ç•Œæ¡ä»¶æµ‹è¯•
- æ€§èƒ½åŸºå‡†æµ‹è¯•

**é›†æˆæµ‹è¯•** (1å‘¨):
- UIäº¤äº’æµ‹è¯•
- æ‹–æ‹½æµç¨‹æµ‹è¯•
- å¤šåœºæ™¯å…¼å®¹æ€§æµ‹è¯•

**ç”¨æˆ·æµ‹è¯•** (1å‘¨):
- çœŸå®ä½¿ç”¨åœºæ™¯æµ‹è¯•
- ç”¨æˆ·ä½“éªŒåé¦ˆ
- åŠŸèƒ½å®Œå–„å’Œè°ƒä¼˜

### 8.3 å‘å¸ƒè®¡åˆ’

**Betaç‰ˆæœ¬**:
- åŸºç¡€å¯¹é½åŠŸèƒ½
- ä¸‰æ€æ¨¡å¼åˆ‡æ¢
- åŸºæœ¬è§†è§‰åé¦ˆ

**æ­£å¼ç‰ˆæœ¬**:
- å®Œæ•´å¯¹é½ç®—æ³•
- æ€§èƒ½ä¼˜åŒ–
- å®Œæ•´æµ‹è¯•è¦†ç›–

**åç»­ä¼˜åŒ–**:
- é«˜çº§å¯¹é½é€‰é¡¹
- è‡ªå®šä¹‰é˜ˆå€¼è®¾ç½®
- å¯¹é½å†å²è®°å½•

## 9. é£é™©è¯„ä¼°

### 9.1 æŠ€æœ¯é£é™©

**æ€§èƒ½é£é™©**:
- å¤§é‡å…ƒç´ åœºæ™¯ä¸‹ç®—æ³•æ€§èƒ½
- å®æ—¶é¢„è§ˆçš„æ¸²æŸ“æ€§èƒ½
- å†…å­˜å ç”¨å¢é•¿

**ç¼“è§£æªæ–½**:
- ç©ºé—´ç´¢å¼•ä¼˜åŒ–ç®—æ³•
- æ¡ä»¶æ¸²æŸ“å’ŒRepaintBoundary
- ç¼“å­˜æ¸…ç†ç­–ç•¥

**å…¼å®¹æ€§é£é™©**:
- ä¸ç°æœ‰æ‹–æ‹½æœºåˆ¶çš„é›†æˆ
- å¤šå¹³å°æ¸²æŸ“ä¸€è‡´æ€§
- ä¸åŒå±å¹•å°ºå¯¸é€‚é…

**ç¼“è§£æªæ–½**:
- å……åˆ†çš„é›†æˆæµ‹è¯•
- æ¸è¿›å¼åŠŸèƒ½é›†æˆ
- å¤šå¹³å°æµ‹è¯•éªŒè¯

### 9.2 ç”¨æˆ·ä½“éªŒé£é™©

**å­¦ä¹ æˆæœ¬**:
- æ–°åŠŸèƒ½çš„å­¦ä¹ æ›²çº¿
- ä¸ç°æœ‰æ“ä½œä¹ æƒ¯çš„å†²çª

**ç¼“è§£æªæ–½**:
- ç›´è§‚çš„è§†è§‰è®¾è®¡
- æ¸è¿›å¼åŠŸèƒ½å¼•å¯¼
- è¯¦ç»†çš„å¸®åŠ©æ–‡æ¡£

**åŠŸèƒ½å¤æ‚åº¦**:
- è¿‡å¤šçš„å¯¹é½é€‰é¡¹å¯èƒ½é€ æˆå›°æƒ‘
- é¢„è§ˆæ•ˆæœå¯èƒ½ä¸å¤Ÿæ¸…æ™°

**ç¼“è§£æªæ–½**:
- ç®€åŒ–ç”¨æˆ·ç•Œé¢
- ä¼˜åŒ–è§†è§‰åé¦ˆè®¾è®¡
- ç”¨æˆ·æµ‹è¯•éªŒè¯

## 10. æ€»ç»“

æœ¬è®¾è®¡æ–¹æ¡ˆä¸ºå­—å¸–ç¼–è¾‘å™¨æä¾›äº†å®Œæ•´çš„å‚è€ƒçº¿è‡ªåŠ¨å¯¹é½åŠŸèƒ½ï¼Œå…·æœ‰ä»¥ä¸‹ç‰¹ç‚¹ï¼š

**æ ¸å¿ƒä¼˜åŠ¿**:
1. **æ™ºèƒ½å¯¹é½**: æ”¯æŒ6ç§å‚è€ƒçº¿ç±»å‹å’Œå¤šç§å¯¹é½ç»„åˆ
2. **ç›´è§‚äº¤äº’**: é¢„è§ˆæç¤ºæ¨¡å¼ä¿æŒç”¨æˆ·æ§åˆ¶æ„Ÿ
3. **æ€§èƒ½ä¼˜åŒ–**: å¤šå±‚ä¼˜åŒ–ç­–ç•¥æ”¯æŒå¤§é‡å…ƒç´ åœºæ™¯
4. **æ— ç¼é›†æˆ**: æœ€å°ä¾µå…¥æ€§è®¾è®¡ï¼Œä¸ç°æœ‰æ¶æ„å’Œè°å…±å­˜

**æŠ€æœ¯åˆ›æ–°**:
1. **åˆ†å±‚æ¸²æŸ“æ¶æ„**: ç‹¬ç«‹çš„å‚è€ƒçº¿æ¸²æŸ“å±‚
2. **æ™ºèƒ½çŠ¶æ€ç®¡ç†**: ä¸‰æ€äº’æ–¥çš„å¯¹é½æ¨¡å¼
3. **å®æ—¶é¢„è§ˆæŠ€æœ¯**: Liveé˜¶æ®µçš„å‚è€ƒçº¿æ£€æµ‹å’Œé¢„è§ˆ
4. **æ€§èƒ½ä¼˜åŒ–ç­–ç•¥**: ç©ºé—´ç´¢å¼•ã€ç¼“å­˜æœºåˆ¶ã€åˆ†å±‚è®¡ç®—

**ç”¨æˆ·ä»·å€¼**:
1. **æé«˜è®¾è®¡æ•ˆç‡**: ç²¾ç¡®çš„è‡ªåŠ¨å¯¹é½å‡å°‘æ‰‹åŠ¨è°ƒæ•´
2. **å¢å¼ºè®¾è®¡è´¨é‡**: ä¸“ä¸šçš„å¯¹é½æ•ˆæœæå‡ä½œå“è§†è§‰æ•ˆæœ
3. **ç®€åŒ–æ“ä½œæµç¨‹**: æ™ºèƒ½åŒ–çš„å¯¹é½æ›¿ä»£å¤æ‚çš„æ‰‹åŠ¨æ“ä½œ
4. **çµæ´»çš„æ§åˆ¶**: ä¸‰æ€æ¨¡å¼æ»¡è¶³ä¸åŒåœºæ™¯éœ€æ±‚

è¯¥æ–¹æ¡ˆåœ¨ä¿æŒä»£ç ç®€æ´æ€§çš„åŒæ—¶å®ç°äº†åŠŸèƒ½çš„å®Œæ•´æ€§ï¼Œä¸ºç”¨æˆ·æä¾›äº†ä¸“ä¸šçº§çš„è®¾è®¡è¾…åŠ©å·¥å…·ã€‚ 