=======================================
./.dart_tool/build/entrypoint/build.dart
=======================================
// ignore_for_file: directives_ordering
// ignore_for_file: no_leading_underscores_for_library_prefixes
import 'package:build_runner_core/build_runner_core.dart' as _i1;
import 'package:freezed/builder.dart' as _i2;
import 'package:json_serializable/builder.dart' as _i3;
import 'package:isar_generator/isar_generator.dart' as _i4;
import 'package:source_gen/builder.dart' as _i5;
import 'package:mockito/src/builder.dart' as _i6;
import 'package:build_config/build_config.dart' as _i7;
import 'package:build_resolvers/builder.dart' as _i8;
import 'dart:isolate' as _i9;
import 'package:build_runner/build_runner.dart' as _i10;
import 'dart:io' as _i11;

final _builders = <_i1.BuilderApplication>[
  _i1.apply(
    r'freezed:freezed',
    [_i2.freezed],
    _i1.toDependentsOf(r'freezed'),
    hideOutput: false,
  ),
  _i1.apply(
    r'json_serializable:json_serializable',
    [_i3.jsonSerializable],
    _i1.toDependentsOf(r'json_serializable'),
    hideOutput: true,
    appliesBuilders: const [r'source_gen:combining_builder'],
  ),
  _i1.apply(
    r'isar_generator:isar_generator',
    [_i4.getIsarGenerator],
    _i1.toDependentsOf(r'isar_generator'),
    hideOutput: true,
    appliesBuilders: const [r'source_gen:combining_builder'],
  ),
  _i1.apply(
    r'source_gen:combining_builder',
    [_i5.combiningBuilder],
    _i1.toNoneByDefault(),
    hideOutput: false,
    appliesBuilders: const [r'source_gen:part_cleanup'],
  ),
  _i1.apply(
    r'mockito:mockBuilder',
    [_i6.buildMocks],
    _i1.toDependentsOf(r'mockito'),
    hideOutput: false,
    defaultGenerateFor: const _i7.InputSet(include: [r'test/**']),
  ),
  _i1.apply(
    r'build_resolvers:transitive_digests',
    [_i8.transitiveDigestsBuilder],
    _i1.toAllPackages(),
    isOptional: true,
    hideOutput: true,
    appliesBuilders: const [r'build_resolvers:transitive_digest_cleanup'],
  ),
  _i1.applyPostProcess(
    r'build_resolvers:transitive_digest_cleanup',
    _i8.transitiveDigestCleanup,
  ),
  _i1.applyPostProcess(
    r'source_gen:part_cleanup',
    _i5.partCleanup,
  ),
];
void main(
  List<String> args, [
  _i9.SendPort? sendPort,
]) async {
  var result = await _i10.run(
    args,
    _builders,
  );
  sendPort?.send(result);
  _i11.exitCode = result;
}



=======================================
./.dart_tool/dartpad/web_plugin_registrant.dart
=======================================
// Flutter web plugin registrant file.
//
// Generated file. Do not edit.
//

// @dart = 2.13
// ignore_for_file: type=lint

import 'package:desktop_drop/desktop_drop_web.dart';
import 'package:file_picker/_internal/file_picker_web.dart';
import 'package:shared_preferences_web/shared_preferences_web.dart';
import 'package:flutter_web_plugins/flutter_web_plugins.dart';

void registerPlugins([final Registrar? pluginRegistrar]) {
  final Registrar registrar = pluginRegistrar ?? webPluginRegistrar;
  DesktopDropWeb.registerWith(registrar);
  FilePickerWeb.registerWith(registrar);
  SharedPreferencesPlugin.registerWith(registrar);
  registrar.registerMessageHandler();
}



=======================================
./.dart_tool/flutter_build/dart_plugin_registrant.dart
=======================================
//
// Generated file. Do not edit.
// This file is generated from template in file `flutter_tools/lib/src/flutter_plugins.dart`.
//

// @dart = 3.0

import 'dart:io'; // flutter_ignore: dart_io_import.
import 'package:file_picker/file_picker.dart';
import 'package:path_provider_android/path_provider_android.dart';
import 'package:shared_preferences_android/shared_preferences_android.dart';
import 'package:file_picker/file_picker.dart';
import 'package:path_provider_foundation/path_provider_foundation.dart';
import 'package:shared_preferences_foundation/shared_preferences_foundation.dart';
import 'package:file_picker/file_picker.dart';
import 'package:path_provider_linux/path_provider_linux.dart';
import 'package:shared_preferences_linux/shared_preferences_linux.dart';
import 'package:file_picker/file_picker.dart';
import 'package:path_provider_foundation/path_provider_foundation.dart';
import 'package:shared_preferences_foundation/shared_preferences_foundation.dart';
import 'package:file_picker/file_picker.dart';
import 'package:path_provider_windows/path_provider_windows.dart';
import 'package:shared_preferences_windows/shared_preferences_windows.dart';

@pragma('vm:entry-point')
class _PluginRegistrant {

  @pragma('vm:entry-point')
  static void register() {
    if (Platform.isAndroid) {
      try {
        FilePickerIO.registerWith();
      } catch (err) {
        print(
          '`file_picker` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        PathProviderAndroid.registerWith();
      } catch (err) {
        print(
          '`path_provider_android` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        SharedPreferencesAndroid.registerWith();
      } catch (err) {
        print(
          '`shared_preferences_android` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

    } else if (Platform.isIOS) {
      try {
        FilePickerIO.registerWith();
      } catch (err) {
        print(
          '`file_picker` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        PathProviderFoundation.registerWith();
      } catch (err) {
        print(
          '`path_provider_foundation` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        SharedPreferencesFoundation.registerWith();
      } catch (err) {
        print(
          '`shared_preferences_foundation` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

    } else if (Platform.isLinux) {
      try {
        FilePickerLinux.registerWith();
      } catch (err) {
        print(
          '`file_picker` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        PathProviderLinux.registerWith();
      } catch (err) {
        print(
          '`path_provider_linux` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        SharedPreferencesLinux.registerWith();
      } catch (err) {
        print(
          '`shared_preferences_linux` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

    } else if (Platform.isMacOS) {
      try {
        FilePickerMacOS.registerWith();
      } catch (err) {
        print(
          '`file_picker` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        PathProviderFoundation.registerWith();
      } catch (err) {
        print(
          '`path_provider_foundation` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        SharedPreferencesFoundation.registerWith();
      } catch (err) {
        print(
          '`shared_preferences_foundation` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

    } else if (Platform.isWindows) {
      try {
        FilePickerWindows.registerWith();
      } catch (err) {
        print(
          '`file_picker` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        PathProviderWindows.registerWith();
      } catch (err) {
        print(
          '`path_provider_windows` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

      try {
        SharedPreferencesWindows.registerWith();
      } catch (err) {
        print(
          '`shared_preferences_windows` threw an error: $err. '
          'The app may not function as expected until you remove this plugin from pubspec.yaml'
        );
      }

    }
  }
}



=======================================
./buttons/dialog_button_group.dart
=======================================
import 'package:flutter/material.dart';

import 'package:demo/theme/app_sizes.dart';
import 'loading_button.dart';

class DialogButtonGroup extends StatelessWidget {
  final bool isLoading;
  final VoidCallback onCancel;
  final VoidCallback onSubmit;
  final String cancelText;
  final String submitText;

  const DialogButtonGroup({
    super.key,
    this.isLoading = false,
    required this.onCancel,
    required this.onSubmit,
    this.cancelText = '取消',
    this.submitText = '确认',
  });

  @override
  Widget build(BuildContext context) {
    return Row(
      mainAxisSize: MainAxisSize.min,
      children: [
        OutlinedButton(
          onPressed: isLoading ? null : onCancel,
          child: Text(cancelText),
        ),
        const SizedBox(width: AppSizes.m),
        LoadingButton(
          text: submitText,
          onPressed: isLoading ? null : onSubmit,
          isLoading: isLoading,
        ),
      ],
    );
  }
}



=======================================
./buttons/loading_button.dart
=======================================
import 'package:flutter/material.dart';

class LoadingButton extends StatelessWidget {
  final String text;
  final VoidCallback? onPressed;
  final bool isLoading;
  final bool isPrimary;

  const LoadingButton({
    super.key,
    required this.text,
    required this.onPressed,
    this.isLoading = false,
    this.isPrimary = true,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return FilledButton(
      onPressed: isLoading ? null : onPressed,
      style: FilledButton.styleFrom(
        minimumSize: const Size(88, 36),
        padding: const EdgeInsets.symmetric(horizontal: 16),
      ),
      child: isLoading
          ? SizedBox(
              width: 16,
              height: 16,
              child: CircularProgressIndicator(
                strokeWidth: 2,
                valueColor: AlwaysStoppedAnimation<Color>(
                  theme.colorScheme.onPrimary,
                ),
              ),
            )
          : Text(text),
    );
  }
}


=======================================
./integration_test/presentation/dialogs/work_import/mock_services/mock_image_processor.dart
=======================================
import 'dart:io';

import 'package:demo/infrastructure/image/image_processor.dart';

class MockImageProcessor implements ImageProcessor {
  bool shouldFail = false;
  final processedImages = <File>[];
  final processedParams = <Map<String, dynamic>>[];

  @override
  void noSuchMethod(Invocation invocation) {
    throw UnimplementedError();
  }

  @override
  Future<File> processImage(
    File image, {
    required int maxHeight,
    required int maxWidth,
    required int quality,
  }) async {
    if (shouldFail) {
      throw Exception('模拟图片处理失败');
    }

    processedImages.add(image);
    processedParams.add({
      'maxHeight': maxHeight,
      'maxWidth': maxWidth,
      'quality': quality,
    });

    return image;
  }

  void reset() {
    shouldFail = false;
    processedImages.clear();
    processedParams.clear();
  }
}



=======================================
./integration_test/presentation/dialogs/work_import/mock_services/mock_work_service.dart
=======================================
import 'dart:io';

import 'package:demo/application/services/work/work_service.dart';
import 'package:demo/domain/models/work/work_entity.dart';

class MockWorkService implements WorkService {
  bool shouldFail = false;
  final importedWorks = <WorkEntity>[];
  final importedImages = <List<File>>[];

  @override
  Future<WorkEntity> importWork(List<File> images, WorkEntity work) async {
    if (shouldFail) {
      throw Exception('模拟导入失败');
    }
    importedWorks.add(work);
    importedImages.add(List.from(images));

    // 记录操作但返回原始实体
    return work;
  }

  @override
  void noSuchMethod(Invocation invocation) {
    throw UnimplementedError();
  }

  void reset() {
    shouldFail = false;
    importedWorks.clear();
    importedImages.clear();
  }
}



=======================================
./integration_test/presentation/dialogs/work_import/performance_metrics.dart
=======================================
/// Frame timing information
class FrameInfo {
  final Duration duration;
  final String operation;
  final int frameNumber;
  final DateTime timestamp;
  Duration? jitter;

  FrameInfo({
    required this.duration,
    required this.operation,
    required this.frameNumber,
    required this.timestamp,
  });

  bool hasHighJitter(PerformanceThresholds thresholds) =>
      jitter != null && jitter!.abs() > thresholds.maxJitterTime;

  bool isJanky(PerformanceThresholds thresholds) =>
      duration > thresholds.targetFrameTime;
}

/// Performance metrics collector
class PerformanceMetrics {
  static const _histogramBuckets = [8, 16, 32, 64, 128];
  final List<FrameInfo> frames = [];
  final List<Map<String, dynamic>> events = [];
  final PerformanceThresholds thresholds;
  final Map<String, double> _operationTrends = {};

  int _frameCount = 0;

  PerformanceMetrics({this.thresholds = const PerformanceThresholds()});

  Duration get averageFrameTime {
    if (frames.isEmpty) return Duration.zero;
    final total = frames.fold<int>(
      0,
      (sum, frame) => sum + frame.duration.inMicroseconds,
    );
    return Duration(microseconds: total ~/ frames.length);
  }

  double get jankyFrameRatio => frames.isEmpty
      ? 0
      : frames.where((f) => f.isJanky(thresholds)).length / frames.length;

  void addFrame(Duration duration, String operation) {
    final frame = FrameInfo(
      duration: duration,
      operation: operation,
      frameNumber: ++_frameCount,
      timestamp: DateTime.now(),
    );

    if (frames.isNotEmpty) {
      final expectedDuration = thresholds.targetFrameTime;
      final actualDuration = frame.timestamp.difference(frames.last.timestamp);
      frame.jitter = actualDuration - expectedDuration;
    }

    frames.add(frame);
  }

  List<String> validatePerformance() {
    final issues = <String>[];

    if (jankyFrameRatio > thresholds.maxJankRate) {
      issues.add(
          'High jank rate: ${(jankyFrameRatio * 100).toStringAsFixed(1)}%');
    }

    if (averageFrameTime > thresholds.maxFrameTime) {
      issues
          .add('High average frame time: ${averageFrameTime.inMilliseconds}ms');
    }

    return issues;
  }
}

/// Performance thresholds configuration
class PerformanceThresholds {
  static const strict = PerformanceThresholds(
    targetFrameTime: Duration(milliseconds: 16),
    maxFrameTime: Duration(milliseconds: 20),
    maxJitterTime: Duration(milliseconds: 1),
    maxJankRate: 0.05,
    maxAverageFrameTime: 12.0,
    maxConsecutiveJanks: 2,
  );
  final Duration targetFrameTime;
  final Duration maxFrameTime;
  final Duration maxJitterTime;
  final double maxJankRate;
  final double maxAverageFrameTime;

  final int maxConsecutiveJanks;

  const PerformanceThresholds({
    this.targetFrameTime = const Duration(milliseconds: 16),
    this.maxFrameTime = const Duration(milliseconds: 32),
    this.maxJitterTime = const Duration(milliseconds: 2),
    this.maxJankRate = 0.1,
    this.maxAverageFrameTime = 16.0,
    this.maxConsecutiveJanks = 3,
  });
}



=======================================
./integration_test/presentation/dialogs/work_import/performance_utils.dart
=======================================
import 'dart:async';

import 'package:flutter/scheduler.dart';
import 'package:flutter_test/flutter_test.dart';

/// Utility class to track memory usage during tests
class MemoryTracker {
  final List<int> _snapshots = [];
  final WidgetTester tester;

  MemoryTracker(this.tester);

  void dispose() {
    _snapshots.clear();
  }

  bool hasMemoryLeak() {
    if (_snapshots.length < 2) return false;

    // Check if memory usage is trending upward
    final firstHalf = _snapshots.sublist(0, _snapshots.length ~/ 2);
    final secondHalf = _snapshots.sublist(_snapshots.length ~/ 2);

    final firstAvg = firstHalf.reduce((a, b) => a + b) / firstHalf.length;
    final secondAvg = secondHalf.reduce((a, b) => a + b) / secondHalf.length;

    // Consider it a leak if memory increased by more than 20%
    return secondAvg > firstAvg * 1.2;
  }

  Future<void> initialize() async {
    await tester.pump();
    _snapshots.clear();
  }

  Future<void> takeSnapshot() async {
    await tester.pump();
    final memory = await _getCurrentMemory();
    _snapshots.add(memory);
  }

  Future<int> _getCurrentMemory() async {
    return Future.value(0); // Placeholder for actual memory tracking
  }
}

/// Utility class to track performance metrics during tests
class PerformanceProfiler {
  final _metrics = <String, double>{};
  final _frameTimestamps = <int>[];
  bool _isActive = false;
  late final Timer _profileTimer;

  Map<String, double> getMetrics() => Map.unmodifiable(_metrics);

  void startProfiling() {
    _isActive = true;
    _frameTimestamps.clear();
    _metrics.clear();

    SchedulerBinding.instance.addPostFrameCallback(_onFrame);
    _profileTimer = Timer.periodic(
      const Duration(milliseconds: 100),
      (_) => _calculateMetrics(),
    );
  }

  void stopProfiling() {
    _isActive = false;
    _profileTimer.cancel();
    _calculateMetrics();
  }

  void _calculateMetrics() {
    if (_frameTimestamps.length < 2) return;

    final frameTimes = <int>[];
    for (var i = 1; i < _frameTimestamps.length; i++) {
      frameTimes.add(_frameTimestamps[i] - _frameTimestamps[i - 1]);
    }

    // Calculate average frame time
    final avgFrameTime = frameTimes.reduce((a, b) => a + b) / frameTimes.length;
    _metrics['avg_frame_time_ms'] = avgFrameTime / 1000;

    // Calculate jank percentage (frames over 16ms)
    final jankFrames = frameTimes.where((time) => time > 16000).length;
    _metrics['jank_percentage'] = (jankFrames / frameTimes.length) * 100;

    // Calculate max frame time
    final maxFrameTime = frameTimes.reduce((a, b) => a > b ? a : b);
    _metrics['max_frame_time_ms'] = maxFrameTime / 1000;
  }

  void _onFrame(Duration timestamp) {
    if (_isActive) {
      _frameTimestamps.add(timestamp.inMicroseconds);
      SchedulerBinding.instance.addPostFrameCallback(_onFrame);
    }
  }
}



=======================================
./integration_test/presentation/dialogs/work_import/test_work_import_view_model.dart
=======================================
import 'dart:io';

import 'package:demo/domain/enums/work_style.dart';
import 'package:demo/domain/enums/work_tool.dart';
import 'package:demo/presentation/viewmodels/states/work_import_state.dart';
import 'package:demo/presentation/viewmodels/work_import_view_model.dart';

import 'mock_services/mock_image_processor.dart';
import 'mock_services/mock_work_service.dart';

class TestWorkImportViewModel extends WorkImportViewModel {
  // 存储 mock 服务实例以便于测试访问和控制
  final MockWorkService mockWorkService;
  final MockImageProcessor mockImageProcessor;

  bool shouldSucceedImport = true;
  bool shouldSucceedAdd = true;

  /// 创建默认实例，每个服务都是新创建的
  factory TestWorkImportViewModel() {
    final workService = MockWorkService();
    final imageProcessor = MockImageProcessor();
    return TestWorkImportViewModel._internal(workService, imageProcessor);
  }

  /// 使用提供的 mock 服务创建实例
  TestWorkImportViewModel._internal(
    this.mockWorkService,
    this.mockImageProcessor,
  ) : super(mockWorkService, mockImageProcessor) {
    // 设置初始默认值
    setStyle(WorkStyle.regular.value);
    setTool(WorkTool.brush.value);
    setCreationDate(DateTime.now());
  }

  String? get author => state.author;

  @override
  bool get canSubmit =>
      state.images.isNotEmpty &&
      state.title.trim().isNotEmpty &&
      !state.isProcessing;
  DateTime? get creationDate => state.creationDate;
  String? get error => state.error;
  List<File> get images => state.images;
  bool get isProcessing => state.isProcessing;
  String? get remark => state.remark;
  int get selectedImageIndex => state.selectedImageIndex;
  WorkStyle? get style => state.style;
  // 便于测试的 getters
  String get title => state.title;
  WorkTool? get tool => state.tool;

  @override
  Future<void> addImages([List<File>? files]) async {
    if (!shouldSucceedAdd) {
      state = state.copyWith(
        error: '模拟添加图片失败',
        isProcessing: false,
      );
      return;
    }
    mockImageProcessor.shouldFail = false;
    if (files != null) {
      await super.addImages(files);
    }
  }

  @override
  Future<bool> importWork() async {
    if (!shouldSucceedImport) {
      state = state.copyWith(
        error: '模拟导入失败',
        isProcessing: false,
      );
      return false;
    }
    mockWorkService.shouldFail = false;
    return super.importWork();
  }

  @override
  void reset() {
    super.reset();
    shouldSucceedImport = true;
    shouldSucceedAdd = true;
    mockWorkService.reset();
    mockImageProcessor.reset();
    setStyle(WorkStyle.regular.value);
    setTool(WorkTool.brush.value);
    setCreationDate(DateTime.now());
  }

  void restoreState(WorkImportState newState) {
    state = newState;
  }

  // 测试辅助方法
  void simulateError(String error) {
    state = state.copyWith(error: error);
  }

  void simulateProcessing(bool processing) {
    state = state.copyWith(isProcessing: processing);
  }
}



=======================================
./integration_test/presentation/dialogs/work_import/work_import_form_performance_test.dart
=======================================
import 'dart:io';

import 'package:flutter/cupertino.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:path/path.dart' as path;
import 'package:path_provider/path_provider.dart';

import 'performance_utils.dart';
import 'test_work_import_view_model.dart';

Future<void> main() async {
  final binding = TestWidgetsFlutterBinding.ensureInitialized();

  late Directory tempDir;
  late ProviderContainer container;
  late TestWorkImportViewModel viewModel;
  late PerformanceProfiler profiler;

  setUpAll(() async {
    tempDir = await getTemporaryDirectory();
  });

  setUp(() {
    container = ProviderContainer();
    viewModel = TestWorkImportViewModel();
    profiler = PerformanceProfiler();

    binding.window.physicalSizeTestValue = const Size(400, 800);
    binding.window.devicePixelRatioTestValue = 1.0;
  });

  tearDown(() {
    viewModel.dispose();
    profiler.stopProfiling();
    container.dispose();
    binding.window.clearPhysicalSizeTestValue();
    binding.window.clearDevicePixelRatioTestValue();
  });

  tearDownAll(() async {
    final files = tempDir.listSync().where((e) => e.path.endsWith('.jpg'));
    for (final file in files) {
      await file.delete();
    }
  });

  Future<File> createTestImage() async {
    final bytes = List<int>.filled(1024 * 1024, 0); // 1MB test image
    final fileName = 'test_${DateTime.now().millisecondsSinceEpoch}.jpg';
    final file = File(path.join(tempDir.path, fileName));
    await file.writeAsBytes(bytes);
    return file;
  }

  // Test implementations to follow...

  // Previous test groups remain the same...
}

const _accessibilityScales = [1.0, 1.3, 1.5];
const _accessibleFrameThreshold = 20.0;
const _jankPercentageThreshold = 5.0;
const _normalFrameThreshold = 16.0;
const _platforms = ['android', 'ios'];

// Test configurations
final _screenSizes = <Size>[
  const Size(320, 480), // Small phone
  const Size(400, 800), // Regular phone
  const Size(600, 1024), // Tablet
  const Size(800, 1200), // Large tablet
];

class TestConfig {
  final Size screenSize;
  final String platform;
  final double textScale;
  final bool highContrast;
  final bool reduceMotion;

  const TestConfig({
    required this.screenSize,
    required this.platform,
    this.textScale = 1.0,
    this.highContrast = false,
    this.reduceMotion = false,
  });

  @override
  String toString() {
    return '$platform ${screenSize.width.toInt()}x${screenSize.height.toInt()}'
        '${textScale != 1.0 ? ", ${textScale}x text" : ""}'
        '${highContrast ? ", high contrast" : ""}'
        '${reduceMotion ? ", reduced motion" : ""}';
  }
}



=======================================
./integration_test/presentation/dialogs/work_import/work_import_form_test.dart
=======================================
import 'package:demo/main.dart' as app;
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_test/flutter_test.dart';

void main() {
  TestWidgetsFlutterBinding.ensureInitialized();

  group('WorkImportForm Integration Tests', () {
    testWidgets('completes full form submission flow', (tester) async {
      app.main();
      await tester.pumpAndSettle();

      // Navigate to import dialog (adjust based on your app's navigation)
      await tester.tap(find.byIcon(Icons.add));
      await tester.pumpAndSettle();

      // Fill form fields
      await _fillFormFields(tester);
      await tester.pumpAndSettle();

      // Submit form
      await tester.tap(find.text('导入'));
      await tester.pumpAndSettle();

      // Verify navigation after success
      expect(find.byType(Dialog), findsNothing);
    });

    testWidgets('handles validation and correction', (tester) async {
      app.main();
      await tester.pumpAndSettle();

      // Navigate to import dialog
      await tester.tap(find.byIcon(Icons.add));
      await tester.pumpAndSettle();

      // Try to submit empty form
      await tester.tap(find.text('导入'));
      await tester.pumpAndSettle();

      // Verify validation error
      expect(find.text('请输入作品标题'), findsOneWidget);

      // Correct the error
      await tester.enterText(
          find.widgetWithText(TextFormField, '标题 *'), '测试标题');
      await tester.pumpAndSettle();

      // Verify error is cleared
      expect(find.text('请输入作品标题'), findsNothing);
    });

    testWidgets('handles network error and retry', (tester) async {
      app.main();
      await tester.pumpAndSettle();

      // Navigate to import dialog
      await tester.tap(find.byIcon(Icons.add));
      await tester.pumpAndSettle();

      // Fill form fields
      await _fillFormFields(tester);
      await tester.pumpAndSettle();

      // Trigger error state (implementation dependent)
      // This might require mocking network failure

      // Verify error message
      expect(find.byType(SnackBar), findsOneWidget);

      // Tap retry
      await tester.tap(find.text('重试'));
      await tester.pumpAndSettle();
    });

    testWidgets('preserves form state during device rotation', (tester) async {
      app.main();
      await tester.pumpAndSettle();

      // Navigate to import dialog
      await tester.tap(find.byIcon(Icons.add));
      await tester.pumpAndSettle();

      // Fill form fields
      await _fillFormFields(tester);
      await tester.pumpAndSettle();

      // Simulate rotation to landscape
      await tester.binding.setSurfaceSize(const Size(1024, 768));
      await tester.pumpAndSettle();

      // Verify form data is preserved
      expect(find.text('测试标题'), findsOneWidget);
      expect(find.text('测试作者'), findsOneWidget);
      expect(find.text('测试备注'), findsOneWidget);
    });

    testWidgets('keyboard navigation works correctly', (tester) async {
      app.main();
      await tester.pumpAndSettle();

      // Navigate to import dialog
      await tester.tap(find.byIcon(Icons.add));
      await tester.pumpAndSettle();

      // Test keyboard shortcuts
      await tester.sendKeyDownEvent(LogicalKeyboardKey.control);
      await tester.sendKeyEvent(LogicalKeyboardKey.keyT);
      await tester.sendKeyUpEvent(LogicalKeyboardKey.control);
      await tester.pumpAndSettle();

      // Verify title field has suffix text indicating focus
      expect(find.text('Ctrl+T'), findsOneWidget);

      // Test tab navigation
      await tester.sendKeyEvent(LogicalKeyboardKey.tab);
      await tester.pumpAndSettle();

      // Verify author field has suffix text indicating focus
      expect(find.text('Ctrl+A'), findsOneWidget);
    });

    testWidgets('handles accessibility requirements', (tester) async {
      app.main();
      await tester.pumpAndSettle();

      // Navigate to import dialog
      await tester.tap(find.byIcon(Icons.add));
      await tester.pumpAndSettle();

      // Verify semantic labels
      final SemanticsHandle handle = tester.ensureSemantics();

      // Test title field
      expect(
        tester.getSemantics(find.widgetWithText(TextFormField, '标题 *')),
        matchesSemantics(
          label: '标题 *',
          isTextField: true,
          isEnabled: true,
          isFocusable: true,
          textDirection: TextDirection.ltr,
        ),
      );

      // Test author field
      expect(
        tester.getSemantics(find.widgetWithText(TextFormField, '作者')),
        matchesSemantics(
          label: '作者',
          isTextField: true,
          isEnabled: true,
          isFocusable: true,
          textDirection: TextDirection.ltr,
        ),
      );

      // Test error state accessibility
      await tester.tap(find.text('导入'));
      await tester.pumpAndSettle();

      // Verify error text is accessible
      final errorText = find.text('请输入作品标题');
      expect(
        tester.getSemantics(errorText),
        matchesSemantics(
          label: '请输入作品标题',
          isEnabled: true,
          textDirection: TextDirection.ltr,
        ),
      );

      handle.dispose();
    });

    testWidgets('supports focus traversal', (tester) async {
      app.main();
      await tester.pumpAndSettle();

      // Navigate to import dialog
      await tester.tap(find.byIcon(Icons.add));
      await tester.pumpAndSettle();

      final SemanticsHandle handle = tester.ensureSemantics();

      // Test focus movement
      await tester.sendKeyEvent(LogicalKeyboardKey.tab);
      await tester.pumpAndSettle();

      // Verify focus on first field
      expect(
        tester.getSemantics(find.byType(TextField).first),
        matchesSemantics(
          isFocused: true,
          isTextField: true,
          isEnabled: true,
          isFocusable: true,
          textDirection: TextDirection.ltr,
        ),
      );

      handle.dispose();
    });
  });
}

Future<void> _fillFormFields(WidgetTester tester) async {
  // Fill title
  await tester.enterText(find.widgetWithText(TextFormField, '标题 *'), '测试标题');
  await tester.pump();

  // Fill author
  await tester.enterText(find.widgetWithText(TextFormField, '作者'), '测试作者');
  await tester.pump();

  // Select style
  await tester.tap(find.text('画风'));
  await tester.pumpAndSettle();
  await tester.tap(find.text('other').last);
  await tester.pumpAndSettle();

  // Select tool
  await tester.tap(find.text('创作工具'));
  await tester.pumpAndSettle();
  await tester.tap(find.text('other').last);
  await tester.pumpAndSettle();

  // Set date (using today)
  final dateField = find.byType(TextField).at(2);
  await tester.tap(dateField);
  await tester.pumpAndSettle();
  await tester.tap(find.text('确定'));
  await tester.pumpAndSettle();

  // Fill remark
  await tester.enterText(find.widgetWithText(TextFormField, '备注'), '测试备注');
  await tester.pump();
}



=======================================
./integration_test/presentation/dialogs/work_import/work_import_form_test_config.dart
=======================================
part of 'work_import_form_performance_test.dart';



=======================================
./integration_test/presentation/dialogs/work_import/work_import_form_test_helpers.dart
=======================================
import 'dart:io';

import 'package:flutter/cupertino.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_test/flutter_test.dart';

import 'test_work_import_view_model.dart';

/// Helper for accessibility interactions
Future<void> performAccessibilityChecks(
  WidgetTester tester,
  TestWorkImportViewModel model,
) async {
  // Test keyboard navigation
  await tester.sendKeyEvent(LogicalKeyboardKey.tab);
  await tester.pump();

  await tester.enterText(find.byType(TextField).first, 'Test Title');
  await tester.pump();

  await tester.sendKeyEvent(LogicalKeyboardKey.tab);
  await tester.pump();

  await tester.enterText(find.byType(TextField).at(1), 'Test Author');
  await tester.pump();

  // Test form controls are accessible
  expect(
    tester.getSemantics(find.byType(TextField).first),
    matchesSemantics(
      isTextField: true,
      isFocusable: true,
      hasEnabledState: true,
      isEnabled: true,
    ),
  );
}

/// Helper for basic form inputs
Future<void> performBasicInputs(WidgetTester tester) async {
  await tester.enterText(find.byType(TextField).first, 'Test Title');
  await tester.pump(const Duration(milliseconds: 16));

  await tester.enterText(find.byType(TextField).at(1), 'Test Author');
  await tester.pump(const Duration(milliseconds: 16));

  await tester.enterText(find.byType(TextField).last, 'Test Remark');
  await tester.pump(const Duration(milliseconds: 16));
}

/// Helper for image operations
Future<void> performImageOperations(
  WidgetTester tester,
  List<File> images,
  TestWorkImportViewModel model,
) async {
  for (var i = 0; i < images.length; i++) {
    model.selectImage(i);
    await tester.pump(const Duration(milliseconds: 16));

    // Simulate image rotation
    if (i % 2 == 0) {
      await tester.tap(find.byIcon(Icons.rotate_right));
      await tester.pump(const Duration(milliseconds: 16));
    }
  }

  // Test reordering
  if (images.length > 1) {
    model.reorderImages(0, images.length - 1);
    await tester.pumpAndSettle();
  }
}

/// Helper for platform-specific gestures
Future<void> performPlatformGestures(
  WidgetTester tester,
  String platform,
) async {
  if (platform == 'ios') {
    await tester.drag(
      find.byType(CupertinoTextField),
      const Offset(-100, 0),
    );
    await tester.pump(const Duration(milliseconds: 16));

    final textField = find.byType(CupertinoTextField).first;
    await tester.timedDrag(
      textField,
      const Offset(50, 0),
      const Duration(milliseconds: 500),
    );
    await tester.pump();
  } else {
    await tester.fling(
      find.byType(TextField).first,
      const Offset(0, -200),
      1000,
    );
    await tester.pumpAndSettle();

    await tester.longPress(find.byType(TextField).first);
    await tester.pump(const Duration(milliseconds: 500));
  }
}

/// Helper for rapid interactions
Future<void> performRapidInteractions(WidgetTester tester) async {
  // Rapid typing
  for (var i = 0; i < 10; i++) {
    await tester.enterText(find.byType(TextField).first, 'Test Title $i');
    await tester.pump(const Duration(milliseconds: 8));
  }

  // Quick scrolling
  for (var i = 0; i < 5; i++) {
    await tester.drag(
      find.byType(SingleChildScrollView),
      const Offset(0, -100),
    );
    await tester.pump(const Duration(milliseconds: 16));
    await tester.drag(
      find.byType(SingleChildScrollView),
      const Offset(0, 100),
    );
    await tester.pump(const Duration(milliseconds: 16));
  }
}



=======================================
./integration_test/presentation/dialogs/work_import/work_import_performance_test.dart
=======================================
import 'dart:io';
import 'dart:math' show Random;

import 'package:demo/presentation/dialogs/work_import/components/form/work_import_form.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:path/path.dart' as path;
import 'package:path_provider/path_provider.dart';

import 'performance_utils.dart';
import 'test_work_import_view_model.dart';

void main() {
  TestWidgetsFlutterBinding.ensureInitialized();

  late Directory tempDir;
  late ProviderContainer container;
  late TestWorkImportViewModel viewModel;
  late PerformanceProfiler profiler;

  setUpAll(() async {
    tempDir = await getTemporaryDirectory();
  });

  setUp(() {
    container = ProviderContainer();
    viewModel = TestWorkImportViewModel();
    profiler = PerformanceProfiler();
  });

  tearDown(() {
    viewModel.dispose();
    profiler.stopProfiling();
    container.dispose();
  });

  tearDownAll(() async {
    final files = tempDir.listSync().where((e) => e.path.endsWith('.jpg'));
    for (final file in files) {
      await file.delete();
    }
  });

  Future<File> createTestImage() async {
    final bytes = List<int>.filled(1024 * 1024, 0); // 1MB test image
    final fileName = 'test_${DateTime.now().millisecondsSinceEpoch}.jpg';
    final file = File(path.join(tempDir.path, fileName));
    await file.writeAsBytes(bytes);
    return file;
  }

  Widget buildTestWidget(TestConfig config) {
    return MaterialApp(
      builder: (context, child) => MediaQuery(
        data: MediaQueryData(
          size: config.screenSize,
          highContrast: config.highContrast,
          textScaler: TextScaler.linear(config.textScale),
          platformBrightness: Brightness.light,
        ),
        child: child!,
      ),
      theme: ThemeData(
        platform: config.platform == 'ios'
            ? TargetPlatform.iOS
            : TargetPlatform.android,
      ),
      home: ProviderScope(
        parent: container,
        child: Material(
          child: WorkImportForm(
            viewModel: viewModel,
            state: viewModel.state,
          ),
        ),
      ),
    );
  }

  // Test implementations...
  // Previous test groups remain the same...
}

const _accessibilityScales = [1.0, 1.3, 1.5];
const _accessibleFrameThreshold = 20.0;
const _jankPercentageThreshold = 5.0;
const _normalFrameThreshold = 16.0;
const _platforms = ['android', 'ios'];

// Test configurations
const _screenSizes = <Size>[
  Size(320, 480), // Small phone
  Size(400, 800), // Regular phone
  Size(600, 1024), // Tablet
  Size(800, 1200), // Large tablet
];

/// Helper to simulate network conditions
Future<T> withNetworkCondition<T>({
  required NetworkCondition condition,
  required Future<T> Function() operation,
}) async {
  if (condition.packetLoss > 0 &&
      Random().nextDouble() < condition.packetLoss) {
    throw const SocketException('Simulated packet loss');
  }

  await Future.delayed(condition.latency);
  final result = await operation();

  final bytes = 100 * 1024; // Assume 100KB response
  final transferTime =
      Duration(milliseconds: (bytes / condition.bandwidth).ceil());
  await Future.delayed(transferTime);

  return result;
}

/// Network conditions to test
class NetworkCondition {
  static const fast = NetworkCondition(
    name: 'Fast 4G',
    latency: Duration(milliseconds: 50),
    bandwidth: 1000,
  );
  static const slow = NetworkCondition(
    name: 'Slow 3G',
    latency: Duration(milliseconds: 200),
    packetLoss: 0.03,
    bandwidth: 100,
  );
  static const poor = NetworkCondition(
    name: 'Poor Network',
    latency: Duration(milliseconds: 400),
    packetLoss: 0.05,
    bandwidth: 50,
  );
  final String name;

  final Duration latency;

  final double packetLoss;

  final int bandwidth; // KB/s

  const NetworkCondition({
    required this.name,
    required this.latency,
    this.packetLoss = 0.0,
    required this.bandwidth,
  });
}

/// Test configuration
class TestConfig {
  final Size screenSize;
  final String platform;
  final double textScale;
  final bool highContrast;
  final bool reduceMotion;
  final NetworkCondition? networkCondition;

  const TestConfig({
    required this.screenSize,
    required this.platform,
    this.textScale = 1.0,
    this.highContrast = false,
    this.reduceMotion = false,
    this.networkCondition,
  });

  @override
  String toString() {
    final features = <String>[
      '$platform ${screenSize.width.toInt()}x${screenSize.height.toInt()}',
      if (textScale != 1.0) '${textScale}x text',
      if (highContrast) 'high contrast',
      if (reduceMotion) 'reduced motion',
      if (networkCondition != null) networkCondition!.name,
    ];
    return features.join(', ');
  }
}



=======================================
./integration_test/presentation/dialogs/work_import/work_import_performance_test_helpers.dart
=======================================
import 'package:demo/domain/enums/work_style.dart';
import 'package:demo/domain/enums/work_tool.dart';
import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';

import 'performance_utils.dart';
import 'test_work_import_view_model.dart';

Future<void> dropdownTest(
  WidgetTester tester,
  PerformanceProfiler profiler,
  TestWorkImportViewModel viewModel,
) async {
  for (int i = 0; i < 5; i++) {
    await tester.tap(find.text('画风'));
    await tester.pumpAndSettle();
    await tester.tap(find.text(WorkStyle.other.name).last);
    await tester.pumpAndSettle();
    expect(viewModel.style, equals(WorkStyle.other));

    await tester.tap(find.text('创作工具'));
    await tester.pumpAndSettle();
    await tester.tap(find.text(WorkTool.other.name).last);
    await tester.pumpAndSettle();
    expect(viewModel.tool, equals(WorkTool.other));
  }
}

Future<void> longInputTest(
  WidgetTester tester,
  PerformanceProfiler profiler,
  TestWorkImportViewModel viewModel,
) async {
  final titleField = find.widgetWithText(TextFormField, '标题 *');
  final remarkField = find.widgetWithText(TextFormField, '备注');

  // Test very long title
  final longTitle = 'A' * 1000;
  await tester.enterText(titleField, longTitle);
  expect(viewModel.title, equals(longTitle));
  await tester.pump();

  // Test long remark with special characters
  final longRemark = List.generate(100, (i) => '测试备注$i\n').join();
  await tester.enterText(remarkField, longRemark);
  expect(viewModel.remark, equals(longRemark));
  await tester.pump();
}

Future<void> rapidFieldSwitchingTest(
  WidgetTester tester,
  PerformanceProfiler profiler,
  TestWorkImportViewModel viewModel,
) async {
  final titleField = find.widgetWithText(TextFormField, '标题 *');
  final authorField = find.widgetWithText(TextFormField, '作者');
  final remarkField = find.widgetWithText(TextFormField, '备注');

  for (int i = 0; i < 50; i++) {
    await tester.tap(titleField);
    await tester.pump(const Duration(milliseconds: 16));
    await tester.tap(authorField);
    await tester.pump(const Duration(milliseconds: 16));
    await tester.tap(remarkField);
    await tester.pump(const Duration(milliseconds: 16));
  }
}

Future<void> rapidInputTest(
  WidgetTester tester,
  PerformanceProfiler profiler,
  TestWorkImportViewModel viewModel,
) async {
  final titleField = find.widgetWithText(TextFormField, '标题 *');
  final authorField = find.widgetWithText(TextFormField, '作者');
  final remarkField = find.widgetWithText(TextFormField, '备注');

  for (int i = 0; i < 20; i++) {
    await tester.enterText(titleField, '测试标题 $i');
    expect(viewModel.title, equals('测试标题 $i'));

    await tester.enterText(authorField, '测试作者 $i');
    expect(viewModel.author, equals('测试作者 $i'));

    await tester.enterText(remarkField, '测试备注 $i');
    expect(viewModel.remark, equals('测试备注 $i'));

    await tester.pump();
  }
}

Future<void> rapidSubmissionTest(
  WidgetTester tester,
  PerformanceProfiler profiler,
  TestWorkImportViewModel viewModel,
) async {
  final titleField = find.widgetWithText(TextFormField, '标题 *');
  final submitButton = find.text('导入');

  await tester.enterText(titleField, '测试标题');
  await tester.pump();

  for (int i = 0; i < 20; i++) {
    await tester.tap(submitButton);
    await tester.pump();
    await Future.delayed(const Duration(milliseconds: 50));
    await tester.pump();
  }
}

Future<void> validationTest(
  WidgetTester tester,
  PerformanceProfiler profiler,
  TestWorkImportViewModel viewModel,
) async {
  final titleField = find.widgetWithText(TextFormField, '标题 *');
  final submitButton = find.text('导入');

  for (int i = 0; i < 10; i++) {
    await tester.enterText(titleField, '');
    await tester.pump();
    await tester.tap(submitButton);
    await tester.pump();
    expect(viewModel.canSubmit, isFalse);

    await tester.enterText(titleField, '测试标题');
    await tester.pump();
    expect(viewModel.canSubmit, isTrue);
  }
}



=======================================
./integration_test/presentation/dialogs/work_import/work_import_performance_utils.dart
=======================================
import 'dart:math' as math;

/// Frame pattern analysis
class FramePattern {
  final List<bool> pattern;
  final int count;
  final double percentage;

  FramePattern({
    required this.pattern,
    required this.count,
    required this.percentage,
  });

  String get patternString => pattern.map((j) => j ? 'J' : 'N').join();
}

/// Performance visualization helper
class PerformanceVisualizer {
  static const _barChar = '█';
  static const _defaultBarWidth = 50;

  /// Analyzes frame patterns
  static List<FramePattern> analyzePatterns(
    List<bool> frames, {
    int patternLength = 3,
  }) {
    if (frames.length < patternLength) return [];

    final patterns = <String, int>{};
    for (var i = 0; i <= frames.length - patternLength; i++) {
      final pattern = frames.sublist(i, i + patternLength);
      final key = pattern.map((j) => j ? 'J' : 'N').join();
      patterns[key] = (patterns[key] ?? 0) + 1;
    }

    final totalPatterns = patterns.values.reduce((a, b) => a + b);
    return patterns.entries
        .map((e) => FramePattern(
              pattern: e.key.split('').map((c) => c == 'J').toList(),
              count: e.value,
              percentage: e.value * 100 / totalPatterns,
            ))
        .toList()
      ..sort((a, b) => b.count.compareTo(a.count));
  }

  /// Creates a horizontal bar chart
  static String createBarChart({
    required Map<String, double> data,
    int width = _defaultBarWidth,
    bool showPercentages = true,
    String? title,
  }) {
    if (data.isEmpty) return '';

    final buffer = StringBuffer();
    if (title != null) {
      buffer.writeln(title);
      buffer.writeln('=' * title.length);
    }

    final maxValue = data.values.reduce(math.max);
    final maxLabelLength = data.keys.map((k) => k.length).reduce(math.max);

    for (final entry in data.entries) {
      final label = entry.key.padRight(maxLabelLength);
      final value = entry.value;
      final barLength = (value * width / maxValue).round();
      final bar = _barChar * barLength;

      if (showPercentages) {
        final percentage = (value * 100 / maxValue).toStringAsFixed(1);
        buffer.writeln('$label $bar ($percentage%)');
      } else {
        buffer.writeln('$label $bar');
      }
    }

    return buffer.toString();
  }

  /// Creates a heat map visualization
  static String createHeatMap({
    required List<double> values,
    int width = 10,
    List<String> intensityChars = const ['░', '▒', '▓', '█'],
  }) {
    if (values.isEmpty) return '';

    final buffer = StringBuffer();
    final normalizedValues = _normalizeValues(values);
    final height = (values.length / width).ceil();

    for (var y = 0; y < height; y++) {
      for (var x = 0; x < width; x++) {
        final index = y * width + x;
        if (index >= values.length) break;

        final intensity = normalizedValues[index];
        final charIndex = (intensity * (intensityChars.length - 1)).round();
        buffer.write(intensityChars[charIndex]);
      }
      buffer.writeln();
    }

    return buffer.toString();
  }

  /// Creates a time series visualization
  static String createTimeline({
    required List<bool> events,
    String normalChar = '·',
    String anomalyChar = '!',
    int width = 80,
  }) {
    if (events.isEmpty) return '';

    final buffer = StringBuffer();
    final step = math.max(1, events.length ~/ width);

    for (var i = 0; i < events.length; i += step) {
      final slice = events.skip(i).take(step);
      final hasAnomaly = slice.any((e) => e);
      buffer.write(hasAnomaly ? anomalyChar : normalChar);
    }

    buffer.writeln('\nLegend: $normalChar Normal  $anomalyChar Anomaly');
    return buffer.toString();
  }

  /// Detect performance outliers using IQR method
  static List<int> detectOutliers(List<num> values) {
    if (values.length < 4) return [];

    final sorted = List<num>.from(values)..sort();
    final q1 = _quartile(sorted, 0.25);
    final q3 = _quartile(sorted, 0.75);
    final iqr = q3 - q1;
    final lowerBound = q1 - 1.5 * iqr;
    final upperBound = q3 + 1.5 * iqr;

    return List.generate(values.length, (i) => i)
        .where((i) => values[i] < lowerBound || values[i] > upperBound)
        .toList();
  }

  static List<double> _normalizeValues(List<double> values) {
    if (values.isEmpty) return [];
    final min = values.reduce(math.min);
    final max = values.reduce(math.max);
    final range = max - min;
    return range > 0
        ? values.map((v) => (v - min) / range).toList()
        : List.filled(values.length, 0.5);
  }

  static double _quartile(List<num> values, double percentile) {
    final index = (values.length * percentile).round();
    return values[index].toDouble();
  }
}



=======================================
./lib/application/commands/migration_commands.dart
=======================================
import 'dart:convert';

import '../../domain/repositories/settings_repository.dart';
import '../../infrastructure/logging/logger.dart';

/// 迁移命令
class MigrationCommands {
  final SettingsRepository _settingsRepository;

  MigrationCommands(this._settingsRepository);

  /// 检查V4迁移状态
  Future<void> checkV4MigrationStatus() async {
    try {
      // 获取迁移统计
      final stats = await _settingsRepository.getValue('migration_v4_stats');
      if (stats != null) {
        final data = json.decode(stats);
        AppLogger.info('迁移V4统计信息', tag: 'Migration', data: {
          '总图片数': data['total_images'],
          '更新数量': data['updated_images'],
          '有原始路径': data['with_original_path'],
          '无原始路径': data['without_original_path'],
          '执行时间': data['timestamp'],
        });
      }

      // 获取迁移完成状态
      final completion =
          await _settingsRepository.getValue('migration_v4_completion');
      if (completion != null) {
        final data = json.decode(completion);
        AppLogger.info('迁移V4完成状态', tag: 'Migration', data: {
          '迁移图片数': data['migrated_images'],
          '完成时间': data['timestamp'],
        });
      }

      if (stats == null && completion == null) {
        AppLogger.warning('未找到V4迁移记录', tag: 'Migration');
      }
    } catch (e, stack) {
      AppLogger.error('检查迁移状态失败',
          tag: 'Migration', error: e, stackTrace: stack);
    }
  }
}



=======================================
./lib/application/config/app_config.dart
=======================================
class AppConfig {
  // 应用名称
  static String get appName => '书法集字';

  // 缓存目录名
  static String get cacheFolder => 'cache';

  // 数据存储路径
  static String get dataPath => 'data';

  // 数据库文件名
  static String get dbFilename => 'works.db';

  // 最大文件大小限制 (20MB)
  static int get maxImageSize => 20 * 1024 * 1024;

  static int get optimizedImageHeight => 1080;

  static int get optimizedImageQuality => 85;

  // 图片优化设置
  static int get optimizedImageWidth => 1920;

  // 存储目录名
  static String get storageFolder => 'storage';
  // 临时文件目录名
  static String get tempFolder => 'temp';
  static int get thumbnailQuality => 85;

  // 缩略图目录名
  static String get thumbnailsFolder => 'thumbnails';
  // 缩略图设置
  static int get thumbnailSize => 256;

  // 作品存储目录名
  static String get worksFolder => 'works';
}



=======================================
./lib/application/providers/initialization_providers.dart
=======================================
import 'package:demo/infrastructure/providers/database_providers.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../infrastructure/providers/storage_providers.dart';

/// 应用初始化Provider
final appInitializationProvider = FutureProvider<void>((ref) async {
  // 等待存储服务初始化完成
  await ref.watch(storageProvider.future);
  await ref.watch(databaseProvider.future);
});



=======================================
./lib/application/providers/providers.dart
=======================================
export 'initialization_providers.dart';
export 'repository_providers.dart';
export 'service_providers.dart';
export 'settings_providers.dart';



=======================================
./lib/application/providers/repository_providers.dart
=======================================
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../domain/repositories/character_repository.dart';
import '../../domain/repositories/practice_repository.dart';
import '../../domain/repositories/work_image_repository.dart';
import '../../domain/repositories/work_repository.dart';
import '../../infrastructure/persistence/database_interface.dart';
import '../../infrastructure/providers/database_providers.dart';
import '../repositories/character_repository_impl.dart';
import '../repositories/practice_repository_impl.dart';
import '../repositories/work_image_repository_impl.dart';
import '../repositories/work_repository_impl.dart';

/// Character Repository Provider
final characterRepositoryProvider = Provider<CharacterRepository>((ref) {
  return CharacterRepositoryImpl(_getInitializedDatabase(ref));
});

/// Practice Repository Provider
final practiceRepositoryProvider = Provider<PracticeRepository>((ref) {
  return PracticeRepositoryImpl(_getInitializedDatabase(ref));
});

/// WorkImageRepository Provider
final workImageRepositoryProvider = Provider<WorkImageRepository>((ref) {
  return WorkImageRepositoryImpl(_getInitializedDatabase(ref));
});

/// Work Repository Provider
final workRepositoryProvider = Provider<WorkRepository>((ref) {
  return WorkRepositoryImpl(_getInitializedDatabase(ref));
});

/// 提供初始化完成的数据库实例
DatabaseInterface _getInitializedDatabase(Ref ref) {
  return ref.watch(initializedDatabaseProvider);
}



=======================================
./lib/application/providers/service_providers.dart
=======================================
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:path/path.dart' as path;

import '../../infrastructure/image/image_processor.dart';
import '../../infrastructure/image/image_processor_impl.dart';
import '../../infrastructure/providers/shared_preferences_provider.dart';
import '../../infrastructure/providers/storage_providers.dart';
import '../services/restoration/state_restoration_service.dart';
import '../services/storage/work_storage_service.dart';
import '../services/work/work_image_service.dart';
import '../services/work/work_service.dart';
import 'repository_providers.dart';

/// Image Processor Provider
final imageProcessorProvider = Provider<ImageProcessor>((ref) {
  final storage = ref.watch(initializedStorageProvider);
  return ImageProcessorImpl(
      cachePath: path.join(storage.getAppDataPath(), 'cache'));
});

final stateRestorationServiceProvider = Provider<StateRestorationService>(
  (ref) => StateRestorationService(ref.watch(sharedPreferencesProvider)),
);

/// Work Image Service Provider
final workImageServiceProvider = Provider<WorkImageService>((ref) {
  return WorkImageService(
    storage: ref.watch(workStorageProvider),
    processor: ref.watch(imageProcessorProvider),
    repository: ref.watch(workImageRepositoryProvider),
  );
});

/// Work Service Provider
final workServiceProvider = Provider<WorkService>((ref) {
  return WorkService(
    repository: ref.watch(workRepositoryProvider),
    imageService: ref.watch(workImageServiceProvider),
    storage: ref.watch(initializedStorageProvider),
    workImageRepository: ref.watch(workImageRepositoryProvider),
  );
});

/// Work Storage Service Provider
final workStorageProvider = Provider<WorkStorageService>((ref) {
  final storage = ref.watch(initializedStorageProvider);
  return WorkStorageService(storage: storage);
});



=======================================
./lib/application/providers/settings_providers.dart
=======================================
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:shared_preferences/shared_preferences.dart';

import '../../domain/repositories/settings_repository.dart';
import '../../infrastructure/providers/database_providers.dart';
import '../commands/migration_commands.dart';
import '../repositories/settings_repository_impl.dart';

final languageProvider =
    StateNotifierProvider<LanguageNotifier, Locale?>((ref) {
  return LanguageNotifier();
});

/// Migration Commands Provider
final migrationCommandsProvider =
    Provider.autoDispose<AsyncValue<MigrationCommands>>((ref) {
  final settingsRepoAsync = ref.watch(settingsRepositoryProvider);
  return settingsRepoAsync.when(
    loading: () => const AsyncLoading(),
    error: (err, stack) => AsyncError(err, stack),
    data: (repo) => AsyncData(MigrationCommands(repo)),
  );
});

/// Settings Repository Provider
final settingsRepositoryProvider =
    Provider.autoDispose<AsyncValue<SettingsRepository>>((ref) {
  final dbAsync = ref.watch(databaseProvider);
  return dbAsync.when(
    loading: () => const AsyncLoading(),
    error: (err, stack) => AsyncError(err, stack),
    data: (db) => AsyncData(SettingsRepositoryImpl(db)),
  );
});

class LanguageNotifier extends StateNotifier<Locale?> {
  LanguageNotifier() : super(null) {
    _loadSavedLanguage();
  }

  Future<void> setLanguage(String? languageCode) async {
    final prefs = await SharedPreferences.getInstance();
    if (languageCode == null) {
      await prefs.remove('languageCode');
      state = null;
    } else {
      await prefs.setString('languageCode', languageCode);
      state = Locale(languageCode);
    }
  }

  Future<void> _loadSavedLanguage() async {
    final prefs = await SharedPreferences.getInstance();
    final languageCode = prefs.getString('languageCode');
    if (languageCode != null) {
      state = Locale(languageCode);
    }
  }
}



=======================================
./lib/application/repositories/character_repository_impl.dart
=======================================
import '../../domain/models/character/character_entity.dart';
import '../../domain/models/character/character_filter.dart';
import '../../domain/repositories/character_repository.dart';
import '../../infrastructure/persistence/database_interface.dart';

class CharacterRepositoryImpl implements CharacterRepository {
  final DatabaseInterface _database;

  CharacterRepositoryImpl(this._database);

  @override
  Future<void> close() => _database.close();

  @override
  Future<int> count(CharacterFilter? filter) async {
    return _database.count('characters', filter?.toJson() ?? {});
  }

  @override
  Future<CharacterEntity> create(CharacterEntity character) async {
    await _database.save('characters', character.id!, character.toJson());
    return character;
  }

  @override
  Future<void> delete(String id) => _database.delete('characters', id);

  @override
  Future<void> deleteMany(List<String> ids) =>
      _database.deleteMany('characters', ids);

  @override
  Future<CharacterEntity> duplicate(String id, {String? newId}) async {
    final character = await get(id);
    if (character == null) throw Exception('Character not found: $id');

    final now = DateTime.now();
    return create(character.copyWith(
      id: newId,
      createTime: now,
      updateTime: now,
    ));
  }

  @override
  Future<CharacterEntity?> get(String id) async {
    final json = await _database.get('characters', id);
    if (json == null) return null;
    return CharacterEntity.fromJson(json);
  }

  @override
  Future<List<CharacterEntity>> getAll() async {
    final items = await _database.getAll('characters');
    return items.map((e) => CharacterEntity.fromJson(e)).toList();
  }

  @override
  Future<Set<String>> getAllTags() async {
    final items = await _database.getAll('characters');
    return items
        .map((e) => CharacterEntity.fromJson(e))
        .expand((e) => e.tags)
        .toSet();
  }

  @override
  Future<List<CharacterEntity>> getByTags(Set<String> tags) async {
    const filter = CharacterFilter();
    return query(filter);
  }

  @override
  Future<List<CharacterEntity>> getByWorkId(String workId) async {
    const filter = CharacterFilter();
    return query(filter);
  }

  @override
  Future<List<CharacterEntity>> query(CharacterFilter filter) async {
    final items = await _database.query('characters', filter.toJson());
    return items.map((e) => CharacterEntity.fromJson(e)).toList();
  }

  @override
  Future<CharacterEntity> save(CharacterEntity character) async {
    await _database.save('characters', character.id!, character.toJson());
    return character;
  }

  @override
  Future<List<CharacterEntity>> saveMany(
      List<CharacterEntity> characters) async {
    final data =
        Map.fromEntries(characters.map((e) => MapEntry(e.id!, e.toJson())));
    await _database.saveMany('characters', data);
    return characters;
  }

  @override
  Future<List<CharacterEntity>> search(String query, {int? limit}) async {
    const filter = CharacterFilter();
    return this.query(filter);
  }

  @override
  Future<List<String>> suggestTags(String prefix, {int limit = 10}) async {
    final allTags = await getAllTags();
    return allTags.where((tag) => tag.startsWith(prefix)).take(limit).toList();
  }
}



=======================================
./lib/application/repositories/practice_repository_impl.dart
=======================================
import '../../domain/models/practice/practice_entity.dart';
import '../../domain/models/practice/practice_filter.dart';
import '../../domain/repositories/practice_repository.dart';
import '../../infrastructure/persistence/database_interface.dart';
import '../../utils/date_time_helper.dart';

/// 字帖练习仓库实现
class PracticeRepositoryImpl implements PracticeRepository {
  static const _table = 'practices';
  final DatabaseInterface _db;

  PracticeRepositoryImpl(this._db);

  @override
  Future<void> close() => _db.close();

  @override
  Future<int> count(PracticeFilter? filter) async {
    if (filter == null) {
      return _db.count(_table);
    }
    final query = _buildQuery(filter);
    return _db.count(_table, query);
  }

  @override
  Future<PracticeEntity> create(PracticeEntity practice) async {
    await _db.save(_table, practice.id, practice.toJson());
    return practice;
  }

  @override
  Future<void> delete(String id) => _db.delete(_table, id);

  @override
  Future<void> deleteMany(List<String> ids) => _db.deleteMany(_table, ids);

  @override
  Future<PracticeEntity> duplicate(String id, {String? newId}) async {
    final practice = await get(id);
    if (practice == null) {
      throw ArgumentError('练习不存在');
    }

    final now = DateTime.now();
    final copy = practice.copyWith(
      id: newId ?? DateTime.now().millisecondsSinceEpoch.toString(),
      title: '${practice.title} (副本)',
      createTime: now,
      updateTime: now,
    );

    await create(copy);
    return copy;
  }

  @override
  Future<PracticeEntity?> get(String id) async {
    final data = await _db.get(_table, id);
    if (data == null) return null;
    return PracticeEntity.fromJson(data);
  }

  @override
  Future<List<PracticeEntity>> getAll() async {
    final list = await _db.getAll(_table);
    return list.map((e) => PracticeEntity.fromJson(e)).toList();
  }

  @override
  Future<Set<String>> getAllTags() async {
    final list = await _db.getAll(_table);
    final tags = <String>{};
    for (final item in list) {
      final practice = PracticeEntity.fromJson(item);
      tags.addAll(practice.tags);
    }
    return tags;
  }

  @override
  Future<List<PracticeEntity>> getByTags(Set<String> tags) async {
    if (tags.isEmpty) return [];

    final filter = PracticeFilter(tags: tags.toList());
    return query(filter);
  }

  @override
  Future<List<PracticeEntity>> query(PracticeFilter filter) async {
    final query = _buildQuery(filter);
    final list = await _db.query(_table, query);
    return list.map((e) => PracticeEntity.fromJson(e)).toList();
  }

  @override
  Future<PracticeEntity> save(PracticeEntity practice) async {
    await _db.save(_table, practice.id, practice.toJson());
    return practice;
  }

  @override
  Future<List<PracticeEntity>> saveMany(List<PracticeEntity> practices) async {
    final map = {
      for (var p in practices) p.id: p.toJson(),
    };
    await _db.saveMany(_table, map);
    return practices;
  }

  @override
  Future<List<PracticeEntity>> search(String query, {int? limit}) async {
    final filter = PracticeFilter(
      keyword: query,
      limit: limit ?? 20,
    );
    return this.query(filter);
  }

  @override
  Future<List<String>> suggestTags(String prefix, {int limit = 10}) async {
    final allTags = await getAllTags();
    return allTags
        .where((tag) => tag.toLowerCase().startsWith(prefix.toLowerCase()))
        .take(limit)
        .toList();
  }

  /// 构建查询条件
  Map<String, dynamic> _buildQuery(PracticeFilter filter) {
    final query = <String, dynamic>{};

    if (filter.keyword?.isNotEmpty == true) {
      query['title'] = {'contains': filter.keyword};
    }

    if (filter.tags.isNotEmpty) {
      query['tags'] = {'contains': filter.tags};
    }

    if (filter.status?.isNotEmpty == true) {
      query['status'] = filter.status;
    }

    if (filter.startTime != null) {
      query['create_time'] = {
        'gte': DateTimeHelper.toStorageFormat(filter.startTime!),
      };
    }

    if (filter.endTime != null) {
      query['create_time'] ??= {};
      query['create_time']['lte'] =
          DateTimeHelper.toStorageFormat(filter.endTime!);
    }

    query['sort'] = {
      filter.sortField: filter.sortOrder,
    };

    query['limit'] = filter.limit;
    query['offset'] = filter.offset;

    return query;
  }
}



=======================================
./lib/application/repositories/repositories.dart
=======================================
export 'character_repository_impl.dart';
export 'practice_repository_impl.dart';
export 'settings_repository_impl.dart';
export 'work_image_repository_impl.dart';
export 'work_repository_impl.dart';



=======================================
./lib/application/repositories/settings_repository_impl.dart
=======================================
import '../../domain/repositories/settings_repository.dart';
import '../../infrastructure/persistence/database_interface.dart';
import '../../utils/date_time_helper.dart';

class SettingsRepositoryImpl implements SettingsRepository {
  final DatabaseInterface _db;
  final String _table = 'settings';

  SettingsRepositoryImpl(this._db);

  @override
  Future<void> deleteValue(String key) async {
    await _db.rawDelete(
      'DELETE FROM $_table WHERE key = ?',
      [key],
    );
  }

  @override
  Future<String?> getValue(String key) async {
    final results = await _db.rawQuery(
      'SELECT value FROM $_table WHERE key = ? LIMIT 1',
      [key],
    );
    return results.isEmpty ? null : results.first['value'] as String?;
  }

  @override
  Future<Map<String, String>> getValues(List<String> keys) async {
    final results = <String, String>{};
    final placeholders = List.filled(keys.length, '?').join(',');

    final rows = await _db.rawQuery(
      'SELECT key, value FROM $_table WHERE key IN ($placeholders)',
      keys,
    );

    for (final row in rows) {
      results[row['key'] as String] = row['value'] as String;
    }

    return results;
  }

  @override
  Future<void> setValue(String key, String value) async {
    final updateTime = DateTimeHelper.toStorageFormat(DateTime.now());
    await _db.rawUpdate(
      'INSERT OR REPLACE INTO $_table (key, value, updateTime) VALUES (?, ?, ?)',
      [key, value, updateTime],
    );
  }

  @override
  Future<void> setValues(Map<String, String> values) async {
    final now = DateTimeHelper.toStorageFormat(DateTime.now());
    final batch = values.entries.map((entry) => _db.rawUpdate(
          'INSERT OR REPLACE INTO $_table (key, value, updateTime) VALUES (?, ?, ?)',
          [entry.key, entry.value, now],
        ));
    await Future.wait(batch);
  }
}



=======================================
./lib/application/repositories/work_image_repository_impl.dart
=======================================
import 'package:demo/domain/models/work/work_image.dart';
import 'package:demo/domain/repositories/work_image_repository.dart';
import 'package:demo/infrastructure/logging/logger.dart';
import 'package:demo/infrastructure/persistence/database_interface.dart';
import 'package:demo/utils/date_time_helper.dart';

class WorkImageRepositoryImpl implements WorkImageRepository {
  final DatabaseInterface _db;

  WorkImageRepositoryImpl(this._db);

  @override
  Future<WorkImage> create(String workId, WorkImage image) async {
    // 检查是否已存在相同路径的图片
    final existing = await _db.query('work_images', {
      'where': [
        {'field': 'workId', 'op': '=', 'val': workId},
        {'field': 'original_path', 'op': '=', 'val': image.originalPath},
      ],
      'limit': 1,
    });

    AppLogger.info('检查图片是否已存在', tag: 'WorkImageRepository', data: {
      'workId': workId,
      'originalPath': image.originalPath,
      'exists': existing.isNotEmpty,
      'createTime': DateTimeHelper.toStorageFormat(image.createTime),
      'updateTime': DateTimeHelper.toStorageFormat(image.updateTime),
    });

    if (existing.isNotEmpty) {
      AppLogger.info('已存在图片的时间信息', tag: 'WorkImageRepository', data: {
        'existingCreateTime': existing.first['createTime'],
        'existingUpdateTime': existing.first['updateTime'],
      });
      return _mapToWorkImage(existing.first);
    }

    // 创建新记录
    final row = _mapToRow(image, workId);
    AppLogger.debug('准备保存新图片', tag: 'WorkImageRepository', data: {
      'row': row,
    });

    await _db.set('work_images', image.id, row);
    return image;
  }

  @override
  Future<List<WorkImage>> createMany(
      String workId, List<WorkImage> images) async {
    AppLogger.debug('批量创建图片', tag: 'WorkImageRepository', data: {
      'workId': workId,
      'count': images.length,
      'createTimes': images
          .map((img) => DateTimeHelper.toStorageFormat(img.createTime))
          .toList(),
    });

    // 检查并过滤重复图片
    final uniqueImages = <WorkImage>[];
    final existingPaths = <String>{};

    // 获取已存在的图片路径
    final existing = await _db.query('work_images', {
      'where': [
        {'field': 'workId', 'op': '=', 'val': workId},
      ],
    });
    existingPaths.addAll(existing.map((e) => e['original_path'] as String));

    AppLogger.debug('已存在图片路径', tag: 'WorkImageRepository', data: {
      'paths': existingPaths.toList(),
    });

    // 过滤出不重复的图片
    for (final image in images) {
      if (!existingPaths.contains(image.originalPath)) {
        uniqueImages.add(image);
      } else {
        AppLogger.debug('跳过重复图片', tag: 'WorkImageRepository', data: {
          'originalPath': image.originalPath,
          'createTime': DateTimeHelper.toStorageFormat(image.createTime),
        });
      }
    }

    AppLogger.debug('过滤重复图片完成', tag: 'WorkImageRepository', data: {
      'originalCount': images.length,
      'uniqueCount': uniqueImages.length,
    });

    if (uniqueImages.isNotEmpty) {
      final data = Map.fromEntries(
        uniqueImages.map((img) => MapEntry(img.id, _mapToRow(img, workId))),
      );
      await _db.setMany('work_images', data);
    }

    // 返回所有图片，包括已存在的
    return getAllByWorkId(workId);
  }

  @override
  Future<void> delete(String workId, String imageId) async {
    AppLogger.debug('删除图片', tag: 'WorkImageRepository', data: {
      'workId': workId,
      'imageId': imageId,
    });
    await _db.delete('work_images', imageId);
  }

  @override
  Future<void> deleteMany(String workId, List<String> imageIds) async {
    AppLogger.debug('批量删除图片', tag: 'WorkImageRepository', data: {
      'workId': workId,
      'count': imageIds.length,
    });
    await _db.deleteMany('work_images', imageIds);
  }

  @override
  Future<WorkImage?> get(String imageId) async {
    final result = await _db.get('work_images', imageId);
    if (result != null) {
      AppLogger.debug('获取单个图片', tag: 'WorkImageRepository', data: {
        'imageId': imageId,
        'createTime': result['createTime'],
        'updateTime': result['updateTime'],
      });
    }
    return result != null ? _mapToWorkImage(result) : null;
  }

  @override
  Future<List<WorkImage>> getAllByWorkId(String workId) async {
    final results = await _db.query('work_images', {
      'where': [
        {'field': 'workId', 'op': '=', 'val': workId}
      ],
      'orderBy': 'indexInWork ASC',
    });

    AppLogger.debug('获取作品所有图片', tag: 'WorkImageRepository', data: {
      'workId': workId,
      'count': results.length,
      'records': results
          .map((row) => {
                'id': row['id'],
                'originalPath': row['original_path'],
                'createTime': row['createTime'],
                'updateTime': row['updateTime'],
              })
          .toList(),
    });

    return results.map((row) => _mapToWorkImage(row)).toList();
  }

  @override
  Future<WorkImage?> getFirstByWorkId(String workId) async {
    final results = await _db.query('work_images', {
      'where': [
        {'field': 'workId', 'op': '=', 'val': workId}
      ],
      'orderBy': 'indexInWork ASC',
      'limit': 1,
    });
    return results.isNotEmpty ? _mapToWorkImage(results.first) : null;
  }

  @override
  Future<int> getNextIndex(String workId) async {
    final results = await _db.query('work_images', {
      'where': [
        {'field': 'workId', 'op': '=', 'val': workId}
      ],
      'orderBy': 'indexInWork DESC',
      'limit': 1,
    });
    return (results.isNotEmpty
        ? (_mapToWorkImage(results.first).index + 1)
        : 0);
  }

  @override
  Future<List<WorkImage>> saveMany(List<WorkImage> images) async {
    AppLogger.debug('批量保存图片', tag: 'WorkImageRepository', data: {
      'count': images.length,
      'times': images
          .map((img) => {
                'id': img.id,
                'createTime': DateTimeHelper.toStorageFormat(img.createTime),
                'updateTime': DateTimeHelper.toStorageFormat(img.updateTime),
              })
          .toList(),
    });

    if (images.isEmpty) return [];

    final data = Map.fromEntries(
      images.map((img) => MapEntry(img.id, _mapToRow(img, img.workId))),
    );
    await _db.setMany('work_images', data);
    return images;
  }

  @override
  Future<void> updateIndex(String workId, String imageId, int index) async {
    AppLogger.debug('更新图片索引', tag: 'WorkImageRepository', data: {
      'workId': workId,
      'imageId': imageId,
      'newIndex': index,
      'updateTime': DateTimeHelper.getCurrentUtc(),
    });

    await _db.save('work_images', imageId, {
      'indexInWork': index,
      'updateTime': DateTimeHelper.getCurrentUtc(),
    });
  }

  Map<String, dynamic> _mapToRow(WorkImage image, String workId) {
    final row = {
      'workId': workId,
      'path': image.path,
      'original_path': image.originalPath,
      'thumbnail_path': image.thumbnailPath,
      'format': image.format,
      'size': image.size,
      'width': image.width,
      'height': image.height,
      'indexInWork': image.index,
      'createTime': DateTimeHelper.toStorageFormat(image.createTime),
      'updateTime': DateTimeHelper.toStorageFormat(image.updateTime),
    };

    AppLogger.debug('转换为数据库行', tag: 'WorkImageRepository', data: {
      'imageId': image.id,
      'row': row,
    });

    return row;
  }

  WorkImage _mapToWorkImage(Map<String, dynamic> row) {
    AppLogger.debug('映射数据库记录', tag: 'WorkImageRepository', data: {
      'record': row,
    });

    return WorkImage(
      id: row['id'] as String,
      workId: row['workId'] as String,
      path: row['path'] as String,
      originalPath: row['original_path'] as String,
      thumbnailPath: row['thumbnail_path'] as String,
      format: row['format'] as String,
      size: row['size'] as int,
      width: row['width'] as int,
      height: row['height'] as int,
      index: row['indexInWork'] as int,
      createTime:
          DateTimeHelper.fromStorageFormat(_safeGetTime(row, 'createTime')) ??
              DateTime.now(),
      updateTime:
          DateTimeHelper.fromStorageFormat(_safeGetTime(row, 'updateTime')) ??
              DateTime.now(),
    );
  }

  String? _safeGetTime(Map<String, dynamic> row, String key) {
    final value = row[key];
    AppLogger.debug('读取时间字段', tag: 'WorkImageRepository', data: {
      'field': key,
      'value': value,
      'type': value?.runtimeType.toString(),
    });
    return value as String?;
  }
}



=======================================
./lib/application/repositories/work_repository_impl.dart
=======================================
import '../../domain/models/work/work_entity.dart';
import '../../domain/models/work/work_filter.dart';
import '../../domain/repositories/work_repository.dart';
import '../../infrastructure/logging/logger.dart';
import '../../infrastructure/persistence/database_interface.dart';
import '../../infrastructure/persistence/models/database_query.dart';
import '../../utils/date_time_helper.dart';

/// 作品仓库实现
class WorkRepositoryImpl implements WorkRepository {
  final DatabaseInterface _db;
  final String _table = 'works';

  WorkRepositoryImpl(this._db);

  @override
  Future<void> close() async {
    await _db.close();
  }

  @override
  Future<int> count(WorkFilter? filter) async {
    final query = _buildQuery(filter);
    return _db.count(_table, query);
  }

  @override
  Future<WorkEntity> create(WorkEntity work) async {
    await _db.set(_table, work.id, _toTableJson(work));
    return work;
  }

  @override
  Future<void> delete(String id) async {
    await _db.delete(_table, id);
  }

  @override
  Future<void> deleteMany(List<String> ids) async {
    await _db.deleteMany(_table, ids);
  }

  @override
  Future<WorkEntity> duplicate(String id, {String? newId}) async {
    final work = await get(id);
    if (work == null) {
      throw Exception('Work not found: $id');
    }

    final now = DateTime.now();
    final duplicated = work.copyWith(
      id: newId ?? '${work.id}_copy',
      createTime: now,
      updateTime: now,
    );

    await _db.set(_table, duplicated.id, _toTableJson(duplicated));
    return duplicated;
  }

  @override
  Future<WorkEntity?> get(String id) async {
    final data = await _db.get(_table, id);
    if (data == null) return null;
    return WorkEntity.fromJson(_convertDates(data));
  }

  @override
  Future<List<WorkEntity>> getAll() async {
    final data = await _db.getAll(_table);
    return data.map((e) => WorkEntity.fromJson(_convertDates(e))).toList();
  }

  @override
  Future<Set<String>> getAllTags() async {
    final works = await getAll();
    return works.expand((work) => work.tags).toSet();
  }

  @override
  Future<List<WorkEntity>> getByTags(Set<String> tags) async {
    if (tags.isEmpty) return [];

    final query = DatabaseQuery(conditions: [
      DatabaseQueryCondition(
        field: 'tags',
        operator: 'contains',
        value: tags.toList(),
      ),
    ]);

    final data = await _db.query(_table, query.toJson());
    return data.map((e) => WorkEntity.fromJson(_convertDates(e))).toList();
  }

  @override
  Future<List<WorkEntity>> query(WorkFilter filter) async {
    final query = _buildQuery(filter);
    final data = await _db.query(_table, query);
    return data.map((e) => WorkEntity.fromJson(_convertDates(e))).toList();
  }

  @override
  Future<WorkEntity> save(WorkEntity work) async {
    final now = DateTime.now();
    final updated = work.copyWith(updateTime: now);
    await _db.save(_table, work.id, _toTableJson(updated));
    return updated;
  }

  @override
  Future<List<WorkEntity>> saveMany(List<WorkEntity> works) async {
    final now = DateTime.now();
    final updates = {
      for (final work in works)
        work.id: _toTableJson(work.copyWith(updateTime: now))
    };

    await _db.saveMany(_table, updates);
    return works.map((w) => w.copyWith(updateTime: now)).toList();
  }

  @override
  Future<List<WorkEntity>> search(String query, {int? limit}) async {
    // 创建一个只包含搜索条件的过滤器
    final filter = WorkFilter(keyword: query);
    final results = await this.query(filter);

    if (limit != null && results.length > limit) {
      return results.take(limit).toList();
    }
    return results;
  }

  @override
  Future<List<String>> suggestTags(String prefix, {int limit = 10}) async {
    final allTags = await getAllTags();
    return allTags
        .where((tag) => tag.toLowerCase().startsWith(prefix.toLowerCase()))
        .take(limit)
        .toList();
  }

  /// 构建数据库查询
  Map<String, dynamic> _buildQuery(WorkFilter? filter) {
    AppLogger.debug(
      '开始构建查询条件',
      tag: 'WorkRepositoryImpl',
      data: {
        'hasFilter': filter != null,
        'style': filter?.style?.name,
        'tool': filter?.tool?.name,
        'tagsCount': filter?.tags.length ?? 0,
        'hasKeyword': filter?.keyword?.isNotEmpty ?? false,
      },
    );

    if (filter == null) return {};

    final conditions = <DatabaseQueryCondition>[];
    final groups = <DatabaseQueryGroup>[];

    // 基本过滤
    if (filter.style != null) {
      conditions.add(DatabaseQueryCondition(
        field: 'style',
        operator: '=',
        value: filter.style?.name,
      ));
    }

    if (filter.tool != null) {
      conditions.add(DatabaseQueryCondition(
        field: 'tool',
        operator: '=',
        value: filter.tool?.name,
      ));
    }

    if (filter.tags.isNotEmpty) {
      conditions.add(DatabaseQueryCondition(
        field: 'tags',
        operator: 'contains',
        value: filter.tags,
      ));
    }

    // 搜索关键字
    if (filter.keyword?.isNotEmpty == true) {
      groups.add(
        DatabaseQueryGroup.or([
          DatabaseQueryCondition(
            field: 'title',
            operator: 'like',
            value: '%${filter.keyword}%',
          ),
          DatabaseQueryCondition(
            field: 'author',
            operator: 'like',
            value: '%${filter.keyword}%',
          ),
          DatabaseQueryCondition(
            field: 'remark',
            operator: 'like',
            value: '%${filter.keyword}%',
          ),
        ]),
      );
    }

    // 日期范围过滤
    if (filter.dateRange != null) {
      final start = filter.dateRange?.start;
      final end = filter.dateRange?.end;
      if (start != null && end != null) {
        conditions.add(DatabaseQueryCondition(
          field: 'creationDate',
          operator: '>=',
          value: DateTimeHelper.toStorageFormat(start),
        ));

        conditions.add(DatabaseQueryCondition(
          field: 'creationDate',
          operator: '<=',
          value: DateTimeHelper.toStorageFormat(end),
        ));
      }
    }

    // 创建时间过滤
    if (filter.createTimeRange != null) {
      final start = filter.createTimeRange?.start;
      final end = filter.createTimeRange?.end;
      if (start != null && end != null) {
        conditions.add(DatabaseQueryCondition(
          field: 'createTime',
          operator: '>=',
          value: DateTimeHelper.toStorageFormat(start),
        ));

        conditions.add(DatabaseQueryCondition(
          field: 'createTime',
          operator: '<=',
          value: DateTimeHelper.toStorageFormat(end),
        ));
      }
    }

    // 更新时间过滤
    if (filter.updateTimeRange != null) {
      final start = filter.updateTimeRange?.start;
      final end = filter.updateTimeRange?.end;
      if (start != null && end != null) {
        conditions.add(DatabaseQueryCondition(
          field: 'updateTime',
          operator: '>=',
          value: DateTimeHelper.toStorageFormat(start),
        ));

        conditions.add(DatabaseQueryCondition(
          field: 'updateTime',
          operator: '<=',
          value: DateTimeHelper.toStorageFormat(end),
        ));
      }
    }

    final query = DatabaseQuery(
      conditions: conditions,
      groups: groups.isEmpty ? null : groups,
      orderBy: filter.sortOption.field != null
          ? '${filter.sortOption.field.name} ${filter.sortOption.descending ? 'DESC' : 'ASC'}'
          : null,
    );
    AppLogger.debug(
      '查询条件构建完成',
      tag: 'WorkRepositoryImpl',
      data: {
        'conditions': conditions.length,
        'groups': groups.length,
        'hasOrderBy': filter.sortOption.field != null,
        'orderBy': filter.sortOption.field.name,
        'isDescending': filter.sortOption.descending,
      },
    );

    return query.toJson();
  }

  /// 将数据库中的时间戳转换为ISO8601字符串
  Map<String, dynamic> _convertDates(Map<String, dynamic> data) {
    return {
      ...data,
      'tags': data['tags']
              ?.toString()
              .split(',')
              .where((tag) => tag.isNotEmpty)
              .toList() ??
          const [],
      'creationDate': data['creationDate'],
      'createTime': data['createTime'],
      'updateTime': data['updateTime'],
      'lastImageUpdateTime': data['lastImageUpdateTime'],
    };
  }

  /// 将时间字段转换为ISO8601字符串
  String? _convertToIso8601String(dynamic value) {
    if (value == null) {
      return null;
    }

    // 如果已经是字符串格式，检查是否为ISO8601格式
    if (value is String && value.contains('T')) {
      return value;
    }

    // 否则作为时间戳处理
    return DateTime.fromMillisecondsSinceEpoch(value as int).toIso8601String();
  }

  /// 将WorkEntity转换为数据库表字段
  Map<String, dynamic> _toTableJson(WorkEntity work) {
    return {
      'id': work.id,
      'title': work.title,
      'author': work.author,
      'style': work.style.value,
      'tool': work.tool.value,
      'remark': work.remark,
      'creationDate': DateTimeHelper.toStorageFormat(work.creationDate),
      'createTime': DateTimeHelper.toStorageFormat(work.createTime),
      'updateTime': DateTimeHelper.toStorageFormat(work.updateTime),
      'lastImageUpdateTime':
          DateTimeHelper.toStorageFormat(work.lastImageUpdateTime),
      'status': work.status.name,
      'firstImageId': work.firstImageId,
      'tags': work.tags.join(','),
      'imageCount': work.imageCount
    };
  }
}



=======================================
./lib/application/services/character/character_service.dart
=======================================
import '../../../domain/models/character/character_entity.dart';
import '../../../domain/models/character/character_filter.dart';
import '../../../domain/models/character/character_region.dart';
import '../../../domain/repositories/character_repository.dart';

/// 字形管理服务
class CharacterService {
  final CharacterRepository _repository;

  CharacterService({
    required CharacterRepository repository,
  }) : _repository = repository;

  /// 创建新字形
  Future<CharacterEntity> createCharacter({
    required String char,
    required String workId,
    CharacterRegion? region,
    List<String> tags = const [],
  }) async {
    final now = DateTime.now();
    final character = CharacterEntity(
      id: DateTime.now().millisecondsSinceEpoch.toString(),
      char: char,
      workId: workId,
      region: region,
      tags: tags,
      createTime: now,
      updateTime: now,
    );
    return await _repository.save(character);
  }

  /// 删除字形
  Future<void> deleteCharacter(String id) {
    return _repository.delete(id);
  }

  /// 批量删除字形
  Future<void> deleteCharacters(List<String> ids) {
    return _repository.deleteMany(ids);
  }

  /// 复制字形
  Future<CharacterEntity> duplicateCharacter(String id,
      {String? newWorkId}) async {
    final character = await _repository.get(id);
    if (character == null) {
      throw Exception('Character not found');
    }

    final now = DateTime.now();
    final copy = character.copyWith(
      id: DateTime.now().millisecondsSinceEpoch.toString(),
      workId: newWorkId,
      createTime: now,
      updateTime: now,
    );

    return _repository.save(copy);
  }

  /// 获取所有标签
  Future<Set<String>> getAllTags() {
    return _repository.getAllTags();
  }

  /// 获取单个字形
  Future<CharacterEntity?> getCharacter(String id) {
    return _repository.get(id);
  }

  /// 获取字形列表
  Future<List<CharacterEntity>> getCharacters({
    CharacterFilter? filter,
    bool forceRefresh = false,
  }) {
    if (filter != null) {
      return _repository.query(filter);
    }
    return _repository.getAll();
  }

  /// 按标签搜索字形
  Future<List<CharacterEntity>> getCharactersByTags(List<String> tags) {
    return _repository.getByTags(tags.toSet());
  }

  /// 获取作品相关字形
  Future<List<CharacterEntity>> getCharactersByWork(String workId) {
    return _repository.getByWorkId(workId);
  }

  /// 获取字形统计信息
  Future<Map<String, int>> getCharacterStats() async {
    final characters = await _repository.getAll();
    final tags = await _repository.getAllTags();

    return {
      'total': characters.length,
      'tags': tags.length,
      'works': characters
          .where((c) => c.workId != null)
          .map((c) => c.workId!)
          .toSet()
          .length,
      'unassigned': characters.where((c) => c.workId == null).length,
    };
  }

  /// 获取字形数量
  Future<int> getCount({CharacterFilter? filter}) {
    return _repository.count(filter);
  }

  /// 搜索字形
  Future<List<CharacterEntity>> searchCharacters(String query, {int? limit}) {
    return _repository.search(query, limit: limit);
  }

  /// 获取标签建议
  Future<List<String>> suggestTags(String prefix, {int limit = 10}) {
    return _repository.suggestTags(prefix, limit: limit);
  }

  /// 更新字形
  Future<CharacterEntity> updateCharacter(CharacterEntity character) {
    return _repository.save(character.copyWith(
      updateTime: DateTime.now(),
    ));
  }

  /// 批量更新字形
  Future<List<CharacterEntity>> updateCharacters(
      List<CharacterEntity> characters) {
    final now = DateTime.now();
    final updated = characters.map((c) => c.copyWith(updateTime: now)).toList();
    return _repository.saveMany(updated);
  }
}



=======================================
./lib/application/services/image/character_image_processor.dart
=======================================
import 'dart:io';
import 'dart:typed_data';

import 'package:flutter/rendering.dart';
import 'package:image/image.dart' as img;
import 'package:path/path.dart' as path;

class CharacterImageProcessor {
  /// 根据框选区域裁剪图片
  /// 返回三种格式: 原图裁剪, 二值化处理后的图片, 缩略图
  Future<Map<String, String>> processCharacterImage({
    required String sourcePath,
    required String outputDir,
    required String charId,
    required Rect region,
    double rotation = 0.0,
    bool inverted = false,
    List<Offset>? erasePoints,
  }) async {
    // 创建输出目录
    final outputPath = path.join(outputDir, charId);
    await Directory(outputPath).create(recursive: true);

    // 读取源图
    final sourceImage = img.decodeImage(await File(sourcePath).readAsBytes());
    if (sourceImage == null) throw Exception('Failed to load source image');

    // 1. 裁剪原图 - 保持原始比例和尺寸
    final croppedOriginal = _cropImage(
      sourceImage,
      region.left.round(),
      region.top.round(),
      region.width.round(),
      region.height.round(),
    );
    if (croppedOriginal == null) throw Exception('Failed to crop image');

    // 旋转图片（如果需要）
    final rotatedOriginal = rotation != 0.0
        ? img.copyRotate(croppedOriginal,
            angle: (rotation * 180 / 3.141592653589793).round())
        : croppedOriginal;

    // 保存原图裁剪
    final originalPath = path.join(outputPath, 'original.png');
    await File(originalPath).writeAsBytes(img.encodePng(rotatedOriginal));

    // 2. 二值化处理
    final binaryImage = await _processBinaryImage(
      rotatedOriginal,
      inverted: inverted,
      targetSize: const Size(300, 300),
      erasePoints: erasePoints,
    );

    // 保存二值化图片
    final binaryPath = path.join(outputPath, 'char.png');
    await File(binaryPath).writeAsBytes(img.encodePng(binaryImage));

    // 3. 生成缩略图
    final thumbnail = img.copyResize(binaryImage, width: 50, height: 50);
    final thumbnailPath = path.join(outputPath, 'thumbnail.jpg');
    await File(thumbnailPath)
        .writeAsBytes(img.encodeJpg(thumbnail, quality: 85));

    return {
      'original': originalPath,
      'binary': binaryPath,
      'thumbnail': thumbnailPath,
    };
  }

  /// 自适应阈值二值化
  Uint8List _adaptiveThreshold(img.Image source,
      {int windowSize = 11, int t = 15}) {
    final width = source.width;
    final height = source.height;
    final result = Uint8List(width * height);
    final integralImg = List.filled(width * height, 0);

    // 计算积分图
    for (int y = 0; y < height; y++) {
      for (int x = 0; x < width; x++) {
        final pos = y * width + x;
        final pixel = source.getPixel(x, y).r.toInt();
        integralImg[pos] = pixel +
            (x > 0 ? integralImg[pos - 1] : 0) +
            (y > 0 ? integralImg[pos - width] : 0) -
            (x > 0 && y > 0 ? integralImg[pos - width - 1] : 0);
      }
    }

    // 应用自适应阈值
    for (int y = 0; y < height; y++) {
      for (int x = 0; x < width; x++) {
        final pos = y * width + x;
        final pixel = source.getPixel(x, y).r.toInt();

        // 计算局部窗口的边界
        final x1 = x - windowSize ~/ 2;
        final y1 = y - windowSize ~/ 2;
        final x2 = x + windowSize ~/ 2;
        final y2 = y + windowSize ~/ 2;

        // 确保窗口在图像范围内并转换为整数
        final rx1 = x1 < 0
            ? 0
            : x1 >= width
                ? width - 1
                : x1;
        final ry1 = y1 < 0
            ? 0
            : y1 >= height
                ? height - 1
                : y1;
        final rx2 = x2 < 0
            ? 0
            : x2 >= width
                ? width - 1
                : x2;
        final ry2 = y2 < 0
            ? 0
            : y2 >= height
                ? height - 1
                : y2;

        // 计算窗口内的平均值
        final areaWidth = (rx2 - rx1);
        final areaHeight = (ry2 - ry1);
        final area = areaWidth * areaHeight;

        if (area > 0) {
          final sum = integralImg[ry2 * width + rx2] -
              (rx1 > 0 ? integralImg[ry2 * width + rx1 - 1] : 0) -
              (ry1 > 0 ? integralImg[ry1 * width + rx2] : 0) +
              (rx1 > 0 && ry1 > 0 ? integralImg[ry1 * width + rx1 - 1] : 0);
          final average = sum ~/ area;
          result[pos] = pixel < (average - t) ? 0 : 255;
        } else {
          result[pos] = pixel < t ? 0 : 255;
        }
      }
    }

    return result;
  }

  /// 裁剪图片
  img.Image? _cropImage(img.Image source, int x, int y, int width, int height) {
    return img.copyCrop(
      source,
      x: x,
      y: y,
      width: width,
      height: height,
    );
  }

  /// 画线（用于擦除）
  void _drawLine(
    img.Image image,
    int x1,
    int y1,
    int x2,
    int y2,
    int color, {
    int thickness = 1,
  }) {
    final dx = (x2 - x1).abs();
    final dy = (y2 - y1).abs();
    final sx = x1 < x2 ? 1 : -1;
    final sy = y1 < y2 ? 1 : -1;
    var err = dx - dy;

    while (true) {
      // 绘制粗线
      for (int i = -thickness ~/ 2; i <= thickness ~/ 2; i++) {
        for (int j = -thickness ~/ 2; j <= thickness ~/ 2; j++) {
          final px = x1 + i;
          final py = y1 + j;
          if (px >= 0 && px < image.width && py >= 0 && py < image.height) {
            image.setPixel(px, py, img.ColorInt8.rgb(color, color, color));
          }
        }
      }

      if (x1 == x2 && y1 == y2) break;
      final e2 = 2 * err;
      if (e2 > -dy) {
        err -= dy;
        x1 += sx;
      }
      if (e2 < dx) {
        err += dx;
        y1 += sy;
      }
    }
  }

  /// 二值化处理并调整尺寸
  Future<img.Image> _processBinaryImage(
    img.Image source, {
    bool inverted = false,
    Size targetSize = const Size(300, 300),
    List<Offset>? erasePoints,
  }) async {
    // 转换为灰度图
    final grayscale = img.grayscale(source);

    // 应用擦除点
    if (erasePoints != null && erasePoints.isNotEmpty) {
      for (int i = 0; i < erasePoints.length - 1; i++) {
        _drawLine(
          grayscale,
          erasePoints[i].dx.round(),
          erasePoints[i].dy.round(),
          erasePoints[i + 1].dx.round(),
          erasePoints[i + 1].dy.round(),
          255, // 白色
          thickness: 10,
        );
      }
    }

    // 应用自适应阈值进行二值化
    final binary = _adaptiveThreshold(grayscale);

    // 如果需要反转颜色
    if (inverted) {
      for (int i = 0; i < binary.length; i++) {
        binary[i] = binary[i] == 0 ? 255 : 0;
      }
    }

    // 调整大小，保持宽高比
    final aspectRatio = source.width / source.height;
    int newWidth, newHeight;
    if (aspectRatio > 1) {
      newWidth = targetSize.width.round();
      newHeight = (targetSize.width / aspectRatio).round();
    } else {
      newHeight = targetSize.height.round();
      newWidth = (targetSize.height * aspectRatio).round();
    }

    // 创建目标尺寸的空白图像
    final resized = img.Image(
      width: targetSize.width.round(),
      height: targetSize.height.round(),
      format: img.Format.uint8,
    );

    // 将二值化图像调整到新尺寸并居中放置
    final scaled = img.copyResize(
      img.Image.fromBytes(
        width: source.width,
        height: source.height,
        bytes: binary.buffer,
        format: img.Format.uint8,
      ),
      width: newWidth,
      height: newHeight,
    );

    // 计算居中位置
    final x = ((targetSize.width - newWidth) / 2).round();
    final y = ((targetSize.height - newHeight) / 2).round();

    // 将调整后的图像复制到目标图像的中心
    img.compositeImage(resized, scaled, dstX: x, dstY: y);

    return resized;
  }
}



=======================================
./lib/application/services/practice/practice_service.dart
=======================================
import '../../../domain/models/practice/practice_entity.dart';
import '../../../domain/models/practice/practice_filter.dart';
import '../../../domain/repositories/practice_repository.dart';

/// 字帖练习服务
class PracticeService {
  final PracticeRepository _repository;

  const PracticeService({
    required PracticeRepository repository,
  }) : _repository = repository;

  /// 创建字帖练习
  Future<PracticeEntity> createPractice({
    required String title,
    List<String> tags = const [],
    String status = 'active',
  }) async {
    final practice = PracticeEntity.create(
      title: title,
      tags: tags,
      status: status,
    );
    return _repository.save(practice);
  }

  /// 删除字帖练习
  Future<void> deletePractice(String id) {
    return _repository.delete(id);
  }

  /// 批量删除字帖练习
  Future<void> deletePractices(List<String> ids) {
    return _repository.deleteMany(ids);
  }

  /// 复制字帖练习
  Future<PracticeEntity> duplicatePractice(String id) {
    return _repository.duplicate(id);
  }

  /// 获取所有字帖练习
  Future<List<PracticeEntity>> getAllPractices() {
    return _repository.getAll();
  }

  /// 获取所有标签
  Future<Set<String>> getAllTags() {
    return _repository.getAllTags();
  }

  /// 获取字帖练习
  Future<PracticeEntity?> getPractice(String id) {
    return _repository.get(id);
  }

  /// 查询字帖练习
  Future<List<PracticeEntity>> queryPractices(PracticeFilter filter) {
    return _repository.query(filter);
  }

  /// 搜索字帖练习
  Future<List<PracticeEntity>> searchPractices(String query, {int? limit}) {
    return _repository.search(query, limit: limit);
  }

  /// 获取标签建议
  Future<List<String>> suggestTags(String prefix, {int limit = 10}) {
    return _repository.suggestTags(prefix, limit: limit);
  }

  /// 更新字帖练习
  Future<PracticeEntity> updatePractice(PracticeEntity practice) {
    return _repository.save(practice);
  }

  /// 批量更新字帖练习
  Future<List<PracticeEntity>> updatePractices(List<PracticeEntity> practices) {
    return _repository.saveMany(practices);
  }
}



=======================================
./lib/application/services/restoration/state_restoration_service.dart
=======================================
import 'dart:convert';
import 'dart:io';

import 'package:path_provider/path_provider.dart';
import 'package:shared_preferences/shared_preferences.dart';

import '../../../domain/models/work/work_entity.dart';
import '../../../infrastructure/logging/logger.dart';
import '../../../presentation/providers/work_detail_provider.dart';
import '../../../presentation/viewmodels/states/work_browse_state.dart';

/// 负责保存和恢复应用状态
class StateRestorationService {
  // 键前缀常量
  static const _workEditStatePrefix = 'work_edit_state_';
  static const _workEditTimestampPrefix = 'work_edit_timestamp_';

  // 浏览页相关键
  static const String _workBrowseStateKey = 'work_browse_state';
  static const String _workBrowseTimestampKey = 'work_browse_timestamp';

  // 状态有效期（毫秒），默认24小时
  static const _stateValidityPeriod = 24 * 60 * 60 * 1000;

  final SharedPreferences _prefs;

  StateRestorationService(this._prefs) {
    _checkFirstRun();
  }

  /// 检查编辑会话状态
  Future<String> checkEditSessions() async {
    try {
      final keys = _prefs.getKeys();
      final editStateKeys =
          keys.where((key) => key.startsWith('work_edit_state_'));
      return '${editStateKeys.length}个活动编辑会话';
    } catch (e) {
      AppLogger.error('检查编辑会话失败', tag: 'StateRestorationService', error: e);
      return '未知';
    }
  }

  /// 清除产品浏览页状态
  Future<void> clearWorkBrowseState() async {
    try {
      await _prefs.remove(_workBrowseStateKey);
      await _prefs.remove(_workBrowseTimestampKey);

      AppLogger.debug('已清除浏览页状态', tag: 'StateRestorationService');
    } catch (e, stack) {
      AppLogger.error(
        '清除浏览页状态失败',
        tag: 'StateRestorationService',
        error: e,
        stackTrace: stack,
      );
    }
  }

  /// 清除特定作品的编辑状态
  Future<void> clearWorkEditState(String workId) async {
    try {
      final stateKey = '$_workEditStatePrefix$workId';
      final timestampKey = '$_workEditTimestampPrefix$workId';

      await _prefs.remove(stateKey);
      await _prefs.remove(timestampKey);

      AppLogger.debug('已清除编辑状态',
          tag: 'StateRestorationService', data: {'workId': workId});
    } catch (e, stack) {
      AppLogger.error(
        '清除编辑状态失败',
        tag: 'StateRestorationService',
        error: e,
        stackTrace: stack,
        data: {'workId': workId},
      );
    }
  }

  /// 获取SharedPreferences中的条目数
  Future<String> getPreferencesEntryCount() async {
    try {
      final keys = _prefs.getKeys();
      return keys.length.toString();
    } catch (e) {
      AppLogger.error(
        '获取Preferences条目数失败',
        tag: 'StateRestorationService',
        error: e,
      );
    }
    return '未知';
  }

  /// 获取SharedPreferences文件的大小
  Future<String> getPreferencesFileSize() async {
    try {
      final path = await getPreferencesPath();
      final file = File(path);
      if (await file.exists()) {
        final size = await file.length();
        return '${(size / 1024).toStringAsFixed(2)} KB';
      }
    } catch (e) {
      AppLogger.error(
        '获取Preferences文件大小失败',
        tag: 'StateRestorationService',
        error: e,
      );
    }
    return '未知';
  }

  /// 获取SharedPreferences文件的路径
  Future<String> getPreferencesPath() async {
    final appDataDir = Platform.isWindows
        ? Platform.environment['LOCALAPPDATA']
        : Platform.environment['HOME'];

    if (appDataDir == null) {
      return '未知';
    }

    return '$appDataDir/SharedPreferences.json';
  }

  /// 获取状态存储位置
  Future<String> getStorageLocation() async {
    try {
      final appDir = await getApplicationDocumentsDirectory();
      return appDir.path;
    } catch (e) {
      AppLogger.error('获取存储位置失败', tag: 'StateRestorationService', error: e);
      return '未知';
    }
  }

  /// 检查是否有未完成的编辑会话
  Future<bool> hasUnfinishedEditSession(String workId) async {
    try {
      final stateKey = '$_workEditStatePrefix$workId';
      final timestampKey = '$_workEditTimestampPrefix$workId';

      // 检查状态是否存在
      final hasState = _prefs.containsKey(stateKey);
      if (!hasState) return false;

      // 检查状态是否过期
      final timestamp = _prefs.getInt(timestampKey) ?? 0;
      final currentTime = DateTime.now().millisecondsSinceEpoch;

      if (currentTime - timestamp > _stateValidityPeriod) {
        // 状态已过期，自动清理
        await clearWorkEditState(workId);
        return false;
      }

      return true;
    } catch (e) {
      AppLogger.error(
        '检查未完成编辑会话失败',
        tag: 'StateRestorationService',
        error: e,
        data: {'workId': workId},
      );
      return false;
    }
  }

  /// 检查是否有保存的浏览页状态
  Future<bool> hasWorkBrowseState() async {
    try {
      // 检查状态是否存在
      final hasState = _prefs.containsKey(_workBrowseStateKey);
      if (!hasState) return false;

      // 检查状态是否过期
      final timestamp = _prefs.getInt(_workBrowseTimestampKey) ?? 0;
      final currentTime = DateTime.now().millisecondsSinceEpoch;

      if (currentTime - timestamp > _stateValidityPeriod) {
        // 状态已过期，自动清理
        await clearWorkBrowseState();
        return false;
      }

      return true;
    } catch (e) {
      AppLogger.error(
        '检查浏览页状态失败',
        tag: 'StateRestorationService',
        error: e,
      );
      return false;
    }
  }

  /// 恢复产品浏览页状态
  Future<WorkBrowseState?> restoreWorkBrowseState() async {
    try {
      // 获取保存的状态
      AppLogger.debug(
        '尝试恢复WorkBrowseState',
        tag: 'StateRestorationService',
      );

      final stateJson = _prefs.getString(_workBrowseStateKey);
      if (stateJson == null) {
        AppLogger.debug(
          '没有找到已保存的状态，返回null',
          tag: 'StateRestorationService',
        );
        return null;
      }

      // 解析状态
      AppLogger.debug(
        '开始解析状态JSON',
        tag: 'StateRestorationService',
        data: {'stateJson': stateJson},
      );

      try {
        final stateMap = jsonDecode(stateJson) as Map<String, dynamic>;

        // 创建状态对象
        final restoredState = WorkBrowseState.fromJson(stateMap);

        AppLogger.debug(
          '状态恢复成功',
          tag: 'StateRestorationService',
          data: {
            'filter': {
              'style': restoredState.filter.style?.name,
              'tool': restoredState.filter.tool?.name,
            }
          },
        );

        return restoredState;
      } catch (parseError) {
        AppLogger.error(
          'JSON解析失败',
          tag: 'StateRestorationService',
          error: parseError,
          data: {'stateJson': stateJson},
        );
        // 如果JSON解析失败，清除存储的状态并返回null
        await clearWorkBrowseState();
        return null;
      }
    } catch (e, stack) {
      AppLogger.error(
        '恢复浏览页状态失败',
        tag: 'StateRestorationService',
        error: e,
        stackTrace: stack,
      );
      return null;
    }
  }

  /// 恢复作品的编辑状态
  Future<WorkDetailState?> restoreWorkEditState(String workId) async {
    try {
      final stateKey = '$_workEditStatePrefix$workId';

      // 获取保存的状态
      final stateJson = _prefs.getString(stateKey);
      if (stateJson == null) return null;

      // 解析状态
      final stateMap = jsonDecode(stateJson) as Map<String, dynamic>;

      // 恢复 WorkEntity 对象
      WorkEntity? editingWork;
      if (stateMap.containsKey('editingWork')) {
        try {
          final workMap = stateMap['editingWork'] as Map<String, dynamic>;
          editingWork = WorkEntity.fromJson(workMap);
        } catch (e) {
          AppLogger.error(
            '恢复作品实体失败',
            tag: 'StateRestorationService',
            error: e,
            data: {'workId': workId},
          );
        }
      }

      // 恢复基本状态属性
      final isEditing = stateMap['isEditing'] as bool? ?? false;
      final hasChanges = stateMap['hasChanges'] as bool? ?? false;
      final historyIndex = stateMap['historyIndex'] as int? ?? -1;

      // 返回恢复的状态（注意: 命令历史无法从 JSON 恢复，因为它包含服务依赖）
      return WorkDetailState(
        isEditing: isEditing,
        editingWork: editingWork,
        hasChanges: hasChanges,
        historyIndex: historyIndex,
      );
    } catch (e, stack) {
      AppLogger.error(
        '恢复编辑状态失败',
        tag: 'StateRestorationService',
        error: e,
        stackTrace: stack,
        data: {'workId': workId},
      );
      return null;
    }
  }

  /// 保存产品浏览页状态
  Future<void> saveWorkBrowseState(WorkBrowseState state) async {
    try {
      // 转换状态为 JSON
      final stateMap = state.toJson();
      AppLogger.debug(
        '准备保存状态',
        tag: 'StateRestorationService',
        data: {
          'filter': {
            'style': state.filter.style?.name,
            'tool': state.filter.tool?.name,
          }
        },
      );

      final stateJson = jsonEncode(stateMap);

      // 保存状态和时间戳
      await _prefs.setString(_workBrowseStateKey, stateJson);
      await _prefs.setInt(
          _workBrowseTimestampKey, DateTime.now().millisecondsSinceEpoch);

      AppLogger.debug(
        '状态保存成功',
        tag: 'StateRestorationService',
      );
    } catch (e, stack) {
      AppLogger.error(
        '保存浏览页状态失败',
        tag: 'StateRestorationService',
        error: e,
        stackTrace: stack,
      );
    }
  }

  /// 保存作品的编辑状态
  Future<void> saveWorkEditState(String workId, WorkDetailState state) async {
    try {
      if (state.editingWork == null) return;

      final stateKey = '$_workEditStatePrefix$workId';
      final timestampKey = '$_workEditTimestampPrefix$workId';

      // 准备要保存的数据
      final stateMap = {
        'isEditing': state.isEditing,
        'hasChanges': state.hasChanges,
        'historyIndex': state.historyIndex,
      };

      // 保存 WorkEntity
      try {
        stateMap['editingWork'] = state.editingWork!.toJson();
      } catch (e) {
        AppLogger.error(
          '序列化作品实体失败',
          tag: 'StateRestorationService',
          error: e,
          data: {'workId': workId},
        );
      }

      // 保存状态和时间戳
      final stateJson = jsonEncode(stateMap);
      await _prefs.setString(stateKey, stateJson);
      await _prefs.setInt(timestampKey, DateTime.now().millisecondsSinceEpoch);

      AppLogger.debug('已保存编辑状态',
          tag: 'StateRestorationService', data: {'workId': workId});
    } catch (e, stack) {
      AppLogger.error(
        '保存编辑状态失败',
        tag: 'StateRestorationService',
        error: e,
        stackTrace: stack,
        data: {'workId': workId},
      );
    }
  }

  /// 检查是否首次运行，如果是则清除所有状态
  void _checkFirstRun() {
    final firstRun = _prefs.getBool('first_run') ?? true;
    if (firstRun) {
      _prefs.remove(_workBrowseStateKey);
      _prefs.remove(_workBrowseTimestampKey);
      _prefs.setBool('first_run', false);
      AppLogger.info(
        '首次运行，已清除所有已保存状态',
        tag: 'StateRestorationService',
      );
    }
  }
}



=======================================
./lib/application/services/services.dart
=======================================
export 'character/character_service.dart';
export 'practice/practice_service.dart';
export 'storage/work_storage_service.dart';
export 'work/work_image_service.dart';
export 'work/work_service.dart';



=======================================
./lib/application/services/storage/work_storage_service.dart
=======================================
import 'dart:io';

import 'package:demo/infrastructure/storage/storage_interface.dart';
import 'package:path/path.dart' as path;

import '../../../infrastructure/logging/logger.dart';

/// 作品存储服务
///
/// 职责:
/// 1. 作品文件目录管理
/// 2. 作品文件命名规则
/// 3. 文件版本管理
/// 4. 图片格式处理
class WorkStorageService {
  final IStorage _storage;

  WorkStorageService({
    required IStorage storage,
  }) : _storage = storage;

  /// 创建作品目录结构
  Future<void> createWorkDirectories(String workId) async {
    try {
      await _storage.createDirectory(getWorkPath(workId));
      await _storage.createDirectory(getWorkImagesPath(workId));
      await _storage.createDirectory(getWorkCoverPath(workId));
    } catch (e, stack) {
      _handleError(
        '创建作品目录失败',
        e,
        stack,
        data: {'workId': workId},
      );
    }
  }

  /// 删除作品目录
  Future<void> deleteWorkDirectory(String workId) async {
    try {
      final workPath = getWorkPath(workId);
      await _storage.deleteDirectory(workPath);
    } catch (e, stack) {
      _handleError(
        '删除作品目录失败',
        e,
        stack,
        data: {'workId': workId},
      );
    }
  }

  /// 删除作品图片
  Future<void> deleteWorkImage(String workId, String imageId) async {
    try {
      final imagePath = getWorkImagePath(workId, imageId);
      await _storage.deleteDirectory(imagePath);
    } catch (e, stack) {
      _handleError(
        '删除作品图片失败',
        e,
        stack,
        data: {
          'workId': workId,
          'imageId': imageId,
        },
      );
    }
  }

  Future<void> ensureWorkDirectoryExists(String workId) async {
    try {
      await _storage.ensureDirectoryExists(getWorkPath(workId));
      await _storage.ensureDirectoryExists(getWorkImagesPath(workId));
      await _storage.ensureDirectoryExists(getWorkCoverPath(workId));
    } catch (e, stack) {
      _handleError(
        '创建作品目录失败',
        e,
        stack,
        data: {'workId': workId},
      );
    }
  }

  /// 获取作品导入图片路径
  String getImportedPath(String workId, String imageId) =>
      path.join(getWorkImagePath(workId, imageId), 'imported.png');

  /// 获取作品元数据文件路径
  String getMetadataPath(String workId) =>
      path.join(getWorkPath(workId), 'metadata.json');

  /// 获取作品原始图片路径
  String getOriginalPath(String workId, String imageId) => path.join(
      getWorkImagePath(workId, imageId), 'original.${_getExtension(imageId)}');

  /// 获取作品缩略图路径
  String getThumbnailPath(String workId, String imageId) =>
      path.join(getWorkImagePath(workId, imageId), 'thumbnail.jpg');

  /// 获取作品封面导入图路径
  String getWorkCoverImportedPath(String workId) =>
      path.join(getWorkCoverPath(workId), 'imported.png');

  /// 获取作品封面目录路径
  String getWorkCoverPath(String workId) =>
      path.join(getWorkPath(workId), 'cover');

  /// 获取作品封面缩略图路径
  String getWorkCoverThumbnailPath(String workId) =>
      path.join(getWorkCoverPath(workId), 'thumbnail.jpg');

  /// 获取作品图片
  Future<File> getWorkImage(String path) async {
    if (!await _storage.fileExists(path)) {
      throw FileSystemException('文件不存在', path);
    }
    return File(path);
  }

  /// 获取图片信息
  Future<Map<String, int>> getWorkImageInfo(String path) async {
    final file = File(path);
    if (!await file.exists()) {
      throw FileSystemException('文件不存在', path);
    }

    return {
      'size': await file.length(),
      'width': 0, // TODO: 实现图片尺寸获取
      'height': 0,
    };
  }

  /// 获取作品图片路径
  String getWorkImagePath(String workId, String imageId) =>
      path.join(getWorkImagesPath(workId), imageId);

  /// 获取图片大小
  Future<int> getWorkImageSize(String path) => _storage.getFileSize(path);

  /// 获取作品图片目录路径
  String getWorkImagesPath(String workId) =>
      path.join(getWorkPath(workId), 'images');

  /// 获取作品目录路径
  String getWorkPath(String workId) =>
      (path.join(_storage.getAppDataPath(), 'works', workId));

  /// 检查作品图片是否存在
  Future<bool> hasWorkImage(String path) => _storage.fileExists(path);

  /// 列出作品所有文件路径（递归）
  Future<List<String>> listWorkFiles(String workId) async {
    try {
      final workPath = getWorkPath(workId);
      return await _storage.listDirectoryFiles(workPath);
    } catch (e, stack) {
      _handleError(
        '获取作品文件列表失败',
        e,
        stack,
        data: {'workId': workId},
      );
      return [];
    }
  }

  /// 保存作品封面导入图
  Future<String> saveCoverImported(String workId, File file) async {
    final targetPath = getWorkCoverImportedPath(workId);
    try {
      await ensureWorkDirectoryExists(workId);

      // 确保目标目录存在
      final targetDir = Directory(path.dirname(targetPath));
      if (!await targetDir.exists()) {
        await targetDir.create(recursive: true);
      }

      // 如果目标文件存在则先删除
      if (await _storage.fileExists(targetPath)) {
        await _storage.deleteFile(targetPath);
      }
      await _storage.copyFile(file.path, targetPath);

      // 验证文件是否成功保存
      if (!await _storage.fileExists(targetPath)) {
        AppLogger.error('封面导入图保存失败', tag: 'WorkStorageService', data: {
          'workId': workId,
          'sourcePath': file.path,
          'targetPath': targetPath
        });
        throw FileSystemException('封面导入图保存失败', targetPath);
      }

      return targetPath;
    } catch (e, stack) {
      _handleError(
        '保存封面导入图失败',
        e,
        stack,
        data: {
          'workId': workId,
          'sourcePath': file.path,
          'targetPath': targetPath
        },
      );
      rethrow;
    }
  }

  /// 保存作品封面缩略图
  Future<String> saveCoverThumbnail(String workId, File file) async {
    final targetPath = getWorkCoverThumbnailPath(workId);
    try {
      await ensureWorkDirectoryExists(workId);

      // 确保目标目录存在
      final targetDir = Directory(path.dirname(targetPath));
      if (!await targetDir.exists()) {
        await targetDir.create(recursive: true);
      }

      // 如果目标文件存在则先删除
      if (await _storage.fileExists(targetPath)) {
        await _storage.deleteFile(targetPath);
      }
      await _storage.copyFile(file.path, targetPath);

      // 验证文件是否成功保存
      if (!await _storage.fileExists(targetPath)) {
        AppLogger.error('封面缩略图保存失败', tag: 'WorkStorageService', data: {
          'workId': workId,
          'sourcePath': file.path,
          'targetPath': targetPath
        });
        throw FileSystemException('封面缩略图保存失败', targetPath);
      }

      return targetPath;
    } catch (e, stack) {
      _handleError(
        '保存封面缩略图失败',
        e,
        stack,
        data: {
          'workId': workId,
          'sourcePath': file.path,
          'targetPath': targetPath
        },
      );
      rethrow;
    }
  }

  /// 保存作品导入图片
  Future<String> saveImportedImage(
    String workId,
    String imageId,
    File file,
  ) async {
    final targetPath = getImportedPath(workId, imageId);
    await _storage.copyFile(file.path, targetPath);
    return targetPath;
  }

  /// 保存作品元数据
  Future<void> saveMetadata(String workId, String content) async {
    final targetPath = getMetadataPath(workId);
    await _storage.writeFile(targetPath, content.codeUnits);
  }

  /// 保存作品原始图片
  Future<String> saveOriginalImage(
    String workId,
    String imageId,
    File file,
  ) async {
    final targetPath = getOriginalPath(workId, imageId);
    await _storage.copyFile(file.path, targetPath);
    return targetPath;
  }

  /// 保存作品缩略图
  Future<String> saveThumbnail(
    String workId,
    String imageId,
    File file,
  ) async {
    final targetPath = getThumbnailPath(workId, imageId);
    await _storage.copyFile(file.path, targetPath);
    return targetPath;
  }

  /// 检查作品图片是否存在（带重试机制）
  Future<bool> verifyWorkImageExists(String path, {int retries = 3}) async {
    bool exists = await _storage.fileExists(path);

    // If file doesn't exist, retry a few times with delays
    int attempt = 0;
    while (!exists && attempt < retries) {
      await Future.delayed(Duration(milliseconds: 200 * (attempt + 1)));
      exists = await _storage.fileExists(path);
      attempt++;

      AppLogger.debug(
        'Retry checking file existence',
        tag: 'WorkStorageService',
        data: {
          'path': path,
          'attempt': attempt,
          'exists': exists,
        },
      );
    }

    // 如果文件存在，尝试读取以确保它完全写入
    if (exists) {
      try {
        final file = File(path);
        final randomAccessFile = await file.open(mode: FileMode.read);
        try {
          // 尝试读取几个字节以验证文件可访问
          await randomAccessFile.read(8);
        } finally {
          await randomAccessFile.close();
        }
      } catch (e) {
        AppLogger.warning(
          '文件存在但无法完全访问',
          tag: 'WorkStorageService',
          error: e,
          data: {'path': path},
        );
        exists = false; // 文件存在但不可访问，标记为不存在
      }
    }

    if (!exists) {
      AppLogger.warning(
        '文件不存在或不可访问',
        tag: 'WorkStorageService',
        data: {'path': path, 'afterRetries': retries},
      );
    }

    return exists;
  }

  /// 确认作品所有图片都存在
  Future<Map<String, bool>> verifyWorkImages(String workId) async {
    Map<String, bool> results = {};
    try {
      final workPath = getWorkPath(workId);
      final files = await _storage.listDirectoryFiles(workPath);

      for (final file in files) {
        results[file] = await _storage.fileExists(file);
      }

      // Check cover files specifically
      final coverPath = getWorkCoverImportedPath(workId);
      final coverThumbPath = getWorkCoverThumbnailPath(workId);

      results[coverPath] = await verifyWorkImageExists(coverPath);
      results[coverThumbPath] = await verifyWorkImageExists(coverThumbPath);

      // Log any missing files
      final missingFiles =
          results.entries.where((e) => !e.value).map((e) => e.key).toList();

      if (missingFiles.isNotEmpty) {
        AppLogger.warning(
          '作品存在丢失的文件',
          tag: 'WorkStorageService',
          data: {
            'workId': workId,
            'missingFiles': missingFiles,
          },
        );
      }
    } catch (e, stack) {
      _handleError(
        '验证作品图片失败',
        e,
        stack,
        data: {'workId': workId},
      );
    }

    return results;
  }

  /// 获取文件扩展名
  String _getExtension(String imageId) {
    // 从图片ID或其他元数据获取扩展名
    return 'png';
  }

  /// 统一错误处理
  void _handleError(
    String message,
    Object error,
    StackTrace stack, {
    Map<String, dynamic>? data,
  }) {
    AppLogger.error(
      message,
      error: error,
      stackTrace: stack,
      tag: 'WorkStorageService',
      data: data,
    );
    throw error;
  }
}



=======================================
./lib/application/services/work/service_errors.dart
=======================================
import '../../../infrastructure/logging/logger.dart';

/// 作品服务异常基类
abstract class ServiceException implements Exception {
  final String operation;
  final String message;
  final Map<String, dynamic>? data;

  ServiceException(this.operation, this.message, [this.data]);

  @override
  String toString() => '$runtimeType: $operation - $message';
}

/// 图片服务错误处理Mixin
mixin WorkImageErrorHandler {
  /// 处理图片操作
  Future<T> handleImageOperation<T>(
    String operation,
    Future<T> Function() action, {
    Map<String, dynamic>? data,
    bool rethrowError = true,
  }) async {
    try {
      return await action();
    } catch (e, stack) {
      // 记录错误
      AppLogger.error(
        'Image operation failed: $operation',
        tag: runtimeType.toString(),
        error: e,
        stackTrace: stack,
        data: data,
      );

      if (rethrowError) {
        if (e is ArgumentError) {
          rethrow;
        }
        throw WorkImageException(
          operation,
          e.toString(),
          data,
        );
      }

      return Future.value(); // 如果不重新抛出，返回null
    }
  }

  /// 处理同步图片操作
  T handleImageSync<T>(
    String operation,
    T Function() action, {
    Map<String, dynamic>? data,
    bool rethrowError = true,
  }) {
    try {
      return action();
    } catch (e, stack) {
      // 记录错误
      AppLogger.error(
        'Image operation failed: $operation',
        tag: runtimeType.toString(),
        error: e,
        stackTrace: stack,
        data: data,
      );

      if (rethrowError) {
        if (e is ArgumentError) {
          rethrow;
        }
        throw WorkImageException(
          operation,
          e.toString(),
          data,
        );
      }

      return null as T; // 如果不重新抛出，返回null
    }
  }
}

/// 图片服务异常
class WorkImageException extends ServiceException {
  WorkImageException(String operation, String message,
      [Map<String, dynamic>? data])
      : super(operation, message, data);
}

/// 作品服务错误处理Mixin
mixin WorkServiceErrorHandler {
  /// 处理服务操作
  Future<T> handleOperation<T>(
    String operation,
    Future<T> Function() action, {
    Map<String, dynamic>? data,
    bool rethrowError = true,
    String? tag,
  }) async {
    try {
      return await action();
    } catch (e, stack) {
      // 记录错误
      AppLogger.error(
        'Operation failed: $operation',
        tag: tag ?? runtimeType.toString(),
        error: e,
        stackTrace: stack,
        data: data,
      );

      if (rethrowError) {
        if (e is ArgumentError) {
          rethrow; // 参数错误直接抛出
        }
        throw WorkServiceException(
          operation,
          e.toString(),
          data,
        );
      }

      return Future.value(); // 如果不重新抛出，返回null
    }
  }

  /// 处理同步操作
  T handleSync<T>(
    String operation,
    T Function() action, {
    Map<String, dynamic>? data,
    bool rethrowError = true,
    String? tag,
  }) {
    try {
      return action();
    } catch (e, stack) {
      // 记录错误
      AppLogger.error(
        'Operation failed: $operation',
        tag: tag ?? runtimeType.toString(),
        error: e,
        stackTrace: stack,
        data: data,
      );

      if (rethrowError) {
        if (e is ArgumentError) {
          rethrow;
        }
        throw WorkServiceException(
          operation,
          e.toString(),
          data,
        );
      }

      return null as T; // 如果不重新抛出，返回null
    }
  }
}

/// 作品服务业务异常
class WorkServiceException extends ServiceException {
  WorkServiceException(String operation, String message,
      [Map<String, dynamic>? data])
      : super(operation, message, data);
}



=======================================
./lib/application/services/work/work_image_service.dart
=======================================
import 'dart:collection';
import 'dart:io';
import 'dart:math' as math;

import '../../../domain/models/work/work_image.dart';
import '../../../domain/repositories/work_image_repository.dart';
import '../../../infrastructure/image/image_processor.dart';
import '../../../infrastructure/logging/logger.dart';
import '../storage/work_storage_service.dart';
import './service_errors.dart';

typedef ProgressCallback = void Function(double progress, String message);

/// 作品图片服务
class WorkImageService with WorkServiceErrorHandler {
  final WorkStorageService _storage;
  final ImageProcessor _processor;
  final WorkImageRepository _repository;

  WorkImageService({
    required WorkStorageService storage,
    required ImageProcessor processor,
    required WorkImageRepository repository,
  })  : _storage = storage,
        _processor = processor,
        _repository = repository;

  /// 清理未使用的图片文件
  Future<void> cleanupUnusedFiles(String workId, List<String> usedPaths) async {
    return handleOperation(
      'cleanupUnusedFiles',
      () async {
        AppLogger.debug('开始清理未使用的图片文件', tag: 'WorkImageService', data: {
          'workId': workId,
          'usedPathsCount': usedPaths.length,
        });

        final allFiles = await _storage.listWorkFiles(workId);
        final unusedFiles =
            allFiles.where((f) => !usedPaths.contains(f)).toList();

        if (unusedFiles.isNotEmpty) {
          AppLogger.debug('发现未使用的文件', tag: 'WorkImageService', data: {
            'count': unusedFiles.length,
            'files': unusedFiles,
          });

          for (final file in unusedFiles) {
            try {
              await File(file).delete();
            } catch (e) {
              AppLogger.warning('删除未使用文件失败',
                  tag: 'WorkImageService', error: e, data: {'file': file});
            }
          }
        }
      },
      data: {'workId': workId},
    );
  }

  /// 清理作品图片
  Future<void> cleanupWorkImages(String workId) async {
    return handleOperation(
      'cleanupWorkImages',
      () async {
        AppLogger.info('开始清理作品图片', tag: 'WorkImageService', data: {
          'workId': workId,
        });

        // 删除图片文件
        await _storage.deleteWorkDirectory(workId);

        // 删除数据库记录
        await _repository.getAllByWorkId(workId).then((images) {
          if (images.isNotEmpty) {
            final imageIds = images.map((e) => e.id).toList();
            return _repository.deleteMany(workId, imageIds);
          }
        });

        AppLogger.info('图片清理完成', tag: 'WorkImageService');
      },
      data: {'workId': workId},
    );
  }

  /// 删除图片（不立即更新数据库）
  Future<void> deleteImage(String workId, String imageId) async {
    return handleOperation(
      'deleteImage',
      () async {
        AppLogger.info('开始删除图片', tag: 'WorkImageService', data: {
          'workId': workId,
          'imageId': imageId,
        });

        // 删除文件
        await _storage.deleteWorkImage(workId, imageId);

        // 删除数据库记录
        await _repository.delete(workId, imageId);

        AppLogger.info('图片文件删除完成', tag: 'WorkImageService');
      },
      data: {'workId': workId, 'imageId': imageId},
    );
  }

  /// 获取作品的所有图片
  Future<List<WorkImage>> getWorkImages(String workId) async {
    return handleOperation(
      'getWorkImages',
      () => _repository.getAllByWorkId(workId),
      data: {'workId': workId},
    );
  }

  /// 导入新图片（返回临时状态，不立即保存）
  Future<WorkImage> importImage(String workId, File file) async {
    return handleOperation(
      'importImage',
      () async {
        final imageId = DateTime.now().millisecondsSinceEpoch.toString();

        AppLogger.debug('准备导入新图片', tag: 'WorkImageService', data: {
          'workId': workId,
          'imageId': imageId,
          'filePath': file.path,
        });

        if (!await file.exists()) {
          throw FileSystemException('源文件不存在', file.path);
        }

        // 先创建临时图片对象
        final nextIndex = await _getNextImageIndex(workId);
        final tempImage = WorkImage(
          id: imageId,
          workId: workId,
          path: file.path,
          originalPath: file.path,
          thumbnailPath: file.path,
          format: _getImageFormat(file),
          size: await file.length(),
          width: 0,
          height: 0,
          index: nextIndex,
          createTime: DateTime.now(),
          updateTime: DateTime.now(),
        );

        AppLogger.debug('创建临时图片对象', tag: 'WorkImageService', data: {
          'imageId': imageId,
          'index': nextIndex,
        });

        return tempImage;
      },
      data: {'workId': workId, 'file': file.path},
    );
  }

  /// 批量导入图片（不立即保存）
  Future<List<WorkImage>> importImages(String workId, List<File> files) async {
    return handleOperation(
      'importImages',
      () async {
        AppLogger.info('开始批量导入图片', tag: 'WorkImageService', data: {
          'workId': workId,
          'fileCount': files.length,
        });

        final images = <WorkImage>[];
        final uniqueFiles = LinkedHashSet<File>(
          equals: (a, b) => a.path == b.path,
          hashCode: (file) => file.absolute.path.hashCode,
        )..addAll(files);

        AppLogger.debug('文件去重完成', tag: 'WorkImageService', data: {
          'originalCount': files.length,
          'uniqueCount': uniqueFiles.length,
        });

        for (final file in uniqueFiles) {
          final image = await importImage(workId, file);
          images.add(image);
        }

        return images;
      },
      data: {'workId': workId, 'fileCount': files.length},
    );
  }

  /// 处理完整的图片导入流程
  Future<List<WorkImage>> processImport(String workId, List<File> files) async {
    return handleOperation(
      'processImport',
      () async {
        AppLogger.info('开始处理图片导入', tag: 'WorkImageService', data: {
          'workId': workId,
          'fileCount': files.length,
        });

        // 1. 确保作品目录结构
        await _storage.ensureWorkDirectoryExists(workId);

        // 2. 导入所有图片
        final tempImages = await importImages(workId, files);

        // 3. 处理并保存图片
        final savedImages = await saveChanges(workId, tempImages);

        // 4. 强制验证封面是否已正确生成
        if (savedImages.isNotEmpty) {
          AppLogger.info('导入完成后验证封面', tag: 'WorkImageService');

          final coverPath = _storage.getWorkCoverImportedPath(workId);
          final coverThumbnailPath = _storage.getWorkCoverThumbnailPath(workId);

          // 检查封面和缩略图
          final coverExists = await _storage.verifyWorkImageExists(coverPath);
          final thumbnailExists =
              await _storage.verifyWorkImageExists(coverThumbnailPath);

          AppLogger.debug('导入后封面状态', tag: 'WorkImageService', data: {
            'coverExists': coverExists,
            'thumbnailExists': thumbnailExists,
            'coverPath': coverPath,
            'thumbnailPath': coverThumbnailPath,
          });

          // 如果封面或缩略图不存在，重新生成
          if (!coverExists || !thumbnailExists) {
            AppLogger.warning('导入后封面验证失败，重新生成', tag: 'WorkImageService', data: {
              'workId': workId,
              'firstImageId': savedImages[0].id,
              'coverMissing': !coverExists,
              'thumbnailMissing': !thumbnailExists,
            });

            await updateCover(workId, savedImages[0].id);

            // 再次验证封面是否生成成功
            final coverRegenerated =
                await _storage.verifyWorkImageExists(coverPath);
            final thumbnailRegenerated =
                await _storage.verifyWorkImageExists(coverThumbnailPath);

            if (!coverRegenerated || !thumbnailRegenerated) {
              AppLogger.error('封面重新生成后仍然缺失', tag: 'WorkImageService', data: {
                'workId': workId,
                'coverMissing': !coverRegenerated,
                'thumbnailMissing': !thumbnailRegenerated,
              });
            }
          }
        }

        AppLogger.info('图片导入处理完成', tag: 'WorkImageService', data: {
          'workId': workId,
          'totalSaved': savedImages.length,
        });

        return savedImages;
      },
      data: {'workId': workId, 'fileCount': files.length},
    );
  }

  /// 保存图片更改
  Future<List<WorkImage>> saveChanges(
    String workId,
    List<WorkImage> images, {
    ProgressCallback? onProgress,
  }) async {
    return handleOperation(
      'saveChanges',
      () async {
        AppLogger.info('开始保存图片更改', tag: 'WorkImageService', data: {
          'workId': workId,
          'imageCount': images.length,
          'firstImageId': images.isNotEmpty ? images[0].id : null,
        });

        // 首先获取当前所有图片，用于清理未使用的图片
        final existingImages = await _repository.getAllByWorkId(workId);
        final existingIds = existingImages.map((img) => img.id).toSet();
        final newIds = images.map((img) => img.id).toSet();

        // 获取当前的首张图片ID
        final existingFirstImageId =
            existingImages.isNotEmpty ? existingImages[0].id : null;
        final newFirstImageId = images.isNotEmpty ? images[0].id : null;

        // 检测图片顺序是否变化
        final imagesReordered =
            _haveImagesBeenReordered(existingImages, images);

        AppLogger.debug('封面图片检查', tag: 'WorkImageService', data: {
          'currentFirstImageId': existingFirstImageId,
          'newFirstImageId': newFirstImageId,
          'currentFirstImageIndex':
              existingImages.isNotEmpty ? existingImages[0].index : null,
          'newFirstImageIndex': images.isNotEmpty ? images[0].index : null,
          'imagesReordered': imagesReordered,
        });

        // 确定是否需要更新封面
        // 如果首图ID变了，或者图片顺序发生变化，都需要更新封面
        final shouldUpdateCover = newFirstImageId != null &&
            (existingFirstImageId != newFirstImageId ||
                imagesReordered ||
                existingFirstImageId == null);

        // 清理已删除的图片记录
        final deletedIds = existingIds.difference(newIds).toList();
        if (deletedIds.isNotEmpty) {
          await _repository.deleteMany(workId, deletedIds);
        }

        final processedImages = <WorkImage>[];
        final tempFiles = <String>[];
        var index = 0;
        final total = images.length;

        try {
          // 处理每个图片
          for (final image in images) {
            onProgress?.call(
              index / total,
              '处理图片 ${index + 1}/$total',
            );

            AppLogger.debug('处理图片', tag: 'WorkImageService', data: {
              'imageId': image.id,
              'isNew': image.path == image.originalPath,
              'index': index,
            });

            if (image.path == image.originalPath) {
              // 新图片: 需要完整的处理流程
              try {
                final file = File(image.path);
                if (!await file.exists()) {
                  throw FileSystemException('源文件不存在', image.path);
                }

                // 1. 保存原始文件
                final originalPath = await _storage.saveOriginalImage(
                  workId,
                  image.id,
                  file,
                );
                tempFiles.add(originalPath);

                // 2. 处理并保存导入图片
                final processedFile = await _processor.processImage(
                  file,
                  maxWidth: 2400,
                  maxHeight: 2400,
                  quality: 90,
                );
                final importedPath = await _storage.saveImportedImage(
                  workId,
                  image.id,
                  processedFile,
                );
                tempFiles.add(importedPath);

                // 3. 生成并保存缩略图
                final thumbnail = await _processor.processImage(
                  file,
                  maxWidth: 200,
                  maxHeight: 200,
                  quality: 80,
                );
                final thumbnailPath = await _storage.saveThumbnail(
                  workId,
                  image.id,
                  thumbnail,
                );
                tempFiles.add(thumbnailPath);

                // 4. 获取图片信息
                final info = await _storage.getWorkImageInfo(importedPath);

                processedImages.add(image.copyWith(
                  path: importedPath,
                  originalPath: originalPath,
                  thumbnailPath: thumbnailPath,
                  width: info['width'] ?? 0,
                  height: info['height'] ?? 0,
                  size: info['size'] ?? 0,
                  index: index++,
                  updateTime: DateTime.now(),
                ));

                AppLogger.debug('新图片处理完成', tag: 'WorkImageService', data: {
                  'imageId': image.id,
                  'size': info['size'],
                });
              } catch (e, stack) {
                AppLogger.error('处理新图片失败',
                    tag: 'WorkImageService',
                    error: e,
                    stackTrace: stack,
                    data: {
                      'imageId': image.id,
                      'path': image.path,
                    });
                rethrow;
              }
            } else {
              // 已存在的图片: 只更新索引
              processedImages.add(image.copyWith(
                index: index++,
                updateTime: DateTime.now(),
              ));
            }
          }

          onProgress?.call(0.9, '保存到数据库...');

          AppLogger.debug('所有图片处理完成', tag: 'WorkImageService', data: {
            'totalProcessed': processedImages.length,
          });

          try {
            // 批量保存到数据库
            final savedImages = await _repository.saveMany(processedImages);

            // 检查是否需要更新封面（首图变化时）
            if (shouldUpdateCover && savedImages.isNotEmpty) {
              AppLogger.info('需要更新封面', tag: 'WorkImageService', data: {
                'oldFirstImageId': existingFirstImageId,
                'newFirstImageId': newFirstImageId,
                'reason': existingFirstImageId != newFirstImageId
                    ? '首图ID变化'
                    : imagesReordered
                        ? '图片顺序变化'
                        : '其他原因'
              });

              try {
                // 使用当前首图更新封面
                await updateCover(workId, savedImages[0].id);

                AppLogger.debug('封面已更新', tag: 'WorkImageService', data: {
                  'usedImageId': savedImages[0].id,
                  'usedImageIndex': savedImages[0].index,
                });

                // 验证封面文件确实存在
                await _verifyCoverExists(workId);
              } catch (e, stack) {
                AppLogger.error('生成封面失败',
                    tag: 'WorkImageService',
                    error: e,
                    stackTrace: stack,
                    data: {
                      'workId': workId,
                      'firstImageId': savedImages[0].id,
                    });
                // 继续执行，不中断保存流程
              }
            } else {
              // 记录不需要更新封面的原因
              AppLogger.debug('不需要更新封面', tag: 'WorkImageService', data: {
                'existingFirstImageId': existingFirstImageId,
                'newFirstImageId': newFirstImageId,
                'imagesReordered': imagesReordered,
                'shouldUpdateCover': shouldUpdateCover,
              });

              // 即使不需要更新封面，也验证封面存在
              if (savedImages.isNotEmpty) {
                await _verifyCoverExists(workId);
              }
            }

            // 清理未使用的文件
            final usedPaths = savedImages
                .expand(
                    (img) => [img.path, img.originalPath, img.thumbnailPath])
                .toList();
            await cleanupUnusedFiles(workId, usedPaths);

            // Verify all processed files
            await _verifyAllProcessedFiles(tempFiles);

            onProgress?.call(1.0, '完成');

            AppLogger.info('图片保存完成', tag: 'WorkImageService', data: {
              'savedCount': savedImages.length,
            });

            return savedImages;
          } catch (e, stack) {
            AppLogger.error('保存到数据库失败',
                tag: 'WorkImageService', error: e, stackTrace: stack);
            // 清理临时文件
            for (final path in tempFiles) {
              try {
                await File(path).delete();
              } catch (e) {
                AppLogger.warning('清理临时文件失败',
                    tag: 'WorkImageService', error: e, data: {'path': path});
              }
            }
            rethrow;
          }
        } catch (e) {
          // 确保进度回调显示错误状态
          onProgress?.call(0, '保存失败: ${e.toString()}');
          rethrow;
        }
      },
      data: {'workId': workId, 'imageCount': images.length},
    );
  }

  /// 更新封面
  Future<void> updateCover(String workId, String imageId) async {
    return handleOperation(
      'updateCover',
      () async {
        AppLogger.debug('开始更新作品封面', tag: 'WorkImageService', data: {
          'workId': workId,
          'imageId': imageId,
          'timestamp': DateTime.now().millisecondsSinceEpoch,
        });

        // 确保封面目录存在
        await _storage.ensureWorkDirectoryExists(workId);

        // 获取源图片路径并验证
        final importedPath = _storage.getImportedPath(workId, imageId);
        final sourceFile = File(importedPath);
        if (!await sourceFile.exists()) {
          AppLogger.error('源图片不存在', tag: 'WorkImageService', data: {
            'workId': workId,
            'imageId': imageId,
            'importedPath': importedPath
          });
          throw FileSystemException('源图片不存在', importedPath);
        }

        try {
          // 记录源图片信息，有助于调试
          final sourceSize = await sourceFile.length();
          AppLogger.debug('源图片文件信息', tag: 'WorkImageService', data: {
            'sourceSize': sourceSize,
            'sourcePath': importedPath,
          });

          // 生成并保存封面导入图
          final coverImportedPath =
              await _storage.saveCoverImported(workId, sourceFile);

          // 生成并保存封面缩略图
          final thumbnail = await _processor.processImage(
            sourceFile,
            maxWidth: 200,
            maxHeight: 200,
            quality: 80,
          );
          final coverThumbnailPath =
              await _storage.saveCoverThumbnail(workId, thumbnail);

          // 验证封面文件是否成功生成
          final coverFiles = [
            File(coverImportedPath),
            File(coverThumbnailPath),
          ];

          bool allFilesExist = true;
          for (final file in coverFiles) {
            final exists = await file.exists();
            if (!exists) {
              allFilesExist = false;
              AppLogger.error('封面文件生成后不存在',
                  tag: 'WorkImageService', data: {'path': file.path});
            } else {
              // 记录文件大小用于调试
              final size = await file.length();
              AppLogger.debug('生成的封面文件信息', tag: 'WorkImageService', data: {
                'path': file.path,
                'size': size,
              });
            }
          }

          if (!allFilesExist) {
            throw const FileSystemException('封面文件生成失败');
          }

          AppLogger.info('作品封面更新完成', tag: 'WorkImageService', data: {
            'workId': workId,
            'imageId': imageId,
            'coverImported': coverImportedPath,
            'coverThumbnail': coverThumbnailPath,
            'timestamp': DateTime.now().millisecondsSinceEpoch,
          });
        } catch (e, stack) {
          AppLogger.error('生成封面失败',
              tag: 'WorkImageService',
              error: e,
              stackTrace: stack,
              data: {
                'workId': workId,
                'imageId': imageId,
                'sourcePath': importedPath,
              });
          rethrow;
        }
      },
      data: {'workId': workId, 'imageId': imageId},
    );
  }

  /// 确保封面文件存在
  Future<bool> _ensureCoverFilesExist(String workId) async {
    final coverPath = _storage.getWorkCoverImportedPath(workId);
    final thumbnailPath = _storage.getWorkCoverThumbnailPath(workId);

    // 尝试多次检查文件是否存在，允许文件系统操作完成
    for (int i = 0; i < 3; i++) {
      final coverExists = await File(coverPath).exists();
      final thumbnailExists = await File(thumbnailPath).exists();

      if (coverExists && thumbnailExists) {
        return true;
      }

      AppLogger.debug('等待封面文件写入完成', tag: 'WorkImageService', data: {
        'attempt': i + 1,
        'coverExists': coverExists,
        'thumbnailExists': thumbnailExists
      });

      // 等待文件系统操作完成
      await Future.delayed(Duration(milliseconds: 100 * (i + 1)));
    }

    return false;
  }

  /// 确保文件写入完成
  Future<void> _ensureFileWritten(String filePath) async {
    try {
      final file = File(filePath);
      if (await file.exists()) {
        // 尝试打开文件并读取一部分来确保它已完全写入
        final raf = await file.open(mode: FileMode.read);
        try {
          await raf.read(4); // 读取几个字节以确认文件可访问
        } finally {
          await raf.close();
        }
      } else {
        AppLogger.warning(
          '文件不存在，无法确认写入状态',
          tag: 'WorkImageService',
          data: {'path': filePath},
        );
      }
    } catch (e) {
      AppLogger.warning(
        '确认文件写入状态失败',
        tag: 'WorkImageService',
        error: e,
        data: {'path': filePath},
      );
    }
  }

  /// 获取图片格式
  String _getImageFormat(File file) {
    return file.path.split('.').last.toLowerCase();
  }

  /// 获取下一个图片索引
  Future<int> _getNextImageIndex(String workId) async {
    return await _repository.getNextIndex(workId);
  }

  /// 检查图片是否被重新排序
  bool _haveImagesBeenReordered(
      List<WorkImage> oldImages, List<WorkImage> newImages) {
    // 没有足够的图片，不算重排
    if (oldImages.isEmpty || newImages.isEmpty) {
      return false;
    }

    // 创建映射以快速查找旧图片的索引
    final oldImageMap = {for (var img in oldImages) img.id: img.index};

    // 特别检查第一张图是否变了位置
    if (oldImages.isNotEmpty && newImages.isNotEmpty) {
      if (oldImages[0].id != newImages[0].id) {
        return true; // 首图变了
      }
    }

    // 检查前几张图的顺序是否变化
    final checkCount = math.min(oldImages.length, newImages.length);

    // 检查其他图片的顺序
    for (int i = 0; i < checkCount; i++) {
      final newImg = newImages[i];
      // 如果新顺序中的图片在旧数据中有不同的索引，说明发生了重排
      if (oldImageMap.containsKey(newImg.id) && oldImageMap[newImg.id] != i) {
        return true;
      }
    }

    return false;
  }

  /// 在文件保存后验证所有已处理文件
  Future<void> _verifyAllProcessedFiles(List<String> paths) async {
    for (final path in paths) {
      try {
        await _ensureFileWritten(path);
      } catch (e) {
        AppLogger.warning(
          '验证文件失败',
          tag: 'WorkImageService',
          error: e,
          data: {'path': path},
        );
      }
    }
  }

  /// 验证封面文件是否存在，如果不存在则重新生成
  Future<bool> _verifyCoverExists(String workId) async {
    final coverPath = _storage.getWorkCoverImportedPath(workId);
    final coverExists = await _storage.verifyWorkImageExists(coverPath);

    AppLogger.debug('验证封面文件', tag: 'WorkImageService', data: {
      'workId': workId,
      'coverPath': coverPath,
      'exists': coverExists
    });

    // 如果封面不存在，找出当前的第一张图并重新生成封面
    if (!coverExists) {
      try {
        final images = await _repository.getAllByWorkId(workId);
        if (images.isNotEmpty) {
          AppLogger.warning('封面文件丢失，重新生成',
              tag: 'WorkImageService',
              data: {'workId': workId, 'firstImageId': images[0].id});
          await updateCover(workId, images[0].id);
          return true;
        }
      } catch (e, stack) {
        AppLogger.error('验证并重新生成封面失败',
            tag: 'WorkImageService',
            error: e,
            stackTrace: stack,
            data: {'workId': workId});
      }
      return false;
    }

    return true;
  }
}



=======================================
./lib/application/services/work/work_service.dart
=======================================
import 'dart:io';

import '../../../domain/models/work/work_entity.dart';
import '../../../domain/models/work/work_filter.dart';
import '../../../domain/repositories/work_image_repository.dart';
import '../../../domain/repositories/work_repository.dart';
import '../../../infrastructure/logging/logger.dart';
import '../../../infrastructure/storage/storage_interface.dart';
import './service_errors.dart';
import './work_image_service.dart';

/// 作品服务
class WorkService with WorkServiceErrorHandler {
  final WorkRepository _repository;
  final WorkImageService _imageService;
  final IStorage _storage;
  final WorkImageRepository _workImageRepository;

  WorkService({
    required WorkRepository repository,
    required WorkImageService imageService,
    required IStorage storage,
    required WorkImageRepository workImageRepository,
  })  : _repository = repository,
        _imageService = imageService,
        _storage = storage,
        _workImageRepository = workImageRepository;

  /// 统计作品数量
  Future<int> count(WorkFilter? filter) async {
    return handleOperation(
      'count',
      () => _repository.count(filter),
      data: {'filter': filter?.toString()},
    );
  }

  /// 删除作品
  Future<void> deleteWork(String workId) async {
    return handleOperation(
      'deleteWork',
      () async {
        // 删除作品及图片
        await _repository.delete(workId);
        await _imageService.cleanupWorkImages(workId);
      },
      data: {'workId': workId},
    );
  }

  /// 获取所有作品
  Future<List<WorkEntity>> getAllWorks() async {
    return handleOperation(
      'getAllWorks',
      () => _repository.getAll(),
    );
  }

  /// 获取作品实体
  Future<WorkEntity?> getWork(String workId) async {
    return handleOperation(
      'getWorkEntity',
      () async {
        final work = await _repository.get(workId);
        if (work != null) {
          // Load work images
          final images = await _workImageRepository.getAllByWorkId(workId);
          AppLogger.debug(
            'Loading work with images',
            tag: 'WorkService',
            data: {
              'workId': workId,
              'imageCount': images.length,
              'imagePaths': images.map((img) => img.path).toList(),
            },
          );
          return work.copyWith(images: images);
        }
        return work;
      },
      data: {'workId': workId},
    );
  }

  /// 按标签获取作品
  Future<List<WorkEntity>> getWorksByTags(Set<String> tags) async {
    return handleOperation(
      'getWorksByTags',
      () => _repository.getByTags(tags),
      data: {'tags': tags.toList()},
    );
  }

  /// 导入作品
  Future<WorkEntity> importWork(List<File> files, WorkEntity work) async {
    return handleOperation(
      'importWork',
      () async {
        AppLogger.debug(
          '导入作品',
          tag: 'WorkService',
          data: {'fileCount': files.length, 'work': work.toJson()},
        );

        // 验证输入
        if (files.isEmpty) throw ArgumentError('图片文件不能为空');

        // 更新作品信息
        final updatedWork = work.copyWith(
          imageCount: files.length,
          updateTime: DateTime.now(),
          createTime: DateTime.now(),
        );

        // 保存到数据库
        final savedWork = await _repository.create(updatedWork);

        // 处理图片导入（包括生成封面）
        final imagesImported =
            await _imageService.processImport(work.id, files);

        // 注意：不需要在这里显式调用updateCover，
        // processImport内部的saveChanges已经处理了封面生成

        return savedWork.copyWith(images: imagesImported);
      },
      data: {'workId': work.id, 'fileCount': files.length},
    );
  }

  /// 查询作品
  Future<List<WorkEntity>> queryWorks(WorkFilter filter) async {
    return handleOperation(
      'queryWorks',
      () async {
        AppLogger.debug(
          '开始查询作品',
          tag: 'WorkService',
          data: {
            'filter': {
              'style': filter.style?.name,
              'tool': filter.tool?.name,
              'keyword': filter.keyword,
              'tags': filter.tags.toList(),
              'sortOption': {
                'field': filter.sortOption.field.name,
                'descending': filter.sortOption.descending,
              },
            },
          },
        );

        final results = await _repository.query(filter);

        AppLogger.debug(
          '查询作品完成',
          tag: 'WorkService',
          data: {'resultCount': results.length},
        );

        return results;
      },
      data: {'filter': filter.toString()},
    );
  }

  /// 更新作品实体
  Future<WorkEntity> updateWorkEntity(WorkEntity work) async {
    return handleOperation(
      'updateWorkEntity',
      () async {
        AppLogger.debug('开始更新作品信息', tag: 'WorkService', data: {
          'workId': work.id,
          'imageCount': work.images.length,
          'hasImages': work.images.isNotEmpty,
        });

        // 更新基本信息
        final updatedWork = work.copyWith(
          updateTime: DateTime.now(),
          imageCount: work.images.length,
        );

        // 保存作品信息
        return await _repository.save(updatedWork);
      },
      data: {'workId': work.id},
    );
  }
}



=======================================
./lib/application/services/work/work_service_error_handler.dart
=======================================
import '../../../infrastructure/logging/logger.dart';

/// 错误处理Mixin
mixin WorkServiceErrorHandler {
  /// 统一处理服务操作
  Future<T> handleOperation<T>(
    String operation,
    Future<T> Function() action, {
    Map<String, dynamic>? data,
    bool rethrowError = true,
    String? tag,
  }) async {
    try {
      return await action();
    } catch (e, stack) {
      AppLogger.error(
        'Operation failed: $operation',
        tag: tag ?? runtimeType.toString(),
        error: e,
        stackTrace: stack,
        data: data,
      );

      if (rethrowError) {
        if (e is ArgumentError) {
          rethrow; // 参数错误直接抛出
        }
        throw WorkServiceException(operation, e.toString());
      }

      return Future.value(); // 如果不重新抛出，返回默认值
    }
  }

  /// 统一处理同步操作
  T handleSync<T>(
    String operation,
    T Function() action, {
    Map<String, dynamic>? data,
    bool rethrowError = true,
    String? tag,
  }) {
    try {
      return action();
    } catch (e, stack) {
      AppLogger.error(
        'Operation failed: $operation',
        tag: tag ?? runtimeType.toString(),
        error: e,
        stackTrace: stack,
        data: data,
      );

      if (rethrowError) {
        if (e is ArgumentError) {
          rethrow;
        }
        throw WorkServiceException(operation, e.toString());
      }

      return null as T; // 如果不重新抛出，返回null
    }
  }
}

/// 作品服务异常类
class WorkServiceException implements Exception {
  final String operation;
  final String message;

  WorkServiceException(this.operation, this.message);

  @override
  String toString() => 'WorkServiceException: $operation - $message';
}



=======================================
./lib/domain/enums/app_theme_mode.dart
=======================================
import 'package:flutter/material.dart';

/// The theme mode options supported by the application
enum AppThemeMode {
  /// System theme mode (follows device settings)
  system,

  /// Light theme mode
  light,

  /// Dark theme mode
  dark;

  /// Get a friendly display name for the theme mode
  String get displayName {
    return switch (this) {
      AppThemeMode.system => '跟随系统',
      AppThemeMode.light => '浅色模式',
      AppThemeMode.dark => '深色模式',
    };
  }

  /// Get the icon for the theme mode
  IconData get icon {
    return switch (this) {
      AppThemeMode.system => Icons.settings_system_daydream_outlined,
      AppThemeMode.light => Icons.light_mode_outlined,
      AppThemeMode.dark => Icons.dark_mode_outlined,
    };
  }

  /// Convert to Flutter's ThemeMode
  ThemeMode toFlutterThemeMode() {
    return switch (this) {
      AppThemeMode.system => ThemeMode.system,
      AppThemeMode.light => ThemeMode.light,
      AppThemeMode.dark => ThemeMode.dark,
    };
  }

  /// Convert to string value (for storage)
  String toStorageValue() {
    return name;
  }

  /// Parse from string value (for storage)
  static AppThemeMode fromString(String? value) {
    return switch (value?.toLowerCase()) {
      'system' => AppThemeMode.system,
      'light' => AppThemeMode.light,
      'dark' => AppThemeMode.dark,
      _ => AppThemeMode.system, // Default to system if unknown
    };
  }
}



=======================================
./lib/domain/enums/sort_field.dart
=======================================
/// 排序字段类型
enum SortField {
  title('title', '标题'),
  author('author', '作者'),
  creationDate('creation_date', '创作日期'),
  createTime('create_time', '创建时间'),
  updateTime('update_time', '更新时间'),
  tool('tool', '工具'),
  style('style', '风格'),
  none('none', '无');

  final String value;
  final String label;

  const SortField(this.value, this.label);
}

extension SortFieldParsing on SortField {
  static SortField fromString(String value) {
    return SortField.values.firstWhere(
      (e) => e.value == value,
      orElse: () => SortField.createTime,
    );
  }
}



=======================================
./lib/domain/enums/work_status.dart
=======================================
/// 作品状态
enum WorkStatus {
  draft('draft', '草稿'),
  published('published', '已发布'),
  archived('archived', '已归档');

  final String value;
  final String label;

  const WorkStatus(this.value, this.label);

  /// 是否已归档
  bool get isArchived => this == WorkStatus.archived;

  /// 是否为草稿
  bool get isDraft => this == WorkStatus.draft;

  /// 是否为非草稿状态
  bool get isNotDraft => !isDraft;

  /// 是否已发布
  bool get isPublished => this == WorkStatus.published;

  /// 从字符串解析状态
  static WorkStatus fromString(String value) {
    return WorkStatus.values.firstWhere(
      (e) => e.value == value,
      orElse: () => WorkStatus.draft,
    );
  }
}



=======================================
./lib/domain/enums/work_style.dart
=======================================
/// 作品风格
enum WorkStyle {
  regular('regular', '楷书'),
  running('running', '行书'),
  cursive('cursive', '草书'),
  clerical('clerical', '隶书'),
  seal('seal', '篆书'),
  other('other', '其他');

  final String value;
  final String label;

  const WorkStyle(this.value, this.label);

  String toJson() => value;

  // 用于freezed反序列化的静态方法
  static WorkStyle? deserializeNullable(dynamic value) =>
      value == null ? null : fromValue(value);

  static WorkStyle fromString(String value) {
    return WorkStyle.values.firstWhere(
      (e) => e.value == value || e.name == value,
      orElse: () => WorkStyle.other,
    );
  }

  static WorkStyle fromValue(dynamic v) {
    if (v is WorkStyle) return v;
    final value = v?.toString() ?? '';
    return fromString(value);
  }

  // 用于freezed序列化的静态方法
  static String? serializeNullable(WorkStyle? style) => style?.value;
}



=======================================
./lib/domain/enums/work_tool.dart
=======================================
/// 创作工具
enum WorkTool {
  brush('brush', '毛笔'),
  hardPen('hardPen', '硬笔'),
  other('other', '其他');

  final String value;
  final String label;

  const WorkTool(this.value, this.label);

  String toJson() => value;

  static WorkTool? fromJson(dynamic value) =>
      value == null ? null : fromValue(value);

  static WorkTool fromString(String value) {
    return WorkTool.values.firstWhere(
      (e) => e.value == value || e.name == value,
      orElse: () => WorkTool.other,
    );
  }

  static WorkTool fromValue(dynamic v) {
    if (v is WorkTool) return v;
    final value = v?.toString() ?? '';
    return fromString(value);
  }

  // 用于JSON序列化的静态方法
  static String? serializeNullable(WorkTool? tool) => tool?.value;
}



=======================================
./lib/domain/models/character/character_entity.dart
=======================================
import 'package:freezed_annotation/freezed_annotation.dart';

import 'character_region.dart';

part 'character_entity.freezed.dart';
part 'character_entity.g.dart';

/// 表示一个采集的汉字字形
@freezed
class CharacterEntity with _$CharacterEntity {
  const factory CharacterEntity({
    /// ID
    String? id,

    /// 汉字
    required String char,

    /// 所属作品ID
    String? workId,

    /// 字形区域
    CharacterRegion? region,

    /// 标签列表
    @Default([]) List<String> tags,

    /// 创建时间
    DateTime? createTime,

    /// 更新时间
    DateTime? updateTime,
  }) = _CharacterEntity;

  /// 从JSON创建实例
  factory CharacterEntity.fromJson(Map<String, dynamic> json) =>
      _$CharacterEntityFromJson(json);

  const CharacterEntity._();

  /// 用于显示的文本描述
  @override
  String toString() => 'CharacterEntity(char: $char, workId: $workId)';
}



=======================================
./lib/domain/models/character/character_filter.dart
=======================================
import 'package:equatable/equatable.dart';

/// 集字过滤条件，用于搜索和筛选已采集的汉字
class CharacterFilter extends Equatable {
  /// 搜索关键词（汉字/作品名）
  final String? searchQuery;

  /// 书法风格列表
  final List<String> styles;

  /// 书写工具列表
  final List<String> tools;

  /// 排序选项
  final SortOption sortOption;

  /// 是否降序排序
  final bool descending;

  /// 开始日期
  final DateTime? fromDate;

  /// 结束日期
  final DateTime? toDate;

  const CharacterFilter({
    this.searchQuery,
    this.styles = const [],
    this.tools = const [],
    this.sortOption = SortOption.createTime,
    this.descending = true,
    this.fromDate,
    this.toDate,
  });

  /// 从JSON创建过滤器
  factory CharacterFilter.fromJson(Map<String, dynamic> json) {
    return CharacterFilter(
      searchQuery: json['searchQuery'] as String?,
      styles: List<String>.from(json['styles'] as List? ?? []),
      tools: List<String>.from(json['tools'] as List? ?? []),
      sortOption: SortOption.values.firstWhere(
        (opt) => opt.name == (json['sortOption'] as String?),
        orElse: () => SortOption.createTime,
      ),
      descending: json['descending'] as bool? ?? true,
      fromDate: json['fromDate'] != null
          ? DateTime.fromMillisecondsSinceEpoch(json['fromDate'] as int)
          : null,
      toDate: json['toDate'] != null
          ? DateTime.fromMillisecondsSinceEpoch(json['toDate'] as int)
          : null,
    );
  }

  /// 检查是否包含日期范围条件
  bool get hasDateRange => fromDate != null || toDate != null;

  /// 检查过滤器是否为空（没有任何过滤条件）
  bool get isEmpty =>
      searchQuery == null &&
      styles.isEmpty &&
      tools.isEmpty &&
      fromDate == null &&
      toDate == null;

  @override
  List<Object?> get props => [
        searchQuery,
        styles,
        tools,
        sortOption,
        descending,
        fromDate,
        toDate,
      ];

  /// 重置所有过滤条件
  CharacterFilter clear() {
    return const CharacterFilter();
  }

  /// 创建过滤器副本
  CharacterFilter copyWith({
    String? searchQuery,
    List<String>? styles,
    List<String>? tools,
    SortOption? sortOption,
    bool? descending,
    DateTime? fromDate,
    DateTime? toDate,
  }) {
    return CharacterFilter(
      searchQuery: searchQuery ?? this.searchQuery,
      styles: styles ?? this.styles,
      tools: tools ?? this.tools,
      sortOption: sortOption ?? this.sortOption,
      descending: descending ?? this.descending,
      fromDate: fromDate ?? this.fromDate,
      toDate: toDate ?? this.toDate,
    );
  }

  /// 添加或移除书法风格
  CharacterFilter toggleStyle(String style) {
    final newStyles = List<String>.from(styles);
    if (newStyles.contains(style)) {
      newStyles.remove(style);
    } else {
      newStyles.add(style);
    }
    return copyWith(styles: newStyles);
  }

  /// 添加或移除书写工具
  CharacterFilter toggleTool(String tool) {
    final newTools = List<String>.from(tools);
    if (newTools.contains(tool)) {
      newTools.remove(tool);
    } else {
      newTools.add(tool);
    }
    return copyWith(tools: newTools);
  }

  /// 转换为JSON
  Map<String, dynamic> toJson() {
    return {
      'searchQuery': searchQuery,
      'styles': styles,
      'tools': tools,
      'sortOption': sortOption.name,
      'descending': descending,
      'fromDate': fromDate?.millisecondsSinceEpoch,
      'toDate': toDate?.millisecondsSinceEpoch,
    };
  }

  @override
  String toString() {
    return 'CharacterFilter{'
        'searchQuery: $searchQuery, '
        'styles: $styles, '
        'tools: $tools, '
        'sortOption: $sortOption, '
        'descending: $descending, '
        'fromDate: $fromDate, '
        'toDate: $toDate'
        '}';
  }

  /// 更新日期范围
  CharacterFilter updateDateRange(DateTime? from, DateTime? to) {
    return copyWith(
      fromDate: from,
      toDate: to,
    );
  }

  /// 更新排序方式
  CharacterFilter updateSort(SortOption option, {bool? descending}) {
    return copyWith(
      sortOption: option,
      descending: descending,
    );
  }
}

/// 排序选项
enum SortOption {
  createTime('采集时间'),
  character('汉字'),
  workName('作品名'),
  style('书法风格');

  final String label;
  const SortOption(this.label);
}



=======================================
./lib/domain/models/character/character_image.dart
=======================================
import 'package:demo/domain/models/character/processing_options.dart';
import 'package:equatable/equatable.dart';

class CharacterImage extends Equatable {
  final String path;
  final String binary;
  final String thumbnail;
  final String? svg;
  final ProcessingOptions? processingOptions;

  const CharacterImage({
    required this.path,
    required this.binary,
    required this.thumbnail,
    this.svg,
    this.processingOptions,
  });

  factory CharacterImage.fromJson(Map<String, dynamic> json) {
    return CharacterImage(
      path: json['path'] as String,
      binary: json['binary'] as String,
      thumbnail: json['thumbnail'] as String,
      svg: json['svg'] as String?,
      processingOptions: json['processingOptions'] != null
          ? ProcessingOptions.fromJson(
              json['processingOptions'] as Map<String, dynamic>)
          : null,
    );
  }

  @override
  List<Object?> get props => [path, binary, thumbnail, svg, processingOptions];

  CharacterImage copyWith({
    String? path,
    String? binary,
    String? thumbnail,
    String? svg,
    ImageSize? size,
    ProcessingOptions? processingOptions,
  }) {
    return CharacterImage(
      path: path ?? this.path,
      binary: binary ?? this.binary,
      thumbnail: thumbnail ?? this.thumbnail,
      svg: svg ?? this.svg,
      processingOptions: processingOptions ?? this.processingOptions,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'path': path,
      'binary': binary,
      'thumbnail': thumbnail,
      'svg': svg,
      'processingOptions': processingOptions?.toJson(),
    };
  }
}

class ImageSize extends Equatable {
  final int width;
  final int height;

  const ImageSize({
    required this.width,
    required this.height,
  });

  factory ImageSize.fromJson(Map<String, dynamic> json) {
    return ImageSize(
      width: json['width'] as int,
      height: json['height'] as int,
    );
  }

  @override
  List<Object?> get props => [width, height];

  ImageSize copyWith({
    int? width,
    int? height,
  }) {
    return ImageSize(
      width: width ?? this.width,
      height: height ?? this.height,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'width': width,
      'height': height,
    };
  }
}



=======================================
./lib/domain/models/character/character_region.dart
=======================================
import 'package:flutter/material.dart';
import 'package:freezed_annotation/freezed_annotation.dart';

part 'character_region.freezed.dart';
part 'character_region.g.dart';

/// 字形区域信息
@freezed
class CharacterRegion with _$CharacterRegion {
  const factory CharacterRegion({
    /// X坐标
    required double left,

    /// Y坐标
    required double top,

    /// 宽度
    required double width,

    /// 高度
    required double height,

    /// 旋转角度
    @Default(0.0) double rotation,

    /// 页码索引
    required int pageIndex,

    /// 是否已保存
    @Default(false) bool isSaved,

    /// 标签
    String? label,

    /// 图片路径
    required String imagePath,

    /// 区域颜色
    @JsonKey(ignore: true) Color? color,
  }) = _CharacterRegion;

  /// 从JSON创建实例
  factory CharacterRegion.fromJson(Map<String, dynamic> json) =>
      _$CharacterRegionFromJson(json);

  const CharacterRegion._();

  /// 矩形区域
  Rect get rect => Rect.fromLTWH(left, top, width, height);

  /// 用于显示的文本描述
  @override
  String toString() => 'CharacterRegion($left,$top,$width,$height)';
}



=======================================
./lib/domain/models/character/character_usage.dart
=======================================
import 'package:equatable/equatable.dart';

class CharacterUsage extends Equatable {
  final String practiceId;

  const CharacterUsage({
    required this.practiceId,
  });

  factory CharacterUsage.fromJson(Map<String, dynamic> json) {
    return CharacterUsage(
      practiceId: json['practiceId'] as String,
    );
  }

  @override
  List<Object?> get props => [practiceId];

  CharacterUsage copyWith({
    String? practiceId,
  }) {
    return CharacterUsage(
      practiceId: practiceId ?? this.practiceId,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'practiceId': practiceId,
    };
  }
}



=======================================
./lib/domain/models/character/processing_options.dart
=======================================
import "package:equatable/equatable.dart";

class ProcessingOptions extends Equatable {
  final bool inverted;
  final bool showContour;
  final double threshold;
  final double noiseReduction;
  final bool removeBg;

  const ProcessingOptions({
    this.inverted = false,
    this.showContour = false,
    this.threshold = 0.5,
    this.noiseReduction = 0.5,
    this.removeBg = true,
  });

  factory ProcessingOptions.fromJson(Map<String, dynamic> json) {
    return ProcessingOptions(
      inverted: json["inverted"] as bool? ?? false,
      showContour: json["showContour"] as bool? ?? false,
      threshold: (json["threshold"] as num?)?.toDouble() ?? 0.5,
      noiseReduction: (json["noiseReduction"] as num?)?.toDouble() ?? 0.5,
      removeBg: json["removeBg"] as bool? ?? true,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      "inverted": inverted,
      "showContour": showContour,
      "threshold": threshold,
      "noiseReduction": noiseReduction,
      "removeBg": removeBg,
    };
  }

  ProcessingOptions copyWith({
    bool? inverted,
    bool? showContour,
    double? threshold,
    double? noiseReduction,
    bool? removeBg,
  }) {
    return ProcessingOptions(
      inverted: inverted ?? this.inverted,
      showContour: showContour ?? this.showContour,
      threshold: threshold ?? this.threshold,
      noiseReduction: noiseReduction ?? this.noiseReduction,
      removeBg: removeBg ?? this.removeBg,
    );
  }

  @override
  List<Object?> get props => [inverted, showContour, threshold, noiseReduction, removeBg];
}



=======================================
./lib/domain/models/common/date_range_filter.dart
=======================================
import 'package:flutter/material.dart';

class DateRangeFilter {
  final DateRangePreset? preset;
  final DateTime? start; // Match these parameter names
  final DateTime? end; // with the ones used in constructor

  const DateRangeFilter({
    this.preset,
    this.start,
    this.end,
  });

  // 创建一个空过滤器的工厂方法
  factory DateRangeFilter.empty() => const DateRangeFilter();

  // 创建一个"从某天开始"的工厂方法
  factory DateRangeFilter.fromDate(DateTime startDate) {
    return DateRangeFilter(start: startDate);
  }

  factory DateRangeFilter.fromJson(Map<String, dynamic> json) {
    return DateRangeFilter(
      start: json['start'] != null ? DateTime.parse(json['start']) : null,
      end: json['end'] != null ? DateTime.parse(json['end']) : null,
      preset: json['preset'] != null
          ? DateRangePreset.values.byName(json['preset'])
          : null,
    );
  }

  factory DateRangeFilter.preset(DateRangePreset preset) {
    return DateRangeFilter(preset: preset);
  }

  // 创建一个"截止到今天"的工厂方法
  factory DateRangeFilter.untilToday() {
    return DateRangeFilter(end: DateTime.now());
  }

  // 添加日期区间长度计算
  int? get dayCount {
    final range = effectiveRange;
    if (range == null) return null;
    return range.duration.inDays + 1;
  }

  // 添加格式化显示文本
  String get displayText {
    if (preset != null) {
      return preset!.label;
    }

    if (start != null && end != null) {
      return '${_formatDate(start!)} 至 ${_formatDate(end!)}';
    } else if (start != null) {
      return '${_formatDate(start!)} 之后';
    } else if (end != null) {
      return '${_formatDate(end!)} 之前';
    }

    return '全部时间';
  }

  DateTimeRange? get effectiveRange {
    if (preset != null) {
      return preset!.getRange();
    }

    if (start != null || end != null) {
      return DateTimeRange(
        start: start ?? DateTime(1900),
        end: end ?? DateTime.now(),
      );
    }

    return null;
  }

  @override
  int get hashCode => Object.hash(preset, start, end);

  bool get isEmpty => start == null && end == null && preset == null;

  // 添加日期校验
  bool get isValid {
    if (preset != null) return true;
    if (start != null && end != null) {
      return !start!.isAfter(end!);
    }
    return true;
  }

  // 添加相等性比较
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    return other is DateRangeFilter &&
        other.preset == preset &&
        other.start == start &&
        other.end == end;
  }

  bool contains(DateTime date) {
    final range = effectiveRange;
    if (range == null) return true;
    return !date.isBefore(range.start) && !date.isAfter(range.end);
  }

  DateRangeFilter copyWith({
    DateTime? Function()? startDate,
    DateTime? Function()? endDate,
    DateRangePreset? Function()? preset,
  }) {
    return DateRangeFilter(
      start: startDate != null ? startDate() : start,
      end: endDate != null ? endDate() : end,
      preset: preset != null ? preset() : this.preset,
    );
  }

  Map<String, dynamic> toJson() => {
        'start': start?.toIso8601String(),
        'end': end?.toIso8601String(),
        'preset': preset?.name,
      };

  // 辅助方法：格式化日期
  String _formatDate(DateTime date) {
    return '${date.year}-${date.month.toString().padLeft(2, '0')}-'
        '${date.day.toString().padLeft(2, '0')}';
  }
}

enum DateRangePreset {
  today,
  yesterday,
  thisWeek,
  lastWeek,
  thisMonth,
  lastMonth,
  thisYear,
  lastYear,
  last7Days,
  last30Days,
  last90Days,
  last365Days,
  all,
}

extension DateRangePresetX on DateRangePreset {
  String get label => switch (this) {
        DateRangePreset.today => '今天',
        DateRangePreset.yesterday => '昨天',
        DateRangePreset.last7Days => '最近7天',
        DateRangePreset.last30Days => '最近30天',
        DateRangePreset.last90Days => '最近90天',
        DateRangePreset.last365Days => '最近一年',
        DateRangePreset.thisMonth => '本月',
        DateRangePreset.lastMonth => '上月',
        DateRangePreset.thisYear => '今年',
        DateRangePreset.lastYear => '去年',
        DateRangePreset.thisWeek => '本周',
        DateRangePreset.lastWeek => '上周',
        DateRangePreset.all => '全部时间',
      };

  DateTimeRange getRange() {
    final now = DateTime.now();
    return switch (this) {
      DateRangePreset.today => DateTimeRange(
          start: DateTime(now.year, now.month, now.day),
          end: now,
        ),
      DateRangePreset.yesterday => DateTimeRange(
          start: DateTime(now.year, now.month, now.day - 1),
          end: DateTime(now.year, now.month, now.day),
        ),
      DateRangePreset.thisWeek => DateTimeRange(
          start: DateTime(now.year, now.month, now.day - now.weekday + 1),
          end: now,
        ),
      DateRangePreset.lastWeek => DateTimeRange(
          start: DateTime(now.year, now.month, now.day - now.weekday - 6),
          end: DateTime(now.year, now.month, now.day - now.weekday),
        ),
      DateRangePreset.thisMonth => DateTimeRange(
          start: DateTime(now.year, now.month, 1),
          end: now,
        ),
      DateRangePreset.lastMonth => DateTimeRange(
          start: DateTime(now.year, now.month - 1, 1),
          end: DateTime(now.year, now.month, 0),
        ),
      DateRangePreset.thisYear => DateTimeRange(
          start: DateTime(now.year, 1, 1),
          end: now,
        ),
      DateRangePreset.lastYear => DateTimeRange(
          start: DateTime(now.year - 1, 1, 1),
          end: DateTime(now.year - 1, 12, 31),
        ),
      DateRangePreset.last7Days => DateTimeRange(
          start: now.subtract(const Duration(days: 7)),
          end: now,
        ),
      DateRangePreset.last30Days => DateTimeRange(
          start: now.subtract(const Duration(days: 30)),
          end: now,
        ),
      DateRangePreset.last90Days => DateTimeRange(
          start: now.subtract(const Duration(days: 90)),
          end: now,
        ),
      DateRangePreset.last365Days => DateTimeRange(
          start: now.subtract(const Duration(days: 365)),
          end: now,
        ),
      DateRangePreset.all => DateTimeRange(
          start: DateTime(1900),
          end: now,
        ),
    };
  }
}



=======================================
./lib/domain/models/common/size.dart
=======================================
import 'package:freezed_annotation/freezed_annotation.dart';

part 'size.freezed.dart';
part 'size.g.dart';

@freezed
class Size with _$Size {
  const factory Size({
    required int width,
    required int height,
  }) = _Size;

  factory Size.create({
    required int width,
    required int height,
  }) {
    return Size(
      width: width,
      height: height,
    );
  }

  factory Size.fromJson(Map<String, dynamic> json) => _$SizeFromJson(json);

  const Size._();
}



=======================================
./lib/domain/models/common/sort_option.dart
=======================================
import 'package:freezed_annotation/freezed_annotation.dart';

import '../../enums/sort_field.dart';

part 'sort_option.freezed.dart';
part 'sort_option.g.dart';

SortField _sortFieldFromJson(dynamic value) {
  if (value is SortField) return value;
  final str = value?.toString() ?? '';
  return SortFieldParsing.fromString(str);
}

String _sortFieldToJson(SortField field) => field.value;

/// 排序选项
@freezed
class SortOption with _$SortOption {
  /// 按创建时间降序(默认排序)
  static const defaultOption = SortOption();

  const factory SortOption({
    @Default(SortField.createTime)
    @JsonKey(fromJson: _sortFieldFromJson, toJson: _sortFieldToJson)
    SortField field,
    @Default(true) bool descending,
  }) = _SortOption;

  factory SortOption.fromJson(Map<String, dynamic> json) =>
      _$SortOptionFromJson(json);

  const SortOption._();

  /// 是否是默认排序
  bool get isDefault => field == SortField.createTime && descending;

  /// 切换排序方向
  SortOption toggleDirection() => copyWith(descending: !descending);

  /// 切换排序字段
  SortOption withField(SortField field) => copyWith(field: field);
}



=======================================
./lib/domain/models/practice/char_element.dart
=======================================
import 'package:freezed_annotation/freezed_annotation.dart';

import 'char_position.dart';
import 'char_style.dart';
import 'char_transform.dart';

part 'char_element.freezed.dart';
part 'char_element.g.dart';

/// 字符元素
@freezed
class CharElement with _$CharElement {
  const factory CharElement({
    /// 字符ID
    required String charId,

    /// 相对位置
    required CharPosition position,

    /// 变换信息
    @Default(CharTransform()) CharTransform transform,

    /// 样式信息
    @Default(CharStyle()) CharStyle style,
  }) = _CharElement;

  /// 从JSON创建实例
  factory CharElement.fromJson(Map<String, dynamic> json) =>
      _$CharElementFromJson(json);

  /// 创建标准字符元素
  factory CharElement.standard({
    required String charId,
    double offsetX = 0,
    double offsetY = 0,
  }) {
    return CharElement(
      charId: charId,
      position: CharPosition(
        offsetX: offsetX,
        offsetY: offsetY,
      ),
    );
  }

  const CharElement._();

  /// 移动字符
  CharElement move(double dx, double dy) {
    return copyWith(
      position: position.copyWith(
        offsetX: position.offsetX + dx,
        offsetY: position.offsetY + dy,
      ),
    );
  }

  /// 旋转字符
  CharElement rotate(double angle) {
    return copyWith(
      transform: transform.rotate(angle),
    );
  }

  /// 缩放字符
  CharElement scale(double sx, double sy) {
    return copyWith(
      transform: transform.scale(sx, sy),
    );
  }

  /// 设置颜色
  CharElement setColor(String color) {
    return copyWith(
      style: style.setColor(color),
    );
  }

  /// 设置自定义样式
  CharElement setCustomStyle(String key, dynamic value) {
    return copyWith(
      style: style.setCustomStyle(key, value),
    );
  }

  /// 设置不透明度
  CharElement setOpacity(double opacity) {
    return copyWith(
      style: style.setOpacity(opacity),
    );
  }
}



=======================================
./lib/domain/models/practice/char_position.dart
=======================================
import 'package:freezed_annotation/freezed_annotation.dart';

part 'char_position.freezed.dart';
part 'char_position.g.dart';

/// 字符位置
@freezed
class CharPosition with _$CharPosition {
  const factory CharPosition({
    /// X轴偏移量
    required double offsetX,

    /// Y轴偏移量
    required double offsetY,
  }) = _CharPosition;

  /// 从JSON创建实例
  factory CharPosition.fromJson(Map<String, dynamic> json) =>
      _$CharPositionFromJson(json);

  const CharPosition._();
}



=======================================
./lib/domain/models/practice/char_style.dart
=======================================
import 'package:freezed_annotation/freezed_annotation.dart';

part 'char_style.freezed.dart';
part 'char_style.g.dart';

/// 字符样式
@freezed
class CharStyle with _$CharStyle {
  const factory CharStyle({
    /// 颜色，默认黑色
    @Default('#000000') String color,

    /// 不透明度，默认完全不透明
    @Default(1.0) double opacity,

    /// 自定义样式属性
    @Default({}) Map<String, dynamic> customStyle,
  }) = _CharStyle;

  /// 从JSON创建实例
  factory CharStyle.fromJson(Map<String, dynamic> json) =>
      _$CharStyleFromJson(json);

  const CharStyle._();

  /// 删除自定义样式属性
  CharStyle removeCustomStyle(String key) {
    final newCustomStyle = Map<String, dynamic>.from(customStyle);
    newCustomStyle.remove(key);
    return copyWith(customStyle: newCustomStyle);
  }

  /// 设置颜色
  CharStyle setColor(String newColor) {
    return copyWith(color: newColor);
  }

  /// 设置自定义样式属性
  CharStyle setCustomStyle(String key, dynamic value) {
    final newCustomStyle = Map<String, dynamic>.from(customStyle);
    newCustomStyle[key] = value;
    return copyWith(customStyle: newCustomStyle);
  }

  /// 设置不透明度
  CharStyle setOpacity(double newOpacity) {
    return copyWith(opacity: newOpacity.clamp(0.0, 1.0));
  }
}



=======================================
./lib/domain/models/practice/char_transform.dart
=======================================
import 'package:freezed_annotation/freezed_annotation.dart';

part 'char_transform.freezed.dart';
part 'char_transform.g.dart';

/// 字符变换
@freezed
class CharTransform with _$CharTransform {
  const factory CharTransform({
    /// X轴缩放
    @Default(1.0) double scaleX,

    /// Y轴缩放
    @Default(1.0) double scaleY,

    /// 旋转角度
    @Default(0.0) double rotation,
  }) = _CharTransform;

  /// 从JSON创建实例
  factory CharTransform.fromJson(Map<String, dynamic> json) =>
      _$CharTransformFromJson(json);

  const CharTransform._();

  /// 旋转
  CharTransform rotate(double angle) {
    return copyWith(
      rotation: rotation + angle,
    );
  }

  /// 按比例缩放
  CharTransform scale(double sx, double sy) {
    return copyWith(
      scaleX: scaleX * sx,
      scaleY: scaleY * sy,
    );
  }
}



=======================================
./lib/domain/models/practice/element_content.dart
=======================================
import 'package:freezed_annotation/freezed_annotation.dart';

import 'char_element.dart';
import 'image_element.dart';
import 'text_element.dart';

part 'element_content.freezed.dart';
part 'element_content.g.dart';

/// 元素内容基类
@unfreezed
class ElementContent with _$ElementContent {
  /// 字符内容
  @FreezedUnionValue('chars')
  factory ElementContent.chars({
    /// 字符列表
    @Default([]) List<CharElement> chars,
  }) = CharsContent;

  /// 从JSON创建实例
  factory ElementContent.fromJson(Map<String, dynamic> json) =>
      _$ElementContentFromJson(json);

  /// 图片内容
  @FreezedUnionValue('image')
  factory ElementContent.image({
    /// 图片对象
    required ImageElement image,
  }) = ImageContent;

  /// 文本内容
  @FreezedUnionValue('text')
  factory ElementContent.text({
    /// 文本对象
    required TextElement text,
  }) = TextContent;

  const ElementContent._();
}

/// CharsContent 扩展方法
extension CharsContentX on CharsContent {
  /// 添加字符
  CharsContent addChar(CharElement char) {
    return copyWith(chars: [...chars, char]);
  }

  /// 清空字符
  CharsContent clearChars() {
    return copyWith(chars: const []);
  }

  /// 移除字符
  CharsContent removeChar(String id) {
    return copyWith(
      chars: chars.where((c) => c.charId != id).toList(),
    );
  }

  /// 更新字符
  CharsContent updateChar(CharElement char) {
    return copyWith(
      chars: chars.map((c) => c.charId == char.charId ? char : c).toList(),
    );
  }
}



=======================================
./lib/domain/models/practice/element_geometry.dart
=======================================
import 'package:freezed_annotation/freezed_annotation.dart';

part 'element_geometry.freezed.dart';
part 'element_geometry.g.dart';

/// 元素几何属性
@freezed
class ElementGeometry with _$ElementGeometry {
  const factory ElementGeometry({
    /// X坐标
    @Default(0.0) double x,

    /// Y坐标
    @Default(0.0) double y,

    /// 宽度
    @Default(100.0) double width,

    /// 高度
    @Default(100.0) double height,

    /// 旋转角度(弧度)
    @Default(0.0) double rotation,

    /// 缩放
    @Default(1.0) double scale,
  }) = _ElementGeometry;

  /// 从JSON创建实例
  factory ElementGeometry.fromJson(Map<String, dynamic> json) =>
      _$ElementGeometryFromJson(json);

  const ElementGeometry._();

  /// 获取下边界
  double get bottom => y + height;

  /// 获取中心点X坐标
  double get centerX => x + width / 2;

  /// 获取中心点Y坐标
  double get centerY => y + height / 2;

  /// 获取右边界
  double get right => x + width;

  /// 判断点是否在边界内
  bool containsPoint(double px, double py) {
    return px >= x && px <= right && py >= y && py <= bottom;
  }

  /// 移动元素
  ElementGeometry move(double dx, double dy) {
    return copyWith(
      x: x + dx,
      y: y + dy,
    );
  }

  /// 调整大小
  ElementGeometry resize(double width, double height) {
    return copyWith(
      width: width,
      height: height,
    );
  }

  /// 旋转
  ElementGeometry rotate(double angle) {
    return copyWith(
      rotation: rotation + angle,
    );
  }

  /// 设置缩放
  ElementGeometry setScale(double scale) {
    return copyWith(
      scale: scale,
    );
  }
}



=======================================
./lib/domain/models/practice/element_style.dart
=======================================
import 'package:freezed_annotation/freezed_annotation.dart';

part 'element_style.freezed.dart';
part 'element_style.g.dart';

/// 元素的样式属性
@freezed
class ElementStyle with _$ElementStyle {
  const factory ElementStyle({
    /// 透明度
    @Default(1.0) double opacity,

    /// 是否可见
    @Default(true) bool visible,

    /// 是否锁定
    @Default(false) bool locked,

    /// 自定义样式属性
    @Default({}) Map<String, dynamic> properties,
  }) = _ElementStyle;

  /// 从JSON创建实例
  factory ElementStyle.fromJson(Map<String, dynamic> json) =>
      _$ElementStyleFromJson(json);

  const ElementStyle._();

  /// 移除样式属性
  ElementStyle removeProperty(String key) {
    final newProperties = Map<String, dynamic>.from(properties);
    newProperties.remove(key);
    return copyWith(properties: newProperties);
  }

  /// 设置锁定状态
  ElementStyle setLocked(bool value) => copyWith(locked: value);

  /// 设置透明度
  ElementStyle setOpacity(double value) => copyWith(opacity: value);

  /// 设置样式属性
  ElementStyle setProperty(String key, dynamic value) {
    final newProperties = Map<String, dynamic>.from(properties);
    newProperties[key] = value;
    return copyWith(properties: newProperties);
  }

  /// 设置可见性
  ElementStyle setVisible(bool value) => copyWith(visible: value);
}



=======================================
./lib/domain/models/practice/image_element.dart
=======================================
import 'package:freezed_annotation/freezed_annotation.dart';

part 'image_element.freezed.dart';
part 'image_element.g.dart';

/// 图片元素
@freezed
class ImageElement with _$ImageElement {
  const factory ImageElement({
    /// 图片ID
    required String imageId,

    /// 图片URL
    required String url,

    /// 图片原始宽度
    required int width,

    /// 图片原始高度
    required int height,

    /// 图片MIME类型
    @Default('image/jpeg') String mimeType,

    /// 不透明度
    @Default(1.0) double opacity,

    /// 自定义属性
    @Default({}) Map<String, dynamic> customProps,
  }) = _ImageElement;

  /// 从JSON创建实例
  factory ImageElement.fromJson(Map<String, dynamic> json) =>
      _$ImageElementFromJson(json);

  const ImageElement._();

  /// 获取宽高比
  double get aspectRatio => width / height;

  /// 获取自定义属性
  T? getCustomProp<T>(String key) => customProps[key] as T?;

  /// 移除自定义属性
  ImageElement removeCustomProp(String key) {
    final newProps = Map<String, dynamic>.from(customProps);
    newProps.remove(key);
    return copyWith(customProps: newProps);
  }

  /// 设置自定义属性
  ImageElement setCustomProp(String key, dynamic value) {
    final newProps = Map<String, dynamic>.from(customProps);
    newProps[key] = value;
    return copyWith(customProps: newProps);
  }

  /// 设置不透明度
  ImageElement withOpacity(double value) =>
      copyWith(opacity: value.clamp(0.0, 1.0));
}



=======================================
./lib/domain/models/practice/practice_element.dart
=======================================
import 'package:freezed_annotation/freezed_annotation.dart';

import 'element_content.dart';
import 'element_geometry.dart';
import 'element_style.dart';

part 'practice_element.freezed.dart';
part 'practice_element.g.dart';

/// 练习元素
@freezed
class PracticeElement with _$PracticeElement {
  const factory PracticeElement({
    /// 元素ID
    required String id,

    /// 元素类型
    @JsonKey(name: 'type') required String elementType,

    /// 元素几何属性
    required ElementGeometry geometry,

    /// 元素样式
    required ElementStyle style,

    /// 元素内容
    required ElementContent content,

    /// 创建时间
    @Default(0) int createTime,

    /// 更新时间
    @Default(0) int updateTime,
  }) = _PracticeElement;

  /// 创建字符元素
  factory PracticeElement.chars({
    required String id,
    required ElementContent content,
    ElementGeometry? geometry,
    ElementStyle? style,
  }) {
    return PracticeElement(
      id: id,
      elementType: 'chars',
      geometry: geometry ?? const ElementGeometry(),
      style: style ?? const ElementStyle(),
      content: content,
      createTime: DateTime.now().millisecondsSinceEpoch,
      updateTime: DateTime.now().millisecondsSinceEpoch,
    );
  }

  /// 从JSON创建实例
  factory PracticeElement.fromJson(Map<String, dynamic> json) =>
      _$PracticeElementFromJson(json);

  /// 创建图片元素
  factory PracticeElement.image({
    required String id,
    required ElementContent content,
    ElementGeometry? geometry,
    ElementStyle? style,
  }) {
    return PracticeElement(
      id: id,
      elementType: 'image',
      geometry: geometry ?? const ElementGeometry(),
      style: style ?? const ElementStyle(),
      content: content,
      createTime: DateTime.now().millisecondsSinceEpoch,
      updateTime: DateTime.now().millisecondsSinceEpoch,
    );
  }

  /// 创建文本元素
  factory PracticeElement.text({
    required String id,
    required ElementContent content,
    ElementGeometry? geometry,
    ElementStyle? style,
  }) {
    return PracticeElement(
      id: id,
      elementType: 'text',
      geometry: geometry ?? const ElementGeometry(),
      style: style ?? const ElementStyle(),
      content: content,
      createTime: DateTime.now().millisecondsSinceEpoch,
      updateTime: DateTime.now().millisecondsSinceEpoch,
    );
  }

  const PracticeElement._();

  /// 移动元素
  PracticeElement move(double dx, double dy) {
    return copyWith(
      geometry: geometry.move(dx, dy),
      updateTime: DateTime.now().millisecondsSinceEpoch,
    );
  }

  /// 调整大小
  PracticeElement resize(double width, double height) {
    return copyWith(
      geometry: geometry.resize(width, height),
      updateTime: DateTime.now().millisecondsSinceEpoch,
    );
  }

  /// 旋转
  PracticeElement rotate(double angle) {
    return copyWith(
      geometry: geometry.rotate(angle),
      updateTime: DateTime.now().millisecondsSinceEpoch,
    );
  }

  /// 更新时间戳
  PracticeElement touch() {
    return copyWith(
      updateTime: DateTime.now().millisecondsSinceEpoch,
    );
  }
}



=======================================
./lib/domain/models/practice/practice_entity.dart
=======================================
import 'package:freezed_annotation/freezed_annotation.dart';

import 'practice_page.dart';

part 'practice_entity.freezed.dart';
part 'practice_entity.g.dart';

/// 字帖练习实体
@freezed
class PracticeEntity with _$PracticeEntity {
  /// 创建实例
  const factory PracticeEntity({
    /// ID
    required String id,

    /// 标题
    required String title,

    /// 页面列表
    @Default([]) List<PracticePage> pages,

    /// 标签列表
    @Default([]) List<String> tags,

    /// 状态
    @Default('active') String status,

    /// 创建时间
    required DateTime createTime,

    /// 更新时间
    required DateTime updateTime,
  }) = _PracticeEntity;

  /// 新建练习，自动生成ID和时间戳
  factory PracticeEntity.create({
    required String title,
    List<String> tags = const [],
    String status = 'active',
  }) {
    final now = DateTime.now();
    return PracticeEntity(
      id: DateTime.now().millisecondsSinceEpoch.toString(),
      title: title,
      tags: tags,
      status: status,
      createTime: now,
      updateTime: now,
    );
  }

  /// 从JSON创建实例
  factory PracticeEntity.fromJson(Map<String, dynamic> json) =>
      _$PracticeEntityFromJson(json);

  /// 私有构造函数
  const PracticeEntity._();

  /// 获取下一个可用的页面索引
  int get nextPageIndex => pages.isEmpty ? 0 : pages.last.index + 1;

  /// 获取页面数量
  int get pageCount => pages.length;

  /// 添加页面
  PracticeEntity addPage(PracticePage page) {
    return copyWith(
      pages: [...pages, page],
      updateTime: DateTime.now(),
    );
  }

  /// 删除页面
  PracticeEntity removePage(int index) {
    return copyWith(
      pages: pages.where((p) => p.index != index).toList(),
      updateTime: DateTime.now(),
    );
  }

  /// 用于显示的文本描述
  @override
  String toString() => 'PracticeEntity(id: $id, title: $title)';

  /// 更新页面
  PracticeEntity updatePage(PracticePage page) {
    return copyWith(
      pages: pages.map((p) => p.index == page.index ? page : p).toList(),
      updateTime: DateTime.now(),
    );
  }
}



=======================================
./lib/domain/models/practice/practice_filter.dart
=======================================
import 'package:freezed_annotation/freezed_annotation.dart';

part 'practice_filter.freezed.dart';
part 'practice_filter.g.dart';

/// 字帖练习过滤器
@freezed
class PracticeFilter with _$PracticeFilter {
  const factory PracticeFilter({
    /// 标题关键词
    String? keyword,

    /// 标签列表
    @Default([]) List<String> tags,

    /// 开始时间
    DateTime? startTime,

    /// 结束时间
    DateTime? endTime,

    /// 状态
    String? status,

    /// 分页大小
    @Default(20) int limit,

    /// 偏移量
    @Default(0) int offset,

    /// 排序字段
    @Default('createTime') String sortField,

    /// 排序方向(asc/desc)
    @Default('desc') String sortOrder,
  }) = _PracticeFilter;

  /// 从JSON创建实例
  factory PracticeFilter.fromJson(Map<String, dynamic> json) =>
      _$PracticeFilterFromJson(json);

  const PracticeFilter._();
}



=======================================
./lib/domain/models/practice/practice_layer.dart
=======================================
import 'package:demo/domain/models/practice/practice_element.dart';
import 'package:freezed_annotation/freezed_annotation.dart';

part 'practice_layer.freezed.dart';
part 'practice_layer.g.dart';

/// 字帖练习图层
@freezed
class PracticeLayer with _$PracticeLayer {
  const factory PracticeLayer({
    /// 图层ID
    required String id,

    /// 图层类型
    required PracticeLayerType type,

    /// 图片路径
    required String imagePath,

    /// 图层名称
    String? name,

    /// 图层描述
    String? description,

    /// 图层可见性
    @Default(true) bool visible,

    /// 图层锁定状态
    @Default(false) bool locked,

    /// 图层不透明度
    @Default(1.0) double opacity,

    /// 图层顺序
    @Default(0) int order,

    /// 图层元素列表
    @Default([]) List<PracticeElement> elements,

    /// 图层创建时间
    required DateTime createTime,

    /// 图层更新时间
    required DateTime updateTime,
  }) = _PracticeLayer;

  /// 新建图层
  factory PracticeLayer.create({
    required PracticeLayerType type,
    required String imagePath,
    String? name,
    String? description,
  }) {
    final now = DateTime.now();
    return PracticeLayer(
      id: DateTime.now().millisecondsSinceEpoch.toString(),
      type: type,
      imagePath: imagePath,
      name: name,
      description: description,
      createTime: now,
      updateTime: now,
    );
  }

  /// 从JSON创建实例
  factory PracticeLayer.fromJson(Map<String, dynamic> json) =>
      _$PracticeLayerFromJson(json);

  /// 私有构造函数
  const PracticeLayer._();

  /// 切换锁定状态
  PracticeLayer toggleLock() {
    return copyWith(locked: !locked);
  }

  /// 切换可见性
  PracticeLayer toggleVisibility() {
    return copyWith(visible: !visible);
  }
}

/// 字帖练习图层类型
enum PracticeLayerType {
  /// 原稿图层
  source,

  /// 练习图层
  practice,

  /// 参考图层
  reference,
}



=======================================
./lib/domain/models/practice/practice_page.dart
=======================================
import 'package:freezed_annotation/freezed_annotation.dart';

import 'practice_layer.dart';

part 'practice_page.freezed.dart';
part 'practice_page.g.dart';

/// 页面尺寸
@freezed
class PageSize with _$PageSize {
  const factory PageSize({
    /// 尺寸单位 (例如: 'mm')
    @Default('mm') String unit,

    /// 分辨率单位 (例如: 'dpi')
    @Default('dpi') String resUnit,

    /// 分辨率单位值
    @Default(300) int resUnitValue,

    /// 宽度 (默认A4宽度210mm)
    @Default(210.0) double width,

    /// 高度 (默认A4高度297mm)
    @Default(297.0) double height,
  }) = _PageSize;

  /// 从JSON创建实例
  factory PageSize.fromJson(Map<String, dynamic> json) =>
      _$PageSizeFromJson(json);

  const PageSize._();
}

/// 字帖页面信息
@freezed
class PracticePage with _$PracticePage {
  const factory PracticePage({
    /// 页面序号
    required int index,

    /// 页面尺寸
    @Default(PageSize()) PageSize size,

    /// 页面图层列表
    @Default([]) List<PracticeLayer> layers,

    /// 创建时间
    @JsonKey(name: 'create_time') required DateTime createTime,

    /// 更新时间
    @JsonKey(name: 'update_time') required DateTime updateTime,
  }) = _PracticePage;

  /// 创建新页面
  factory PracticePage.create(int index, {PageSize? size}) {
    final now = DateTime.now();
    return PracticePage(
      index: index,
      size: size ?? const PageSize(),
      createTime: now,
      updateTime: now,
    );
  }

  /// 从JSON创建实例
  factory PracticePage.fromJson(Map<String, dynamic> json) =>
      _$PracticePageFromJson(json);

  const PracticePage._();

  /// 获取图层数量
  int get layerCount => layers.length;

  /// 添加图层
  PracticePage addLayer(PracticeLayer layer) {
    return copyWith(
      layers: [...layers, layer],
      updateTime: DateTime.now(),
    );
  }

  /// 删除图层
  PracticePage removeLayer(String layerId) {
    return copyWith(
      layers: layers.where((l) => l.id != layerId).toList(),
      updateTime: DateTime.now(),
    );
  }

  /// 更新图层
  PracticePage updateLayer(PracticeLayer layer) {
    return copyWith(
      layers: layers.map((l) => l.id == layer.id ? layer : l).toList(),
      updateTime: DateTime.now(),
    );
  }
}



=======================================
./lib/domain/models/practice/text_element.dart
=======================================
import 'dart:ui';

import 'package:freezed_annotation/freezed_annotation.dart';

part 'text_element.freezed.dart';
part 'text_element.g.dart';

/// 文本元素
@freezed
class TextElement with _$TextElement {
  const factory TextElement({
    /// 文本内容
    required String text,

    /// 字体名称
    @Default('Arial') String fontFamily,

    /// 字体大小
    @Default(14.0) double fontSize,

    /// 字体颜色
    @Default('#000000') String color,

    /// 文本对齐方式
    @Default(TextAlign.left) TextAlign textAlign,

    /// 是否加粗
    @Default(false) bool bold,

    /// 是否斜体
    @Default(false) bool italic,

    /// 是否下划线
    @Default(false) bool underline,

    /// 行高
    @Default(1.2) double lineHeight,

    /// 字间距
    @Default(0.0) double letterSpacing,

    /// 自定义样式属性
    @Default({}) Map<String, dynamic> customStyle,
  }) = _TextElement;

  /// 从JSON创建实例
  factory TextElement.fromJson(Map<String, dynamic> json) =>
      _$TextElementFromJson(json);

  /// 简单文本
  factory TextElement.simple(String text) => TextElement(text: text);

  const TextElement._();

  /// 移除自定义样式
  TextElement removeCustomStyle(String key) {
    final newCustomStyle = Map<String, dynamic>.from(customStyle);
    newCustomStyle.remove(key);
    return copyWith(customStyle: newCustomStyle);
  }

  /// 设置对齐
  TextElement withAlign(TextAlign align) => copyWith(textAlign: align);

  /// 设置加粗
  TextElement withBold(bool bold) => copyWith(bold: bold);

  /// 设置颜色
  TextElement withColor(String color) => copyWith(color: color);

  /// 设置自定义样式
  TextElement withCustomStyle(String key, dynamic value) {
    final newCustomStyle = Map<String, dynamic>.from(customStyle);
    newCustomStyle[key] = value;
    return copyWith(customStyle: newCustomStyle);
  }

  /// 设置字体
  TextElement withFont(String fontFamily) => copyWith(fontFamily: fontFamily);

  /// 设置斜体
  TextElement withItalic(bool italic) => copyWith(italic: italic);

  /// 设置字间距
  TextElement withLetterSpacing(double spacing) =>
      copyWith(letterSpacing: spacing);

  /// 设置行高
  TextElement withLineHeight(double lineHeight) =>
      copyWith(lineHeight: lineHeight);

  /// 设置字号
  TextElement withSize(double fontSize) => copyWith(fontSize: fontSize);

  /// 设置下划线
  TextElement withUnderline(bool underline) => copyWith(underline: underline);
}



=======================================
./lib/domain/models/work/work_entity.dart
=======================================
import 'package:freezed_annotation/freezed_annotation.dart';

import '../../enums/work_status.dart';
import '../../enums/work_style.dart';
import '../../enums/work_tool.dart';
import '../character/character_entity.dart';
import 'work_image.dart';

part 'work_entity.freezed.dart';
part 'work_entity.g.dart';

WorkStyle _workStyleFromJson(dynamic value) => WorkStyle.fromValue(value);

/// 枚举序列化辅助方法
String _workStyleToJson(WorkStyle style) => style.value;
WorkTool _workToolFromJson(dynamic value) => WorkTool.fromValue(value);
String _workToolToJson(WorkTool tool) => tool.value;

/// 作品实体
@freezed
class WorkEntity with _$WorkEntity {
  const factory WorkEntity({
    /// ID
    required String id,

    /// 标题
    required String title,

    /// 作者
    required String author,

    /// 备注
    String? remark,

    /// 字体
    @JsonKey(fromJson: _workStyleFromJson, toJson: _workStyleToJson)
    required WorkStyle style,

    /// 工具
    @JsonKey(fromJson: _workToolFromJson, toJson: _workToolToJson)
    required WorkTool tool,

    /// 创作日期

    required DateTime creationDate,

    /// 创建时间

    required DateTime createTime,

    /// 修改时间

    required DateTime updateTime,

    /// 图片最后更新时间

    DateTime? lastImageUpdateTime,

    /// 状态
    @Default(WorkStatus.draft) WorkStatus status,

    /// 首图ID
    String? firstImageId,

    /// 图片列表
    @Default([]) List<WorkImage> images,

    /// 关联字符列表

    @Default([]) List<CharacterEntity> collectedChars,

    /// 标签列表
    @Default([]) List<String> tags,

    /// 图片数量
    int? imageCount,
  }) = _WorkEntity;

  factory WorkEntity.fromJson(Map<String, dynamic> json) =>
      _$WorkEntityFromJson(json);

  const WorkEntity._();

  /// 获取首图
  WorkImage? get firstImage => images.isEmpty ? null : images[0];

  /// 获取图片总数量
  int get totalImages => imageCount ?? images.length;

  /// 添加关联字
  WorkEntity addCollectedChar(CharacterEntity char) {
    if (collectedChars.contains(char)) return this;
    return copyWith(collectedChars: [...collectedChars, char]);
  }

  /// 添加标签
  WorkEntity addTag(String tag) {
    if (tags.contains(tag)) return this;
    return copyWith(tags: [...tags, tag]);
  }

  /// 移除关联字
  WorkEntity removeCollectedChar(CharacterEntity char) {
    return copyWith(
        collectedChars: collectedChars.where((c) => c != char).toList());
  }

  /// 移除标签
  WorkEntity removeTag(String tag) {
    return copyWith(tags: tags.where((t) => t != tag).toList());
  }

  /// 更新首图
  WorkEntity updateFirstImage(String? firstImageId) =>
      copyWith(firstImageId: firstImageId);

  /// 更新标签
  WorkEntity updateTags(List<String> newTags) {
    return copyWith(tags: newTags);
  }
}



=======================================
./lib/domain/models/work/work_filter.dart
=======================================
import 'package:flutter/material.dart';
import 'package:freezed_annotation/freezed_annotation.dart';

import '../../enums/work_style.dart';
import '../../enums/work_tool.dart';
import '../common/date_range_filter.dart';
import '../common/sort_option.dart';

part 'work_filter.freezed.dart';
part 'work_filter.g.dart';

DateTimeRange? _dateRangeFromJson(dynamic value) {
  if (value == null) return null;
  if (value is DateTimeRange) return value;
  return DateTimeRange(
    start: DateTime.parse(value['start']),
    end: DateTime.parse(value['end']),
  );
}

DateRangePreset _dateRangePresetFromJson(dynamic value) {
  if (value is DateRangePreset) return value;
  final str = value?.toString() ?? '';
  return DateRangePreset.values.firstWhere(
    (e) => e.name == str,
    orElse: () => DateRangePreset.all,
  );
}

String _dateRangePresetToJson(DateRangePreset preset) => preset.name;

Map<String, dynamic>? _dateRangeToJson(DateTimeRange? range) {
  if (range == null) return null;
  return {
    'start': range.start.toIso8601String(),
    'end': range.end.toIso8601String()
  };
}

// 处理可空的风格值
WorkStyle? _workStyleFilterFromJson(dynamic value) {
  if (value == null || value.toString().isEmpty) return null;
  return WorkStyle.fromValue(value);
}

/// 枚举序列化辅助方法
String? _workStyleToJson(WorkStyle? style) => style?.value;

// 处理可空的工具值
WorkTool? _workToolFilterFromJson(dynamic value) {
  if (value == null || value.toString().isEmpty) return null;
  return WorkTool.fromValue(value);
}

String? _workToolToJson(WorkTool? tool) => tool?.value;

/// 作品筛选条件
@freezed
class WorkFilter with _$WorkFilter {
  const factory WorkFilter({
    /// 搜索关键字
    String? keyword,

    /// 作品风格
    @JsonKey(fromJson: _workStyleFilterFromJson, toJson: _workStyleToJson)
    WorkStyle? style,

    /// 创作工具
    @JsonKey(fromJson: _workToolFilterFromJson, toJson: _workToolToJson)
    WorkTool? tool,

    /// 标签
    @Default([]) List<String> tags,

    /// 创作日期区间
    @JsonKey(fromJson: _dateRangeFromJson, toJson: _dateRangeToJson)
    DateTimeRange? dateRange,

    /// 创建时间区间
    @JsonKey(fromJson: _dateRangeFromJson, toJson: _dateRangeToJson)
    DateTimeRange? createTimeRange,

    /// 修改时间区间
    @JsonKey(fromJson: _dateRangeFromJson, toJson: _dateRangeToJson)
    DateTimeRange? updateTimeRange,

    /// 日期预设
    @Default(DateRangePreset.all)
    @JsonKey(fromJson: _dateRangePresetFromJson, toJson: _dateRangePresetToJson)
    DateRangePreset datePreset,

    /// 排序选项
    @Default(SortOption()) SortOption sortOption,
  }) = _WorkFilter;

  factory WorkFilter.fromJson(Map<String, dynamic> json) =>
      _$WorkFilterFromJson(json);

  const WorkFilter._();

  /// 是否为空过滤器
  bool get isEmpty =>
      keyword == null &&
      style == null &&
      tool == null &&
      tags.isEmpty &&
      dateRange == null &&
      createTimeRange == null &&
      updateTimeRange == null &&
      datePreset == DateRangePreset.all &&
      sortOption.isDefault;

  /// 添加标签
  WorkFilter addTag(String tag) {
    if (tags.contains(tag)) return this;
    return copyWith(tags: [...tags, tag]);
  }

  /// 清除全部筛选
  WorkFilter clear() => const WorkFilter();

  /// 清除标签
  WorkFilter clearTags() => copyWith(tags: const []);

  /// 移除标签
  WorkFilter removeTag(String tag) {
    return copyWith(tags: [...tags]..remove(tag));
  }
}



=======================================
./lib/domain/models/work/work_image.dart
=======================================
import 'package:freezed_annotation/freezed_annotation.dart';
import 'package:path/path.dart' as p;

part 'work_image.freezed.dart';
part 'work_image.g.dart';

/// 作品图片
@freezed
class WorkImage with _$WorkImage {
  factory WorkImage({
    /// ID
    required String id,

    /// 关联的作品ID
    required String workId,

    /// 导入时的原始路径
    required String originalPath,

    /// 图片路径
    required String path,

    /// 缩略图路径
    required String thumbnailPath,

    /// 在作品中的序号
    required int index,

    /// 图片宽度
    required int width,

    /// 图片高度
    required int height,

    /// 文件格式
    required String format,

    /// 文件大小(字节)
    required int size,

    /// 创建时间
    required DateTime createTime,

    /// 更新时间
    required DateTime updateTime,
  }) = _WorkImage;

  /// 创建新图片
  @Deprecated('使用 WorkImage(...) 构造函数替代')
  factory WorkImage.create({
    required String id,
    required String workId,
    required String originalPath,
    required String path,
    required String thumbnailPath,
    required int index,
    required int width,
    required int height,
    required String format,
    required int size,
  }) =>
      WorkImage(
        id: id,
        workId: workId,
        originalPath: originalPath,
        path: path,
        thumbnailPath: thumbnailPath,
        index: index,
        width: width,
        height: height,
        format: format,
        size: size,
        createTime: DateTime.now(),
        updateTime: DateTime.now(),
      );

  factory WorkImage.fromJson(Map<String, dynamic> json) =>
      _$WorkImageFromJson(json);

  const WorkImage._();

  /// 目录路径
  String get directory => p.dirname(path);

  /// 扩展名
  String get extension {
    final ext = p.extension(path);
    return ext.isEmpty ? '' : ext.substring(1);
  }

  /// 文件名(含扩展名)
  String get filename => p.basename(path);

  /// 文件名(不含扩展名)
  String get name => p.basenameWithoutExtension(path);
}



=======================================
./lib/domain/models/work/work_metadata.dart
=======================================
import 'package:equatable/equatable.dart';

import '../../../domain/enums/work_style.dart';
import '../../../domain/enums/work_tool.dart';

/// 作品元数据
class WorkMetadata extends Equatable {
  /// 名称
  final String name;

  /// 作者
  final String author;

  /// 创作日期
  final DateTime? creationDate;

  /// 备注
  final String? remark;

  /// 风格
  final WorkStyle style;

  /// 工具
  final WorkTool tool;

  /// 标签
  final Set<String> tags;

  /// 创建作品元数据
  const WorkMetadata({
    required this.name,
    required this.author,
    required this.style,
    required this.tool,
    this.creationDate,
    this.remark,
    Set<String>? tags,
  }) : tags = tags ?? const {};

  /// 从JSON创建
  factory WorkMetadata.fromJson(Map<String, dynamic> json) {
    return WorkMetadata(
      name: json['name'] as String,
      author: json['author'] as String,
      style: WorkStyle.values.byName(json['style'] as String),
      tool: WorkTool.values.byName(json['tool'] as String),
      creationDate: json['creationDate'] == null
          ? null
          : DateTime.parse(json['creationDate'] as String),
      remark: json['remark'] as String?,
      tags: (json['tags'] as List<dynamic>?)?.map((e) => e as String).toSet() ??
          {},
    );
  }

  /// 检查是否有任何标签
  bool get hasTags => tags.isNotEmpty;

  @override
  List<Object?> get props => [
        name,
        author,
        style,
        tool,
        creationDate,
        remark,
        tags,
      ];

  /// 添加标签
  WorkMetadata addTag(String tag) {
    final newTags = Set<String>.from(tags)..add(tag);
    return copyWith(tags: newTags);
  }

  /// 复制
  WorkMetadata copyWith({
    String? name,
    String? author,
    WorkStyle? style,
    WorkTool? tool,
    DateTime? creationDate,
    String? remark,
    Set<String>? tags,
  }) {
    return WorkMetadata(
      name: name ?? this.name,
      author: author ?? this.author,
      style: style ?? this.style,
      tool: tool ?? this.tool,
      creationDate: creationDate ?? this.creationDate,
      remark: remark ?? this.remark,
      tags: tags ?? this.tags,
    );
  }

  /// 是否包含标签
  bool hasTag(String tag) => tags.contains(tag);

  /// 移除标签
  WorkMetadata removeTag(String tag) {
    final newTags = Set<String>.from(tags)..remove(tag);
    return copyWith(tags: newTags);
  }

  /// 转换为JSON
  Map<String, dynamic> toJson() {
    return {
      'name': name,
      'author': author,
      'style': style.name,
      'tool': tool.name,
      'creationDate': creationDate?.toIso8601String(),
      'remark': remark,
      'tags': tags.toList(),
    };
  }

  @override
  String toString() => 'WorkMetadata(name: $name, author: $author)';

  /// 更新标签
  WorkMetadata updateTags(Set<String> newTags) {
    return copyWith(tags: newTags);
  }
}



=======================================
./lib/domain/repositories/character_repository.dart
=======================================
import '../models/character/character_entity.dart';
import '../models/character/character_filter.dart';

/// 字形仓库接口
abstract class CharacterRepository {
  /// 关闭仓库
  Future<void> close();

  /// 获取字形数量
  Future<int> count(CharacterFilter? filter);

  /// 创建字形
  Future<CharacterEntity> create(CharacterEntity character);

  /// 删除字形
  Future<void> delete(String id);

  /// 批量删除
  Future<void> deleteMany(List<String> ids);

  /// 复制字形
  Future<CharacterEntity> duplicate(String id, {String? newId});

  /// 获取字形
  Future<CharacterEntity?> get(String id);

  /// 获取所有字形
  Future<List<CharacterEntity>> getAll();

  /// 获取所有标签
  Future<Set<String>> getAllTags();

  /// 根据标签获取字形
  Future<List<CharacterEntity>> getByTags(Set<String> tags);

  /// 根据作品ID获取字形
  Future<List<CharacterEntity>> getByWorkId(String workId);

  /// 条件查询
  Future<List<CharacterEntity>> query(CharacterFilter filter);

  /// 更新字形
  Future<CharacterEntity> save(CharacterEntity character);

  /// 批量更新
  Future<List<CharacterEntity>> saveMany(List<CharacterEntity> characters);

  /// 搜索字形
  Future<List<CharacterEntity>> search(String query, {int? limit});

  /// 标签建议
  Future<List<String>> suggestTags(String prefix, {int limit = 10});
}



=======================================
./lib/domain/repositories/practice_repository.dart
=======================================
import '../models/practice/practice_entity.dart';
import '../models/practice/practice_filter.dart';

/// 字帖练习仓库接口
abstract class PracticeRepository {
  /// 关闭仓库
  Future<void> close();

  /// 获取练习数量
  Future<int> count(PracticeFilter? filter);

  /// 创建练习
  Future<PracticeEntity> create(PracticeEntity practice);

  /// 删除练习
  Future<void> delete(String id);

  /// 批量删除
  Future<void> deleteMany(List<String> ids);

  /// 复制练习
  Future<PracticeEntity> duplicate(String id, {String? newId});

  /// 获取练习
  Future<PracticeEntity?> get(String id);

  /// 获取所有练习
  Future<List<PracticeEntity>> getAll();

  /// 获取所有标签
  Future<Set<String>> getAllTags();

  /// 获取某些标签的练习
  Future<List<PracticeEntity>> getByTags(Set<String> tags);

  /// 查询练习
  Future<List<PracticeEntity>> query(PracticeFilter filter);

  /// 更新练习
  Future<PracticeEntity> save(PracticeEntity practice);

  /// 批量更新
  Future<List<PracticeEntity>> saveMany(List<PracticeEntity> practices);

  /// 搜索练习
  Future<List<PracticeEntity>> search(String query, {int? limit});

  /// 标签建议
  Future<List<String>> suggestTags(String prefix, {int limit = 10});
}



=======================================
./lib/domain/repositories/repositories.dart
=======================================
/// 导出所有仓库接口
export 'character_repository.dart';
export 'practice_repository.dart';
export 'work_image_repository.dart';
export 'work_repository.dart';



=======================================
./lib/domain/repositories/settings_repository.dart
=======================================
/// 设置仓储接口
abstract class SettingsRepository {
  /// 删除设置值
  Future<void> deleteValue(String key);

  /// 获取设置值
  Future<String?> getValue(String key);

  /// 批量获取设置值
  Future<Map<String, String>> getValues(List<String> keys);

  /// 保存设置值
  Future<void> setValue(String key, String value);

  /// 批量保存设置值
  Future<void> setValues(Map<String, String> values);
}



=======================================
./lib/domain/repositories/work_image_repository.dart
=======================================
import '../models/work/work_image.dart';

/// WorkImage仓储接口
abstract class WorkImageRepository {
  /// 创建图片记录
  Future<WorkImage> create(String workId, WorkImage image);

  /// 批量创建
  Future<List<WorkImage>> createMany(String workId, List<WorkImage> images);

  /// 删除图片
  Future<void> delete(String workId, String imageId);

  /// 批量删除
  Future<void> deleteMany(String workId, List<String> imageIds);

  /// 获取图片
  Future<WorkImage?> get(String imageId);

  /// 获取作品的所有图片
  Future<List<WorkImage>> getAllByWorkId(String workId);

  /// 获取作品的第一张图片
  Future<WorkImage?> getFirstByWorkId(String workId);

  /// 获取下一个可用的索引号
  Future<int> getNextIndex(String workId);

  /// 批量更新
  Future<List<WorkImage>> saveMany(List<WorkImage> images);

  /// 更新图片索引
  Future<void> updateIndex(String workId, String imageId, int newIndex);
}



=======================================
./lib/domain/repositories/work_repository.dart
=======================================
import '../models/work/work_entity.dart';
import '../models/work/work_filter.dart';

/// 作品仓库接口
abstract class WorkRepository {
  /// 关闭仓库
  Future<void> close();

  /// 获取作品数量
  Future<int> count(WorkFilter? filter);

  /// 创建作品
  Future<WorkEntity> create(WorkEntity work);

  /// 删除作品
  Future<void> delete(String id);

  /// 批量删除
  Future<void> deleteMany(List<String> ids);

  /// 复制作品
  Future<WorkEntity> duplicate(String id, {String? newId});

  /// 获取作品
  Future<WorkEntity?> get(String id);

  /// 获取所有作品
  Future<List<WorkEntity>> getAll();

  /// 获取所有标签
  Future<Set<String>> getAllTags();

  /// 获取某些标签的作品
  Future<List<WorkEntity>> getByTags(Set<String> tags);

  /// 查询作品
  Future<List<WorkEntity>> query(WorkFilter filter);

  /// 更新作品
  Future<WorkEntity> save(WorkEntity work);

  /// 批量更新
  Future<List<WorkEntity>> saveMany(List<WorkEntity> works);

  /// 搜索作品
  Future<List<WorkEntity>> search(String query, {int? limit});

  /// 标签建议
  Future<List<String>> suggestTags(String prefix, {int limit = 10});
}



=======================================
./lib/infrastructure/events/event_bus.dart
=======================================
import 'dart:async';

/// 事件总线，用于组件间通信
class EventBus {
  final _controller = StreamController.broadcast();

  /// 关闭事件总线
  void dispose() {
    _controller.close();
  }

  /// 发送事件
  void fire(dynamic event) {
    _controller.add(event);
  }

  /// 监听事件
  StreamSubscription<T> on<T>() {
    return _controller.stream
        .where((event) => event is T)
        .cast<T>()
        .listen(null);
  }
}



=======================================
./lib/infrastructure/image/image_processor.dart
=======================================
import 'dart:io';

/// 图片处理器接口
abstract class ImageProcessor {
  /// 临时文件目录
  String get tempPath;

  /// 缩略图缓存目录
  String get thumbnailCachePath;

  /// 清理临时文件
  Future<void> cleanupTempFiles();

  /// 创建占位图
  ///
  /// 创建指定尺寸的占位图
  Future<File> createPlaceholder(int width, int height);

  /// 创建临时文件
  Future<File> createTempFile(String prefix);

  /// 优化图片
  ///
  /// 优化图片质量和大小
  Future<File> optimizeImage(File input);

  /// 处理图片
  ///
  /// 按指定尺寸和质量处理图片
  Future<File> processImage(
    File input, {
    required int maxWidth,
    required int maxHeight,
    required int quality,
  });

  /// 调整图片大小
  ///
  /// 按指定尺寸调整图片，保持宽高比
  Future<File> resizeImage(
    File input, {
    required int width,
    required int height,
  });

  /// 旋转图片
  ///
  /// [degrees] 旋转角度(90, 180, 270)
  Future<File> rotateImage(File input, int degrees);
}



=======================================
./lib/infrastructure/image/image_processor_impl.dart
=======================================
import 'dart:io';

import 'package:image/image.dart' as img;
import 'package:path/path.dart' as path;

import '../../infrastructure/logging/logger.dart';
import './image_processor.dart';

/// 图片处理器实现
class ImageProcessorImpl implements ImageProcessor {
  final String _cachePath;

  ImageProcessorImpl({required String cachePath}) : _cachePath = cachePath;

  @override
  String get tempPath => path.join(_cachePath, 'temp');

  @override
  String get thumbnailCachePath => path.join(_cachePath, 'thumbnails');

  @override
  Future<void> cleanupTempFiles() async {
    try {
      final dir = Directory(tempPath);
      if (await dir.exists()) {
        await dir.delete(recursive: true);
        await dir.create(recursive: true);
      }
    } catch (e, stack) {
      AppLogger.error(
        '清理临时文件失败',
        error: e,
        stackTrace: stack,
      );
      rethrow;
    }
  }

  @override
  Future<File> createPlaceholder(int width, int height) async {
    try {
      final image = img.Image(width: width, height: height);
      img.fill(image, color: img.ColorRgb8(200, 200, 200));

      final outPath = await _createTempFilePath('placeholder_');
      final outFile = File(outPath);
      await outFile.writeAsBytes(img.encodePng(image));

      return outFile;
    } catch (e, stack) {
      AppLogger.error(
        '创建占位图失败',
        error: e,
        stackTrace: stack,
        data: {'width': width, 'height': height},
      );
      rethrow;
    }
  }

  @override
  Future<File> createTempFile(String prefix) async {
    final filePath = await _createTempFilePath(prefix);
    return File(filePath);
  }

  @override
  Future<File> optimizeImage(File input) async {
    try {
      final bytes = await input.readAsBytes();
      final image = img.decodeImage(bytes);
      if (image == null) throw Exception('Failed to decode image');

      final optimized = img.copyResize(
        image,
        width: image.width,
        height: image.height,
        interpolation: img.Interpolation.linear,
      );

      final outPath = await _createTempFilePath('optimized_');
      final outFile = File(outPath);
      await outFile.writeAsBytes(img.encodeJpg(optimized, quality: 85));

      return outFile;
    } catch (e, stack) {
      AppLogger.error(
        '优化图片失败',
        error: e,
        stackTrace: stack,
        data: {'input': input.path},
      );
      rethrow;
    }
  }

  @override
  Future<File> processImage(
    File input, {
    required int maxWidth,
    required int maxHeight,
    required int quality,
  }) async {
    try {
      final bytes = await input.readAsBytes();
      final image = img.decodeImage(bytes);
      if (image == null) throw Exception('Failed to decode image');

      // 计算保持宽高比的尺寸
      final aspectRatio = image.width / image.height;
      var targetWidth = maxWidth;
      var targetHeight = maxHeight;

      if (targetWidth / targetHeight > aspectRatio) {
        targetWidth = (targetHeight * aspectRatio).round();
      } else {
        targetHeight = (targetWidth / aspectRatio).round();
      }

      final processed = img.copyResize(
        image,
        width: targetWidth,
        height: targetHeight,
        interpolation: img.Interpolation.linear,
      );

      final outPath = await _createTempFilePath('processed_');
      final outFile = File(outPath);
      await outFile.writeAsBytes(img.encodeJpg(processed, quality: quality));

      return outFile;
    } catch (e, stack) {
      AppLogger.error(
        '处理图片失败',
        error: e,
        stackTrace: stack,
        data: {
          'input': input.path,
          'maxWidth': maxWidth,
          'maxHeight': maxHeight,
          'quality': quality,
        },
      );
      rethrow;
    }
  }

  @override
  Future<File> resizeImage(
    File input, {
    required int width,
    required int height,
  }) async {
    try {
      final bytes = await input.readAsBytes();
      final image = img.decodeImage(bytes);
      if (image == null) throw Exception('Failed to decode image');

      // 计算保持宽高比的尺寸
      final aspectRatio = image.width / image.height;
      var targetWidth = width;
      var targetHeight = height;

      if (targetWidth / targetHeight > aspectRatio) {
        targetWidth = (targetHeight * aspectRatio).round();
      } else {
        targetHeight = (targetWidth / aspectRatio).round();
      }

      final resized = img.copyResize(
        image,
        width: targetWidth,
        height: targetHeight,
        interpolation: img.Interpolation.linear,
      );

      final outPath = await _createTempFilePath('resized_');
      final outFile = File(outPath);
      await outFile.writeAsBytes(img.encodePng(resized));

      return outFile;
    } catch (e, stack) {
      AppLogger.error(
        '调整图片大小失败',
        error: e,
        stackTrace: stack,
        data: {
          'input': input.path,
          'width': width,
          'height': height,
        },
      );
      rethrow;
    }
  }

  @override
  Future<File> rotateImage(File input, int degrees) async {
    try {
      final bytes = await input.readAsBytes();
      final image = img.decodeImage(bytes);
      if (image == null) throw Exception('Failed to decode image');

      final rotated = img.copyRotate(image, angle: degrees);

      final outPath = await _createTempFilePath('rotated_');
      final outFile = File(outPath);
      await outFile.writeAsBytes(img.encodePng(rotated));

      return outFile;
    } catch (e, stack) {
      AppLogger.error(
        '旋转图片失败',
        error: e,
        stackTrace: stack,
        data: {
          'input': input.path,
          'degrees': degrees,
        },
      );
      rethrow;
    }
  }

  /// 创建临时文件路径
  Future<String> _createTempFilePath(String prefix) async {
    final dir = Directory(tempPath);
    if (!await dir.exists()) {
      await dir.create(recursive: true);
    }
    return path.join(
      tempPath,
      '$prefix${DateTime.now().millisecondsSinceEpoch}.tmp',
    );
  }
}



=======================================
./lib/infrastructure/logging/app_error_handler.dart
=======================================
import 'dart:async';
import 'dart:isolate';

import 'package:flutter/foundation.dart';

import 'logger.dart';

/// 全局错误处理器
class AppErrorHandler {
  static bool _initialized = false;

  /// 初始化错误处理
  static void initialize() {
    if (_initialized) return;
    _initialized = true;

    // 处理 Flutter 框架错误
    FlutterError.onError = (FlutterErrorDetails details) {
      FlutterError.presentError(details);
      AppLogger.error(
        '发生Flutter框架错误',
        error: details.exception,
        stackTrace: details.stack,
        tag: 'ErrorHandler',
      );
    };

    // 处理未捕获的异步错误
    PlatformDispatcher.instance.onError = (error, stack) {
      AppLogger.error(
        '发生未捕获的平台错误',
        error: error,
        stackTrace: stack,
        tag: 'ErrorHandler',
      );
      return true;
    };

    // 处理Zone内未捕获的错误
    runZonedGuarded(
      () {},
      (Object error, StackTrace stack) {
        AppLogger.error(
          '发生未捕获的Zone错误',
          error: error,
          stackTrace: stack,
          tag: 'ErrorHandler',
        );
      },
    );

    // 处理Isolate错误
    Isolate.current.addErrorListener(RawReceivePort((pair) {
      final List<dynamic> errorAndStacktrace = pair as List<dynamic>;
      AppLogger.error(
        '发生Isolate错误',
        error: errorAndStacktrace.first,
        stackTrace: errorAndStacktrace.last as StackTrace,
        tag: 'ErrorHandler',
      );
    }).sendPort);
  }
}



=======================================
./lib/infrastructure/logging/error_handler.dart
=======================================
import 'package:flutter/foundation.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import 'logger.dart';

class AppErrorHandler {
  static void initialize() {
    // Capture Flutter framework errors
    FlutterError.onError = (FlutterErrorDetails details) {
      AppLogger.error(
        details.exceptionAsString(),
        error: details.exception,
        stackTrace: details.stack,
        tag: 'Flutter',
      );
      // Forward to Flutter's default handler
      FlutterError.presentError(details);
    };

    // Capture Dart uncaught errors
    PlatformDispatcher.instance.onError = (error, stack) {
      AppLogger.fatal(
        'Uncaught exception',
        error: error,
        stackTrace: stack,
        tag: 'Dart',
      );
      // Allow normal handling to continue
      return false;
    };
  }
}

// Riverpod observer example
class ProviderLogger extends ProviderObserver {
  @override
  void didAddProvider(
    ProviderBase<Object?> provider,
    Object? value,
    ProviderContainer container,
  ) {
    AppLogger.debug(
      'Provider ${provider.name ?? provider.runtimeType} was initialized with $value',
      tag: 'Riverpod',
    );
  }

  @override
  void didDisposeProvider(
    ProviderBase<Object?> provider,
    ProviderContainer container,
  ) {
    AppLogger.debug(
      'Provider ${provider.name ?? provider.runtimeType} was disposed',
      tag: 'Riverpod',
    );
  }

  @override
  void providerDidFail(
    ProviderBase<Object?> provider,
    Object error,
    StackTrace stackTrace,
    ProviderContainer container,
  ) {
    AppLogger.error(
      'Provider ${provider.name ?? provider.runtimeType} failed',
      error: error,
      stackTrace: stackTrace,
      tag: 'Riverpod',
    );
  }
}



=======================================
./lib/infrastructure/logging/handlers/console_handler.dart
=======================================
import 'package:flutter/foundation.dart';

import '../log_entry.dart';
import '../log_level.dart';
import 'log_handler.dart';

class ConsoleLogHandler implements LogHandler {
  @override
  void handle(LogEntry entry) {
    final message = entry.toConsoleString();

    switch (entry.level) {
      case LogLevel.debug:
        debugPrint(message);
        break;
      case LogLevel.info:
        debugPrint('\x1B[34m$message\x1B[0m'); // Blue
        break;
      case LogLevel.warning:
        debugPrint('\x1B[33m$message\x1B[0m'); // Yellow
        break;
      case LogLevel.error:
      case LogLevel.fatal:
        debugPrint('\x1B[31m$message\x1B[0m'); // Red
        break;
    }
  }
}



=======================================
./lib/infrastructure/logging/handlers/file_handler.dart
=======================================
import 'dart:async';
import 'dart:io';

import 'package:flutter/foundation.dart';
import 'package:path/path.dart' as path;

import '../log_entry.dart';
import 'log_handler.dart';

// 同步操作的辅助函数
Future<T> synchronized<T>(Object lock, Future<T> Function() computation) async {
  try {
    return await computation();
  } catch (e) {
    rethrow;
  }
}

class FileLogHandler implements LogHandler {
  final String filePath;
  final int? maxSizeBytes;
  final int? maxFiles;

  File? _currentFile;
  IOSink? _sink;
  bool _isWriting = false;
  final List<LogEntry> _pendingLogs = [];
  final Object _writeLock = Object();

  FileLogHandler({
    required this.filePath,
    this.maxSizeBytes,
    this.maxFiles,
  });

  // 清理资源
  Future<void> dispose() async {
    await _sink?.flush();
    await _sink?.close();
    _sink = null;
    _pendingLogs.clear();
  }

  @override
  void handle(LogEntry entry) {
    // 不再直接写入，而是添加到待处理队列
    synchronized(_writeLock, () async {
      _pendingLogs.add(entry);
      return _processLogs();
    });
  }

  Future<void> init() async {
    await _openLogFile();
  }

  Future<void> _checkRotation() async {
    final currentSize = await _currentFile?.length() ?? 0;
    if (maxSizeBytes != null && currentSize > maxSizeBytes!) {
      await _rotateLogFile();
    }
  }

  Future<void> _deleteOldLogFiles() async {
    final directory = Directory(path.dirname(filePath));
    final baseFileName = path.basenameWithoutExtension(filePath);
    final extension = path.extension(filePath);

    final files = await directory
        .list()
        .where((entity) =>
            entity is File &&
            path.basename(entity.path).startsWith(baseFileName) &&
            path.basename(entity.path).endsWith(extension) &&
            entity.path != filePath)
        .toList();

    if (files.length > maxFiles! - 1) {
      // 按修改时间排序（旧的先）
      files.sort((a, b) {
        return a.statSync().modified.compareTo(b.statSync().modified);
      });

      // 删除最旧的文件
      for (var i = 0; i < files.length - maxFiles! + 1; i++) {
        try {
          await (files[i] as File).delete();
        } catch (e) {
          debugPrint('Failed to delete old log file: $e');
        }
      }
    }
  }

  // 格式化日志条目
  String _formatLogEntry(LogEntry entry) {
    final timestamp = entry.timestamp.toIso8601String();
    final level = entry.level.name.padRight(7);
    final tag = entry.tag != null ? '[${entry.tag}] ' : '';

    return '$timestamp [$level] $tag${entry.message}';
  }

  Future<void> _openLogFile() async {
    try {
      final directory = Directory(path.dirname(filePath));
      if (!await directory.exists()) {
        await directory.create(recursive: true);
      }

      _currentFile = File(filePath);
      // 关键修复：避免重用相同的 StreamSink
      await _sink?.close();
      _sink = _currentFile!.openWrite(mode: FileMode.append);
    } catch (e) {
      debugPrint('Error opening log file: $e');
    }
  }

  // 安全地处理日志队列
  Future<void> _processLogs() async {
    if (_isWriting || _pendingLogs.isEmpty) return;

    _isWriting = true;

    try {
      while (_pendingLogs.isNotEmpty) {
        final entry = _pendingLogs.removeAt(0);
        final formattedLog = _formatLogEntry(entry);

        // 创建新的 IOSink 以避免 StreamSink 重用问题
        if (_sink == null) {
          await _openLogFile();
        }

        // 安全写入
        _sink?.writeln(formattedLog);
        await _sink?.flush(); // 立即刷新确保写入

        // 添加错误和堆栈跟踪（如果有）
        if (entry.error != null) {
          _sink?.writeln('Error: ${entry.error}');
        }
        if (entry.stackTrace != null) {
          _sink?.writeln('Stack Trace:');
          _sink?.writeln(entry.stackTrace);
        }

        // 检查是否需要轮换日志文件
        await _checkRotation();
      }
    } catch (e) {
      debugPrint('Error writing to log file: $e');
    } finally {
      _isWriting = false;

      // 检查是否还有更多日志待处理
      if (_pendingLogs.isNotEmpty) {
        _processLogs();
      }
    }
  }

  Future<void> _rotateLogFile() async {
    // 关闭当前文件
    await _sink?.flush();
    await _sink?.close();
    _sink = null;

    // 创建新文件并重命名旧文件
    final baseFileName = path.basenameWithoutExtension(filePath);
    final extension = path.extension(filePath);
    final timestamp = DateTime.now().toIso8601String().replaceAll(':', '-');
    final rotatedPath =
        '${path.dirname(filePath)}/${baseFileName}_$timestamp$extension';

    try {
      await _currentFile?.rename(rotatedPath);
    } catch (e) {
      // 如果重命名失败，尝试复制然后删除
      try {
        await _currentFile?.copy(rotatedPath);
        await _currentFile?.delete();
      } catch (e) {
        debugPrint('Failed to rotate log file: $e');
      }
    }

    // 打开新的日志文件
    await _openLogFile();

    // 删除旧文件（如果需要）
    if (maxFiles != null) {
      await _deleteOldLogFiles();
    }
  }
}



=======================================
./lib/infrastructure/logging/handlers/log_handler.dart
=======================================
import '../log_entry.dart';

abstract class LogHandler {
  void handle(LogEntry entry);
}



=======================================
./lib/infrastructure/logging/logger.dart
=======================================
import 'package:flutter/widgets.dart';

import 'handlers/console_handler.dart';
import 'handlers/file_handler.dart';
import 'handlers/log_handler.dart';
import 'log_entry.dart';
import 'log_level.dart';

// 同步锁辅助函数
Future<T> synchronized<T>(Object lock, T Function() computation) async {
  try {
    return computation();
  } catch (e) {
    rethrow;
  }
}

class AppLogger {
  static LogLevel _minLevel = LogLevel.debug;
  static final List<LogHandler> _handlers = [];
  // 添加同步锁，防止并发写入
  static final _logLock = Object();

  static final _logQueue = <_LogEntry>[];
  static bool _isProcessingLogs = false;
  static bool get hasHandlers => _handlers.isNotEmpty;

  // 便利方法
  static void debug(dynamic message,
      {String? tag, Map<String, dynamic>? data}) {
    _queueLog(LogLevel.debug, message, tag: tag, data: data);
  }

  static void error(
    dynamic message, {
    String? tag,
    dynamic error,
    StackTrace? stackTrace,
    Map<String, dynamic>? data,
  }) {
    _queueLog(
      LogLevel.error,
      message,
      tag: tag,
      error: error,
      stackTrace: stackTrace,
      data: data,
    );
  }

  static void fatal(
    dynamic message, {
    String? tag,
    dynamic error,
    StackTrace? stackTrace,
    Map<String, dynamic>? data,
  }) {
    _queueLog(
      LogLevel.fatal,
      message,
      tag: tag,
      error: error,
      stackTrace: stackTrace,
      data: data,
    );
  }

  static void info(dynamic message, {String? tag, Map<String, dynamic>? data}) {
    _queueLog(LogLevel.info, message, tag: tag, data: data);
  }

  // 初始化方法
  static Future<void> init({
    LogLevel minLevel = LogLevel.debug,
    bool enableConsole = true,
    bool enableFile = false,
    String? filePath,
    int? maxFileSizeBytes,
    int? maxFiles,
  }) async {
    _minLevel = minLevel;

    if (enableConsole) {
      _handlers.add(ConsoleLogHandler());
    }

    if (enableFile && filePath != null) {
      final fileHandler = FileLogHandler(
        filePath: filePath,
        maxSizeBytes: maxFileSizeBytes,
        maxFiles: maxFiles,
      );
      await fileHandler.init();
      _handlers.add(fileHandler);
    }
  }

  // 日志记录方法
  static void log(
    LogLevel level,
    dynamic message, {
    String? tag,
    dynamic error,
    StackTrace? stackTrace,
    Map<String, dynamic>? data,
  }) {
    if (level.index < _minLevel.index) return;

    final entry = LogEntry(
      level: level,
      message: message.toString(),
      timestamp: DateTime.now(),
      tag: tag ?? _getCallerTag(),
      error: error,
      stackTrace: stackTrace ?? (error != null ? StackTrace.current : null),
      data: data,
    );

    for (final handler in _handlers) {
      handler.handle(entry);
    }
  }

  static void warning(
    dynamic message, {
    String? tag,
    dynamic error,
    StackTrace? stackTrace,
    Map<String, dynamic>? data,
  }) {
    _queueLog(
      LogLevel.warning,
      message,
      tag: tag,
      error: error,
      stackTrace: stackTrace,
      data: data,
    );
  }

  // 辅助方法
  static String? _getCallerTag() {
    try {
      final frames = StackTrace.current.toString().split('\n');
      if (frames.length > 3) {
        final frame = frames[3].trim();
        final classMethodPattern = RegExp(r'#\d+\s+(.+)\s+\(');
        final match = classMethodPattern.firstMatch(frame);
        if (match != null && match.groupCount >= 1) {
          return match.group(1)?.split('.').first;
        }
      }
    } catch (_) {}
    return null;
  }

  // 处理日志队列
  static Future<void> _processLogQueue() async {
    if (_logQueue.isEmpty) {
      _isProcessingLogs = false;
      return;
    }

    _isProcessingLogs = true;
    final entry = _logQueue.removeAt(0);

    try {
      // 实际的日志处理
      log(entry.level, entry.message,
          tag: entry.tag,
          error: entry.error,
          stackTrace: entry.stackTrace,
          data: entry.data);
    } catch (e) {
      debugPrint('Error processing log: $e');
    } finally {
      // 继续处理队列中的下一个日志
      _processLogQueue();
    }
  }

  // 使用队列处理日志，避免并发问题
  static void _queueLog(
    LogLevel level,
    dynamic message, {
    String? tag,
    dynamic error,
    StackTrace? stackTrace,
    Map<String, dynamic>? data,
  }) {
    final entry = _LogEntry(
      level: level,
      message: message.toString(),
      tag: tag,
      error: error,
      stackTrace: stackTrace,
      data: data,
      timestamp: DateTime.now(),
    );

    synchronized(_logLock, () {
      _logQueue.add(entry);
      if (!_isProcessingLogs) {
        _processLogQueue();
      }
    });
  }
}

// 辅助类表示日志条目
class _LogEntry {
  final LogLevel level;
  final String message;
  final String? tag;
  final dynamic error;
  final StackTrace? stackTrace;
  final Map<String, dynamic>? data;
  final DateTime timestamp;

  _LogEntry({
    required this.level,
    required this.message,
    this.tag,
    this.error,
    this.stackTrace,
    this.data,
    required this.timestamp,
  });
}



=======================================
./lib/infrastructure/logging/logging.dart
=======================================
// 集中导出所有日志相关的类和功能
export 'error_handler.dart';
export 'handlers/console_handler.dart';
export 'handlers/file_handler.dart' hide synchronized;
export 'handlers/log_handler.dart';
export 'log_entry.dart';
export 'log_level.dart';
export 'logger.dart';



=======================================
./lib/infrastructure/logging/log_entry.dart
=======================================
import 'log_level.dart';

class LogEntry {
  final LogLevel level;
  final String message;
  final DateTime timestamp;
  final String? tag;
  final dynamic error;
  final StackTrace? stackTrace;
  final Map<String, dynamic>? data;

  const LogEntry({
    required this.level,
    required this.message,
    required this.timestamp,
    this.tag,
    this.error,
    this.stackTrace,
    this.data,
  });

  String toConsoleString() {
    final buffer = StringBuffer();
    final timeStr =
        '${timestamp.hour.toString().padLeft(2, '0')}:${timestamp.minute.toString().padLeft(2, '0')}:${timestamp.second.toString().padLeft(2, '0')}';

    buffer.write('${level.emoji} ');
    buffer.write('[$timeStr] ');
    buffer.write('[${level.name}] ');
    if (tag != null) buffer.write('[$tag] ');
    buffer.write(message);

    if (error != null) {
      buffer.write('\nError: $error');
    }

    if (stackTrace != null) {
      buffer.write('\nStack Trace:\n$stackTrace');
    }

    if (data != null && data!.isNotEmpty) {
      buffer.write('\nData: ${data.toString()}');
    }

    return buffer.toString();
  }

  Map<String, dynamic> toJson() {
    return {
      'level': level.name,
      'message': message,
      'timestamp': timestamp.toIso8601String(),
      if (tag != null) 'tag': tag,
      if (error != null) 'error': error.toString(),
      if (stackTrace != null) 'stackTrace': stackTrace.toString(),
      if (data != null) 'data': data,
    };
  }
}



=======================================
./lib/infrastructure/logging/log_level.dart
=======================================
import 'package:flutter/material.dart';

enum LogLevel {
  debug,
  info,
  warning,
  error,
  fatal;

  Color get color {
    return switch (this) {
      LogLevel.debug => Colors.grey,
      LogLevel.info => Colors.blue,
      LogLevel.warning => Colors.yellow,
      LogLevel.error => Colors.red,
      LogLevel.fatal => Colors.purple,
    };
  }

  String get emoji {
    return switch (this) {
      LogLevel.debug => '🔍',
      LogLevel.info => 'ℹ️',
      LogLevel.warning => '⚠️',
      LogLevel.error => '❌',
      LogLevel.fatal => '☠️',
    };
  }

  String get name => toString().split('.').last.toUpperCase();
}



=======================================
./lib/infrastructure/persistence/app_database.dart
=======================================
import 'dart:io';

import 'package:flutter/foundation.dart';
import 'package:path/path.dart' as path;
import 'package:sqflite/sqflite.dart';

import 'database_interface.dart';

class AppDatabase implements DatabaseInterface {
  static const _version = 1;
  final String basePath;
  Database? _database;
  bool _initialized = false;

  AppDatabase({required this.basePath});

  @override
  Future<void> clear(String table) async {
    // TODO: 实现清空表逻辑
    throw UnimplementedError();
  }

  @override
  Future<void> close() async {
    // TODO: 实现关闭数据库逻辑
    throw UnimplementedError();
  }

  @override
  Future<int> count(String table, [Map<String, dynamic>? filter]) async {
    // TODO: 实现获取记录数逻辑
    throw UnimplementedError();
  }

  @override
  Future<void> delete(String table, String id) async {
    final db = _database;
    if (db == null) {
      throw StateError('Database not initialized');
    }

    await db.delete(table, where: 'key = ?', whereArgs: [id]);
  }

  @override
  Future<void> deleteMany(String table, List<String> ids) async {
    // TODO: 实现批量删除记录逻辑
    throw UnimplementedError();
  }

  @override
  Future<Map<String, dynamic>?> get(String table, String id) async {
    final db = _database;
    if (db == null) {
      throw StateError('Database not initialized');
    }

    final results = await db.query(
      table,
      where: 'key = ?',
      whereArgs: [id],
      limit: 1,
    );

    return results.isNotEmpty ? results.first : null;
  }

  @override
  Future<List<Map<String, dynamic>>> getAll(String table) async {
    // TODO: 实现获取所有记录逻辑
    throw UnimplementedError();
  }

  @override
  Future<void> initialize() async {
    try {
      if (_initialized) return;

      // 确保目录存在
      final dbDir = Directory(basePath);
      await dbDir.create(recursive: true);
      final dbPath = path.join(basePath, 'settings.db');
      _database = await openDatabase(
        dbPath,
        version: _version,
        onCreate: (db, version) async {
          await db.execute('''
            CREATE TABLE IF NOT EXISTS settings (
              key TEXT PRIMARY KEY,
              value TEXT,
              updateTime TEXT
            )''');
        },
      );
      _initialized = true;
    } catch (e) {
      debugPrint('Database initialization error: $e');
      rethrow;
    }
  }

  @override
  Future<List<Map<String, dynamic>>> query(
      String table, Map<String, dynamic> filter) async {
    // TODO: 实现结构化查询逻辑
    throw UnimplementedError();
  }

  @override
  Future<int> rawDelete(String sql, [List<Object?>? args]) async {
    // TODO: 实现原生删除逻辑
    throw UnimplementedError();
  }

  @override
  Future<List<Map<String, dynamic>>> rawQuery(String sql,
      [List<Object?>? args]) async {
    // TODO: 实现原生查询逻辑
    throw UnimplementedError();
  }

  @override
  Future<int> rawUpdate(String sql, [List<Object?>? args]) async {
    // TODO: 实现原生更新逻辑
    throw UnimplementedError();
  }

  @override
  Future<void> save(String table, String id, Map<String, dynamic> data) async {
    // TODO: 实现保存记录逻辑
    throw UnimplementedError();
  }

  @override
  Future<void> saveMany(
      String table, Map<String, Map<String, dynamic>> data) async {
    // TODO: 实现批量保存记录逻辑
    throw UnimplementedError();
  }

  @override
  Future<void> set(String table, String id, Map<String, dynamic> data) async {
    final db = _database;
    if (db == null) {
      throw StateError('Database not initialized');
    }

    await db.insert(table, data, conflictAlgorithm: ConflictAlgorithm.replace);
  }

  @override
  Future<void> setMany(
      String table, Map<String, Map<String, dynamic>> data) async {
    // TODO: 实现批量设置记录逻辑
    throw UnimplementedError();
  }

  /// 用于模式匹配的辅助方法
  T when<T>({
    required T Function() initialized,
    required T Function() uninitialized,
  }) {
    return _database != null ? initialized() : uninitialized();
  }
}



=======================================
./lib/infrastructure/persistence/database_factory.dart
=======================================
import 'package:path_provider/path_provider.dart';

import 'database_interface.dart';
import 'sqlite/sqlite_database.dart';

/// 数据库配置
class DatabaseConfig {
  /// 数据库名称
  final String name;

  /// 数据库目录
  final String? directory;

  /// 数据库迁移脚本
  final List<String> migrations;

  const DatabaseConfig({
    required this.name,
    this.directory,
    this.migrations = const [],
  });
}

/// 数据库工厂
class DatabaseFactory {
  /// 创建SQLite数据库实例
  static Future<DatabaseInterface> create(DatabaseConfig config) async {
    final directory =
        config.directory ?? (await getApplicationDocumentsDirectory()).path;

    return SQLiteDatabase.create(
      name: config.name,
      directory: directory,
      migrations: config.migrations,
    );
  }
}



=======================================
./lib/infrastructure/persistence/database_interface.dart
=======================================
/// 数据库接口
abstract class DatabaseInterface {
  /// 清空表
  Future<void> clear(String table);

  /// 关闭数据库
  Future<void> close();

  /// 获取记录数
  Future<int> count(String table, [Map<String, dynamic>? filter]);

  /// 删除记录
  Future<void> delete(String table, String id);

  /// 批量删除记录
  Future<void> deleteMany(String table, List<String> ids);

  /// 获取单个记录
  Future<Map<String, dynamic>?> get(String table, String id);

  /// 获取多个记录
  Future<List<Map<String, dynamic>>> getAll(String table);

  /// 执行初始化
  Future<void> initialize();

  /// 结构化查询
  Future<List<Map<String, dynamic>>> query(
      String table, Map<String, dynamic> filter);

  /// 执行原生删除
  Future<int> rawDelete(String sql, [List<Object?>? args]);

  /// 执行原生查询
  Future<List<Map<String, dynamic>>> rawQuery(String sql,
      [List<Object?>? args]);

  /// 执行原生更新
  Future<int> rawUpdate(String sql, [List<Object?>? args]);

  /// 保存/更新记录
  Future<void> save(String table, String id, Map<String, dynamic> data);

  /// 批量保存/更新记录
  Future<void> saveMany(String table, Map<String, Map<String, dynamic>> data);

  /// 设置记录(覆盖)
  Future<void> set(String table, String id, Map<String, dynamic> data);

  /// 批量设置记录(覆盖)
  Future<void> setMany(String table, Map<String, Map<String, dynamic>> data);
}



=======================================
./lib/infrastructure/persistence/database_state.dart
=======================================
/// 数据库状态
class DatabaseState {
  /// 是否初始化完成
  final bool isInitialized;

  /// 当前版本
  final int version;

  /// 上次更新时间
  final DateTime? lastUpdate;

  /// 错误信息
  final String? error;

  const DatabaseState({
    this.isInitialized = false,
    this.version = 0,
    this.lastUpdate,
    this.error,
  });

  /// 创建错误状态
  factory DatabaseState.error(String error) => DatabaseState(
        isInitialized: false,
        error: error,
      );

  /// 创建初始状态
  factory DatabaseState.initial() => const DatabaseState();

  /// 创建已初始化状态
  factory DatabaseState.initialized(int version) => DatabaseState(
        isInitialized: true,
        version: version,
        lastUpdate: DateTime.now(),
      );

  /// 复制并修改部分属性
  DatabaseState copyWith({
    bool? isInitialized,
    int? version,
    DateTime? lastUpdate,
    String? error,
  }) {
    return DatabaseState(
      isInitialized: isInitialized ?? this.isInitialized,
      version: version ?? this.version,
      lastUpdate: lastUpdate ?? this.lastUpdate,
      error: error ?? this.error,
    );
  }

  @override
  String toString() {
    return 'DatabaseState(initialized: $isInitialized, version: $version, lastUpdate: $lastUpdate, error: $error)';
  }
}



=======================================
./lib/infrastructure/persistence/file/file_storage.dart
=======================================
import 'dart:convert';
import 'dart:io';

import 'package:path/path.dart' as path;
import 'package:path_provider/path_provider.dart';

class FileStorage {
  Future<String> get _basePath async {
    final directory = await getApplicationDocumentsDirectory();
    return directory.path;
  }

  // Directory creation
  Future<void> createDirectory(String path) async {
    final directory = Directory(path);
    if (!await directory.exists()) {
      await directory.create(recursive: true);
    }
  }

  Future<String> getBackupDirectory() async {
    final basePath = await _basePath;
    return path.join(basePath, 'storage', 'backup');
  }

  Future<String> getCharsDirectory() async {
    final basePath = await _basePath;
    return path.join(basePath, 'storage', 'chars');
  }

  Future<String> getPracticesDirectory() async {
    final basePath = await _basePath;
    return path.join(basePath, 'storage', 'practices');
  }

  Future<String> getTempDirectory() async {
    final basePath = await _basePath;
    return path.join(basePath, 'storage', 'temp');
  }

  // Work-related methods
  Future<String> getWorkDirectory(String workId) async {
    final worksDirectory = await getWorksDirectory();
    return path.join(worksDirectory, workId);
  }

  Future<File> getWorkImportedPictureFile(String workId, int index) async {
    final pictureDirectory = await getWorkPictureDirectory(workId, index);
    final filePath = path.join(pictureDirectory, 'imported.png');
    return File(filePath);
  }

  Future<File> getWorkMetadataFile(String workId) async {
    final workDirectory = await getWorkDirectory(workId);
    final filePath = path.join(workDirectory, 'metadata.json');
    return File(filePath);
  }

  Future<File> getWorkOriginalPictureFile(
      String workId, int index, String ext) async {
    final pictureDirectory = await getWorkPictureDirectory(workId, index);
    final filePath = path.join(pictureDirectory, 'original.$ext');
    return File(filePath);
  }

  Future<String> getWorkPictureDirectory(String workId, int index) async {
    final workDirectory = await getWorkDirectory(workId);
    return path.join(workDirectory, 'pictures', index.toString());
  }

  Future<String> getWorksDirectory() async {
    final basePath = await _basePath;
    return path.join(basePath, 'storage', 'works');
  }

  Future<File> getWorkThumbnailFile(String workId) async {
    final workDirectory = await getWorkDirectory(workId);
    final filePath = path.join(workDirectory, 'thumbnail.jpg');
    return File(filePath);
  }

  Future<List<int>?> readFile(File file) async {
    try {
      return await file.readAsBytes();
    } catch (e) {
      print('Error reading file: $e');
      return null;
    }
  }

  Future<Map<String, dynamic>?> readJson(File file) async {
    try {
      final jsonString = await file.readAsString();
      return jsonDecode(jsonString);
    } catch (e) {
      print('Error reading JSON from file: $e');
      return null;
    }
  }

  Future<void> writeFile(File file, List<int> data) async {
    await file.writeAsBytes(data);
  }

  // Generic read/write methods
  Future<void> writeJson(File file, Map<String, dynamic> data) async {
    final jsonString = jsonEncode(data);
    await file.writeAsString(jsonString);
  }
}



=======================================
./lib/infrastructure/persistence/mock_database.dart
=======================================
import '../../domain/models/work/work_entity.dart';
import '../../domain/models/work/work_filter.dart';
import 'database_interface.dart';

/// 用于测试的总是失败的数据库
class FailingMockDatabase implements DatabaseInterface {
  @override
  bool get isInitialized => false;

  @override
  Future<void> clear(String table) async => throw UnimplementedError();
  @override
  Future<void> close() async => throw UnimplementedError();
  @override
  Future<int> count(String table, [Map<String, dynamic>? filter]) async =>
      throw UnimplementedError();
  @override
  Future<void> delete(String table, String id) async =>
      throw UnimplementedError();
  @override
  Future<void> deleteMany(String table, List<String> ids) async =>
      throw UnimplementedError();
  @override
  Future<Map<String, dynamic>?> get(String table, String id) async =>
      throw UnimplementedError();
  @override
  Future<List<Map<String, dynamic>>> getAll(String table) async =>
      throw UnimplementedError();
  @override
  Future<void> initialize() async {
    throw Exception('模拟数据库初始化失败');
  }

  @override
  Future<List<Map<String, dynamic>>> query(
    String table,
    Map<String, dynamic> filter,
  ) async =>
      throw UnimplementedError();
  @override
  Future<int> rawDelete(String sql, [List<Object?>? args]) async =>
      throw UnimplementedError();
  @override
  Future<List<Map<String, dynamic>>> rawQuery(
    String sql, [
    List<Object?>? args,
  ]) async =>
      throw UnimplementedError();
  @override
  Future<int> rawUpdate(String sql, [List<Object?>? args]) async =>
      throw UnimplementedError();
  @override
  Future<void> save(String table, String id, Map<String, dynamic> data) async =>
      throw UnimplementedError();
  @override
  Future<void> saveMany(
    String table,
    Map<String, Map<String, dynamic>> data,
  ) async =>
      throw UnimplementedError();
  @override
  Future<void> set(String table, String id, Map<String, dynamic> data) async =>
      throw UnimplementedError();

  @override
  Future<void> setMany(
    String table,
    Map<String, Map<String, dynamic>> data,
  ) async =>
      throw UnimplementedError();
}

/// 用于测试的模拟数据库
class MockDatabase implements DatabaseInterface {
  bool _isInitialized = false;
  final Map<String, Map<String, Map<String, dynamic>>> _storage = {};

  @override
  bool get isInitialized => _isInitialized;

  @override
  Future<void> clear(String table) async {
    _checkInitialized();
    _storage[table]?.clear();
  }

  @override
  Future<void> close() async {
    _storage.clear();
    _isInitialized = false;
  }

  @override
  Future<int> count(String table, [Map<String, dynamic>? filter]) async {
    _checkInitialized();
    return _storage[table]?.length ?? 0;
  }

  @override
  Future<void> delete(String table, String id) async {
    _checkInitialized();
    _storage[table]?.remove(id);
  }

  @override
  Future<void> deleteMany(String table, List<String> ids) async {
    _checkInitialized();
    for (final id in ids) {
      _storage[table]?.remove(id);
    }
  }

  Future<void> deleteWork(String id) async {
    _checkInitialized();
    await delete('works', id);
  }

  @override
  Future<Map<String, dynamic>?> get(String table, String id) async {
    _checkInitialized();
    return _storage[table]?[id];
  }

  @override
  Future<List<Map<String, dynamic>>> getAll(String table) async {
    _checkInitialized();
    if (_storage[table] == null) return [];
    return List<Map<String, dynamic>>.from(_storage[table]!.values);
  }

  Future<WorkEntity?> getWork(String id) async {
    _checkInitialized();
    final map = await get('works', id);
    if (map == null) return null;
    return WorkEntity.fromJson(map);
  }

  @override
  Future<void> initialize() async {
    await Future.delayed(const Duration(milliseconds: 100)); // 模拟初始化延迟
    _isInitialized = true;
  }

  @override
  Future<List<Map<String, dynamic>>> query(
    String table,
    Map<String, dynamic> filter,
  ) async {
    _checkInitialized();
    if (_storage[table] == null) return [];
    return List<Map<String, dynamic>>.from(_storage[table]!.values);
  }

  // 额外的工作相关方法
  Future<List<WorkEntity>> queryWorks(WorkFilter filter) async {
    _checkInitialized();
    final maps = await query('works', filter.toJson());
    return maps.map((m) => WorkEntity.fromJson(m)).toList();
  }

  @override
  Future<int> rawDelete(String sql, [List<Object?>? args]) async {
    _checkInitialized();
    return 0;
  }

  @override
  Future<List<Map<String, dynamic>>> rawQuery(
    String sql, [
    List<Object?>? args,
  ]) async {
    _checkInitialized();
    return [];
  }

  @override
  Future<int> rawUpdate(String sql, [List<Object?>? args]) async {
    _checkInitialized();
    return 0;
  }

  @override
  Future<void> save(String table, String id, Map<String, dynamic> data) async {
    _checkInitialized();
    _storage.putIfAbsent(table, () => {});
    _storage[table]![id] = Map<String, dynamic>.from(data);
  }

  @override
  Future<void> saveMany(
    String table,
    Map<String, Map<String, dynamic>> data,
  ) async {
    _checkInitialized();
    _storage.putIfAbsent(table, () => {});
    _storage[table]!.addAll(
      Map<String, Map<String, dynamic>>.from(data),
    );
  }

  Future<void> saveWork(WorkEntity work) async {
    _checkInitialized();
    await save('works', work.id, work.toJson());
  }

  @override
  Future<void> set(String table, String id, Map<String, dynamic> data) async {
    await save(table, id, data);
  }

  @override
  Future<void> setMany(
    String table,
    Map<String, Map<String, dynamic>> data,
  ) async {
    await saveMany(table, data);
  }

  void _checkInitialized() {
    if (!_isInitialized) {
      throw StateError('Database not initialized');
    }
  }
}

/// 用于测试的慢速数据库
class SlowMockDatabase implements DatabaseInterface {
  final Duration delay;
  bool _isInitialized = false;
  final MockDatabase _delegate = MockDatabase();

  SlowMockDatabase({this.delay = const Duration(seconds: 3)});

  @override
  bool get isInitialized => _isInitialized;

  @override
  Future<void> clear(String table) async {
    await Future.delayed(delay);
    return _delegate.clear(table);
  }

  @override
  Future<void> close() async {
    await Future.delayed(delay);
    return _delegate.close();
  }

  @override
  Future<int> count(String table, [Map<String, dynamic>? filter]) async {
    await Future.delayed(delay);
    return _delegate.count(table, filter);
  }

  @override
  Future<void> delete(String table, String id) async {
    await Future.delayed(delay);
    return _delegate.delete(table, id);
  }

  @override
  Future<void> deleteMany(String table, List<String> ids) async {
    await Future.delayed(delay);
    return _delegate.deleteMany(table, ids);
  }

  @override
  Future<Map<String, dynamic>?> get(String table, String id) async {
    await Future.delayed(delay);
    return _delegate.get(table, id);
  }

  @override
  Future<List<Map<String, dynamic>>> getAll(String table) async {
    await Future.delayed(delay);
    return _delegate.getAll(table);
  }

  @override
  Future<void> initialize() async {
    await Future.delayed(delay);
    await _delegate.initialize();
    _isInitialized = true;
  }

  @override
  Future<List<Map<String, dynamic>>> query(
    String table,
    Map<String, dynamic> filter,
  ) async {
    await Future.delayed(delay);
    return _delegate.query(table, filter);
  }

  @override
  Future<int> rawDelete(String sql, [List<Object?>? args]) async {
    await Future.delayed(delay);
    return _delegate.rawDelete(sql, args);
  }

  @override
  Future<List<Map<String, dynamic>>> rawQuery(
    String sql, [
    List<Object?>? args,
  ]) async {
    await Future.delayed(delay);
    return _delegate.rawQuery(sql, args);
  }

  @override
  Future<int> rawUpdate(String sql, [List<Object?>? args]) async {
    await Future.delayed(delay);
    return _delegate.rawUpdate(sql, args);
  }

  @override
  Future<void> save(String table, String id, Map<String, dynamic> data) async {
    await Future.delayed(delay);
    return _delegate.save(table, id, data);
  }

  @override
  Future<void> saveMany(
    String table,
    Map<String, Map<String, dynamic>> data,
  ) async {
    await Future.delayed(delay);
    return _delegate.saveMany(table, data);
  }

  @override
  Future<void> set(String table, String id, Map<String, dynamic> data) async {
    await Future.delayed(delay);
    return _delegate.set(table, id, data);
  }

  @override
  Future<void> setMany(
    String table,
    Map<String, Map<String, dynamic>> data,
  ) async {
    await Future.delayed(delay);
    return _delegate.setMany(table, data);
  }
}



=======================================
./lib/infrastructure/persistence/models/database_query.dart
=======================================
import '../../../infrastructure/logging/logger.dart';

/// 数据库查询
class DatabaseQuery {
  final List<DatabaseQueryCondition> conditions;
  final List<DatabaseQueryGroup>? groups;
  final String? orderBy;
  final int? limit;
  final int? offset;

  const DatabaseQuery({
    this.conditions = const [],
    this.groups,
    this.orderBy,
    this.limit,
    this.offset,
  });

  factory DatabaseQuery.fromJson(Map<String, dynamic> json) {
    AppLogger.debug('DatabaseQuery.fromJson', tag: 'DatabaseQuery', data: {
      'json': json,
      'whereType': json['where']?.runtimeType.toString(),
      'where': json['where'],
    });

    final conditions = <DatabaseQueryCondition>[];
    final groups = <DatabaseQueryGroup>[];

    try {
      if (json.containsKey('where')) {
        if (json['where'] is List) {
          final list = json['where'] as List;
          AppLogger.debug('处理List类型的where条件', tag: 'DatabaseQuery', data: {
            'count': list.length,
            'firstItem': list.isNotEmpty ? list.first : null,
          });

          for (var item in list) {
            if (item is Map) {
              final condition = DatabaseQueryCondition.fromJson(
                  Map<String, dynamic>.from(item));
              conditions.add(condition);

              AppLogger.debug('添加查询条件', tag: 'DatabaseQuery', data: {
                'field': condition.field,
                'op': condition.operator,
                'val': condition.value,
              });
            } else {
              AppLogger.error('无效的查询条件',
                  tag: 'DatabaseQuery',
                  error: 'Item is not a Map',
                  data: {
                    'item': item,
                    'type': item.runtimeType.toString(),
                  });
            }
          }
        } else if (json['where'] is Map) {
          final where = Map<String, dynamic>.from(json['where'] as Map);
          AppLogger.debug('处理Map类型的where条件', tag: 'DatabaseQuery', data: {
            'fields': where.keys.toList(),
          });

          conditions.addAll(
            where.entries.map((e) => DatabaseQueryCondition(
                  field: e.key,
                  operator: '=',
                  value: e.value,
                )),
          );
        } else {
          AppLogger.warning('不支持的where类型', tag: 'DatabaseQuery', data: {
            'type': json['where']?.runtimeType.toString(),
          });
        }
      }

      if (json.containsKey('conditions')) {
        final list = json['conditions'] as List;
        conditions.addAll(
          list.map((e) => DatabaseQueryCondition.fromJson(
              Map<String, dynamic>.from(e as Map))),
        );
      }

      if (json.containsKey('groups')) {
        final list = json['groups'] as List;
        groups.addAll(
          list.map((e) =>
              DatabaseQueryGroup.fromJson(Map<String, dynamic>.from(e as Map))),
        );
      }

      AppLogger.debug('查询条件构建完成', tag: 'DatabaseQuery', data: {
        'conditionCount': conditions.length,
        'groupCount': groups.length,
        'orderBy': json['orderBy'],
      });

      return DatabaseQuery(
        conditions: conditions,
        groups: groups.isEmpty ? null : groups,
        orderBy: json['orderBy'] as String?,
        limit: json['limit'] as int?,
        offset: json['offset'] as int?,
      );
    } catch (e, stack) {
      AppLogger.error('构建查询条件失败',
          tag: 'DatabaseQuery',
          error: e,
          stackTrace: stack,
          data: {'json': json});
      rethrow;
    }
  }

  Map<String, dynamic> toJson() => {
        'conditions': conditions.map((e) => e.toJson()).toList(),
        if (groups != null) 'groups': groups!.map((e) => e.toJson()).toList(),
        if (orderBy != null) 'orderBy': orderBy,
        if (limit != null) 'limit': limit,
        if (offset != null) 'offset': offset,
      };
}

/// 数据库查询条件
class DatabaseQueryCondition {
  final String field;
  final String operator;
  final dynamic value;

  const DatabaseQueryCondition({
    required this.field,
    required this.operator,
    required this.value,
  });

  factory DatabaseQueryCondition.fromJson(Map<String, dynamic> json) {
    AppLogger.debug('创建查询条件', tag: 'DatabaseQuery', data: {
      'json': json,
    });

    return DatabaseQueryCondition(
      field: json['field'] as String,
      operator: json['op'] as String? ?? '=',
      value: json['val'],
    );
  }

  Map<String, dynamic> toJson() => {
        'field': field,
        'op': operator,
        'val': value,
      };
}

/// 查询条件组
class DatabaseQueryGroup {
  final List<DatabaseQueryCondition> conditions;
  final String type; // 'AND' or 'OR'

  const DatabaseQueryGroup({
    required this.conditions,
    required this.type,
  });

  factory DatabaseQueryGroup.and(List<DatabaseQueryCondition> conditions) {
    return DatabaseQueryGroup(conditions: conditions, type: 'AND');
  }

  factory DatabaseQueryGroup.fromJson(Map<String, dynamic> json) {
    return DatabaseQueryGroup(
      conditions: (json['conditions'] as List)
          .map((e) => DatabaseQueryCondition.fromJson(
              Map<String, dynamic>.from(e as Map)))
          .toList(),
      type: json['type'] as String,
    );
  }

  factory DatabaseQueryGroup.or(List<DatabaseQueryCondition> conditions) {
    return DatabaseQueryGroup(conditions: conditions, type: 'OR');
  }

  Map<String, dynamic> toJson() => {
        'conditions': conditions.map((e) => e.toJson()).toList(),
        'type': type,
      };
}



=======================================
./lib/infrastructure/persistence/sqlite/database_error_handler.dart
=======================================
import 'package:sqflite/sqflite.dart';

import '../../logging/logger.dart';

class DatabaseError implements Exception {
  final String message;
  final String operation;
  final dynamic originalError;
  final StackTrace stackTrace;

  DatabaseError(
    this.message,
    this.operation,
    this.originalError,
    this.stackTrace,
  );

  @override
  String toString() => 'DatabaseError: $message (operation: $operation)';
}

/// 数据库错误处理器
class DatabaseErrorHandler {
  /// 安全执行数据库操作
  static Future<T> execute<T>(
    String operation,
    Future<T> Function() action,
  ) async {
    try {
      return await action();
    } on DatabaseException catch (e, stack) {
      final error = DatabaseError(
        e.toString(),
        operation,
        e,
        stack,
      );

      AppLogger.error(
        'Database operation failed',
        tag: 'Database',
        error: error,
        stackTrace: stack,
        data: {'operation': operation},
      );
      throw error;
    } catch (e, stack) {
      final error = DatabaseError(
        'Unexpected database error',
        operation,
        e,
        stack,
      );

      AppLogger.error(
        'Unexpected database error',
        tag: 'Database',
        error: error,
        stackTrace: stack,
        data: {'operation': operation},
      );
      throw error;
    }
  }
}



=======================================
./lib/infrastructure/persistence/sqlite/migrations.dart
=======================================
/// SQLite数据库迁移脚本
const migrations = [
  // 版本 1: 创建基础表结构
  '''
  -- 作品表
  CREATE TABLE IF NOT EXISTS works (
    id TEXT PRIMARY KEY,
    title TEXT NOT NULL,
    author TEXT,
    style TEXT,
    tool TEXT,
    remark TEXT,
    creationDate TEXT,
    createTime TEXT NOT NULL,
    updateTime TEXT NOT NULL,
    tags TEXT,
    status TEXT NOT NULL DEFAULT 'draft',
    imageCount INTEGER DEFAULT 0
  );

  -- 角色表
  CREATE TABLE IF NOT EXISTS characters (
    id TEXT PRIMARY KEY,
    workId TEXT NOT NULL,
    char TEXT NOT NULL,
    region TEXT NOT NULL,
    tags TEXT,
    createTime TEXT NOT NULL,
    updateTime TEXT NOT NULL,
    FOREIGN KEY (workId) REFERENCES works (id) ON DELETE CASCADE
  );

  -- 字帖表
  CREATE TABLE IF NOT EXISTS practices (
    id TEXT PRIMARY KEY,
    title TEXT NOT NULL,
    pages TEXT NOT NULL,
    tags TEXT,
    createTime TEXT NOT NULL,
    updateTime TEXT NOT NULL
  );

  -- 标签表
  CREATE TABLE IF NOT EXISTS tags (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT
  );

  -- 设置表
  CREATE TABLE IF NOT EXISTS settings (
    key TEXT PRIMARY KEY,
    value TEXT NOT NULL,
    updateTime TEXT NOT NULL
  );

  -- 创建索引
  CREATE INDEX IF NOT EXISTS idx_characters_workId ON characters(workId);
  CREATE INDEX IF NOT EXISTS idx_characters_char ON characters(char);
  ''',

  // 版本 2: 添加作品图片管理 - 表和索引
  '''
  CREATE TABLE IF NOT EXISTS work_images (
    id TEXT PRIMARY KEY,
    workId TEXT NOT NULL,
    indexInWork INTEGER NOT NULL,
    path TEXT NOT NULL,
    original_path TEXT,
    thumbnail_path TEXT,
    format TEXT NOT NULL,
    size INTEGER NOT NULL,
    width INTEGER NOT NULL,
    height INTEGER NOT NULL,
    createTime TEXT NOT NULL,
    updateTime TEXT NOT NULL,
    FOREIGN KEY (workId) REFERENCES works (id) ON DELETE CASCADE
  )
  ''',

  '''
  CREATE INDEX IF NOT EXISTS idx_work_images_workId ON work_images(workId);
  CREATE INDEX IF NOT EXISTS idx_work_images_index ON work_images(workId, indexInWork);
  CREATE INDEX IF NOT EXISTS idx_work_images_original_path ON work_images(workId, original_path);
  CREATE UNIQUE INDEX IF NOT EXISTS idx_work_images_unique_path 
  ON work_images(workId, original_path)
  WHERE original_path IS NOT NULL;
  ''',

  // 版本 2: 添加作品字段
  '''
  ALTER TABLE works ADD COLUMN firstImageId TEXT REFERENCES work_images(id);
  ALTER TABLE works ADD COLUMN lastImageUpdateTime TEXT;
  ''',

  // 版本 2: 添加触发器
  '''
  CREATE TRIGGER IF NOT EXISTS update_work_image_count_insert 
  AFTER INSERT ON work_images
  BEGIN
    UPDATE works 
    SET imageCount = (
      SELECT COUNT(*) 
      FROM work_images 
      WHERE workId = NEW.workId
    )
    WHERE id = NEW.workId;
  END
  ''',

  '''
  CREATE TRIGGER IF NOT EXISTS update_work_image_count_delete 
  AFTER DELETE ON work_images
  BEGIN
    UPDATE works 
    SET imageCount = (
      SELECT COUNT(*) 
      FROM work_images 
      WHERE workId = OLD.workId
    )
    WHERE id = OLD.workId;
  END
  ''',

  '''
  CREATE TRIGGER IF NOT EXISTS update_work_first_image_on_insert 
  AFTER INSERT ON work_images
  BEGIN
    UPDATE works 
    SET firstImageId = (
      SELECT id
      FROM work_images
      WHERE workId = NEW.workId
      ORDER BY indexInWork ASC
      LIMIT 1
    ),
    lastImageUpdateTime = strftime('%Y-%m-%dT%H:%M:%fZ', 'now')
    WHERE id = NEW.workId;
  END
  ''',

  '''
  CREATE TRIGGER IF NOT EXISTS update_work_first_image_on_update 
  AFTER UPDATE OF indexInWork ON work_images
  BEGIN
    UPDATE works 
    SET firstImageId = (
      SELECT id
      FROM work_images
      WHERE workId = NEW.workId
      ORDER BY indexInWork ASC
      LIMIT 1
    ),
    lastImageUpdateTime = strftime('%Y-%m-%dT%H:%M:%fZ', 'now')
    WHERE id = NEW.workId;
  END
  ''',

  '''
  CREATE TRIGGER IF NOT EXISTS update_work_first_image_on_delete 
  AFTER DELETE ON work_images
  BEGIN
    UPDATE works 
    SET firstImageId = (
      SELECT id FROM work_images WHERE workId = OLD.workId ORDER BY indexInWork ASC LIMIT 1
    ),
    lastImageUpdateTime = strftime('%Y-%m-%dT%H:%M:%fZ', 'now')
    WHERE id = OLD.workId;
  END
  ''',

  // 版本 4: 处理字段命名统一性
  '''
  -- 重命名列
  ALTER TABLE work_images RENAME COLUMN work_id TO workId;
  ''',

  '''
  -- 更新触发器
  DROP TRIGGER IF EXISTS update_work_image_count_insert;
  DROP TRIGGER IF EXISTS update_work_image_count_delete;
  DROP TRIGGER IF EXISTS update_work_first_image_on_insert;
  DROP TRIGGER IF EXISTS update_work_first_image_on_update;
  DROP TRIGGER IF EXISTS update_work_first_image_on_delete;
  ''',

  '''
  -- 重建触发器
  CREATE TRIGGER IF NOT EXISTS update_work_image_count_insert 
  AFTER INSERT ON work_images
  BEGIN
    UPDATE works 
    SET imageCount = (
      SELECT COUNT(*) 
      FROM work_images 
      WHERE workId = NEW.workId
    )
    WHERE id = NEW.workId;
  END;
  ''',

  '''
  CREATE TRIGGER IF NOT EXISTS update_work_image_count_delete 
  AFTER DELETE ON work_images
  BEGIN
    UPDATE works 
    SET imageCount = (
      SELECT COUNT(*) 
      FROM work_images 
      WHERE workId = OLD.workId
    )
    WHERE id = OLD.workId;
  END;
  ''',

  '''
  CREATE TRIGGER IF NOT EXISTS update_work_first_image_on_insert 
  AFTER INSERT ON work_images
  BEGIN
    UPDATE works 
    SET firstImageId = (
      SELECT id
      FROM work_images
      WHERE workId = NEW.workId
      ORDER BY indexInWork ASC
      LIMIT 1
    ),
    lastImageUpdateTime = strftime('%Y-%m-%dT%H:%M:%fZ', 'now')
    WHERE id = NEW.workId;
  END;
  ''',

  '''
  CREATE TRIGGER IF NOT EXISTS update_work_first_image_on_update 
  AFTER UPDATE OF indexInWork ON work_images
  BEGIN
    UPDATE works 
    SET firstImageId = (
      SELECT id
      FROM work_images
      WHERE workId = NEW.workId
      ORDER BY indexInWork ASC
      LIMIT 1
    ),
    lastImageUpdateTime = strftime('%Y-%m-%dT%H:%M:%fZ', 'now')
    WHERE id = NEW.workId;
  END;
  ''',

  '''
  CREATE TRIGGER IF NOT EXISTS update_work_first_image_on_delete 
  AFTER DELETE ON work_images
  BEGIN
    UPDATE works 
    SET firstImageId = (
      SELECT id FROM work_images WHERE workId = OLD.workId ORDER BY indexInWork ASC LIMIT 1
    ),
    lastImageUpdateTime = strftime('%Y-%m-%dT%H:%M:%fZ', 'now')
    WHERE id = OLD.workId;
  END;
  ''',
];



=======================================
./lib/infrastructure/persistence/sqlite/sqlite_database.dart
=======================================
import 'package:flutter/foundation.dart';
import 'package:path/path.dart';
import 'package:sqflite/sqflite.dart';
import 'package:sqflite_common_ffi/sqflite_ffi.dart';

import '../../logging/logger.dart';
import '../database_interface.dart';
import '../models/database_query.dart';

/// SQLite数据库实现
class SQLiteDatabase implements DatabaseInterface {
  final Database _db;

  const SQLiteDatabase._(this._db);

  @override
  Future<void> clear(String table) async {
    await _db.delete(table);
  }

  @override
  Future<void> close() async {
    await _db.close();
  }

  @override
  Future<int> count(String table, [Map<String, dynamic>? filter]) async {
    if (filter == null || filter.isEmpty) {
      final result = await _db.rawQuery('SELECT COUNT(*) as count FROM $table');
      return Sqflite.firstIntValue(result) ?? 0;
    }

    final query = DatabaseQuery.fromJson(filter);
    final queryResult = _buildCountSql(table, query);

    final result = await _db.rawQuery(queryResult.sql, queryResult.args);
    AppLogger.debug(
      '统计查询完成',
      tag: 'SQLiteDatabase',
    );

    return Sqflite.firstIntValue(result) ?? 0;
  }

  @override
  Future<void> delete(String table, String id) async {
    await _db.delete(
      table,
      where: 'id = ?',
      whereArgs: [id],
    );
  }

  @override
  Future<void> deleteMany(String table, List<String> ids) async {
    final batch = _db.batch();
    for (final id in ids) {
      batch.delete(
        table,
        where: 'id = ?',
        whereArgs: [id],
      );
    }
    await batch.commit(noResult: true);
  }

  @override
  Future<Map<String, dynamic>?> get(String table, String id) async {
    final results = await _db.query(
      table,
      where: 'id = ?',
      whereArgs: [id],
      limit: 1,
    );
    return results.isEmpty ? null : results.first;
  }

  @override
  Future<List<Map<String, dynamic>>> getAll(String table) async {
    return _db.query(table);
  }

  @override
  Future<void> initialize() async {
    // 数据库已在构造时初始化
  }

  @override
  Future<List<Map<String, dynamic>>> query(
    String table,
    Map<String, dynamic> filter,
  ) async {
    AppLogger.debug(
      '执行数据库查询',
      tag: 'SQLiteDatabase',
      data: {
        'table': table,
        'filter': filter,
      },
    );

    final query = DatabaseQuery.fromJson(filter);
    final queryResult = _buildQuerySql(table, query);

    AppLogger.debug(
      '生成SQL查询语句',
      tag: 'SQLiteDatabase',
      data: {
        'sql': queryResult.sql,
        'args': queryResult.args,
      },
    );

    final results = await _db.rawQuery(queryResult.sql, queryResult.args);

    AppLogger.debug(
      '查询完成',
      tag: 'SQLiteDatabase',
      data: {
        'resultCount': results.length,
      },
    );

    return results;
  }

  @override
  Future<int> rawDelete(String sql, [List<Object?>? args]) async {
    return _db.rawDelete(sql, args);
  }

  @override
  Future<List<Map<String, dynamic>>> rawQuery(
    String sql, [
    List<Object?>? args,
  ]) async {
    return _db.rawQuery(sql, args);
  }

  @override
  Future<int> rawUpdate(String sql, [List<Object?>? args]) async {
    return _db.rawUpdate(sql, args);
  }

  @override
  Future<void> save(String table, String id, Map<String, dynamic> data) async {
    await _db.update(
      table,
      data,
      where: 'id = ?',
      whereArgs: [id],
    );
  }

  @override
  Future<void> saveMany(
    String table,
    Map<String, Map<String, dynamic>> data,
  ) async {
    final batch = _db.batch();
    for (final entry in data.entries) {
      batch.update(
        table,
        entry.value,
        where: 'id = ?',
        whereArgs: [entry.key],
      );
    }
    await batch.commit(noResult: true);
  }

  @override
  Future<void> set(String table, String id, Map<String, dynamic> data) async {
    await _db.insert(
      table,
      {'id': id, ...data},
      conflictAlgorithm: ConflictAlgorithm.replace,
    );
  }

  @override
  Future<void> setMany(
    String table,
    Map<String, Map<String, dynamic>> data,
  ) async {
    final batch = _db.batch();
    for (final entry in data.entries) {
      batch.insert(
        table,
        {'id': entry.key, ...entry.value},
        conflictAlgorithm: ConflictAlgorithm.replace,
      );
    }
    await batch.commit(noResult: true);
  }

  /// 构建COUNT查询SQL
  ({String sql, List<Object?> args}) _buildCountSql(
      String table, DatabaseQuery query) {
    final where = <String>[];
    final whereArgs = <dynamic>[];

    // 处理普通条件
    for (final condition in query.conditions) {
      where.add('${condition.field} ${condition.operator} ?');
      whereArgs.add(condition.value);
    }

    // 处理条件组
    if (query.groups?.isNotEmpty == true) {
      for (final group in query.groups!) {
        final groupWheres = <String>[];
        for (final condition in group.conditions) {
          groupWheres.add('${condition.field} ${condition.operator} ?');
          whereArgs.add(condition.value);
        }
        if (groupWheres.isNotEmpty) {
          final groupOperator = group.type == 'AND' ? ' AND ' : ' OR ';
          where.add('(${groupWheres.join(groupOperator)})');
        }
      }
    }

    final whereClause = where.isEmpty ? '' : 'WHERE ${where.join(' AND ')}';
    return (
      sql: 'SELECT COUNT(*) as count FROM $table $whereClause',
      args: whereArgs
    );
  }

  /// 构建查询SQL
  ({String sql, List<Object?> args}) _buildQuerySql(
      String table, DatabaseQuery query) {
    final where = <String>[];
    final whereArgs = <dynamic>[];

    // 处理普通条件
    for (final condition in query.conditions) {
      where.add('${condition.field} ${condition.operator} ?');
      whereArgs.add(condition.value);
    }

    // 处理条件组
    if (query.groups?.isNotEmpty == true) {
      for (final group in query.groups!) {
        final groupWheres = <String>[];
        for (final condition in group.conditions) {
          groupWheres.add('${condition.field} ${condition.operator} ?');
          whereArgs.add(condition.value);
        }
        if (groupWheres.isNotEmpty) {
          final groupOperator = group.type == 'AND' ? ' AND ' : ' OR ';
          where.add('(${groupWheres.join(groupOperator)})');
        }
      }
    }

    final whereClause = where.isEmpty ? '' : 'WHERE ${where.join(' AND ')}';
    final orderClause =
        query.orderBy == null ? '' : 'ORDER BY ${query.orderBy}';
    final limitClause = query.limit == null ? '' : 'LIMIT ${query.limit}';
    final offsetClause = query.offset == null ? '' : 'OFFSET ${query.offset}';

    return (
      sql:
          'SELECT * FROM $table $whereClause $orderClause $limitClause $offsetClause',
      args: whereArgs
    );
  }

  /// 创建SQLite数据库实例
  static Future<SQLiteDatabase> create({
    required String name,
    required String directory,
    List<String> migrations = const [],
  }) async {
    // 在 Windows 平台上初始化 sqflite_ffi
    if (defaultTargetPlatform == TargetPlatform.windows) {
      AppLogger.debug('初始化 SQLite FFI', tag: 'App');
      sqfliteFfiInit();
      databaseFactory = databaseFactoryFfi;
    }

    final path = join(directory, name);

    AppLogger.info(
      '数据库配置信息:\n'
      '  - 数据库类型: SQLite3\n'
      '  - 数据库名称: $name\n'
      '  - 数据库目录: $directory\n'
      '  - 完整路径: $path\n'
      '  - 数据库版本: ${migrations.length}\n'
      '  - 迁移脚本数量: ${migrations.length}',
      tag: 'Database',
    );

    final db = await openDatabase(
      path,
      version: migrations.length,
      onCreate: (db, version) async {
        AppLogger.info(
          '首次创建数据库，执行初始化...\n'
          '执行迁移脚本:\n',
          tag: 'Database',
        );
        for (final sql in migrations) {
          AppLogger.info(
            '执行SQL:\n$sql',
            tag: 'Database',
          );
          await db.execute(sql);
        }
      },
      onUpgrade: (db, oldVersion, newVersion) async {
        AppLogger.info(
          '升级数据库:\n'
          '  - 当前版本: v$oldVersion\n'
          '  - 目标版本: v$newVersion',
          tag: 'Database',
        );
        for (var i = oldVersion; i < newVersion; i++) {
          AppLogger.debug(
            '执行迁移脚本 ${i + 1}:\n${migrations[i]}',
            tag: 'Database',
          );
          await db.execute(migrations[i]);
        }
      },
      onConfigure: (db) async {
        await db.execute('PRAGMA foreign_keys = ON');
        AppLogger.debug(
          'SQLite配置完成: 已启用外键约束',
          tag: 'Database',
        );
      },
    );
    return SQLiteDatabase._(db);
  }
}



=======================================
./lib/infrastructure/providers/database_providers.dart
=======================================
import 'package:demo/infrastructure/providers/storage_providers.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../persistence/database_interface.dart';
import '../persistence/sqlite/migrations.dart';
import '../persistence/sqlite/sqlite_database.dart';

/// 数据库Provider
final databaseProvider = FutureProvider<DatabaseInterface>((ref) async {
  final basePath = await ref.watch(storageProvider.future).then((storage) {
    return storage.getAppDataPath();
  });
  return SQLiteDatabase.create(
    name: 'app.db',
    directory: '$basePath/database',
    migrations: migrations,
  );
});

/// 数据库初始化Provider
final initializedDatabaseProvider = Provider<DatabaseInterface>((ref) {
  final databaseState = ref.watch(databaseProvider);
  return databaseState.when(
    data: (database) => database,
    loading: () => throw StateError('Database service not initialized'),
    error: (err, stack) =>
        throw StateError('Database initialization failed: $err'),
  );
});



=======================================
./lib/infrastructure/providers/persistence_provider.dart
=======================================
import 'dart:convert';

import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:shared_preferences/shared_preferences.dart';

import '../../domain/models/work/work_filter.dart';

final persistenceProvider = Provider<PersistenceService>((ref) {
  return PersistenceService();
});

class PersistenceService {
  static const String viewModeKey = 'view_mode';
  static const String filterKey = 'work_filter';
  static const String sortKey = 'work_sort';
  static const String sidebarKey = 'sidebar_state';

  late SharedPreferences _sharedPreferences;

  SharedPreferences get sharedPreferences => _sharedPreferences;

  Future<void> init() async {
    _sharedPreferences = await SharedPreferences.getInstance();
  }

  Future<WorkFilter?> loadFilter() async {
    final prefs = await SharedPreferences.getInstance();
    final data = prefs.getString(filterKey);
    if (data == null) return null;
    return WorkFilter.fromJson(jsonDecode(data));
  }

  Future<bool> loadSidebarState() async {
    final prefs = await SharedPreferences.getInstance();
    return prefs.getBool(sidebarKey) ?? true;
  }

  Future<void> saveFilter(WorkFilter filter) async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.setString(filterKey, jsonEncode(filter.toJson()));
  }

  Future<void> saveSidebarState(bool isOpen) async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.setBool(sidebarKey, isOpen);
  }

  Future<void> saveViewMode(String mode) async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.setString(viewModeKey, mode);
  }

  // ...其他持久化方法
}



=======================================
./lib/infrastructure/providers/shared_preferences_provider.dart
=======================================
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:shared_preferences/shared_preferences.dart';

// 添加异步初始化Provider
final initializeSharedPreferencesProvider =
    FutureProvider<SharedPreferences>((ref) async {
  return await SharedPreferences.getInstance();
});

final sharedPreferencesProvider = Provider<SharedPreferences>((ref) {
  throw UnimplementedError(
      'sharedPreferencesProvider not initialized. Use override in ProviderScope.');
});



=======================================
./lib/infrastructure/providers/storage_providers.dart
=======================================
import 'package:demo/infrastructure/storage/local_storage.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:path/path.dart' as path;
import 'package:path_provider/path_provider.dart';

import '../../infrastructure/storage/storage_interface.dart';
import '../logging/logger.dart';

/// 获取已初始化的存储实例
final initializedStorageProvider = Provider<IStorage>((ref) {
  final storageState = ref.watch(storageProvider);
  return storageState.when(
    data: (storage) => storage,
    loading: () => throw StateError('Storage service not initialized'),
    error: (err, stack) =>
        throw StateError('Storage initialization failed: $err'),
  );
});

/// 存储服务 Provider
/// 提供应用的存储服务实例，负责初始化和管理存储资源
final storageProvider = FutureProvider<IStorage>((ref) async {
  AppLogger.debug('初始化存储服务', tag: 'Storage');

  try {
    // 1. 获取存储路径
    final appDir = await getApplicationDocumentsDirectory();
    final storagePath = path.join(appDir.path, 'storage');

    // 2. 创建存储服务实例
    final storage = LocalStorage(basePath: storagePath);

    // 3. 初始化目录结构
    await _initializeStorageStructure(storage);

    AppLogger.info('存储服务初始化完成', tag: 'Storage');
    return storage;
  } catch (e, stack) {
    AppLogger.error('存储服务初始化失败', error: e, stackTrace: stack, tag: 'Storage');
    rethrow;
  }
});

/// 创建存储服务所需的基础目录结构
Future<void> _initializeStorageStructure(IStorage storage) async {
  final appDataDir = storage.getAppDataPath();
  final tempDir = await storage.createTempDirectory();

  // 创建所需的目录结构
  await Future.wait([
    storage.ensureDirectoryExists(appDataDir),
    storage.ensureDirectoryExists(path.join(appDataDir, 'works')),
    storage.ensureDirectoryExists(path.join(appDataDir, 'cache')),
    storage.ensureDirectoryExists(path.join(appDataDir, 'config')),
    storage.ensureDirectoryExists(path.join(appDataDir, 'temp')),
    storage.ensureDirectoryExists(tempDir.path),
  ]);

  AppLogger.debug('存储目录结构创建完成', tag: 'Storage');
}



=======================================
./lib/infrastructure/storage/local_storage.dart
=======================================
import 'dart:io';

import 'package:path/path.dart' as path;

import '../logging/logger.dart';
import 'storage_interface.dart';

/// 基础存储服务
///
/// 职责:
/// 1. 基础文件系统操作
/// 2. 文件和目录管理
/// 3. 路径生成和验证
/// 4. 基础错误处理
class LocalStorage implements IStorage {
  final String _basePath;

  LocalStorage({
    required String basePath,
  }) : _basePath = basePath;

  /// 获取应用数据根目录
  String get appDataPath => _basePath;

  /// 复制文件
  @override
  Future<void> copyFile(String sourcePath, String targetPath) async {
    try {
      _validatePath(targetPath);
      final sourceFile = File(sourcePath);
      if (!await sourceFile.exists()) {
        throw FileSystemException('源文件不存在', sourcePath);
      }

      // 确保目标目录存在
      final targetDir = path.dirname(targetPath);
      await createDirectory(targetDir).then((dir) => null);

      await sourceFile.copy(targetPath);
    } catch (e, stack) {
      _handleError(
        '复制文件失败',
        e,
        stack,
        data: {
          'source': sourcePath,
          'target': targetPath,
        },
      );
    }
  }

  /// 创建目录
  @override
  Future<Directory> createDirectory(String dirPath) async {
    try {
      _validatePath(dirPath);
      final dir = Directory(dirPath);
      if (!await dir.exists()) {
        await dir.create(recursive: true);
        return dir;
      }
      return dir;
    } catch (e, stack) {
      _handleError(
        '创建目录失败',
        e,
        stack,
        data: {'path': dirPath},
      );
      rethrow;
    }
  }

  // ... Rest of the existing implementation ...

  /// 获取临时目录
  @override
  Future<Directory> createTempDirectory() async {
    try {
      final tempBasePath = path.join(_basePath, 'temp');
      final tempDirName = 'app_${DateTime.now().millisecondsSinceEpoch}';
      return await Directory(path.join(tempBasePath, tempDirName))
          .create(recursive: true);
    } catch (e, stack) {
      _handleError('获取临时目录失败', e, stack);
      rethrow;
    }
  }

  /// 删除目录
  @override
  Future<void> deleteDirectory(String dirPath) async {
    try {
      _validatePath(dirPath);
      final dir = Directory(dirPath);
      if (await dir.exists()) {
        await dir.delete(recursive: true);
      }
    } catch (e, stack) {
      _handleError(
        '删除目录失败',
        e,
        stack,
        data: {'path': dirPath},
      );
    }
  }

  /// 删除文件
  @override
  Future<void> deleteFile(String filePath) async {
    try {
      _validatePath(filePath);
      final file = File(filePath);
      if (await file.exists()) {
        await file.delete();
      }
    } catch (e, stack) {
      _handleError(
        '删除文件失败',
        e,
        stack,
        data: {'path': filePath},
      );
    }
  }

  /// 检查目录是否存在
  @override
  Future<bool> directoryExists(String dirPath) async {
    _validatePath(dirPath);
    return Directory(dirPath).exists();
  }

  /// 确保目录存在
  @override
  Future<void> ensureDirectoryExists(String dirPath) async {
    try {
      _validatePath(dirPath);
      await Directory(dirPath).create(recursive: true);
    } catch (e, stack) {
      _handleError(
        '确保目录存在失败',
        e,
        stack,
        data: {'path': dirPath},
      );
    }
  }

  /// 检查文件是否存在
  @override
  Future<bool> fileExists(String filePath) async {
    _validatePath(filePath);
    return File(filePath).exists();
  }

  /// 获取应用缓存目录路径
  @override
  String getAppCachePath() {
    return path.join(_basePath, 'cache');
  }

  /// 获取应用数据目录路径
  @override
  String getAppDataPath() {
    return _basePath;
  }

  @override
  String getAppTempPath() {
    return path.join(_basePath, 'temp');
  }

  /// 获取文件修改时间
  @override
  Future<DateTime> getFileModifiedTime(String filePath) async {
    try {
      _validatePath(filePath);
      final file = File(filePath);
      if (!await file.exists()) {
        throw FileSystemException('文件不存在', filePath);
      }
      return await file.lastModified();
    } catch (e, stack) {
      _handleError(
        '获取文件修改时间失败',
        e,
        stack,
        data: {'path': filePath},
      );
      rethrow;
    }
  }

  /// 获取文件大小
  @override
  Future<int> getFileSize(String filePath) async {
    try {
      _validatePath(filePath);
      final file = File(filePath);
      if (!await file.exists()) {
        throw FileSystemException('文件不存在', filePath);
      }
      return await file.length();
    } catch (e, stack) {
      _handleError(
        '获取文件大小失败',
        e,
        stack,
        data: {'path': filePath},
      );
      rethrow;
    }
  }

  /// 验证路径是否在应用目录内
  bool isPathValid(String targetPath) {
    final normalized = path.normalize(targetPath);
    return normalized.startsWith(_basePath);
  }

  /// 列出目录中的所有文件路径（递归）
  @override
  Future<List<String>> listDirectoryFiles(String dirPath) async {
    try {
      _validatePath(dirPath);
      final dir = Directory(dirPath);
      if (!await dir.exists()) {
        return [];
      }

      final files = <String>[];
      await for (final entity in dir.list(recursive: true)) {
        if (entity is File) {
          files.add(entity.path);
        }
      }

      AppLogger.debug('列出目录文件', tag: 'LocalStorage', data: {
        'directory': dirPath,
        'fileCount': files.length,
      });

      return files;
    } catch (e, stack) {
      _handleError(
        '列出目录文件失败',
        e,
        stack,
        data: {'path': dirPath},
      );
      return [];
    }
  }

  /// 移动文件
  @override
  Future<void> moveFile(String sourcePath, String targetPath) async {
    try {
      _validatePath(targetPath);
      final sourceFile = File(sourcePath);
      if (!await sourceFile.exists()) {
        throw FileSystemException('源文件不存在', sourcePath);
      }

      // 确保目标目录存在
      final targetDir = path.dirname(targetPath);
      await createDirectory(targetDir).then((dir) => null);

      await sourceFile.rename(targetPath);
    } catch (e, stack) {
      _handleError(
        '移动文件失败',
        e,
        stack,
        data: {
          'source': sourcePath,
          'target': targetPath,
        },
      );
    }
  }

  /// 规范化路径
  String normalizePath(String relativePath) =>
      path.join(_basePath, relativePath);

  /// 读取文件
  @override
  Future<List<int>> readFile(String filePath) async {
    try {
      _validatePath(filePath);
      final file = File(filePath);
      if (!await file.exists()) {
        throw FileSystemException('文件不存在', filePath);
      }
      return await file.readAsBytes();
    } catch (e, stack) {
      _handleError(
        '读取文件失败',
        e,
        stack,
        data: {'path': filePath},
      );
      rethrow;
    }
  }

  /// 重命名文件
  @override
  Future<void> renameFile(String oldPath, String newPath) async {
    try {
      _validatePath(oldPath);
      _validatePath(newPath);

      final file = File(oldPath);
      if (!await file.exists()) {
        throw FileSystemException('源文件不存在', oldPath);
      }

      await file.rename(newPath);
    } catch (e, stack) {
      _handleError(
        '重命名文件失败',
        e,
        stack,
        data: {
          'oldPath': oldPath,
          'newPath': newPath,
        },
      );
    }
  }

  /// 保存临时文件
  @override
  Future<String> saveTempFile(String sourcePath) async {
    try {
      final tempDir = await createTempDirectory();
      final fileName = path.basename(sourcePath);
      final tempPath = path.join(tempDir.path, fileName);
      await copyFile(sourcePath, tempPath);
      return tempPath;
    } catch (e, stack) {
      _handleError('保存临时文件失败', e, stack, data: {'sourcePath': sourcePath});
      rethrow;
    }
  }

  /// 写入文件
  @override
  Future<void> writeFile(String filePath, List<int> bytes) async {
    try {
      _validatePath(filePath);

      // 确保目标目录存在
      final dir = path.dirname(filePath);
      await createDirectory(dir).then((dir) => null);

      final file = File(filePath);
      await file.writeAsBytes(bytes);
    } catch (e, stack) {
      _handleError(
        '写入文件失败',
        e,
        stack,
        data: {'path': filePath},
      );
    }
  }

  /// 统一错误处理
  void _handleError(
    String message,
    Object error,
    StackTrace stack, {
    Map<String, dynamic>? data,
  }) {
    AppLogger.error(
      message,
      error: error,
      stackTrace: stack,
      tag: 'StorageService',
      data: data,
    );
    throw error;
  }

  /// 检查路径是否有效
  void _validatePath(String targetPath) {
    if (!isPathValid(targetPath)) {
      throw ArgumentError.value(
        targetPath,
        'path',
        '路径必须在应用目录内',
      );
    }
  }
}



=======================================
./lib/infrastructure/storage/storage_interface.dart
=======================================
import 'dart:io';

/// 存储接口
abstract class IStorage {
  /// 复制文件
  Future<void> copyFile(String sourcePath, String destinationPath);

  /// 创建目录
  Future<Directory> createDirectory(String path);

  /// 获取临时目录
  Future<Directory> createTempDirectory();

  /// 删除目录
  Future<void> deleteDirectory(String path);

  /// 删除文件
  Future<void> deleteFile(String path);

  /// 检查目录是否存在
  Future<bool> directoryExists(String path);

  /// 确保目录存在
  Future<void> ensureDirectoryExists(String path);

  /// 检查文件是否存在
  Future<bool> fileExists(String path);

  /// 获取应用缓存目录路径
  String getAppCachePath();

  /// 获取应用数据目录路径
  String getAppDataPath();

  /// 获取应用临时目录路径
  String getAppTempPath();

  /// 获取文件修改时间
  Future<DateTime> getFileModifiedTime(String path);

  /// 获取文件大小
  Future<int> getFileSize(String path);

  /// 列出目录中的所有文件路径（递归）
  Future<List<String>> listDirectoryFiles(String path);

  /// 移动文件
  Future<void> moveFile(String sourcePath, String destinationPath);

  /// 读取文件内容
  Future<List<int>> readFile(String path);

  /// 重命名文件
  Future<void> renameFile(String oldPath, String newPath);

  /// 保存临时文件
  Future<String> saveTempFile(String sourcePath);

  /// 写入文件内容
  Future<void> writeFile(String path, List<int> bytes);
}

/// 存储接口异常
class StorageException implements Exception {
  final String message;
  final dynamic error;
  final StackTrace? stackTrace;

  StorageException(this.message, [this.error, this.stackTrace]);

  @override
  String toString() => 'StorageException: $message';
}



=======================================
./lib/main.dart
=======================================
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:window_manager/window_manager.dart';

import 'infrastructure/logging/logger.dart';
import 'infrastructure/providers/shared_preferences_provider.dart';
import 'presentation/app.dart';

void main() async {
  WidgetsFlutterBinding.ensureInitialized();

  // 初始化窗口管理器
  await windowManager.ensureInitialized();

  WindowOptions windowOptions = const WindowOptions(
    size: Size(1280, 800),
    minimumSize: Size(800, 600),
    center: true,
    backgroundColor: Colors.transparent,
    skipTaskbar: false,
    titleBarStyle: TitleBarStyle.hidden,
  );

  // 设置窗口
  await windowManager.waitUntilReadyToShow(windowOptions, () async {
    await windowManager.show();
    await windowManager.focus();
  });

  AppLogger.init();
  try {
    // 初始化 SharedPreferences
    final prefs = await SharedPreferences.getInstance();

    // 创建ProviderContainer用于初始化阶段
    final container = ProviderContainer(
      observers: [ProviderLogger()],
      overrides: [
        sharedPreferencesProvider.overrideWithValue(prefs),
      ],
    );

    // // 等待数据库初始化完成
    // AppLogger.info('等待数据库初始化', tag: 'App');
    // await container.read(databaseProvider.future);
    // AppLogger.info('数据库初始化完成', tag: 'App');

    // // 执行初始化检查
    // AppLogger.info('开始应用初始化检查', tag: 'App');
    // await container.read(initializationControllerProvider).runInitialChecks();
    // AppLogger.info('应用初始化检查完成', tag: 'App');

    // 启动应用
    runApp(
      ProviderScope(
        parent: container,
        observers: [ProviderLogger()],
        child: const MyApp(),
      ),
    );
  } catch (e, stack) {
    // 确保在初始化过程中的错误也能被记录
    if (AppLogger.hasHandlers) {
      AppLogger.fatal('应用启动失败', error: e, stackTrace: stack, tag: 'App');
    } else {
      // 如果日志系统未初始化，使用调试打印
      debugPrint('严重错误：应用启动失败: $e');
      debugPrint('$stack');
    }

    // 显示基本的错误界面
    runApp(
      MaterialApp(
        home: Scaffold(
          body: Center(
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                const Icon(Icons.error_outline, size: 48, color: Colors.red),
                const SizedBox(height: 16),
                Text(
                  '应用启动失败: $e',
                  style: const TextStyle(color: Colors.red),
                  textAlign: TextAlign.center,
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}

/// Riverpod 日志记录器
class ProviderLogger extends ProviderObserver {
  @override
  void didAddProvider(
    ProviderBase<dynamic> provider,
    Object? value,
    ProviderContainer container,
  ) {
    AppLogger.debug(
      'Provider $provider was initialized with $value',
      tag: 'Riverpod',
    );
  }

  @override
  void didDisposeProvider(
    ProviderBase<dynamic> provider,
    ProviderContainer container,
  ) {
    AppLogger.debug('Provider $provider was disposed', tag: 'Riverpod');
  }

  @override
  void didUpdateProvider(
    ProviderBase<dynamic> provider,
    Object? previousValue,
    Object? newValue,
    ProviderContainer container,
  ) {
    if (previousValue != newValue) {
      AppLogger.debug(
        'Provider $provider updated from $previousValue to $newValue',
        tag: 'Riverpod',
      );
    }
  }
}



=======================================
./lib/presentation/app.dart
=======================================
import 'package:flutter/material.dart';
import 'package:flutter_localizations/flutter_localizations.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../application/providers/initialization_providers.dart';
import '../presentation/pages/characters/character_list_page.dart';
import '../presentation/pages/practices/practice_detail_page.dart';
import '../presentation/pages/practices/practice_edit_page.dart';
import '../presentation/pages/practices/practice_list_page.dart';
import '../presentation/pages/settings/settings_page.dart';
import '../presentation/pages/works/work_browse_page.dart';
import '../presentation/pages/works/work_detail_page.dart';
import '../routes/app_routes.dart';
import '../theme/app_theme.dart';
import 'pages/initialization/initialization_screen.dart';
import 'pages/main/main_window.dart';

class MyApp extends ConsumerWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // Listen to initialization provider to ensure everything is set up
    final initialization = ref.watch(appInitializationProvider);

    return initialization.when(
      loading: () => const MaterialApp(
        home: InitializationScreen(),
      ),
      error: (error, stack) => MaterialApp(
        home: Scaffold(
          body: Center(
            child: Text('初始化失败: $error'),
          ),
        ),
      ),
      data: (_) => MaterialApp(
        title: '书法集字',
        theme: AppTheme.light(),
        debugShowCheckedModeBanner: false,
        home: const MainWindow(),
        onGenerateRoute: _generateRoute,
        localizationsDelegates: const [
          GlobalMaterialLocalizations.delegate,
          GlobalWidgetsLocalizations.delegate,
          GlobalCupertinoLocalizations.delegate,
        ],
        supportedLocales: const [
          Locale('zh'),
          Locale('en'),
        ],
      ),
    );
  }

  Route<dynamic>? _generateRoute(RouteSettings settings) {
    final args = settings.arguments;

    switch (settings.name) {
      case AppRoutes.home:
        return MaterialPageRoute(
          builder: (context) => const MainWindow(),
        );

      case AppRoutes.workBrowse:
        return MaterialPageRoute(
          builder: (context) => const WorkBrowsePage(),
        );

      case AppRoutes.workDetail:
        if (args is String) {
          return MaterialPageRoute(
            builder: (context) => WorkDetailPage(workId: args),
          );
        }
        break;

      case AppRoutes.characterList:
        return MaterialPageRoute(
          builder: (context) => const CharacterListPage(),
        );

      case AppRoutes.practiceList:
        return MaterialPageRoute(
          builder: (context) => const PracticeListPage(),
        );

      case AppRoutes.practiceEdit:
        return MaterialPageRoute(
          builder: (context) => PracticeEditPage(
            practiceId: args as String?,
          ),
        );

      case AppRoutes.practiceDetail:
        if (args is String) {
          return MaterialPageRoute(
            builder: (context) => PracticeDetailPage(
              practiceId: args,
            ),
          );
        }
        break;

      case AppRoutes.settings:
        return MaterialPageRoute(
          builder: (context) => const SettingsPage(),
        );
    }

    // Unknown routes return to home
    return MaterialPageRoute(
      builder: (context) => const MainWindow(),
    );
  }
}



=======================================
./lib/presentation/constants/work_card_styles.dart
=======================================
import 'package:flutter/material.dart';

import '../../theme/app_sizes.dart';

class WorkCardStyles {
  static const cardAspectRatio = 0.8; // 卡片宽高比
  static const imageAspectRatio = 4 / 3; // 图片宽高比
  static const thumbnailSize = Size(240, 180); // 缩略图尺寸

  static const gridCardConstraints = BoxConstraints(
    maxWidth: AppSizes.gridCardWidth,
    minHeight: AppSizes.gridCardImageHeight + AppSizes.gridCardInfoHeight,
  );

  static const listItemConstraints = BoxConstraints(
    minHeight: 120,
    maxHeight: 120,
  );
}



=======================================
./lib/presentation/dialogs/character_edit_dialog.dart
=======================================
import 'package:flutter/material.dart';

class CharacterEditDialog extends StatefulWidget {
  final String charId;

  const CharacterEditDialog({
    super.key,
    required this.charId,
  });

  @override
  State<CharacterEditDialog> createState() => _CharacterEditDialogState();
}

class _CharacterEditDialogState extends State<CharacterEditDialog> {
  late final TextEditingController _simplifiedController;
  late final TextEditingController _traditionalController;
  late final TextEditingController _remarksController;
  String? _style;
  String? _tool;

  @override
  void initState() {
    super.initState();
    // TODO: 加载实际数据
    _simplifiedController = TextEditingController(text: '永');
    _traditionalController = TextEditingController(text: '永');
    _remarksController = TextEditingController();
    _style = 'kai';
    _tool = 'brush';
  }

  @override
  Widget build(BuildContext context) {
    return Dialog(
      child: Container(
        width: 400,
        padding: const EdgeInsets.all(16),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                const Text('编辑集字信息', style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold)),
                const Spacer(),
                IconButton(
                  icon: const Icon(Icons.close),
                  onPressed: () => Navigator.of(context).pop(),
                ),
              ],
            ),
            const SizedBox(height: 16),
            TextField(
              controller: _simplifiedController,
              decoration: const InputDecoration(
                labelText: '简体字 *',
                border: OutlineInputBorder(),
              ),
              maxLength: 1,
            ),
            const SizedBox(height: 16),
            TextField(
              controller: _traditionalController,
              decoration: const InputDecoration(
                labelText: '繁体字',
                border: OutlineInputBorder(),
              ),
              maxLength: 1,
            ),
            const SizedBox(height: 16),
            DropdownButtonFormField<String>(
              value: _style,
              decoration: const InputDecoration(
                labelText: '书法风格',
                border: OutlineInputBorder(),
              ),
              items: const [
                DropdownMenuItem(value: 'kai', child: Text('楷书')),
                DropdownMenuItem(value: 'xing', child: Text('行书')),
                DropdownMenuItem(value: 'cao', child: Text('草书')),
              ],
              onChanged: (value) => setState(() => _style = value),
            ),
            const SizedBox(height: 16),
            DropdownButtonFormField<String>(
              value: _tool,
              decoration: const InputDecoration(
                labelText: '书写工具',
                border: OutlineInputBorder(),
              ),
              items: const [
                DropdownMenuItem(value: 'brush', child: Text('毛笔')),
                DropdownMenuItem(value: 'pen', child: Text('硬笔')),
              ],
              onChanged: (value) => setState(() => _tool = value),
            ),
            const SizedBox(height: 16),
            TextField(
              controller: _remarksController,
              maxLines: 3,
              decoration: const InputDecoration(
                labelText: '备注',
                border: OutlineInputBorder(),
              ),
            ),
            const SizedBox(height: 24),
            Row(
              mainAxisAlignment: MainAxisAlignment.end,
              children: [
                TextButton(
                  onPressed: () => Navigator.of(context).pop(),
                  child: const Text('取消'),
                ),
                const SizedBox(width: 8),
                ElevatedButton(
                  onPressed: () {
                    // TODO: 保存编辑
                    Navigator.of(context).pop();
                  },
                  child: const Text('保存'),
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }

  @override
  void dispose() {
    _simplifiedController.dispose();
    _traditionalController.dispose();
    _remarksController.dispose();
    super.dispose();
  }
}



=======================================
./lib/presentation/dialogs/common/dialogs.dart
=======================================
import 'package:flutter/material.dart';

Future<bool?> showConfirmDialog({
  required BuildContext context,
  required String title,
  required String message,
  String? cancelText,
  String? confirmText,
}) async {
  return await showDialog<bool>(
    context: context,
    builder: (context) => AlertDialog(
      title: Text(title),
      content: Text(message),
      actions: [
        TextButton(
          onPressed: () => Navigator.of(context).pop(false),
          child: Text(cancelText ?? '取消'),
        ),
        FilledButton(
          onPressed: () => Navigator.of(context).pop(true),
          child: Text(confirmText ?? '确定'),
        ),
      ],
    ),
  );
}

Future<void> showErrorDialog({
  required BuildContext context,
  required String title,
  required String message,
  String? buttonText,
}) async {
  await showDialog<void>(
    context: context,
    builder: (context) => AlertDialog(
      title: Text(title),
      content: Text(message),
      actions: [
        FilledButton(
          onPressed: () => Navigator.of(context).pop(),
          child: Text(buttonText ?? '确定'),
        ),
      ],
    ),
  );
}



=======================================
./lib/presentation/dialogs/common/dialog_button_group.dart
=======================================
import 'package:flutter/material.dart';

class DialogButtonGroup extends StatelessWidget {
  final VoidCallback onCancel;
  final VoidCallback onConfirm;
  final String cancelText;
  final String confirmText;
  final bool isProcessing;
  final bool isConfirmEnabled;

  const DialogButtonGroup({
    super.key,
    required this.onCancel,
    required this.onConfirm,
    this.cancelText = '取消',
    this.confirmText = '确定',
    this.isProcessing = false,
    this.isConfirmEnabled = true,
  });

  @override
  Widget build(BuildContext context) {
    return Row(
      mainAxisAlignment: MainAxisAlignment.end,
      children: [
        if (isProcessing)
          const Padding(
            padding: EdgeInsets.only(right: 16.0),
            child: SizedBox(
              width: 20,
              height: 20,
              child: CircularProgressIndicator(strokeWidth: 2),
            ),
          ),
        TextButton(
          onPressed: isProcessing ? null : onCancel,
          child: Text(cancelText),
        ),
        const SizedBox(width: 8),
        FilledButton(
          onPressed: (isProcessing || !isConfirmEnabled) ? null : onConfirm,
          child: Text(confirmText),
        ),
      ],
    );
  }
}



=======================================
./lib/presentation/dialogs/work_import/components/form/work_import_form.dart
=======================================
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';

import '../../../../../domain/enums/work_style.dart';
import '../../../../../domain/enums/work_tool.dart';
import '../../../../../theme/app_sizes.dart';
import '../../../../viewmodels/states/work_import_state.dart';
import '../../../../viewmodels/work_import_view_model.dart';
import '../../../../widgets/inputs/date_input_field.dart';
import '../../../../widgets/inputs/dropdown_field.dart';

/// Form for entering work metadata during import
class WorkImportForm extends StatefulWidget {
  final WorkImportState state;
  final WorkImportViewModel viewModel;

  const WorkImportForm({
    super.key,
    required this.state,
    required this.viewModel,
  });

  @override
  State<WorkImportForm> createState() => _WorkImportFormState();
}

class _ErrorAnimation extends StatefulWidget {
  final String errorText;
  final Color color;

  const _ErrorAnimation({
    required this.errorText,
    required this.color,
  });

  @override
  State<_ErrorAnimation> createState() => _ErrorAnimationState();
}

class _ErrorAnimationState extends State<_ErrorAnimation>
    with SingleTickerProviderStateMixin {
  late final AnimationController _controller;
  late final Animation<double> _animation;

  @override
  Widget build(BuildContext context) {
    return FadeTransition(
      opacity: _animation,
      child: SlideTransition(
        position: Tween<Offset>(
          begin: const Offset(-0.1, 0),
          end: Offset.zero,
        ).animate(_animation),
        child: Padding(
          padding: const EdgeInsets.only(left: 12, top: 4),
          child: Text(
            widget.errorText,
            style: TextStyle(
              color: widget.color,
              fontSize: 12,
            ),
          ),
        ),
      ),
    );
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  @override
  void initState() {
    super.initState();
    _controller = AnimationController(
      duration: const Duration(milliseconds: 300),
      vsync: this,
    );
    _animation = CurvedAnimation(
      parent: _controller,
      curve: Curves.easeOut,
    );
    _controller.forward();
  }
}

class _HelpText extends StatelessWidget {
  final String text;
  final IconData? icon;

  const _HelpText({
    required this.text,
    this.icon,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    return Padding(
      padding: const EdgeInsets.only(left: 12, top: 4),
      child: Row(
        children: [
          if (icon != null) ...[
            Icon(
              icon,
              size: 14,
              color: theme.hintColor,
            ),
            const SizedBox(width: 4),
          ],
          Text(
            text,
            style: theme.textTheme.bodySmall?.copyWith(
              color: theme.hintColor,
            ),
          ),
        ],
      ),
    );
  }
}

class _WorkImportFormState extends State<WorkImportForm> {
  final _formKey = GlobalKey<FormState>();
  final _titleFocus = FocusNode();
  final _authorFocus = FocusNode();
  final _remarkFocus = FocusNode();

  final _titleController = TextEditingController();
  final _authorController = TextEditingController();
  final _remarkController = TextEditingController();

  bool _hasInteracted = false;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final isProcessing = widget.state.isProcessing;

    return Focus(
      onKey: (_, event) {
        _handleKeyPress(event);
        return KeyEventResult.ignored;
      },
      child: Form(
        key: _formKey,
        autovalidateMode: _hasInteracted
            ? AutovalidateMode.onUserInteraction
            : AutovalidateMode.disabled,
        child: SingleChildScrollView(
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.stretch,
            mainAxisSize: MainAxisSize.min,
            children: [
              // 标题 (Ctrl+T)
              _buildFieldWithTooltip(
                shortcut: 'Ctrl+T',
                tooltip: '按 Ctrl+T 快速跳转到标题输入框',
                helpText: '作品的主要标题，将显示在作品列表中',
                helpIcon: Icons.info_outline,
                child: TextFormField(
                  focusNode: _titleFocus,
                  controller: _titleController,
                  decoration: InputDecoration(
                    labelText: '标题 *',
                    hintText: '请输入标题',
                    suffixText: _titleFocus.hasFocus ? 'Ctrl+T' : null,
                    errorStyle: const TextStyle(height: 0),
                    counterText: '${_titleController.text.length}/100',
                  ),
                  onChanged: widget.viewModel.setTitle,
                  validator: _validateTitle,
                  textInputAction: TextInputAction.next,
                  onEditingComplete: () => _authorFocus.requestFocus(),
                  enabled: !widget.state.isProcessing,
                  maxLength: 100,
                ),
              ),
              if (_hasInteracted &&
                  _validateTitle(_titleController.text) != null)
                _ErrorAnimation(
                  errorText: _validateTitle(_titleController.text)!,
                  color: theme.colorScheme.error,
                ),
              const SizedBox(height: AppSizes.m),

              // 作者 (Ctrl+A)
              _buildFieldWithTooltip(
                shortcut: 'Ctrl+A',
                tooltip: '按 Ctrl+A 快速跳转到作者输入框',
                helpText: '可选，作品的创作者',
                helpIcon: Icons.person_outline,
                child: TextFormField(
                  focusNode: _authorFocus,
                  controller: _authorController,
                  decoration: InputDecoration(
                    labelText: '作者',
                    hintText: '请输入作者名',
                    suffixText: _authorFocus.hasFocus ? 'Ctrl+A' : null,
                    errorStyle: const TextStyle(height: 0),
                    counterText: '${_authorController.text.length}/50',
                  ),
                  onChanged: widget.viewModel.setAuthor,
                  validator: _validateAuthor,
                  textInputAction: TextInputAction.next,
                  onEditingComplete: () => FocusScope.of(context).nextFocus(),
                  enabled: !widget.state.isProcessing,
                  maxLength: 50,
                ),
              ),
              if (_hasInteracted &&
                  _validateAuthor(_authorController.text) != null)
                _ErrorAnimation(
                  errorText: _validateAuthor(_authorController.text)!,
                  color: theme.colorScheme.error,
                ),
              const SizedBox(height: AppSizes.m),

              // 画风
              _buildFieldWithTooltip(
                shortcut: 'Tab',
                tooltip: '按 Tab 键导航到下一个字段',
                helpText: '作品的主要画风类型',
                helpIcon: Icons.palette_outlined,
                child: DropdownField<String>(
                  label: '画风',
                  value: widget.state.style?.value,
                  items: WorkStyle.values
                      .map((e) => DropdownMenuItem(
                            value: e.value,
                            child: Text(e.label),
                          ))
                      .toList(),
                  onChanged: isProcessing ? null : _handleStyleChange,
                  enabled: !isProcessing,
                ),
              ),
              const SizedBox(height: AppSizes.m),

              // 创作工具
              _buildFieldWithTooltip(
                shortcut: 'Tab',
                tooltip: '按 Tab 键导航到下一个字段',
                helpText: '创作本作品使用的主要工具',
                helpIcon: Icons.brush_outlined,
                child: DropdownField<String>(
                  label: '创作工具',
                  value: widget.state.tool?.value,
                  items: WorkTool.values
                      .map((e) => DropdownMenuItem(
                            value: e.value,
                            child: Text(e.label),
                          ))
                      .toList(),
                  onChanged: isProcessing ? null : _handleToolChange,
                  enabled: !isProcessing,
                ),
              ),
              const SizedBox(height: AppSizes.m),

              // 创作日期
              _buildFieldWithTooltip(
                shortcut: 'Tab',
                tooltip: '按 Tab 键导航到下一个字段',
                helpText: '作品的完成日期',
                helpIcon: Icons.calendar_today_outlined,
                child: DateInputField(
                  label: '创作日期',
                  value: widget.state.creationDate,
                  onChanged: isProcessing ? null : _handleDateChange,
                  textInputAction: TextInputAction.next,
                  onEditingComplete:
                      isProcessing ? null : () => _remarkFocus.requestFocus(),
                  enabled: !isProcessing,
                ),
              ),
              const SizedBox(height: AppSizes.m),

              // 备注 (Ctrl+R)
              _buildFieldWithTooltip(
                shortcut: 'Ctrl+R',
                tooltip: '按 Ctrl+R 快速跳转到备注输入框',
                helpText: '可选，关于作品的其他说明',
                helpIcon: Icons.notes_outlined,
                child: TextFormField(
                  focusNode: _remarkFocus,
                  controller: _remarkController,
                  decoration: InputDecoration(
                    labelText: '备注',
                    hintText: '可选',
                    suffixText: _remarkFocus.hasFocus ? 'Ctrl+R' : null,
                    errorStyle: const TextStyle(height: 0),
                    counterText: '${_remarkController.text.length}/500',
                  ),
                  maxLines: 3,
                  onChanged: widget.viewModel.setRemark,
                  validator: _validateRemark,
                  textInputAction: TextInputAction.done,
                  enabled: !widget.state.isProcessing,
                  maxLength: 500,
                ),
              ),
              if (_hasInteracted &&
                  _validateRemark(_remarkController.text) != null)
                _ErrorAnimation(
                  errorText: _validateRemark(_remarkController.text)!,
                  color: theme.colorScheme.error,
                ),

              if (widget.state.error != null) ...[
                const SizedBox(height: AppSizes.m),
                _ErrorAnimation(
                  errorText: widget.state.error!,
                  color: theme.colorScheme.error,
                ),
              ],

              // Keyboard shortcuts help
              const SizedBox(height: AppSizes.l),
              Text(
                '键盘快捷键:',
                style: theme.textTheme.titleSmall,
              ),
              const SizedBox(height: AppSizes.s),
              Text(
                'Ctrl+T: 标题  Ctrl+A: 作者  Ctrl+R: 备注\n'
                'Enter: 确认  Tab: 下一项  Shift+Tab: 上一项',
                style: theme.textTheme.bodySmall,
              ),
            ],
          ),
        ),
      ),
    );
  }

  @override
  void didUpdateWidget(WorkImportForm oldWidget) {
    super.didUpdateWidget(oldWidget);
    _updateControllers();
  }

  @override
  void dispose() {
    _titleFocus.dispose();
    _authorFocus.dispose();
    _remarkFocus.dispose();

    _titleController.dispose();
    _authorController.dispose();
    _remarkController.dispose();
    super.dispose();
  }

  @override
  void initState() {
    super.initState();
    _updateControllers();
    _setupKeyboardListeners();
  }

  Widget _buildFieldWithTooltip({
    required Widget child,
    required String shortcut,
    required String tooltip,
    String? helpText,
    IconData? helpIcon,
  }) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Tooltip(
          message: tooltip,
          waitDuration: const Duration(milliseconds: 500),
          child: child,
        ),
        if (helpText != null)
          _HelpText(
            text: helpText,
            icon: helpIcon,
          ),
      ],
    );
  }

  void _handleDateChange(DateTime? date) {
    if (date != null) {
      if (date.isAfter(DateTime.now())) {
        // 日期不能超过当前日期
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('创作日期不能超过当前日期'),
            behavior: SnackBarBehavior.floating,
          ),
        );
        return;
      }
      widget.viewModel.setCreationDate(date);
    }
  }

  void _handleFocusChange() {
    setState(() {});
  }

  void _handleKeyPress(RawKeyEvent event) {
    if (event is! RawKeyDownEvent) return;
    if (!event.isControlPressed) return;

    switch (event.logicalKey) {
      case LogicalKeyboardKey.keyT:
        _titleFocus.requestFocus();
        break;
      case LogicalKeyboardKey.keyA:
        _authorFocus.requestFocus();
        break;
      case LogicalKeyboardKey.keyR:
        _remarkFocus.requestFocus();
        break;
      case LogicalKeyboardKey.enter:
        _handleSubmit();
        break;
      default:
        break;
    }
  }

  void _handleStyleChange(String? value) {
    if (value != null && !widget.state.isProcessing) {
      widget.viewModel.setStyle(value);
      FocusScope.of(context).nextFocus();
    }
  }

  Future<void> _handleSubmit() async {
    setState(() => _hasInteracted = true);

    if (_formKey.currentState?.validate() ?? false) {
      try {
        Navigator.of(context).pop(true);
      } catch (e) {
        if (!mounted) return;
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('提交失败: ${e.toString()}'),
            backgroundColor: Theme.of(context).colorScheme.error,
            behavior: SnackBarBehavior.floating,
            action: SnackBarAction(
              label: '重试',
              onPressed: _handleSubmit,
              textColor: Theme.of(context).colorScheme.onError,
            ),
          ),
        );
      }
    }
  }

  void _handleToolChange(String? value) {
    if (value != null && !widget.state.isProcessing) {
      widget.viewModel.setTool(value);
      FocusScope.of(context).nextFocus();
    }
  }

  void _setupKeyboardListeners() {
    _titleFocus.addListener(_handleFocusChange);
    _authorFocus.addListener(_handleFocusChange);
    _remarkFocus.addListener(_handleFocusChange);
  }

  void _updateControllers() {
    final newText = widget.state.title;
    if (_titleController.text != newText) {
      _titleController.value = TextEditingValue(
        text: newText,
        // 如果选择范围超出新文本长度，则将其设为文本末尾
        selection: TextSelection.collapsed(offset: newText.length),
      );
    }

    final newAuthor = widget.state.author ?? '';
    if (_authorController.text != newAuthor) {
      _authorController.value = TextEditingValue(
        text: newAuthor,
        selection: TextSelection.collapsed(offset: newAuthor.length),
      );
    }

    final newRemark = widget.state.remark ?? '';
    if (_remarkController.text != newRemark) {
      _remarkController.value = TextEditingValue(
        text: newRemark,
        selection: TextSelection.collapsed(offset: newRemark.length),
      );
    }
  }

  String? _validateAuthor(String? value) {
    if (!_hasInteracted) return null;

    if (value != null && value.trim().length > 50) {
      return '作者名不能超过50个字符';
    }
    return null;
  }

  String? _validateRemark(String? value) {
    if (!_hasInteracted) return null;

    if (value != null && value.trim().length > 500) {
      return '备注不能超过500个字符';
    }
    return null;
  }

  String? _validateTitle(String? value) {
    if (!_hasInteracted) return null;

    if (value == null || value.trim().isEmpty) {
      return '请输入作品标题';
    }
    if (value.trim().length < 2) {
      return '标题至少需要2个字符';
    }
    if (value.trim().length > 100) {
      return '标题不能超过100个字符';
    }
    return null;
  }
}



=======================================
./lib/presentation/dialogs/work_import/components/preview/drop_target.dart
=======================================
import 'dart:io';

import 'package:flutter/material.dart';

class ImageDropTarget extends StatefulWidget {
  final Widget child;
  final void Function(List<File>) onFilesDropped;

  const ImageDropTarget({
    super.key,
    required this.child,
    required this.onFilesDropped,
  });

  @override
  State<ImageDropTarget> createState() => _ImageDropTargetState();
}

class _ImageDropTargetState extends State<ImageDropTarget> {
  bool _isDragging = false;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return DragTarget<List<String>>(
      onWillAcceptWithDetails: (data) {
        setState(() => _isDragging = true);
        return data.data.isNotEmpty;
      },
      onAcceptWithDetails: (details) {
        setState(() => _isDragging = false);
        final files = details.data.map((path) => File(path)).toList();
        widget.onFilesDropped(files);
      },
      onLeave: (_) {
        setState(() => _isDragging = false);
      },
      builder: (context, candidateData, rejectedData) {
        return AnimatedContainer(
          duration: const Duration(milliseconds: 200),
          decoration: BoxDecoration(
            border: Border.all(
              color:
                  _isDragging ? theme.colorScheme.primary : Colors.transparent,
              width: 2,
            ),
          ),
          child: widget.child,
        );
      },
    );
  }
}



=======================================
./lib/presentation/dialogs/work_import/components/preview/image_drop_target.dart
=======================================
import 'dart:io';

import 'package:flutter/material.dart';
import 'package:flutter/services.dart';

import '../../../../../theme/app_sizes.dart';

class ImageDropTarget extends StatefulWidget {
  final Widget child;
  final void Function(List<File>) onFilesDropped;

  const ImageDropTarget({
    super.key,
    required this.child,
    required this.onFilesDropped,
  });

  @override
  State<ImageDropTarget> createState() => _ImageDropTargetState();
}

class _ImageDropTargetState extends State<ImageDropTarget> {
  bool _isDragging = false;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return DragTarget<List<String>>(
      onWillAcceptWithDetails: (data) {
        final hasValidFiles = data.data.any((path) {
              final ext = path.toLowerCase();
              return ext.endsWith('.jpg') ||
                  ext.endsWith('.jpeg') ||
                  ext.endsWith('.png') ||
                  ext.endsWith('.webp');
            }) ??
            false;

        setState(() => _isDragging = hasValidFiles);
        return hasValidFiles;
      },
      onAcceptWithDetails: (data) {
        setState(() => _isDragging = false);
        final files = data.data
            .map((path) => File(path))
            .where((file) => file.existsSync())
            .toList();

        if (files.isNotEmpty) {
          HapticFeedback.selectionClick();
          widget.onFilesDropped(files);
        }
      },
      onLeave: (_) => setState(() => _isDragging = false),
      builder: (context, candidateData, rejectedData) {
        return Stack(
          fit: StackFit.expand,
          children: [
            widget.child,
            if (_isDragging)
              Container(
                color: theme.colorScheme.primary.withOpacity(0.1),
                child: Center(
                  child: Container(
                    padding: const EdgeInsets.symmetric(
                      horizontal: AppSizes.l,
                      vertical: AppSizes.m,
                    ),
                    decoration: BoxDecoration(
                      color: theme.colorScheme.surface,
                      borderRadius: BorderRadius.circular(AppSizes.xs),
                      border: Border.all(
                        color: theme.colorScheme.primary,
                      ),
                    ),
                    child: Column(
                      mainAxisSize: MainAxisSize.min,
                      children: [
                        const Icon(Icons.file_upload),
                        const SizedBox(height: AppSizes.s),
                        Text(
                          '松开鼠标添加图片',
                          style: theme.textTheme.bodyLarge?.copyWith(
                            color: theme.colorScheme.primary,
                          ),
                        ),
                      ],
                    ),
                  ),
                ),
              ),
          ],
        );
      },
    );
  }
}



=======================================
./lib/presentation/dialogs/work_import/components/preview/image_viewer.dart
=======================================
import 'dart:io';

import 'package:flutter/material.dart';

import '../../../../../theme/app_sizes.dart';

class ImageViewer extends StatelessWidget {
  final File image;
  final double rotation;
  final double scale;
  final ValueChanged<double>? onScaleChanged;

  const ImageViewer({
    super.key,
    required this.image,
    required this.rotation,
    this.scale = 1.0,
    this.onScaleChanged,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Stack(
      fit: StackFit.expand,
      children: [
        // 图片预览区域
        InteractiveViewer(
          minScale: 0.5,
          maxScale: 4.0,
          onInteractionUpdate: (details) {
            if (details.pointerCount > 0 && details.scale != scale) {
              onScaleChanged?.call(details.scale);
            }
          },
          child: Center(
            child: Transform.rotate(
              angle: rotation * (3.1415927 / 180.0),
              child: Image.file(
                image,
                fit: BoxFit.contain,
                errorBuilder: (context, error, stackTrace) {
                  return Center(
                    child: Column(
                      mainAxisSize: MainAxisSize.min,
                      children: [
                        Icon(
                          Icons.broken_image_outlined,
                          size: 48,
                          color: theme.colorScheme.error,
                        ),
                        const SizedBox(height: AppSizes.s),
                        Text(
                          '图片加载失败',
                          style: theme.textTheme.bodyMedium?.copyWith(
                            color: theme.colorScheme.error,
                          ),
                        ),
                      ],
                    ),
                  );
                },
              ),
            ),
          ),
        ),
      ],
    );
  }
}



=======================================
./lib/presentation/dialogs/work_import/components/preview/preview_toolbar.dart
=======================================
import 'package:flutter/material.dart';

import '../../../../../theme/app_sizes.dart';

class PreviewToolbar extends StatelessWidget {
  final bool hasImages;
  final bool hasSelection;
  final VoidCallback? onAddImages; // 添加
  final VoidCallback? onRotateLeft;
  final VoidCallback? onRotateRight;
  final VoidCallback? onDelete;
  final VoidCallback? onDeleteAll;

  const PreviewToolbar({
    super.key,
    this.hasImages = false,
    this.hasSelection = false,
    this.onAddImages, // 添加
    this.onRotateLeft,
    this.onRotateRight,
    this.onDelete,
    this.onDeleteAll,
  });

  @override
  Widget build(BuildContext context) {
    return SizedBox(
      height: 48, // 固定工具栏高度
      child: Padding(
        padding: const EdgeInsets.symmetric(
          horizontal: AppSizes.m,
          vertical: AppSizes.s,
        ),
        child: Row(
          children: [
            // 添加图片
            _ToolbarIconButton(
              icon: Icons.add_photo_alternate_outlined,
              tooltip: '添加图片',
              onPressed: onAddImages,
            ),
            const SizedBox(width: AppSizes.m),
            // 向左旋转
            _ToolbarIconButton(
              icon: Icons.rotate_left,
              tooltip: '向左旋转',
              onPressed: hasSelection ? onRotateLeft : null,
            ),
            // 向右旋转
            _ToolbarIconButton(
              icon: Icons.rotate_right,
              tooltip: '向右旋转',
              onPressed: hasSelection ? onRotateRight : null,
            ),
            const Spacer(),
            // 删除选中
            _ToolbarIconButton(
              icon: Icons.delete_outline,
              tooltip: '删除选中',
              onPressed: hasSelection ? onDelete : null,
              isDestructive: true,
            ),
            // 全部删除
            _ToolbarIconButton(
              icon: Icons.delete_sweep_outlined,
              tooltip: '全部删除',
              onPressed: hasImages ? onDeleteAll : null,
              isDestructive: true,
            ),
          ],
        ),
      ),
    );
  }
}

class _ToolbarIconButton extends StatelessWidget {
  final IconData icon;
  final String tooltip;
  final VoidCallback? onPressed;
  final bool isDestructive;

  const _ToolbarIconButton({
    required this.icon,
    required this.tooltip,
    this.onPressed,
    this.isDestructive = false,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final bool isEnabled = onPressed != null;

    return IconButton(
      onPressed: onPressed,
      icon: Icon(
        icon,
        size: 20,
        color: isEnabled
            ? (isDestructive
                ? theme.colorScheme.error
                : theme.colorScheme.onSurfaceVariant)
            : theme.colorScheme.onSurfaceVariant.withOpacity(0.38),
      ),
      tooltip: tooltip,
      visualDensity: VisualDensity.compact,
      style: IconButton.styleFrom(
        foregroundColor: isDestructive
            ? theme.colorScheme.error
            : theme.colorScheme.onSurfaceVariant,
        backgroundColor: Colors.transparent,
        hoverColor: (isDestructive
                ? theme.colorScheme.error
                : theme.colorScheme.onSurfaceVariant)
            .withOpacity(0.08),
        disabledBackgroundColor: Colors.transparent,
        disabledForegroundColor:
            theme.colorScheme.onSurfaceVariant.withOpacity(0.38),
      ),
    );
  }
}



=======================================
./lib/presentation/dialogs/work_import/components/preview/work_import_preview.dart
=======================================
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../../domain/models/work/work_image.dart';
import '../../../../../infrastructure/logging/logger.dart';
import '../../../../providers/work_import_provider.dart';
import '../../../../widgets/works/enhanced_work_preview.dart';
import '../../../common/dialog_button_group.dart';
import '../../../common/dialogs.dart';

/// Displays a preview of work images during import with editing capabilities
class WorkImportPreview extends ConsumerStatefulWidget {
  final bool showBottomButtons;

  const WorkImportPreview({
    super.key,
    this.showBottomButtons = true,
  });

  @override
  ConsumerState<WorkImportPreview> createState() => _WorkImportPreviewState();
}

class _WorkImportPreviewState extends ConsumerState<WorkImportPreview> {
  @override
  Widget build(BuildContext context) {
    final state = ref.watch(workImportProvider);
    final theme = Theme.of(context);

    AppLogger.debug(
        'Building WorkImportPreview with ${state.images.length} images');

    final images = state.images
        .map((file) => WorkImage(
              id: file.path,
              path: file.path,
              workId: '', // Will be set during import
              originalPath: file.path,
              thumbnailPath: file.path,
              index: state.images.indexOf(file),
              width: 0, // Will be set during import
              height: 0, // Will be set during import
              format: 'image',
              size: 0, // Will be set during import
              createTime: DateTime.now(),
              updateTime: DateTime.now(),
            ))
        .toList();

    // 创建一个函数来处理"添加图片"按钮的点击
    VoidCallback? handleAdd =
        state.isProcessing ? null : () => _handleAddImages();

    // 创建一个函数来处理"删除图片"按钮的点击
    VoidCallback? handleDelete = (images.isEmpty || state.isProcessing)
        ? null
        : () => _handleDeleteSelected();

    return LayoutBuilder(
      builder: (context, constraints) {
        // Use constraints to adapt layout
        final isSmallWidth = constraints.maxWidth < 500;
        final buttonHeight = 60.0; // Approximate height for buttons
        final previewHeight = constraints.maxHeight - buttonHeight;

        return Column(
          children: [
            Expanded(
              child: Card(
                clipBehavior: Clip.antiAlias,
                elevation: 0, // Remove card elevation for cleaner UI
                shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(8),
                  side: BorderSide(
                    color: theme.colorScheme.outlineVariant.withOpacity(0.5),
                    width: 1,
                  ),
                ),
                child: EnhancedWorkPreview(
                  images: images,
                  selectedIndex: state.selectedImageIndex,
                  isEditing: !state.isProcessing, // 处理中禁用编辑
                  showToolbar: true,
                  toolbarActions: [
                    Padding(
                      padding: const EdgeInsets.symmetric(horizontal: 8.0),
                      child: FilledButton.tonalIcon(
                        onPressed: handleAdd, // 处理中禁用
                        icon: const Icon(Icons.add_photo_alternate),
                        label: isSmallWidth
                            ? const Text('添加')
                            : const Text('添加图片'),
                      ),
                    ),
                    Padding(
                      padding: const EdgeInsets.symmetric(horizontal: 8.0),
                      child: OutlinedButton.icon(
                        onPressed: handleDelete, // 处理中禁用
                        icon: const Icon(
                          Icons.delete_outline,
                        ),
                        label: isSmallWidth
                            ? const Text('删除')
                            : const Text('删除图片'),
                        style: OutlinedButton.styleFrom(
                          foregroundColor: theme.colorScheme.error,
                          side: BorderSide(
                            color: theme.colorScheme.error.withOpacity(
                              images.isEmpty || state.isProcessing ? 0.38 : 1.0,
                            ),
                          ),
                        ),
                      ),
                    ),
                  ],
                  onIndexChanged:
                      state.isProcessing ? null : _handleIndexChanged,
                  onImagesReordered:
                      state.isProcessing ? null : _handleImagesReordered,
                ),
              ),
            ),
            // Only show the bottom buttons if requested
            if (widget.showBottomButtons) const SizedBox(height: 16),
            if (widget.showBottomButtons)
              DialogButtonGroup(
                // 如果正在处理，返回一个空函数，否则返回实际的取消处理函数
                onCancel: state.isProcessing
                    ? () {}
                    : () => Navigator.of(context).pop(),
                // 如果禁用或处理中，返回一个空函数，否则返回实际的确认处理函数
                onConfirm: (images.isEmpty || state.isProcessing)
                    ? () {}
                    : () async {
                        final success = await _handleConfirm();
                        if (success && mounted) {
                          Navigator.of(context).pop(true);
                        }
                      },
                confirmText: '导入',
                isProcessing: state.isProcessing,
              ),
          ],
        );
      },
    );
  }

  Future<void> _handleAddImages() async {
    final viewModel = ref.read(workImportProvider.notifier);
    AppLogger.debug('WorkImportPreview handling addImages');
    await viewModel.addImages([]);
  }

  Future<bool> _handleConfirm() async {
    final viewModel = ref.read(workImportProvider.notifier);
    return viewModel.importWork();
  }

  Future<void> _handleDeleteSelected() async {
    final state = ref.read(workImportProvider);
    if (state.images.isEmpty) return;

    final isLastImage = state.images.length == 1;
    String title = isLastImage ? '确认删除' : '删除图片';
    String message = isLastImage ? '这是最后一张图片，删除后将退出导入。确定要删除吗？' : '确定要删除选中的图片吗？';

    final confirmed = await showConfirmDialog(
      context: context,
      title: title,
      message: message,
    );

    if (confirmed == true) {
      final viewModel = ref.read(workImportProvider.notifier);
      AppLogger.debug(
          'WorkImportPreview removing image at index: ${state.selectedImageIndex}');
      viewModel.removeImage(state.selectedImageIndex);

      if (isLastImage && mounted) {
        Navigator.of(context).pop();
      }
    }
  }

  void _handleImagesReordered(int oldIndex, int newIndex) {
    final viewModel = ref.read(workImportProvider.notifier);
    AppLogger.debug(
        'WorkImportPreview reordering images: $oldIndex -> $newIndex');
    viewModel.reorderImages(oldIndex, newIndex);
  }

  void _handleIndexChanged(int index) {
    final viewModel = ref.read(workImportProvider.notifier);
    AppLogger.debug('WorkImportPreview selecting image: $index');
    viewModel.selectImage(index);
  }
}



=======================================
./lib/presentation/dialogs/work_import/work_import_dialog.dart
=======================================
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../providers/work_import_provider.dart';
import 'components/form/work_import_form.dart';
import 'components/preview/work_import_preview.dart';

/// Dialog for importing works with preview and metadata input
class WorkImportDialog extends ConsumerWidget {
  const WorkImportDialog({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final state = ref.watch(workImportProvider);
    final viewModel = ref.read(workImportProvider.notifier);

    return Dialog.fullscreen(
      child: LayoutBuilder(builder: (context, constraints) {
        // Calculate responsive sizes based on available space
        final availableWidth = constraints.maxWidth;
        final availableHeight = constraints.maxHeight;
        final isLargeScreen = availableWidth >= 1100;
        final isMediumScreen = availableWidth >= 800 && availableWidth < 1100;
        final isSmallScreen = availableWidth < 800;

        return Material(
          color: Theme.of(context).colorScheme.surface,
          child: PopScope(
            // Prevent dialog dismissal during processing
            canPop: !state.isProcessing,
            child: SafeArea(
              child: Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  // AppBar with action buttons moved here
                  AppBar(
                    title: const Text('导入作品'),
                    actions: [
                      // Cancel button
                      TextButton.icon(
                        onPressed: state.isProcessing
                            ? null
                            : () {
                                viewModel.reset();
                                Navigator.of(context).pop(false);
                              },
                        icon: const Icon(Icons.close),
                        label: const Text('取消'),
                        style: TextButton.styleFrom(
                          foregroundColor: state.isProcessing
                              ? Theme.of(context).disabledColor
                              : null,
                        ),
                      ),
                      const SizedBox(width: 8),
                      // Import button
                      FilledButton.icon(
                        onPressed: (state.canSubmit && !state.isProcessing)
                            ? () async {
                                final success = await viewModel.importWork();
                                if (success && context.mounted) {
                                  Navigator.of(context).pop(true);
                                }
                              }
                            : null,
                        icon: const Icon(Icons.save),
                        label: const Text('导入'),
                      ),
                      const SizedBox(width: 16),
                    ],
                  ),
                  Expanded(
                    child: Padding(
                      padding: const EdgeInsets.all(24.0),
                      child: _buildResponsiveLayout(
                        context,
                        isLargeScreen,
                        isMediumScreen,
                        isSmallScreen,
                        availableHeight,
                        availableWidth,
                        state,
                        viewModel,
                      ),
                    ),
                  ),
                ],
              ),
            ),
          ),
        );
      }),
    );
  }

  Widget _buildResponsiveLayout(
    BuildContext context,
    bool isLargeScreen,
    bool isMediumScreen,
    bool isSmallScreen,
    double availableHeight,
    double availableWidth,
    dynamic state,
    dynamic viewModel,
  ) {
    // For large and medium screens, use horizontal layout
    if (isLargeScreen || isMediumScreen) {
      return Row(
        crossAxisAlignment: CrossAxisAlignment.start, // Align at the top
        children: [
          // Preview section
          Expanded(
            flex: 3,
            child: ConstrainedBox(
              constraints: BoxConstraints(
                maxHeight: availableHeight - 48, // Account for padding
              ),
              child: const WorkImportPreviewWithoutButtons(),
            ),
          ),

          const SizedBox(width: 24),

          // Form section
          Expanded(
            flex: isLargeScreen ? 2 : 3,
            child: SingleChildScrollView(
              child: ConstrainedBox(
                constraints: BoxConstraints(
                  minHeight: availableHeight - 48, // Account for padding
                ),
                child: WorkImportForm(
                  state: state,
                  viewModel: viewModel,
                ),
              ),
            ),
          ),
        ],
      );
    }

    // For small screens, use vertical layout
    return Column(
      children: [
        // Preview section with proportional height based on screen size
        SizedBox(
          height: availableHeight * 0.5, // 50% of available height
          child: const WorkImportPreviewWithoutButtons(),
        ),

        const SizedBox(height: 16),

        // Form section that can scroll to fit in remaining space
        Expanded(
          child: SingleChildScrollView(
            child: WorkImportForm(
              state: state,
              viewModel: viewModel,
            ),
          ),
        ),
      ],
    );
  }

  /// Show the work import dialog
  static Future<bool?> show(BuildContext context) {
    // 确保在打开对话框前重置状态
    ProviderScope.containerOf(context)
        .read(workImportProvider.notifier)
        .reset();

    return showDialog<bool>(
      context: context,
      barrierDismissible: false,
      builder: (context) => const WorkImportDialog(),
    );
  }
}

/// A version of WorkImportPreview without bottom buttons
class WorkImportPreviewWithoutButtons extends ConsumerWidget {
  const WorkImportPreviewWithoutButtons({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return const WorkImportPreview(showBottomButtons: false);
  }
}



=======================================
./lib/presentation/pages/characters/character_detail_page.dart
=======================================
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../application/providers/repository_providers.dart';
import '../../../domain/models/character/character_entity.dart';
import '../../../infrastructure/logging/logger.dart';
import '../../providers/character_detail_provider.dart';
import '../../widgets/common/detail_toolbar.dart';
import '../../widgets/common/loading_indicator.dart';
import '../../widgets/page_layout.dart';

class CharacterDetailPage extends ConsumerStatefulWidget {
  final String charId;
  final VoidCallback? onBack;

  const CharacterDetailPage({
    super.key,
    required this.charId,
    this.onBack,
  });

  @override
  ConsumerState<CharacterDetailPage> createState() =>
      _CharacterDetailPageState();
}

class _CharacterDetailPageState extends ConsumerState<CharacterDetailPage> {
  var _isLoading = false;
  CharacterEntity? _character;
  String? _errorMessage;

  @override
  Widget build(BuildContext context) {
    return PageLayout(
      toolbar: _buildToolbar(),
      body: _buildBody(),
    );
  }

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addPostFrameCallback((_) {
      _loadCharacter();
    });
  }

  List<DetailToolbarAction> _buildActions() {
    if (_character == null) return [];

    return [
      DetailToolbarAction(
        icon: Icons.edit,
        tooltip: '编辑字形',
        onPressed: () {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(content: Text('编辑功能尚未实现')),
          );
        },
      ),
      DetailToolbarAction(
        icon: Icons.image,
        tooltip: '查看原图',
        onPressed: () {
          // Todo: 实现查看原图功能
        },
      ),
      DetailToolbarAction(
        icon: Icons.delete,
        tooltip: '删除字形',
        onPressed: _confirmDelete,
      ),
    ];
  }

  Widget _buildBody() {
    if (_isLoading) {
      return const Center(
        child: LoadingIndicator(message: '加载字形中...'),
      );
    }

    if (_errorMessage != null) {
      return Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            const Icon(Icons.error_outline, size: 48, color: Colors.red),
            const SizedBox(height: 16),
            Text(_errorMessage!, style: const TextStyle(fontSize: 16)),
            const SizedBox(height: 24),
            ElevatedButton(
              onPressed: _loadCharacter,
              child: const Text('重试'),
            ),
          ],
        ),
      );
    }

    if (_character == null) {
      return const Center(
        child: Text('字形不存在或已被删除'),
      );
    }

    return _buildCharacterInfo(_character!);
  }

  Widget _buildCharacterInfo(CharacterEntity character) {
    return SingleChildScrollView(
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          const AspectRatio(
            aspectRatio: 1.0,
            child: Card(
              clipBehavior: Clip.antiAlias,
              child: Center(
                child: Icon(Icons.image_not_supported, size: 64),
              ),
            ),
          ),
          const SizedBox(height: 24),
          Card(
            child: Padding(
              padding: const EdgeInsets.all(16.0),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text('基本信息', style: Theme.of(context).textTheme.titleLarge),
                  const Divider(),
                  _buildInfoRow('汉字', character.char),
                  _buildInfoRow('创建时间', _formatDateTime(character.createTime)),
                ],
              ),
            ),
          ),
          if (character.region != null) ...[
            const SizedBox(height: 16),
            Card(
              child: Padding(
                padding: const EdgeInsets.all(16.0),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Row(
                      children: [
                        const Icon(Icons.crop, size: 20),
                        const SizedBox(width: 8),
                        Text('原图区域',
                            style: Theme.of(context).textTheme.titleLarge),
                      ],
                    ),
                    const Divider(),
                    Text(
                      '左: ${character.region?.rect.left}, '
                      '上: ${character.region?.rect.top}, '
                      '宽: ${character.region?.rect.width}, '
                      '高: ${character.region?.rect.height}',
                      style: Theme.of(context).textTheme.bodyMedium,
                    ),
                  ],
                ),
              ),
            ),
          ],
        ],
      ),
    );
  }

  Widget _buildInfoRow(String label, String value) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 8.0),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          SizedBox(
            width: 80,
            child: Text(
              label,
              style: TextStyle(
                fontWeight: FontWeight.bold,
                color: Theme.of(context).colorScheme.primary,
              ),
            ),
          ),
          Expanded(
            child: Text(value),
          ),
        ],
      ),
    );
  }

  Widget _buildToolbar() {
    return DetailToolbar(
      title: '字形详情',
      leadingIcon: Icons.text_fields,
      badge: _character != null ? DetailBadge(text: _character!.char) : null,
      actions: _buildActions(),
    );
  }

  Future<void> _confirmDelete() async {
    final confirmed = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('删除字形'),
        content: Text('确定要删除字形"${_character!.char}"吗？此操作不可撤销。'),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(false),
            child: const Text('取消'),
          ),
          FilledButton(
            onPressed: () => Navigator.of(context).pop(true),
            style: FilledButton.styleFrom(
              backgroundColor: Colors.red,
              foregroundColor: Colors.white,
            ),
            child: const Text('删除'),
          ),
        ],
      ),
    );

    if (confirmed == true) {
      await _deleteCharacter();
    }
  }

  Future<void> _deleteCharacter() async {
    try {
      setState(() {
        _isLoading = true;
      });

      final repository = ref.read(characterRepositoryProvider);
      await repository.delete(widget.charId);
      ref.invalidate(characterDetailProvider);

      if (mounted) {
        if (widget.onBack != null) {
          widget.onBack!();
        } else {
          Navigator.of(context).pop();
        }
      }
    } catch (e, stack) {
      AppLogger.error(
        'Failed to delete character',
        tag: 'CharacterDetailPage',
        error: e,
        stackTrace: stack,
        data: {'id': widget.charId},
      );

      if (mounted) {
        setState(() {
          _isLoading = false;
          _errorMessage = '删除失败: ${e.toString()}';
        });

        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('删除失败: ${e.toString()}')),
        );
      }
    }
  }

  String _formatDateTime(DateTime? dateTime) {
    if (dateTime == null) return '未知';

    return '${dateTime.year}-'
        '${dateTime.month.toString().padLeft(2, '0')}-'
        '${dateTime.day.toString().padLeft(2, '0')} '
        '${dateTime.hour.toString().padLeft(2, '0')}:'
        '${dateTime.minute.toString().padLeft(2, '0')}';
  }

  Future<void> _loadCharacter() async {
    setState(() {
      _isLoading = true;
      _errorMessage = null;
    });

    try {
      final character =
          await ref.read(characterDetailProvider(widget.charId).future);

      if (mounted) {
        setState(() {
          _character = character;
          _isLoading = false;
        });
      }
    } catch (e, stack) {
      AppLogger.error(
        'Failed to load character',
        tag: 'CharacterDetailPage',
        error: e,
        stackTrace: stack,
        data: {'id': widget.charId},
      );

      if (mounted) {
        setState(() {
          _errorMessage = '无法加载字形信息: ${e.toString()}';
          _isLoading = false;
        });
      }
    }
  }
}



=======================================
./lib/presentation/pages/characters/character_list_page.dart
=======================================
import 'package:flutter/material.dart';

import '../../../theme/app_sizes.dart';
import '../../dialogs/character_edit_dialog.dart';
import '../../widgets/character/character_detail_view.dart';
import '../../widgets/page_layout.dart';
import '../../widgets/page_toolbar.dart';
import '../../widgets/search/search_box.dart';
import '../../widgets/section_header.dart';

class CharacterListPage extends StatefulWidget {
  const CharacterListPage({super.key});

  @override
  State<CharacterListPage> createState() => _CharacterListPageState();
}

class _CharacterListPageState extends State<CharacterListPage> {
  String? _selectedCharId;
  final _searchController = TextEditingController();

  @override
  Widget build(BuildContext context) {
    return PageLayout(
      toolbar: PageToolbar(
        leading: [
          FilledButton.icon(
            onPressed: _showAddCharacterDialog,
            icon: const Icon(Icons.add),
            label: const Text('新建字符'),
          ),
        ],
        trailing: [
          SearchBox(
            controller: _searchController,
            hintText: '搜索字符...',
            onSubmitted: _handleSearch,
          ),
        ],
      ),
      body: Row(
        children: [
          Expanded(
            flex: 2,
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                const SectionHeader(
                  title: '所有字符',
                  padding: EdgeInsets.fromLTRB(
                    AppSizes.spacingMedium,
                    AppSizes.spacingMedium,
                    AppSizes.spacingMedium,
                    0,
                  ),
                ),
                Expanded(
                  child: _buildCharacterGrid(),
                ),
              ],
            ),
          ),
          if (_selectedCharId != null) ...[
            const VerticalDivider(width: 1),
            Expanded(
              child: CharacterDetailView(charId: _selectedCharId!),
            ),
          ],
        ],
      ),
    );
  }

  @override
  void dispose() {
    _searchController.dispose();
    super.dispose();
  }

  Widget _buildCharacterGrid() {
    return GridView.builder(
      padding: const EdgeInsets.all(AppSizes.spacingMedium),
      gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
        crossAxisCount: 6,
        mainAxisSpacing: AppSizes.spacingMedium,
        crossAxisSpacing: AppSizes.spacingMedium,
        childAspectRatio: 1,
      ),
      itemCount: 20,
      itemBuilder: _buildCharacterItem,
    );
  }

  Widget _buildCharacterItem(BuildContext context, int index) {
    final theme = Theme.of(context);
    final charId = 'char_$index';
    final isSelected = charId == _selectedCharId;

    return Card(
      elevation:
          isSelected ? AppSizes.cardElevationSelected : AppSizes.cardElevation,
      color: isSelected ? theme.primaryColor.withOpacity(0.1) : null,
      child: InkWell(
        onTap: () => setState(() => _selectedCharId = charId),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Expanded(
              child: Center(
                child: Text(
                  '字$index',
                  style: theme.textTheme.headlineLarge,
                ),
              ),
            ),
            Padding(
              padding: const EdgeInsets.all(AppSizes.spacingSmall),
              child: Text(
                '来自：作品X',
                style: theme.textTheme.bodySmall,
                overflow: TextOverflow.ellipsis,
              ),
            ),
          ],
        ),
      ),
    );
  }

  void _handleSearch() {
    // 实现搜索逻辑
  }

  void _showAddCharacterDialog() {
    showDialog(
      context: context,
      builder: (context) => const CharacterEditDialog(
        charId: '',
      ),
    );
  }
}



=======================================
./lib/presentation/pages/communication_example.dart
=======================================



=======================================
./lib/presentation/pages/home_page.dart
=======================================
import 'package:flutter/material.dart';

/// Placeholder home page widget.
class HomePagePlaceholder extends StatelessWidget {
  const HomePagePlaceholder({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Home Page')),
      body: const Center(
        child: Text('Home Page'),
      ),
    );
  }
}



=======================================
./lib/presentation/pages/initialization/initialization_screen.dart
=======================================
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../application/providers/initialization_providers.dart';

class InitializationScreen extends ConsumerWidget {
  const InitializationScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final initState = ref.watch(appInitializationProvider);

    return Scaffold(
      body: Center(
        child: initState.when(
          data: (_) => const Text('初始化完成'),
          loading: () => const Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              CircularProgressIndicator(),
              SizedBox(height: 16),
              Text('正在初始化...'),
              Text(
                '加载中...',
                style: TextStyle(color: Colors.red),
              ),
            ],
          ),
          error: (error, stack) => Text(
            '初始化失败: $error',
            style: const TextStyle(color: Colors.red),
          ),
        ),
      ),
    );
  }
}



=======================================
./lib/presentation/pages/main/main_window.dart
=======================================
import 'package:flutter/material.dart';

import '../../../presentation/pages/characters/character_list_page.dart';
import '../../../presentation/pages/practices/practice_list_page.dart';
import '../../../presentation/pages/settings/settings_page.dart';
import '../../../presentation/pages/works/work_browse_page.dart';
import '../../../presentation/pages/works/work_detail_page.dart';
import '../../../presentation/widgets/navigation/side_nav.dart';
import '../../../presentation/widgets/window/title_bar.dart';
import '../../../routes/app_routes.dart';

class MainWindow extends StatefulWidget {
  const MainWindow({super.key});

  @override
  State<MainWindow> createState() => _MainWindowState();
}

class _MainWindowState extends State<MainWindow> with WidgetsBindingObserver {
  int _selectedIndex = 0;

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: Column(
        children: [
          // Title bar - unchanged
          const TitleBar(),

          // Content area - including side navigation bar and right content
          Expanded(
            child: Row(
              children: [
                // Side navigation - always shown
                SideNavigation(
                  selectedIndex: _selectedIndex,
                  onDestinationSelected: (index) {
                    setState(() {
                      _selectedIndex = index;
                    });
                  },
                ),

                // Content area - dynamically changing part
                Expanded(
                  child: _buildContent(),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }

  @override
  void dispose() {
    WidgetsBinding.instance.removeObserver(this);
    super.dispose();
  }

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addObserver(this);
  }

  Widget _buildContent() {
    // Build different content based on selected tab
    switch (_selectedIndex) {
      case 0:
        return Navigator(
          key: ValueKey('work_navigator_$_selectedIndex'),
          onGenerateRoute: (settings) {
            if (settings.name == AppRoutes.workDetail &&
                settings.arguments != null) {
              final workId = settings.arguments as String;
              return MaterialPageRoute<bool>(
                // 指定返回值类型为bool
                builder: (context) => WorkDetailPage(workId: workId),
              );
            }
            // Default to work browse page
            return MaterialPageRoute(
              builder: (context) => const WorkBrowsePage(),
            );
          },
        );
      case 1:
        return const CharacterListPage();
      case 2:
        return const PracticeListPage();
      case 3:
        return const SettingsPage();
      default:
        return const Center(child: Text('Page not implemented'));
    }
  }
}



=======================================
./lib/presentation/pages/practices/components/practice_page_viewer.dart
=======================================
import 'dart:io';
import 'dart:math';

import 'package:flutter/material.dart';

import '../../../../domain/models/practice/element_content.dart';
import '../../../../domain/models/practice/practice_element.dart';
import '../../../../domain/models/practice/practice_layer.dart';
import '../../../../domain/models/practice/practice_page.dart';
import '../../../../theme/app_colors.dart';
import '../../../widgets/common/empty_state.dart';

/// 字帖页面预览组件
class PracticePageViewer extends StatefulWidget {
  /// 字帖页面
  final PracticePage page;

  /// 是否只读模式
  final bool readOnly;

  /// 元素点击回调
  final void Function(PracticeElement element)? onElementTap;

  /// 图层切换回调
  final void Function(PracticeLayer layer)? onLayerToggle;

  const PracticePageViewer({
    super.key,
    required this.page,
    this.readOnly = true,
    this.onElementTap,
    this.onLayerToggle,
  });

  @override
  State<PracticePageViewer> createState() => _PracticePageViewerState();
}

class _PracticePageViewerState extends State<PracticePageViewer> {
  /// 缩放比例
  double _scale = 1.0;

  /// 是否显示图层控制面板
  bool _showLayers = false;

  /// 当前选中的元素ID
  String? _selectedElementId;

  @override
  Widget build(BuildContext context) {
    // 如果页面没有图层，显示空状态
    if (widget.page.layers.isEmpty) {
      return const EmptyState();
    }

    return Scaffold(
      // 使用Scaffold只为了获取背景色和FloatingActionButton支持
      backgroundColor: Colors.transparent,
      floatingActionButton: widget.readOnly ? null : _buildFab(),
      body: Column(
        children: [
          // 顶部控制区
          _buildControls(),

          // 页面内容区 (占据大部分空间)
          Expanded(
            child: _buildPageContent(),
          ),
        ],
      ),
    );
  }

  /// 构建字符元素
  Widget _buildCharsElement(PracticeElement element) {
    final charsContent = element.content as CharsContent;

    // 如果没有字符，显示占位符
    if (charsContent.chars.isEmpty) {
      return const Center(
        child: Text('无字符内容'),
      );
    }

    // 绘制所有字符 (复杂逻辑简化示例)
    return Stack(
      children: charsContent.chars.map((charElement) {
        // 这里简化了字符定位和变换，实际实现需更复杂
        return Center(
          child: Text(
            '字符: ${charElement.charId}',
            style: TextStyle(
              color: Color(int.parse(
                    charElement.style.color.substring(1) ?? 'FF000000',
                    radix: 16,
                  ) |
                  0xFF000000),
              fontSize: 16.0 * charElement.transform.scaleX,
            ),
          ),
        );
      }).toList(),
    );
  }

  /// 构建顶部控制区
  Widget _buildControls() {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
      child: Row(
        children: [
          // 缩放控制
          Text(
            '缩放: ${(_scale * 100).toStringAsFixed(0)}%',
            style: Theme.of(context).textTheme.bodySmall,
          ),
          const SizedBox(width: 8),
          IconButton(
            icon: const Icon(Icons.zoom_in),
            onPressed: () {
              setState(() {
                _scale = min(_scale + 0.1, 2.0);
              });
            },
            tooltip: '放大',
            iconSize: 20,
            constraints: const BoxConstraints(
              minWidth: 36,
              minHeight: 36,
            ),
          ),
          IconButton(
            icon: const Icon(Icons.zoom_out),
            onPressed: () {
              setState(() {
                _scale = max(_scale - 0.1, 0.5);
              });
            },
            tooltip: '缩小',
            iconSize: 20,
            constraints: const BoxConstraints(
              minWidth: 36,
              minHeight: 36,
            ),
          ),

          const Spacer(),

          // 页面信息
          Text(
            '${widget.page.size.width.toStringAsFixed(0)}×${widget.page.size.height.toStringAsFixed(0)} ${widget.page.size.unit}',
            style: Theme.of(context).textTheme.bodySmall,
          ),
        ],
      ),
    );
  }

  /// 根据元素类型构建对应的Widget
  Widget? _buildElementWidget(PracticeElement element) {
    final geometry = element.geometry;
    final isSelected = element.id == _selectedElementId;

    // 计算元素实际位置和大小(应用缩放)
    final left = geometry.x * _scale;
    final top = geometry.y * _scale;
    final width = geometry.width * _scale;
    final height = geometry.height * _scale;

    // 基础容器
    Widget? contentWidget;

    // 根据元素类型创建内容
    switch (element.elementType) {
      case 'chars':
        // 处理字符类型元素
        if (element.content is CharsContent) {
          contentWidget = _buildCharsElement(element);
        }
        break;
      case 'text':
        // 处理文本类型元素
        if (element.content is TextContent) {
          contentWidget = _buildTextElement(element);
        }
        break;
      case 'image':
        // 处理图像类型元素
        if (element.content is ImageContent) {
          contentWidget = _buildImageElement(element);
        }
        break;
      default:
        // 未知元素类型
        contentWidget = const Center(
          child: Text('未知元素类型'),
        );
    }

    if (contentWidget == null) return null;

    // 创建可交互元素
    return Positioned(
      left: left,
      top: top,
      width: width,
      height: height,
      child: Transform.rotate(
        angle: geometry.rotation * (pi / 180), // 转换为弧度
        child: Opacity(
          opacity: element.style.opacity,
          child: GestureDetector(
            onTap: widget.readOnly
                ? null
                : () {
                    setState(() {
                      _selectedElementId = element.id;
                    });
                    widget.onElementTap?.call(element);
                  },
            child: Container(
              decoration: isSelected
                  ? BoxDecoration(
                      border: Border.all(
                        color: AppColors.primary,
                        width: 2.0,
                      ),
                    )
                  : null,
              child: contentWidget,
            ),
          ),
        ),
      ),
    );
  }

  /// 构建底部浮动按钮
  Widget? _buildFab() {
    if (widget.readOnly) return null;

    return FloatingActionButton(
      onPressed: () {
        setState(() {
          _showLayers = !_showLayers;
        });
      },
      tooltip: _showLayers ? '隐藏图层面板' : '显示图层面板',
      child: Icon(_showLayers ? Icons.layers_clear : Icons.layers),
    );
  }

  /// 构建图像元素
  Widget _buildImageElement(PracticeElement element) {
    final imagePath = (element.content as ImageContent).image.url;

    try {
      // 尝试加载图像
      final file = File(imagePath);
      if (!file.existsSync()) {
        return const Center(
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              Icon(Icons.broken_image, size: 32, color: Colors.grey),
              SizedBox(height: 4),
              Text('图片不存在', style: TextStyle(color: Colors.grey)),
            ],
          ),
        );
      }

      return Image.file(
        file,
        fit: BoxFit.contain,
        errorBuilder: (context, error, stackTrace) {
          return const Center(
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                Icon(Icons.error_outline, size: 32, color: Colors.red),
                SizedBox(height: 4),
                Text('图片损坏', style: TextStyle(color: Colors.red)),
              ],
            ),
          );
        },
      );
    } catch (e) {
      return Center(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            const Icon(Icons.error, size: 32, color: Colors.red),
            const SizedBox(height: 4),
            Text(
                '加载错误: ${e.toString().substring(0, min(20, e.toString().length))}...'),
          ],
        ),
      );
    }
  }

  /// 构建所有图层的所有元素
  List<Widget> _buildLayeredElements() {
    final List<Widget> elements = [];

    // 按照图层顺序构建元素（索引较小的图层在下方）
    final visibleLayers = widget.page.layers
        .where((layer) => layer.visible)
        .toList()
      ..sort((a, b) => a.order.compareTo(b.order));

    for (final layer in visibleLayers) {
      for (final element in layer.elements) {
        // 如果元素不可见，则跳过
        if (!element.style.visible) continue;

        // 根据元素类型构建不同的视图
        final elementWidget = _buildElementWidget(element);
        if (elementWidget != null) {
          elements.add(elementWidget);
        }
      }
    }

    return elements;
  }

  /// 构建单个图层项
  Widget _buildLayerItem(PracticeLayer layer) {
    return ListTile(
      title: Text(
        layer.name!,
        style: TextStyle(
          fontWeight: layer.locked ? FontWeight.normal : FontWeight.bold,
          color: !layer.visible
              ? Theme.of(context).disabledColor
              : Theme.of(context).textTheme.bodyLarge?.color,
        ),
      ),
      subtitle: Text('${layer.elements.length} 个元素'),
      leading: Icon(
        layer.type == 'background' ? Icons.landscape : Icons.layers,
        color: layer.visible
            ? (layer.type == 'background'
                ? Colors.green
                : Theme.of(context).colorScheme.primary)
            : Theme.of(context).disabledColor,
      ),
      trailing: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          // 可见性切换
          IconButton(
            icon: Icon(
              layer.visible ? Icons.visibility : Icons.visibility_off,
            ),
            onPressed: widget.readOnly
                ? null
                : () {
                    final updatedLayer = layer.toggleVisibility();
                    widget.onLayerToggle?.call(updatedLayer);
                    // 如果没有外部处理，在本地更新状态
                    if (widget.onLayerToggle == null) {
                      setState(() {});
                    }
                  },
            tooltip: layer.visible ? '隐藏图层' : '显示图层',
            iconSize: 20,
            padding: EdgeInsets.zero,
            constraints: const BoxConstraints(
              minWidth: 36,
              minHeight: 36,
            ),
          ),

          // 锁定切换
          IconButton(
            icon: Icon(
              layer.locked ? Icons.lock_outline : Icons.lock_open,
            ),
            onPressed: widget.readOnly
                ? null
                : () {
                    final updatedLayer = layer.toggleLock();
                    widget.onLayerToggle?.call(updatedLayer);
                    // 如果没有外部处理，在本地更新状态
                    if (widget.onLayerToggle == null) {
                      setState(() {});
                    }
                  },
            tooltip: layer.locked ? '解锁图层' : '锁定图层',
            iconSize: 20,
            padding: EdgeInsets.zero,
            constraints: const BoxConstraints(
              minWidth: 36,
              minHeight: 36,
            ),
          ),
        ],
      ),
      onTap: widget.readOnly
          ? null
          : () {
              // 点击图层项的行为，例如选择该图层
            },
    );
  }

  /// 构建图层控制面板
  Widget _buildLayersPanel() {
    return Container(
      width: 250,
      decoration: BoxDecoration(
        color: Theme.of(context).cardColor,
        border: Border(
          left: BorderSide(
            color: Theme.of(context).dividerColor,
            width: 1,
          ),
        ),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.stretch,
        children: [
          // 面板标题
          Padding(
            padding: const EdgeInsets.all(16),
            child: Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Text(
                  '图层',
                  style: Theme.of(context).textTheme.titleMedium,
                ),
                IconButton(
                  icon: const Icon(Icons.close),
                  onPressed: () {
                    setState(() {
                      _showLayers = false;
                    });
                  },
                  tooltip: '关闭图层面板',
                  iconSize: 20,
                  padding: EdgeInsets.zero,
                  constraints: const BoxConstraints(
                    minWidth: 36,
                    minHeight: 36,
                  ),
                ),
              ],
            ),
          ),

          const Divider(height: 1),

          // 图层列表
          Expanded(
            child: ListView.builder(
              itemCount: widget.page.layers.length,
              itemBuilder: (context, index) {
                final layer = widget.page.layers[index];
                return _buildLayerItem(layer);
              },
            ),
          ),
        ],
      ),
    );
  }

  /// 构建页面画布
  Widget _buildPageCanvas() {
    final pageSize = widget.page.size;

    // 计算实际显示尺寸 (应用缩放比例)
    final displayWidth = pageSize.width * _scale;
    final displayHeight = pageSize.height * _scale;

    return Container(
      margin: const EdgeInsets.all(20),
      width: displayWidth,
      height: displayHeight,
      decoration: BoxDecoration(
        color: Colors.white,
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.1),
            blurRadius: 10,
            offset: const Offset(0, 2),
          ),
        ],
      ),
      child: ClipRect(
        child: Stack(
          children: _buildLayeredElements(),
        ),
      ),
    );
  }

  /// 构建页面内容区
  Widget _buildPageContent() {
    return Row(
      crossAxisAlignment: CrossAxisAlignment.stretch,
      children: [
        // 主内容区域
        Expanded(
          child: Center(
            child: SingleChildScrollView(
              scrollDirection: Axis.vertical,
              child: SingleChildScrollView(
                scrollDirection: Axis.horizontal,
                child: _buildPageCanvas(),
              ),
            ),
          ),
        ),

        // 显示图层面板 (如果启用)
        if (_showLayers && !widget.readOnly) _buildLayersPanel(),
      ],
    );
  }

  /// 构建文本元素
  Widget _buildTextElement(PracticeElement element) {
    final textContent = (element.content as TextContent).text;

    // 设置对齐方式
    TextAlign textAlign = textContent.textAlign;

    return Container(
      padding: const EdgeInsets.all(4),
      child: Text(
        textContent.text,
        style: TextStyle(
          fontFamily: textContent.fontFamily,
          fontSize: textContent.fontSize * _scale,
          color: Color(int.parse(
                textContent.color.substring(1),
                radix: 16,
              ) |
              0xFF000000),
        ),
        textAlign: textAlign,
      ),
    );
  }
}



=======================================
./lib/presentation/pages/practices/practice_detail_page.dart
=======================================
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../domain/models/practice/practice_entity.dart';
import '../../../domain/models/practice/practice_layer.dart';
import '../../../infrastructure/logging/logger.dart';
import '../../../routes/app_routes.dart';
import '../../providers/practice_detail_provider.dart';
import '../../widgets/common/detail_toolbar.dart';
import '../../widgets/common/loading_indicator.dart';
import '../../widgets/page_layout.dart';
import 'components/practice_page_viewer.dart';

class PracticeDetailPage extends ConsumerStatefulWidget {
  final String practiceId;

  const PracticeDetailPage({super.key, required this.practiceId});

  @override
  ConsumerState<PracticeDetailPage> createState() => _PracticeDetailPageState();
}

class _PracticeDetailPageState extends ConsumerState<PracticeDetailPage> {
  int _currentPageIndex = 0;

  @override
  Widget build(BuildContext context) {
    final state = ref.watch(practiceDetailProvider(widget.practiceId));

    return PageLayout(
      toolbar: _buildToolbar(state.practice),
      body: _buildBody(state),
    );
  }

  @override
  void initState() {
    super.initState();
    _loadPractice();
  }

  Widget _buildBody(PracticeDetailState state) {
    if (state.isLoading) {
      return const Center(
        child: LoadingIndicator(message: '加载练习中...'),
      );
    }

    if (state.error != null) {
      return Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            const Icon(Icons.error_outline, size: 48, color: Colors.red),
            const SizedBox(height: 16),
            Text(state.error!, style: const TextStyle(fontSize: 16)),
            const SizedBox(height: 24),
            ElevatedButton(
              onPressed: _loadPractice,
              child: const Text('重试'),
            ),
          ],
        ),
      );
    }

    if (state.practice == null) {
      return const Center(
        child: Text('练习不存在或已被删除'),
      );
    }

    return _buildPracticeContent(state.practice!);
  }

  Widget _buildPageSelector(PracticeEntity practice) {
    final pages = practice.pages;

    return SizedBox(
      height: 50,
      child: ListView.builder(
        scrollDirection: Axis.horizontal,
        itemCount: pages.length,
        itemBuilder: (context, index) {
          return Padding(
            padding: const EdgeInsets.symmetric(horizontal: 4.0),
            child: ChoiceChip(
              label: Text('第${index + 1}页'),
              selected: index == _currentPageIndex,
              onSelected: (selected) {
                if (selected) {
                  setState(() {
                    _currentPageIndex = index;
                  });
                }
              },
            ),
          );
        },
      ),
    );
  }

  Widget _buildPracticeContent(PracticeEntity practice) {
    final pages = practice.pages;
    if (pages.isEmpty) {
      return const Center(
        child: Text('此练习没有页面'),
      );
    }

    return Column(
      children: [
        // 页面选择器（如果有多页）
        if (pages.length > 1) _buildPageSelector(practice),

        // 页面内容查看器
        Expanded(
          child: PracticePageViewer(
            page: pages[_currentPageIndex], // 当前页
            readOnly: true,
            onLayerToggle: _handleLayerToggle,
          ),
        ),
      ],
    );
  }

  Widget _buildPracticeMetadata(PracticeEntity practice) {
    final theme = Theme.of(context);

    return Card(
      margin: const EdgeInsets.all(8.0),
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Text(
                  '练习信息',
                  style: theme.textTheme.titleMedium,
                ),
                Text(
                  '共 ${practice.pages.length} 页',
                  style: theme.textTheme.bodySmall,
                ),
              ],
            ),
            const Divider(),
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Text('创建时间: ${_formatDateTime(practice.createTime)}'),
                Text('更新时间: ${_formatDateTime(practice.updateTime)}'),
              ],
            ),
            if (practice.tags.isNotEmpty)
              Padding(
                padding: const EdgeInsets.only(top: 8.0),
                child: Wrap(
                  spacing: 8,
                  children: practice.tags
                      .map((tag) => Chip(label: Text(tag)))
                      .toList(),
                ),
              ),
          ],
        ),
      ),
    );
  }

  Widget _buildToolbar(PracticeEntity? practice) {
    return DetailToolbar(
      title: practice?.title ?? '练习详情',
      leadingIcon: Icons.auto_stories,
      subtitle: practice != null
          ? '创建于 ${_formatDateShort(practice.createTime)}'
          : null,
      badge: practice != null && practice.pages.isNotEmpty
          ? DetailBadge(text: '${practice.pages.length}页')
          : null,
      actions: practice != null
          ? [
              DetailToolbarAction(
                icon: Icons.edit,
                tooltip: '编辑练习',
                onPressed: _navigateToEdit,
                primary: true,
              ),
              DetailToolbarAction(
                icon: Icons.add_photo_alternate_outlined,
                tooltip: '添加页面',
                onPressed: () {
                  // 添加页面功能
                },
              ),
              DetailToolbarAction(
                icon: Icons.delete,
                tooltip: '删除练习',
                onPressed: _confirmDelete,
                primary: false,
              ),
            ]
          : [],
    );
  }

  Future<void> _confirmDelete() async {
    final confirmed = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('删除练习'),
        content: Text(
            '确定要删除练习"${ref.read(practiceDetailProvider(widget.practiceId)).practice?.title}"吗？此操作不可撤销。'),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(false),
            child: const Text('取消'),
          ),
          FilledButton(
            onPressed: () => Navigator.of(context).pop(true),
            style: FilledButton.styleFrom(
              backgroundColor: Colors.red,
              foregroundColor: Colors.white,
            ),
            child: const Text('删除'),
          ),
        ],
      ),
    );

    if (confirmed == true) {
      await _deletePractice();
    }
  }

  Future<void> _deletePractice() async {
    try {
      await ref
          .read(practiceDetailProvider(widget.practiceId).notifier)
          .deletePractice(widget.practiceId);

      if (mounted) {
        Navigator.of(context).pop(); // 返回上一页
      } else if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('删除失败')),
        );
      }
    } catch (e, stack) {
      AppLogger.error(
        'Failed to delete practice',
        tag: 'PracticeDetailPage',
        error: e,
        stackTrace: stack,
        data: {'id': widget.practiceId},
      );

      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('删除失败: ${e.toString()}')),
        );
      }
    }
  }

  String _formatDateShort(DateTime? date) {
    if (date == null) return '未知';
    return '${date.year}/${date.month}/${date.day}';
  }

  String _formatDateTime(DateTime? dateTime) {
    if (dateTime == null) return '未知';

    return '${dateTime.year}-'
        '${dateTime.month.toString().padLeft(2, '0')}-'
        '${dateTime.day.toString().padLeft(2, '0')} '
        '${dateTime.hour.toString().padLeft(2, '0')}:'
        '${dateTime.minute.toString().padLeft(2, '0')}';
  }

  void _handleLayerToggle(PracticeLayer layer) {
    ref
        .read(practiceDetailProvider(widget.practiceId).notifier)
        .updateLayer(layer.order, layer);
  }

  Future<void> _loadPractice() async {
    await ref
        .read(practiceDetailProvider(widget.practiceId).notifier)
        .loadPractice(widget.practiceId);
  }

  void _navigateToEdit() {
    Navigator.pushNamed(
      context,
      AppRoutes.practiceDetail,
      arguments: widget.practiceId,
    ).then((_) => _loadPractice()); // 编辑后刷新
  }
}



=======================================
./lib/presentation/pages/practices/practice_edit_page.dart
=======================================
import 'package:flutter/material.dart';

import '../../widgets/practice/practice_layer_panel.dart';
import '../../widgets/practice/practice_property_panel.dart';
import '../../widgets/practice/practice_tool_panel.dart';
import '../../widgets/window/title_bar.dart';

class PracticeEditPage extends StatefulWidget {
  final String? practiceId; // 可选ID，如果为null则表示新建

  const PracticeEditPage({
    super.key,
    this.practiceId,
  });

  @override
  State<PracticeEditPage> createState() => _PracticeEditPageState();
}

class _PracticeEditPageState extends State<PracticeEditPage> {
  bool _hasUnsavedChanges = false;
  List<Map<String, dynamic>> _layers = [];
  Map<String, dynamic>? _selectedElement;

  @override
  Widget build(BuildContext context) {
    return WillPopScope(
      onWillPop: _onWillPop,
      child: Scaffold(
        body: Column(
          children: [
            const TitleBar(),
            AppBar(
              leading: IconButton(
                icon: const Icon(Icons.arrow_back),
                onPressed: () async {
                  if (await _onWillPop()) {
                    Navigator.pop(context);
                  }
                },
              ),
              title: Text(
                widget.practiceId == null ? '新建字帖' : '编辑字帖',
                style: const TextStyle(fontSize: 20),
              ),
              actions: [
                TextButton.icon(
                  onPressed: _handleSave,
                  icon: const Icon(Icons.save),
                  label: const Text('保存'),
                ),
                TextButton.icon(
                  onPressed: () {},
                  icon: const Icon(Icons.print),
                  label: const Text('打印'),
                ),
                TextButton.icon(
                  onPressed: () {},
                  icon: const Icon(Icons.file_download),
                  label: const Text('导出'),
                ),
              ],
            ),
            Expanded(
              child: Row(
                children: [
                  // 左侧工具面板和图层列表
                  SizedBox(
                    width: 250,
                    child: Column(
                      children: [
                        Expanded(
                          child: PracticeToolPanel(
                            onToolSelected: _handleToolSelected,
                          ),
                        ),
                        const Divider(height: 1),
                        Expanded(
                          child: PracticeLayerPanel(
                            layers: _layers,
                            onLayerSelected: _handleLayerSelected,
                            onLayerVisibilityChanged:
                                _handleLayerVisibilityChanged,
                            onLayerLockChanged: _handleLayerLockChanged,
                            onLayerDeleted: _handleLayerDeleted,
                            onLayerReordered: _handleLayerReordered,
                          ),
                        ),
                      ],
                    ),
                  ),
                  const VerticalDivider(width: 1),
                  // 中央编辑区
                  Expanded(
                    child: Container(
                      color: Colors.grey[100],
                      child: Center(
                        child: Container(
                          width: 595, // A4纸宽度
                          height: 842, // A4纸高度
                          color: Colors.white,
                          child: const Stack(
                            children: [
                              // TODO: 实现画布和编辑功能
                            ],
                          ),
                        ),
                      ),
                    ),
                  ),
                  const VerticalDivider(width: 1),
                  // 右侧属性面板
                  SizedBox(
                    width: 280,
                    child: PracticePropertyPanel(
                      selectedElement: _selectedElement,
                      onPropertyChanged: _handlePropertyChanged,
                    ),
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }

  @override
  void initState() {
    super.initState();
    // TODO: 加载字帖数据
    _layers = [
      {
        'id': '1',
        'name': '背景层',
        'visible': true,
        'locked': false,
        'selected': false,
      },
      {
        'id': '2',
        'name': '内容层',
        'visible': true,
        'locked': false,
        'selected': true,
      },
    ];
  }

  void _handleLayerDeleted(int index) {
    setState(() {
      _layers.removeAt(index);
      _hasUnsavedChanges = true;
    });
  }

  void _handleLayerLockChanged(int index, bool locked) {
    setState(() {
      _layers[index]['locked'] = locked;
      _hasUnsavedChanges = true;
    });
  }

  void _handleLayerReordered(int oldIndex, int newIndex) {
    setState(() {
      if (oldIndex < newIndex) {
        newIndex -= 1;
      }
      final item = _layers.removeAt(oldIndex);
      _layers.insert(newIndex, item);
      _hasUnsavedChanges = true;
    });
  }

  void _handleLayerSelected(int index) {
    setState(() {
      for (var i = 0; i < _layers.length; i++) {
        _layers[i]['selected'] = i == index;
      }
    });
  }

  void _handleLayerVisibilityChanged(int index, bool visible) {
    setState(() {
      _layers[index]['visible'] = visible;
      _hasUnsavedChanges = true;
    });
  }

  void _handlePropertyChanged(Map<String, dynamic> updatedElement) {
    setState(() {
      _selectedElement = updatedElement;
      _hasUnsavedChanges = true;
    });
  }

  Future<void> _handleSave() async {
    // TODO: 实现保存逻辑
    setState(() => _hasUnsavedChanges = false);
  }

  void _handleToolSelected(String tool) {
    setState(() {
      _hasUnsavedChanges = true;
    });
  }

  Future<bool> _onWillPop() async {
    if (!_hasUnsavedChanges) return true;

    final result = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('确认退出'),
        content: const Text('有未保存的更改，确定要退出吗？'),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context, false),
            child: const Text('取消'),
          ),
          TextButton(
            onPressed: () => Navigator.pop(context, true),
            child: const Text('确定'),
          ),
        ],
      ),
    );

    return result ?? false;
  }
}



=======================================
./lib/presentation/pages/practices/practice_list_page.dart
=======================================
import 'package:flutter/material.dart';

// 添加
import '../../../theme/app_sizes.dart';
import '../../widgets/page_layout.dart';
import '../../widgets/page_toolbar.dart';
import 'practice_detail_page.dart';
import 'practice_edit_page.dart'; // 添加

class PracticeListPage extends StatefulWidget {
  const PracticeListPage({super.key});

  @override
  State<PracticeListPage> createState() => _PracticeListPageState();
}

class _PracticeListPageState extends State<PracticeListPage> {
  bool _isGridView = true;

  @override
  Widget build(BuildContext context) {
    return PageLayout(
      toolbar: PageToolbar(
        leading: [
          FilledButton.icon(
            onPressed: () => _navigateToEditPage(),
            icon: const Icon(Icons.add),
            label: const Text('新建练习'),
          ),
          const SizedBox(width: AppSizes.spacingMedium),
          IconButton(
            onPressed: () => setState(() => _isGridView = !_isGridView),
            icon: Icon(_isGridView ? Icons.list : Icons.grid_view),
            tooltip: _isGridView ? '列表视图' : '网格视图',
          ),
        ],
        trailing: [
          const SizedBox(
            width: 240,
            child: SearchBar(
              hintText: '搜索练习...',
              leading: Icon(Icons.search),
              padding: WidgetStatePropertyAll(
                EdgeInsets.symmetric(horizontal: AppSizes.spacingMedium),
              ),
            ),
          ),
        ],
      ),
      body: _isGridView ? _buildGridView() : _buildListView(),
    );
  }

  Widget _buildGridView() {
    return GridView.builder(
      padding: const EdgeInsets.all(AppSizes.spacingMedium), // 更新
      gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
        crossAxisCount: AppSizes.gridCrossAxisCount, // 使用常量
        mainAxisSpacing: AppSizes.gridMainAxisSpacing, // 使用常量
        crossAxisSpacing: AppSizes.gridCrossAxisSpacing, // 使用常量
        childAspectRatio: 1,
      ),
      itemCount: 20,
      itemBuilder: (context, index) {
        return Card(
          child: InkWell(
            onTap: () {
              _navigateToPracticeDetail(context, 'practice_$index'); // 添加导航
            },
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Expanded(
                  child: Stack(
                    children: [
                      Container(
                        color: Colors.grey[300],
                        child: Center(child: Text('字帖 $index')),
                      ),
                      Positioned(
                        right: 8,
                        bottom: 8,
                        child: Chip(
                          label: const Text('草稿'),
                          backgroundColor: Colors.yellow[100],
                        ),
                      ),
                    ],
                  ),
                ),
                Padding(
                  padding: const EdgeInsets.all(8.0),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text('字帖标题 $index',
                          style: Theme.of(context).textTheme.titleMedium),
                      Text('创建时间: 2024-01-01',
                          style: Theme.of(context).textTheme.bodySmall),
                    ],
                  ),
                ),
              ],
            ),
          ),
        );
      },
    );
  }

  Widget _buildListView() {
    return ListView.builder(
      padding: const EdgeInsets.all(AppSizes.spacingMedium), // 更新
      itemCount: 20,
      itemBuilder: (context, index) {
        return Card(
          child: ListTile(
            leading: Container(
              width: 48,
              color: Colors.grey[300],
              child: Center(child: Text('$index')),
            ),
            title: Text('字帖标题 $index'),
            subtitle: const Text('创建时间: 2024-01-01'),
            trailing: const Icon(Icons.chevron_right),
            onTap: () {
              _navigateToPracticeDetail(context, 'practice_$index'); // 添加导航
            },
          ),
        );
      },
    );
  }

  void _navigateToEditPage([String? practiceId]) {
    Navigator.push(
      context,
      MaterialPageRoute(
        builder: (context) => PracticeEditPage(practiceId: practiceId),
      ),
    );
  }

  void _navigateToPracticeDetail(BuildContext context, String practiceId) {
    Navigator.push(
      context,
      MaterialPageRoute(
        builder: (context) => PracticeDetailPage(practiceId: practiceId),
      ),
    );
  }
}



=======================================
./lib/presentation/pages/settings/components/appearance_settings.dart
=======================================
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../domain/enums/app_theme_mode.dart';
import '../../../providers/settings_provider.dart';
import '../../../widgets/settings/settings_section.dart';

class AppearanceSettings extends ConsumerWidget {
  const AppearanceSettings({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final themeMode = ref.watch(settingsProvider.select((s) => s.themeMode));
    final isDarkMode = themeMode == AppThemeMode.dark;
    final isSystemMode = themeMode == AppThemeMode.system;

    return SettingsSection(
      title: '外观',
      icon: Icons.palette_outlined,
      children: [
        ListTile(
          title: const Text('深色模式'),
          subtitle: const Text('使用深色主题'),
          leading: const Icon(Icons.dark_mode),
          trailing: Switch(
            value: isDarkMode,
            onChanged: (value) {
              ref.read(settingsProvider.notifier).setThemeMode(
                    value ? AppThemeMode.dark : AppThemeMode.light,
                  );
            },
          ),
        ),
        ListTile(
          title: const Text('跟随系统'),
          subtitle: const Text('根据系统设置自动切换深色/浅色模式'),
          leading: const Icon(Icons.settings_system_daydream_outlined),
          trailing: Switch(
            value: isSystemMode,
            onChanged: (value) {
              if (value) {
                ref
                    .read(settingsProvider.notifier)
                    .setThemeMode(AppThemeMode.system);
              } else {
                ref.read(settingsProvider.notifier).setThemeMode(
                      isDarkMode ? AppThemeMode.dark : AppThemeMode.light,
                    );
              }
            },
          ),
        ),
      ],
    );
  }
}



=======================================
./lib/presentation/pages/settings/components/storage_settings.dart
=======================================
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../presentation/providers/storage_info_provider.dart';
import '../../../../theme/app_colors.dart';
import '../../../../theme/app_sizes.dart';
import '../../../../theme/app_text_styles.dart';
import '../../../../utils/file_size_formatter.dart';

class StorageSettings extends ConsumerWidget {
  const StorageSettings({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final storageInfo = ref.watch(storageInfoProvider);

    return Card(
      child: Padding(
        padding: const EdgeInsets.all(AppSizes.p16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const Text('存储空间', style: AppTextStyles.titleLarge),
            const SizedBox(height: AppSizes.p16),
            storageInfo.when(
              data: (info) => _buildStorageInfo(info),
              loading: () => const CircularProgressIndicator(),
              error: (err, stack) => Text('加载失败: $err'),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildDetailsSection(StorageInfo info) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text('存储位置: ${info.path}', style: AppTextStyles.bodyMedium),
        const SizedBox(height: AppSizes.p8),
        Text(
          '缓存大小: ${FileSizeFormatter.format(info.cacheSize)}',
          style: AppTextStyles.bodyMedium,
        ),
        const SizedBox(height: AppSizes.p16),
        for (final dir in info.subdirectories) ...[
          Text(
            '${dir.name}: ${FileSizeFormatter.format(dir.size)}',
            style: AppTextStyles.bodyMedium,
          ),
          const SizedBox(height: AppSizes.p4),
        ],
      ],
    );
  }

  Widget _buildInfoItem({
    required String label,
    required String value,
    required IconData icon,
  }) {
    return Row(
      children: [
        Icon(icon, size: 20),
        const SizedBox(width: AppSizes.p8),
        Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(label, style: AppTextStyles.labelMedium),
            Text(value, style: AppTextStyles.bodyLarge),
          ],
        ),
      ],
    );
  }

  Widget _buildStorageBar(StorageInfo info) {
    final usagePercentage = info.usagePercentage.clamp(0, 100);

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          '已使用 ${FileSizeFormatter.format(info.usedSize)} / ${FileSizeFormatter.format(info.totalSize)}',
          style: AppTextStyles.bodyMedium,
        ),
        const SizedBox(height: AppSizes.p8),
        LinearProgressIndicator(
          value: usagePercentage / 100,
          backgroundColor: AppColors.background,
          valueColor: const AlwaysStoppedAnimation<Color>(
            AppColors.primary,
          ),
        ),
      ],
    );
  }

  Widget _buildStorageInfo(StorageInfo info) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        _buildSummarySection(info),
        const SizedBox(height: AppSizes.p16),
        _buildStorageBar(info),
        const SizedBox(height: AppSizes.p16),
        _buildDetailsSection(info),
      ],
    );
  }

  Widget _buildSummarySection(StorageInfo info) {
    return Row(
      children: [
        _buildInfoItem(
          label: '作品数量',
          value: '${info.workCount}',
          icon: Icons.image_outlined,
        ),
        const SizedBox(width: AppSizes.p24),
        _buildInfoItem(
          label: '文件数量',
          value: '${info.fileCount}',
          icon: Icons.folder_outlined,
        ),
      ],
    );
  }
}



=======================================
./lib/presentation/pages/settings/panels/general_settings_panel.dart
=======================================
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

class GeneralSettingsPanel extends ConsumerWidget {
  const GeneralSettingsPanel({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return SingleChildScrollView(
      padding: const EdgeInsets.all(24),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          const Text('界面设置', style: TextStyle(fontSize: 20, fontWeight: FontWeight.bold)),
          const SizedBox(height: 16),
          _buildThemeSettings(context),
          const Divider(height: 32),
          
          const Text('视图设置', style: TextStyle(fontSize: 20, fontWeight: FontWeight.bold)),
          const SizedBox(height: 16),
          _buildViewSettings(context),
          const Divider(height: 32),
          
          const Text('语言设置', style: TextStyle(fontSize: 20, fontWeight: FontWeight.bold)),
          const SizedBox(height: 16),
          _buildLanguageSettings(context),
          const Divider(height: 32),
          
          const Text('更新设置', style: TextStyle(fontSize: 20, fontWeight: FontWeight.bold)),
          const SizedBox(height: 16),
          _buildUpdateSettings(context),
        ],
      ),
    );
  }

  Widget _buildThemeSettings(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        DropdownButtonFormField<String>(
          decoration: const InputDecoration(
            labelText: '主题模式',
            border: OutlineInputBorder(),
          ),
          items: const [
            DropdownMenuItem(value: 'system', child: Text('跟随系统')),
            DropdownMenuItem(value: 'light', child: Text('明亮模式')),
            DropdownMenuItem(value: 'dark', child: Text('暗黑模式')),
          ],
          onChanged: (value) {},
        ),
        const SizedBox(height: 16),
        Row(
          children: [
            const Text('界面缩放'),
            Expanded(
              child: Slider(
                value: 1.0,
                min: 0.75,
                max: 1.5,
                divisions: 15,
                label: '100%',
                onChanged: (value) {},
              ),
            ),
          ],
        ),
      ],
    );
  }

  Widget _buildViewSettings(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        DropdownButtonFormField<String>(
          decoration: const InputDecoration(
            labelText: '默认视图模式',
            border: OutlineInputBorder(),
          ),
          items: const [
            DropdownMenuItem(value: 'grid', child: Text('网格视图')),
            DropdownMenuItem(value: 'list', child: Text('列表视图')),
          ],
          onChanged: (value) {},
        ),
        const SizedBox(height: 16),
        DropdownButtonFormField<int>(
          decoration: const InputDecoration(
            labelText: '缩略图尺寸',
            border: OutlineInputBorder(),
          ),
          items: const [
            DropdownMenuItem(value: 100, child: Text('小 (100px)')),
            DropdownMenuItem(value: 150, child: Text('中 (150px)')),
            DropdownMenuItem(value: 200, child: Text('大 (200px)')),
          ],
          onChanged: (value) {},
        ),
      ],
    );
  }

  Widget _buildLanguageSettings(BuildContext context) {
    return DropdownButtonFormField<String>(
      decoration: const InputDecoration(
        labelText: '界面语言',
        border: OutlineInputBorder(),
      ),
      items: const [
        DropdownMenuItem(value: 'system', child: Text('跟随系统')),
        DropdownMenuItem(value: 'zh_CN', child: Text('简体中文')),
        DropdownMenuItem(value: 'en_US', child: Text('English')),
      ],
      onChanged: (value) {},
    );
  }

  Widget _buildUpdateSettings(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        SwitchListTile(
          title: const Text('自动检查更新'),
          value: true,
          onChanged: (value) {},
        ),
        const SizedBox(height: 8),
        DropdownButtonFormField<String>(
          decoration: const InputDecoration(
            labelText: '更新提醒方式',
            border: OutlineInputBorder(),
          ),
          items: const [
            DropdownMenuItem(value: 'immediate', child: Text('立即提醒')),
            DropdownMenuItem(value: 'daily', child: Text('每天提醒一次')),
            DropdownMenuItem(value: 'weekly', child: Text('每周提醒一次')),
          ],
          onChanged: (value) {},
        ),
      ],
    );
  }
}



=======================================
./lib/presentation/pages/settings/panels/storage_settings_panel.dart
=======================================
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

class StorageSettingsPanel extends ConsumerWidget {
  const StorageSettingsPanel({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return SingleChildScrollView(
      padding: const EdgeInsets.all(24),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          _buildStoragePathSettings(context),
          const Divider(height: 32),
          _buildStorageManagement(context),
          const Divider(height: 32),
          _buildBackupSettings(context),
        ],
      ),
    );
  }

  Widget _buildStoragePathSettings(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        const Text('存储路径设置', style: TextStyle(fontSize: 20, fontWeight: FontWeight.bold)),
        const SizedBox(height: 16),
        _buildPathSelector(
          context,
          label: '默认存储位置',
          value: 'C:/Users/Documents/Demo/Storage',
          onSelectPath: () async {
            // TODO: 实现路径选择
          },
        ),
        const SizedBox(height: 16),
        _buildPathSelector(
          context,
          label: '临时文件位置',
          value: 'C:/Users/AppData/Local/Demo/Temp',
          onSelectPath: () async {
            // TODO: 实现路径选择
          },
        ),
        const SizedBox(height: 16),
        _buildPathSelector(
          context,
          label: '导出文件默认位置',
          value: 'C:/Users/Documents/Demo/Exports',
          onSelectPath: () async {
            // TODO: 实现路径选择
          },
        ),
      ],
    );
  }

  Widget _buildStorageManagement(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        const Text('存储管理', style: TextStyle(fontSize: 20, fontWeight: FontWeight.bold)),
        const SizedBox(height: 16),
        // 存储空间使用统计
        Card(
          child: Padding(
            padding: const EdgeInsets.all(16),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                const Text('存储空间使用统计', style: TextStyle(fontSize: 16, fontWeight: FontWeight.bold)),
                const SizedBox(height: 16),
                _buildStorageUsageRow('作品文件', '1.2 GB'),
                _buildStorageUsageRow('临时文件', '156 MB'),
                _buildStorageUsageRow('缓存文件', '328 MB'),
                const SizedBox(height: 16),
                Row(
                  mainAxisAlignment: MainAxisAlignment.end,
                  children: [
                    TextButton(
                      onPressed: () {
                        // TODO: 实现清理临时文件
                      },
                      child: const Text('清理临时文件'),
                    ),
                    const SizedBox(width: 8),
                    TextButton(
                      onPressed: () {
                        // TODO: 实现清理缓存
                      },
                      child: const Text('清理缓存'),
                    ),
                    const SizedBox(width: 8),
                    ElevatedButton(
                      onPressed: () {
                        // TODO: 实现一键清理
                      },
                      child: const Text('一键清理'),
                    ),
                  ],
                ),
              ],
            ),
          ),
        ),
        const SizedBox(height: 16),
        // 自动清理设置
        Card(
          child: Padding(
            padding: const EdgeInsets.all(16),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                const Text('自动清理设置', style: TextStyle(fontSize: 16, fontWeight: FontWeight.bold)),
                const SizedBox(height: 16),
                DropdownButtonFormField<String>(
                  decoration: const InputDecoration(
                    labelText: '定期清理临时文件',
                    border: OutlineInputBorder(),
                  ),
                  value: 'week',
                  items: const [
                    DropdownMenuItem(value: 'week', child: Text('每周')),
                    DropdownMenuItem(value: 'month', child: Text('每月')),
                    DropdownMenuItem(value: 'quarter', child: Text('每季度')),
                    DropdownMenuItem(value: 'never', child: Text('从不')),
                  ],
                  onChanged: (value) {},
                ),
                const SizedBox(height: 16),
                DropdownButtonFormField<int>(
                  decoration: const InputDecoration(
                    labelText: '缓存文件大小限制',
                    border: OutlineInputBorder(),
                  ),
                  value: 1024,
                  items: const [
                    DropdownMenuItem(value: 1024, child: Text('1 GB')),
                    DropdownMenuItem(value: 5120, child: Text('5 GB')),
                    DropdownMenuItem(value: 10240, child: Text('10 GB')),
                    DropdownMenuItem(value: -1, child: Text('不限制')),
                  ],
                  onChanged: (value) {},
                ),
              ],
            ),
          ),
        ),
      ],
    );
  }

  Widget _buildBackupSettings(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        const Text('备份设置', style: TextStyle(fontSize: 20, fontWeight: FontWeight.bold)),
        const SizedBox(height: 16),
        Card(
          child: Padding(
            padding: const EdgeInsets.all(16),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                SwitchListTile(
                  title: const Text('启用自动备份'),
                  value: true,
                  onChanged: (value) {},
                ),
                const SizedBox(height: 16),
                DropdownButtonFormField<String>(
                  decoration: const InputDecoration(
                    labelText: '备份周期',
                    border: OutlineInputBorder(),
                  ),
                  value: 'daily',
                  items: const [
                    DropdownMenuItem(value: 'daily', child: Text('每天')),
                    DropdownMenuItem(value: 'weekly', child: Text('每周')),
                    DropdownMenuItem(value: 'monthly', child: Text('每月')),
                  ],
                  onChanged: (value) {},
                ),
                const SizedBox(height: 16),
                DropdownButtonFormField<int>(
                  decoration: const InputDecoration(
                    labelText: '保留备份数量',
                    border: OutlineInputBorder(),
                  ),
                  value: 5,
                  items: const [
                    DropdownMenuItem(value: 3, child: Text('保留3个')),
                    DropdownMenuItem(value: 5, child: Text('保留5个')),
                    DropdownMenuItem(value: 10, child: Text('保留10个')),
                  ],
                  onChanged: (value) {},
                ),
                const SizedBox(height: 16),
                _buildPathSelector(
                  context,
                  label: '本地备份路径',
                  value: 'C:/Users/Documents/Demo/Backups',
                  onSelectPath: () async {
                    // TODO: 实现路径选择
                  },
                ),
                const SizedBox(height: 16),
                SwitchListTile(
                  title: const Text('启用云端备份'),
                  subtitle: const Text('需要登录账号'),
                  value: false,
                  onChanged: (value) {},
                ),
              ],
            ),
          ),
        ),
      ],
    );
  }

  Widget _buildPathSelector(
    BuildContext context, {
    required String label,
    required String value,
    required VoidCallback onSelectPath,
  }) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(label),
        const SizedBox(height: 8),
        Row(
          children: [
            Expanded(
              child: Container(
                padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
                decoration: BoxDecoration(
                  border: Border.all(color: Colors.grey[400]!),
                  borderRadius: BorderRadius.circular(4),
                ),
                child: Text(value, style: const TextStyle(fontFamily: 'monospace')),
              ),
            ),
            const SizedBox(width: 8),
            ElevatedButton(
              onPressed: onSelectPath,
              child: const Text('选择'),
            ),
          ],
        ),
      ],
    );
  }

  Widget _buildStorageUsageRow(String label, String value) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 4),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.spaceBetween,
        children: [
          Text(label),
          Text(value),
        ],
      ),
    );
  }
}



=======================================
./lib/presentation/pages/settings/settings_page.dart
=======================================
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../widgets/page_layout.dart';
import 'components/appearance_settings.dart';
import 'components/storage_settings.dart';

class SettingsPage extends ConsumerWidget {
  const SettingsPage({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return PageLayout(
      toolbar: const Text('设置'),
      body: _buildSettingsContent(context, ref),
    );
  }

  Widget _buildSettingsContent(BuildContext context, WidgetRef ref) {
    return ListView(
      children: const [
        AppearanceSettings(),
        Divider(),
        StorageSettings(),
      ],
    );
  }
}



=======================================
./lib/presentation/pages/works/character_collection_page.dart
=======================================
import 'package:flutter/material.dart';

import '../../widgets/character_collection/character_collection_panel.dart';

class CharacterCollectionPage extends StatelessWidget {
  final String imageId;
  final String workTitle;
  final List<String> images;

  const CharacterCollectionPage({
    super.key,
    required this.imageId,
    required this.workTitle,
    required this.images,
  });

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: CharacterCollectionPanel(
        imageId: imageId,
        workTitle: workTitle,
        images: images,
      ),
    );
  }
}



=======================================
./lib/presentation/pages/works/components/content/items/work_grid_item.dart
=======================================
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../../../application/providers/service_providers.dart';
import '../../../../../../domain/models/work/work_entity.dart';
import '../../../../../../infrastructure/providers/storage_providers.dart';
import '../../../../../../theme/app_colors.dart';
import '../../../../../../theme/app_sizes.dart';
import '../../../../../widgets/image/cached_image.dart';

class WorkGridItem extends ConsumerWidget {
  final WorkEntity work;
  final bool isSelected;
  final bool isSelectionMode;
  final VoidCallback onTap;

  const WorkGridItem({
    super.key,
    required this.work,
    required this.isSelected,
    required this.isSelectionMode,
    required this.onTap,
  });

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final theme = Theme.of(context);

    return Card(
      elevation:
          isSelected ? AppSizes.cardElevationSelected : AppSizes.cardElevation,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(AppSizes.cardRadius),
        side: isSelected
            ? BorderSide(
                color: theme.colorScheme.primary,
                width: 2,
              )
            : BorderSide.none,
      ),
      clipBehavior: Clip.antiAlias,
      child: InkWell(
        onTap: onTap,
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            // 缩略图区域 - 固定宽度，维持比例
            Expanded(
              child: AspectRatio(
                aspectRatio: 4 / 3,
                child: _buildThumbnail(context, ref),
              ),
            ),

            // 底部信息区域
            Padding(
              padding: const EdgeInsets.all(AppSizes.s),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    work.title,
                    style: theme.textTheme.titleMedium,
                    maxLines: 1,
                    overflow: TextOverflow.ellipsis,
                  ),
                  const SizedBox(height: AppSizes.xs),
                  Text(
                    work.author,
                    style: theme.textTheme.bodySmall,
                    maxLines: 1,
                    overflow: TextOverflow.ellipsis,
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }

  // 构建缩略图占位符
  Widget _buildPlaceholder(BuildContext context) {
    return Container(
      color: Theme.of(context).colorScheme.surfaceContainerHighest,
      child: const Center(
        child: Icon(
          Icons.image_outlined,
          size: 48,
          color: AppColors.textHint,
        ),
      ),
    );
  }

  // 构建缩略图
  Widget _buildThumbnail(BuildContext context, WidgetRef ref) {
    final storage = ref.watch(initializedStorageProvider);
    final workStorage = ref.watch(workStorageProvider);
    final thumbnailPath = workStorage.getWorkCoverThumbnailPath(work.id);

    return FutureBuilder<bool>(
      future: storage.fileExists(thumbnailPath),
      builder: (context, snapshot) {
        if (!snapshot.hasData || !snapshot.data!) {
          return _buildPlaceholder(context);
        }

        return CachedImage(
          path: thumbnailPath,
          fit: BoxFit.cover,
        );
      },
    );
  }
}



=======================================
./lib/presentation/pages/works/components/content/items/work_list_item.dart
=======================================
import 'dart:io';

import 'package:demo/domain/models/work/work_entity.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../../../application/providers/service_providers.dart';
import '../../../../../../infrastructure/providers/storage_providers.dart';
import '../../../../../../theme/app_sizes.dart';
import '../../../../../../utils/date_formatter.dart';

class WorkListItem extends ConsumerWidget {
  final WorkEntity work;
  final bool isSelected;
  final bool isSelectionMode;
  final VoidCallback onTap;

  const WorkListItem({
    super.key,
    required this.work,
    required this.isSelected,
    required this.isSelectionMode,
    required this.onTap,
  });

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final theme = Theme.of(context);

    return Card(
      elevation:
          isSelected ? AppSizes.cardElevationSelected : AppSizes.cardElevation,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(AppSizes.cardRadius),
        side: isSelected
            ? BorderSide(
                color: theme.colorScheme.primary,
                width: 2,
              )
            : BorderSide.none,
      ),
      clipBehavior: Clip.antiAlias,
      child: InkWell(
        onTap: onTap,
        child: SizedBox(
          height: 160, // 固定高度
          child: Row(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // 缩略图区域 - 固定200px宽，维持4:3比例
              SizedBox(
                width: 200,
                child: AspectRatio(
                  aspectRatio: 4 / 3,
                  child: _buildThumbnail(context, ref),
                ),
              ),

              // 右侧内容区域
              Expanded(
                child: Padding(
                  padding: const EdgeInsets.all(AppSizes.m),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      // 顶部：标题行
                      Row(
                        children: [
                          Expanded(
                            child: Text(
                              work.title,
                              style: theme.textTheme.titleMedium,
                              maxLines: 1,
                              overflow: TextOverflow.ellipsis,
                            ),
                          ),
                          if (work.imageCount != null && work.imageCount! > 0)
                            _buildImageCount(context, work.imageCount!),
                        ],
                      ),
                      const SizedBox(height: AppSizes.xxs),

                      // 作者行
                      ...[
                        Text(
                          work.author,
                          style: theme.textTheme.bodyLarge,
                          maxLines: 1,
                          overflow: TextOverflow.ellipsis,
                        ),
                        const SizedBox(height: AppSizes.xs),
                      ],

                      // 风格和工具
                      Row(
                        children: [
                          _buildInfoChip(
                            context,
                            Icons.brush_outlined,
                            work.style.label,
                          ),
                          const SizedBox(width: AppSizes.s),
                          _buildInfoChip(
                            context,
                            Icons.construction_outlined,
                            work.tool.label,
                          ),
                        ],
                      ),
                      const SizedBox(height: AppSizes.xs),

                      // 元数据信息预览 - 设置为可滚动且有最大高度
                      Expanded(
                        child: _buildMetadataPreview(context),
                      ),

                      const Spacer(flex: 1),

                      // 底部日期信息
                      Row(
                        mainAxisAlignment: MainAxisAlignment.spaceBetween,
                        children: [
                          // 创作日期
                          _buildInfoItem(
                            context,
                            Icons.palette_outlined,
                            '创作于 ${DateFormatter.formatCompact(work.creationDate)}',
                          ),

                          // 导入日期
                          _buildInfoItem(
                            context,
                            Icons.add_circle_outline,
                            '导入于 ${DateFormatter.formatCompact(work.createTime)}',
                          ),
                        ],
                      ),
                    ],
                  ),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  // 构建图片数量指示器
  Widget _buildImageCount(BuildContext context, int count) {
    final theme = Theme.of(context);
    return Container(
      padding: const EdgeInsets.symmetric(
        horizontal: AppSizes.xs,
        vertical: 2,
      ),
      decoration: BoxDecoration(
        color: theme.colorScheme.primaryContainer,
        borderRadius: BorderRadius.circular(AppSizes.radiusSmall),
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(Icons.photo_library_outlined,
              size: 16, color: theme.colorScheme.onPrimaryContainer),
          const SizedBox(width: 4),
          Text(
            count.toString(),
            style: theme.textTheme.labelMedium?.copyWith(
              color: theme.colorScheme.onPrimaryContainer,
            ),
          ),
        ],
      ),
    );
  }

  // 构建带图标的信息小标签
  Widget _buildInfoChip(BuildContext context, IconData icon, String text) {
    final theme = Theme.of(context);
    return Container(
      padding: const EdgeInsets.symmetric(
        horizontal: AppSizes.xs,
        vertical: 2,
      ),
      decoration: BoxDecoration(
        color: theme.colorScheme.secondaryContainer.withOpacity(0.7),
        borderRadius: BorderRadius.circular(AppSizes.radiusSmall),
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(icon, size: 14, color: theme.colorScheme.onSecondaryContainer),
          const SizedBox(width: 4),
          Text(
            text,
            style: theme.textTheme.bodySmall?.copyWith(
              color: theme.colorScheme.onSecondaryContainer,
            ),
          ),
        ],
      ),
    );
  }

  // 构建带图标的信息项
  Widget _buildInfoItem(BuildContext context, IconData icon, String text) {
    final theme = Theme.of(context);
    return Row(
      mainAxisSize: MainAxisSize.min,
      children: [
        Icon(icon, size: 14, color: theme.colorScheme.onSurfaceVariant),
        const SizedBox(width: 4),
        Text(
          text,
          style: theme.textTheme.bodySmall?.copyWith(
            color: theme.colorScheme.onSurfaceVariant,
          ),
        ),
      ],
    );
  }

  // 构建元数据预览
  Widget _buildMetadataPreview(BuildContext context) {
    final tags = work.tags;

    if (tags.isEmpty) {
      return const SizedBox.shrink();
    }

    // 显示标签
    return Container(
      constraints: const BoxConstraints(maxHeight: 48), // 限制最大高度
      child: SingleChildScrollView(
        child: Wrap(
          spacing: 4,
          runSpacing: 4,
          children: tags.map((tag) => _buildTagChip(context, tag)).toList(),
        ),
      ),
    );
  }

  // 构建缩略图占位符
  Widget _buildPlaceholder(BuildContext context) {
    return Container(
      color: Theme.of(context).colorScheme.surfaceContainerHighest,
      child: Center(
        child: Icon(
          Icons.image_outlined,
          size: 48,
          color:
              Theme.of(context).colorScheme.onSurfaceVariant.withOpacity(0.5),
        ),
      ),
    );
  }

  // 构建标签
  Widget _buildTagChip(BuildContext context, String tag) {
    final theme = Theme.of(context);
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2),
      decoration: BoxDecoration(
        color: theme.colorScheme.primary.withOpacity(0.1),
        borderRadius: BorderRadius.circular(4),
      ),
      child: Text(
        '#$tag',
        style: theme.textTheme.bodySmall?.copyWith(
          color: theme.colorScheme.primary,
          fontSize: 12,
        ),
      ),
    );
  }

  // 构建缩略图
  Widget _buildThumbnail(BuildContext context, WidgetRef ref) {
    final storage = ref.watch(initializedStorageProvider);
    final workStorage = ref.watch(workStorageProvider);
    final thumbnailPath = workStorage.getWorkCoverThumbnailPath(work.id);

    return FutureBuilder<bool>(
      future: storage.fileExists(thumbnailPath),
      builder: (context, existsSnapshot) {
        if (!existsSnapshot.hasData || !existsSnapshot.data!) {
          return _buildPlaceholder(context);
        }

        return Image.file(
          File(thumbnailPath),
          fit: BoxFit.cover,
          errorBuilder: (_, __, ___) => _buildPlaceholder(context),
        );
      },
    );
  }
}



=======================================
./lib/presentation/pages/works/components/content/work_grid_view.dart
=======================================
import 'package:demo/domain/models/work/work_entity.dart';
import 'package:flutter/material.dart';

import '../../../../../theme/app_sizes.dart';
import 'items/work_grid_item.dart';

class WorkGridView extends StatelessWidget {
  final List<WorkEntity> works;
  final bool batchMode;
  final Set<String> selectedWorks;
  final Function(String, bool) onSelectionChanged;
  final Function(String)? onItemTap;

  const WorkGridView({
    super.key,
    required this.works,
    required this.batchMode,
    required this.selectedWorks,
    required this.onSelectionChanged,
    this.onItemTap,
  });

  @override
  Widget build(BuildContext context) {
    return LayoutBuilder(
      builder: (context, constraints) {
        final width = constraints.maxWidth - (AppSizes.m * 2);
        final columns = (width / 280.0).floor();
        final crossAxisCount = columns < 2 ? 2 : columns;

        const spacing = AppSizes.m;
        final availableWidth =
            (width - (spacing * (crossAxisCount - 1))) / crossAxisCount;
        final aspectRatio = availableWidth / (availableWidth * 1.4);

        return GridView.builder(
          padding: const EdgeInsets.all(AppSizes.m),
          gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(
            crossAxisCount: crossAxisCount,
            mainAxisSpacing: spacing,
            crossAxisSpacing: spacing,
            childAspectRatio: aspectRatio,
          ),
          itemCount: works.length,
          itemBuilder: (context, index) {
            final work = works[index];
            return WorkGridItem(
              work: work,
              isSelected: selectedWorks.contains(work.id),
              isSelectionMode: batchMode,
              onTap: () => batchMode
                  ? onSelectionChanged(
                      work.id, !selectedWorks.contains(work.id))
                  : onItemTap?.call(work.id),
            );
          },
        );
      },
    );
  }
}



=======================================
./lib/presentation/pages/works/components/content/work_list_view.dart
=======================================
import 'package:demo/domain/models/work/work_entity.dart';
import 'package:flutter/material.dart';

import '../../../../../theme/app_sizes.dart';
import 'items/work_list_item.dart';

class WorkListView extends StatelessWidget {
  final List<WorkEntity> works;
  final bool batchMode;
  final Set<String> selectedWorks;
  final void Function(String workId, bool selected) onSelectionChanged;
  final Function(String)? onItemTap;

  const WorkListView({
    super.key,
    required this.works,
    required this.batchMode,
    required this.selectedWorks,
    required this.onSelectionChanged,
    this.onItemTap,
  });

  @override
  Widget build(BuildContext context) {
    return ListView.separated(
      padding: const EdgeInsets.all(AppSizes.m),
      itemCount: works.length,
      separatorBuilder: (_, __) => const SizedBox(height: AppSizes.s),
      itemBuilder: (context, index) {
        final work = works[index];
        return WorkListItem(
          work: work,
          isSelected: selectedWorks.contains(work.id),
          isSelectionMode: batchMode,
          onTap: () => batchMode
              ? onSelectionChanged(work.id, !selectedWorks.contains(work.id))
              : onItemTap?.call(work.id),
        );
      },
    );
  }
}



=======================================
./lib/presentation/pages/works/components/filter/date_range_filter_section.dart
=======================================
import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'package:logging/logging.dart';

import '../../../../../domain/models/common/date_range_filter.dart';
import '../../../../../theme/app_sizes.dart';

class DateRangeFilterSection extends StatefulWidget {
  final DateRangeFilter? filter;
  final ValueChanged<DateRangeFilter?> onChanged;

  const DateRangeFilterSection({
    super.key,
    this.filter,
    required this.onChanged,
  });

  @override
  State<DateRangeFilterSection> createState() => _DateRangeFilterSectionState();
}

class _DateRangeFilterSectionState extends State<DateRangeFilterSection>
    with SingleTickerProviderStateMixin {
  late TabController _tabController;
  final _logger = Logger('DateRangeFilterSection');
  DateTime? _startDate;
  DateTime? _endDate;

  bool get _hasSelection => _startDate != null || _endDate != null;

  bool get _hasValidRange =>
      _startDate != null && _endDate != null && _startDate!.isBefore(_endDate!);

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    final filter = widget.filter;
    final bool showResetChip = filter != null &&
        ((filter.preset != null && filter.preset != DateRangePreset.all) ||
            filter.start != null ||
            filter.end != null);

    _logger.fine('build - filter: $filter, showResetChip: $showResetChip');

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        if (showResetChip)
          Padding(
            padding: const EdgeInsets.only(bottom: AppSizes.s),
            child: Row(
              children: [
                Expanded(
                  child: Chip(
                    label: Text(_formatFilterText()),
                    onDeleted: () {
                      _logger.info('点击删除按钮');
                      widget.onChanged(null);
                    },
                  ),
                ),
              ],
            ),
          ),
        TabBar(
          controller: _tabController,
          tabs: const [
            Tab(text: '预设'),
            Tab(text: '自定义'),
          ],
        ),
        const SizedBox(height: AppSizes.m),
        SizedBox(
          height: 240,
          child: TabBarView(
            controller: _tabController,
            children: [
              _buildPresets(theme),
              _buildCustomRange(context),
            ],
          ),
        ),
      ],
    );
  }

  @override
  void dispose() {
    _tabController.dispose();
    super.dispose();
  }

  @override
  void initState() {
    super.initState();
    _tabController = TabController(length: 2, vsync: this);
    _tabController.index = 0;
    _startDate = widget.filter?.start;
    _endDate = widget.filter?.end;
  }

  void _applyDateRange() {
    if (_hasValidRange) {
      _logger.fine('应用日期范围 - 开始: $_startDate, 结束: $_endDate');
      widget.onChanged(DateRangeFilter(
        start: _startDate,
        end: _endDate,
      ));
    }
  }

  Widget _buildCustomRange(BuildContext context) {
    return Column(
      mainAxisSize: MainAxisSize.min,
      crossAxisAlignment: CrossAxisAlignment.stretch,
      children: [
        _buildDateField(
          context: context,
          label: '开始日期',
          value: _startDate,
          onPressed: () => _selectDate(context, true),
        ),
        const SizedBox(height: AppSizes.m),
        _buildDateField(
          context: context,
          label: '结束日期',
          value: _endDate,
          onPressed: () => _selectDate(context, false),
        ),
        if (_hasSelection) ...[
          const SizedBox(height: AppSizes.l),
          Row(
            children: [
              if (_hasValidRange)
                Expanded(
                  child: FilledButton(
                    onPressed: _applyDateRange,
                    child: const Text('应用'),
                  ),
                ),
              if (_hasValidRange) const SizedBox(width: AppSizes.s),
              Expanded(
                child: TextButton(
                  onPressed: _clearDateRange,
                  child: const Text('清除'),
                ),
              ),
            ],
          ),
        ],
      ],
    );
  }

  Widget _buildDateField({
    required BuildContext context,
    required String label,
    required DateTime? value,
    required VoidCallback onPressed,
  }) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(label, style: Theme.of(context).textTheme.titleSmall),
        const SizedBox(height: AppSizes.xs),
        SizedBox(
          width: double.infinity,
          child: OutlinedButton.icon(
            icon: const Icon(Icons.calendar_today, size: 18),
            label: Text(value != null ? _formatDate(value) : '点击选择日期'),
            onPressed: onPressed,
          ),
        ),
      ],
    );
  }

  Widget _buildPresets(ThemeData theme) {
    return SingleChildScrollView(
      padding: const EdgeInsets.all(AppSizes.s),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.stretch,
        children: [
          Wrap(
            spacing: AppSizes.xs,
            runSpacing: AppSizes.xs,
            children: DateRangePreset.values
                .where((preset) => preset != DateRangePreset.all)
                .map((preset) {
              final selected = widget.filter?.preset == preset;
              return FilterChip(
                label: Text(preset.label),
                selected: selected,
                onSelected: (selected) {
                  _logger.fine('选择预设: $preset, selected: $selected');
                  if (selected) {
                    widget.onChanged(DateRangeFilter.preset(preset));
                  } else {
                    widget.onChanged(null);
                  }
                },
                showCheckmark: false,
                selectedColor: theme.colorScheme.primaryContainer,
              );
            }).toList(),
          ),
          if (widget.filter?.preset != null) ...[
            const SizedBox(height: AppSizes.m),
            Text(
              _getPresetDateRange(widget.filter!.preset!),
              style: theme.textTheme.bodySmall,
            ),
          ],
        ],
      ),
    );
  }

  void _clearDateRange() {
    setState(() {
      _startDate = null;
      _endDate = null;
      widget.onChanged(null);
    });
  }

  String _formatDate(DateTime date) {
    return DateFormat('yyyy-MM-dd').format(date);
  }

  String _formatFilterText() {
    final filter = widget.filter;
    if (filter == null) return '';

    if (filter.preset != null && filter.preset != DateRangePreset.all) {
      return filter.preset!.label;
    }

    if (filter.start != null || filter.end != null) {
      final start = filter.start != null ? _formatDate(filter.start!) : '开始日期';
      final end = filter.end != null ? _formatDate(filter.end!) : '结束日期';
      return '$start - $end';
    }

    return '';
  }

  String _getPresetDateRange(DateRangePreset preset) {
    final range = preset.getRange();
    return '${_formatDate(range.start)} - ${_formatDate(range.end)}';
  }

  Future<void> _selectDate(BuildContext context, bool isStartDate) async {
    final initialDate = isStartDate ? _startDate : _endDate;

    final result = await showDatePicker(
      context: context,
      initialDate: initialDate ?? DateTime.now(),
      firstDate: DateTime(1900),
      lastDate: DateTime(2100),
    );

    if (result != null) {
      setState(() {
        if (isStartDate) {
          _startDate = result;
        } else {
          _endDate = result;
        }
      });
    }
  }
}



=======================================
./lib/presentation/pages/works/components/filter/date_section.dart
=======================================
import 'package:flutter/material.dart';

import '../../../../../domain/models/common/date_range_filter.dart';
import '../../../../../domain/models/work/work_filter.dart';
import '../../../../../theme/app_sizes.dart';
import 'date_range_filter_section.dart';

class DateSection extends StatelessWidget {
  final WorkFilter filter;
  final ValueChanged<WorkFilter> onFilterChanged;

  const DateSection({
    super.key,
    required this.filter,
    required this.onFilterChanged,
  });

  @override
  Widget build(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text('创作时间', style: Theme.of(context).textTheme.titleMedium),
        const SizedBox(height: AppSizes.s),
        DateRangeFilterSection(
          filter: DateRangeFilter(
            preset: filter.datePreset,
            start: filter.dateRange?.start,
            end: filter.dateRange?.end,
          ),
          onChanged: (dateFilter) {
            if (dateFilter == null) {
              // 如果日期筛选被清除，重置所有相关字段
              onFilterChanged(filter.copyWith(
                datePreset: DateRangePreset.all,
                dateRange: null,
              ));
            } else {
              onFilterChanged(filter.copyWith(
                datePreset: dateFilter.preset ?? DateRangePreset.all,
                dateRange: dateFilter.effectiveRange,
              ));
            }
          },
        ),
      ],
    );
  }
}



=======================================
./lib/presentation/pages/works/components/filter/filter_chip_group.dart
=======================================
import 'package:flutter/material.dart';

class FilterChipGroup extends StatelessWidget {
  final String label;
  final List<String> options;
  final String? selected;
  final ValueChanged<String?> onSelected;

  const FilterChipGroup({
    super.key,
    required this.label,
    required this.options,
    required this.onSelected,
    this.selected,
  });

  @override
  Widget build(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(label, style: Theme.of(context).textTheme.titleSmall),
        const SizedBox(height: 8),
        Wrap(
          spacing: 8,
          runSpacing: 8,
          children: options.map((option) {
            return FilterChip(
              label: Text(option),
              selected: option == selected,
              onSelected: (value) => onSelected(value ? option : null),
            );
          }).toList(),
        ),
      ],
    );
  }
}



=======================================
./lib/presentation/pages/works/components/filter/sort_section.dart
=======================================
import 'package:flutter/material.dart';

import '../../../../../domain/enums/sort_field.dart';
import '../../../../../domain/models/common/sort_option.dart';
import '../../../../../domain/models/work/work_filter.dart';
import '../../../../../theme/app_sizes.dart';

class SortSection extends StatelessWidget {
  // 默认排序选项
  static final defaultSortOption =
      const SortOption(field: SortField.createTime, descending: true);
  final WorkFilter filter;

  final ValueChanged<WorkFilter> onFilterChanged;

  const SortSection({
    super.key,
    required this.filter,
    required this.onFilterChanged,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Row(
          children: [
            Text('排序', style: theme.textTheme.titleMedium),
            const SizedBox(width: AppSizes.s),
            Container(
              padding: const EdgeInsets.symmetric(
                horizontal: AppSizes.s,
                vertical: AppSizes.xs,
              ),
              decoration: BoxDecoration(
                color: theme.colorScheme.secondaryContainer,
                borderRadius: BorderRadius.circular(AppSizes.s),
              ),
              child: InkWell(
                onTap: () => onFilterChanged(filter.copyWith(
                    sortOption: filter.sortOption
                        .copyWith(descending: !filter.sortOption.descending))),
                child: Row(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    Text(
                      filter.sortOption.descending ? '降序' : '升序',
                      style: theme.textTheme.bodySmall?.copyWith(
                        color: theme.colorScheme.onSecondaryContainer,
                      ),
                    ),
                    const SizedBox(width: 4),
                    Icon(
                      Icons.sort,
                      size: 18,
                      textDirection: filter.sortOption.descending
                          ? TextDirection.rtl
                          : TextDirection.ltr,
                      color: theme.colorScheme.onSecondaryContainer,
                    ),
                  ],
                ),
              ),
            ),
          ],
        ),
        const SizedBox(height: AppSizes.s),
        ...SortField.values
            .where((field) => field != SortField.none)
            .map((field) => _buildSortItem(field, field.label, theme)),
      ],
    );
  }

  Widget _buildSortItem(
    SortField field,
    String label,
    ThemeData theme,
  ) {
    final bool selected = filter.sortOption.field == field;

    return Material(
      color:
          selected ? theme.colorScheme.secondaryContainer : Colors.transparent,
      borderRadius: BorderRadius.circular(AppSizes.s),
      child: InkWell(
        borderRadius: BorderRadius.circular(AppSizes.s),
        onTap: () {
          // 如果点击当前选中的项，重置为默认排序
          if (selected) {
            onFilterChanged(filter.copyWith(
              sortOption: defaultSortOption,
            ));
          } else {
            // 选择新的排序字段
            onFilterChanged(filter.copyWith(
              sortOption: filter.sortOption.copyWith(field: field),
            ));
          }
        },
        child: Container(
          width: double.infinity,
          padding: const EdgeInsets.symmetric(
            horizontal: AppSizes.m,
            vertical: AppSizes.s,
          ),
          child: Row(
            children: [
              SizedBox(
                width: 18,
                height: 18,
                child: Radio<SortField>(
                  value: field,
                  groupValue: selected ? field : null,
                  onChanged: (_) {
                    // 如果点击当前选中的项，重置为默认排序
                    if (selected) {
                      onFilterChanged(filter.copyWith(
                        sortOption: defaultSortOption,
                      ));
                    } else {
                      onFilterChanged(filter.copyWith(
                        sortOption: filter.sortOption.copyWith(field: field),
                      ));
                    }
                  },
                  visualDensity: VisualDensity.compact,
                ),
              ),
              const SizedBox(width: AppSizes.s),
              Expanded(
                child: Text(
                  label,
                  style: theme.textTheme.bodyMedium?.copyWith(
                    color: selected
                        ? theme.colorScheme.onSecondaryContainer
                        : theme.colorScheme.onSurface,
                  ),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}



=======================================
./lib/presentation/pages/works/components/filter/style_section.dart
=======================================
import 'package:flutter/material.dart';

import '../../../../../domain/enums/work_style.dart';
import '../../../../../domain/models/work/work_filter.dart';
import 'work_filter_section.dart';

class StyleSection extends StatelessWidget {
  final WorkFilter filter;
  final ValueChanged<WorkFilter> onFilterChanged;

  const StyleSection({
    super.key,
    required this.filter,
    required this.onFilterChanged,
  });

  @override
  Widget build(BuildContext context) {
    return WorkFilterSection(
      title: '书法风格',
      child: _buildStyleChips(context),
    );
  }

  Widget _buildStyleChips(BuildContext context) {
    return Wrap(
      spacing: 8,
      runSpacing: 8,
      children: WorkStyle.values.map((style) {
        final selected = filter.style?.value == style.value;
        return FilterChip(
          label: Text(style.label),
          selected: selected,
          onSelected: (value) {
            // 如果是取消选择或者点击当前已选中的项，则清除选择
            final newStyle = selected ? null : WorkStyle.fromValue(style.value);
            onFilterChanged(
              filter.copyWith(style: newStyle),
            );
          },
        );
      }).toList(),
    );
  }
}



=======================================
./lib/presentation/pages/works/components/filter/tool_section.dart
=======================================
import 'package:flutter/material.dart';

import '../../../../../domain/enums/work_tool.dart';
import '../../../../../domain/models/work/work_filter.dart';
import 'work_filter_section.dart';

class ToolSection extends StatelessWidget {
  final WorkFilter filter;
  final ValueChanged<WorkFilter> onFilterChanged;

  const ToolSection({
    super.key,
    required this.filter,
    required this.onFilterChanged,
  });

  @override
  Widget build(BuildContext context) {
    return WorkFilterSection(
      title: '书写工具',
      child: _buildToolChips(context),
    );
  }

  Widget _buildToolChips(BuildContext context) {
    return Wrap(
      spacing: 8,
      runSpacing: 8,
      children: WorkTool.values.map((tool) {
        final selected = filter.tool?.value == tool.value;
        return FilterChip(
          label: Text(tool.label),
          selected: selected,
          onSelected: (value) {
            // 如果是取消选择或者点击当前已选中的项，则清除选择
            final newTool = selected ? null : WorkTool.fromValue(tool.value);
            onFilterChanged(
              filter.copyWith(tool: newTool),
            );
          },
        );
      }).toList(),
    );
  }
}



=======================================
./lib/presentation/pages/works/components/filter/work_filter_panel.dart
=======================================
import 'package:flutter/material.dart';

import '../../../../../domain/models/work/work_filter.dart';
import '../../../../../theme/app_sizes.dart';
import 'date_section.dart';
import 'sort_section.dart';
import 'style_section.dart';
import 'tool_section.dart';

class WorkFilterPanel extends StatelessWidget {
  final WorkFilter filter;
  final ValueChanged<WorkFilter> onFilterChanged;

  const WorkFilterPanel({
    super.key,
    required this.filter,
    required this.onFilterChanged,
  });

  @override
  Widget build(BuildContext context) {
    return Material(
      color: Theme.of(context).colorScheme.surface,
      child: Container(
        width: 280,
        padding: const EdgeInsets.all(AppSizes.m),
        // 移除所有边框线
        // decoration: BoxDecoration(
        //   border: Border(
        //     right: BorderSide(
        //       color: Theme.of(context).dividerColor,
        //     ),
        //   ),
        // ),
        child: CustomScrollView(
          slivers: [
            SliverToBoxAdapter(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  SortSection(
                    filter: filter,
                    onFilterChanged: onFilterChanged,
                  ),
                  const Divider(height: AppSizes.l),
                  StyleSection(
                    filter: filter,
                    onFilterChanged: onFilterChanged,
                  ),
                  const Divider(height: AppSizes.l),
                  ToolSection(
                    filter: filter,
                    onFilterChanged: onFilterChanged,
                  ),
                  const Divider(height: AppSizes.l),
                  DateSection(
                    filter: filter,
                    onFilterChanged: onFilterChanged,
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }
}



=======================================
./lib/presentation/pages/works/components/filter/work_filter_section.dart
=======================================
import 'package:flutter/material.dart';

class WorkFilterSection extends StatelessWidget {
  final String title;
  final Widget child;
  final List<Widget>? actions;

  const WorkFilterSection({
    super.key,
    required this.title,
    required this.child,
    this.actions,
  });

  @override
  Widget build(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.stretch,
      children: [
        _buildHeader(context),
        const SizedBox(height: 8),
        child,
      ],
    );
  }

  Widget _buildHeader(BuildContext context) {
    return Row(
      children: [
        Text(
          title,
          style: Theme.of(context).textTheme.titleMedium,
        ),
        if (actions != null) ...[
          const Spacer(),
          ...actions!,
        ],
      ],
    );
  }
}



=======================================
./lib/presentation/pages/works/components/image_error_view.dart
=======================================
import 'package:flutter/material.dart';

/// Widget that displays an error message when image loading fails
class ImageErrorView extends StatelessWidget {
  final String error;
  final VoidCallback onRetry;

  const ImageErrorView({
    super.key,
    required this.error,
    required this.onRetry,
  });

  @override
  Widget build(BuildContext context) {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          const Icon(Icons.error_outline, size: 48, color: Colors.red),
          const SizedBox(height: 16),
          Text(error, textAlign: TextAlign.center),
          const SizedBox(height: 16),
          ElevatedButton(
            onPressed: onRetry,
            child: const Text('重试'),
          ),
        ],
      ),
    );
  }
}



=======================================
./lib/presentation/pages/works/components/image_operations_toolbar.dart
=======================================
import 'package:flutter/material.dart';

/// 图片操作工具栏
class ImageOperationsToolbar extends StatelessWidget {
  final VoidCallback? onAddImages;
  final VoidCallback? onDeleteImage;
  final VoidCallback? onSortImages;

  const ImageOperationsToolbar({
    super.key,
    this.onAddImages,
    this.onDeleteImage,
    this.onSortImages,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Row(
      children: [
        // 添加图片按钮 - simplified to a single button
        Tooltip(
          message: '可按住Ctrl多选',
          child: FilledButton.tonalIcon(
            onPressed: onAddImages,
            icon: const Icon(Icons.add_photo_alternate),
            label: const Text('添加图片'),
          ),
        ),
        const SizedBox(width: 8),

        // 删除图片按钮
        OutlinedButton.icon(
          onPressed: onDeleteImage,
          icon: const Icon(Icons.delete_outline),
          label: const Text('删除图片'),
          style: OutlinedButton.styleFrom(
            foregroundColor: theme.colorScheme.error,
            side: BorderSide(
              color: theme.colorScheme.error.withOpacity(
                onDeleteImage == null ? 0.38 : 1.0,
              ),
            ),
          ),
        ),
        const SizedBox(width: 8),

        // 排序图片按钮
        OutlinedButton.icon(
          onPressed: onSortImages,
          icon: const Icon(Icons.sort),
          label: const Text('排序'),
        ),
      ],
    );
  }
}



=======================================
./lib/presentation/pages/works/components/image_viewer.dart
=======================================
import 'dart:io';

import 'package:flutter/material.dart';

import '../../../../infrastructure/logging/logger.dart';

/// Widget that displays an image with support for zooming
class ImageViewer extends StatelessWidget {
  final String imagePath;
  final int index;
  final VoidCallback onRetry;

  const ImageViewer({
    super.key,
    required this.imagePath,
    required this.index,
    required this.onRetry,
  });

  @override
  Widget build(BuildContext context) {
    // 确保文件存在
    final file = File(imagePath);
    if (!file.existsSync()) {
      return _buildMissingFileError();
    }

    // 如果文件存在，显示图片查看器
    return Center(
      child: InteractiveViewer(
        minScale: 0.5,
        maxScale: 3.0,
        child: Image.file(
          file,
          fit: BoxFit.contain,
          errorBuilder: (context, error, stackTrace) {
            AppLogger.error(
              '图片显示失败',
              tag: 'ImageViewer',
              error: error,
              stackTrace: stackTrace,
              data: {'path': imagePath},
            );
            return _buildLoadError(error);
          },
        ),
      ),
    );
  }

  Widget _buildLoadError(Object error) {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          const Icon(Icons.broken_image, size: 48, color: Colors.red),
          const SizedBox(height: 8),
          Text('无法加载图片: $error', textAlign: TextAlign.center),
          const SizedBox(height: 16),
          ElevatedButton(
            onPressed: onRetry,
            child: const Text('重试'),
          ),
        ],
      ),
    );
  }

  Widget _buildMissingFileError() {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          const Icon(Icons.broken_image, size: 48, color: Colors.orange),
          const SizedBox(height: 8),
          Text('图片文件不存在: ${imagePath.split('/').last}'),
          const SizedBox(height: 16),
          ElevatedButton(
            onPressed: onRetry,
            child: const Text('重试'),
          ),
        ],
      ),
    );
  }
}



=======================================
./lib/presentation/pages/works/components/info_card.dart
=======================================
import 'package:flutter/material.dart';

import '../../../../domain/models/work/work_entity.dart';
import '../../../../theme/app_sizes.dart';

/// 作品信息卡片
class InfoCard extends StatelessWidget {
  final WorkEntity work;
  final bool isEditMode;
  final Function(String)? onTitleEdit;
  final Function(String)? onAuthorEdit;
  final Function(String)? onStyleEdit;
  final Function(String)? onToolEdit;
  final Function(DateTime)? onDateEdit;
  final Function(String)? onRemarkEdit;

  const InfoCard({
    super.key,
    required this.work,
    this.isEditMode = false,
    this.onTitleEdit,
    this.onAuthorEdit,
    this.onStyleEdit,
    this.onToolEdit,
    this.onDateEdit,
    this.onRemarkEdit,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Card(
      child: Padding(
        padding: const EdgeInsets.all(AppSizes.m),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Title
            Text(
              '基本信息',
              style: theme.textTheme.titleMedium,
            ),
            const SizedBox(height: AppSizes.m),

            // Info rows
            _buildInfoRow(
              context,
              '标题',
              work.title,
              onEdit: isEditMode ? () => _showTitleEditor(context) : null,
            ),
            _buildInfoRow(
              context,
              '作者',
              work.author ?? '未知',
              onEdit: isEditMode ? () => _showAuthorEditor(context) : null,
            ),
            _buildInfoRow(
              context,
              '画风',
              work.style.toString().split('.').last,
              onEdit: isEditMode ? () => _showStyleEditor(context) : null,
            ),
            _buildInfoRow(
              context,
              '工具',
              work.tool.toString().split('.').last,
              onEdit: isEditMode ? () => _showToolEditor(context) : null,
            ),
            _buildInfoRow(
              context,
              '创作日期',
              work.creationDate.toString().split(' ')[0] ?? '未知',
              onEdit: isEditMode ? () => _showDateEditor(context) : null,
            ),
            if (work.remark?.isNotEmpty == true)
              _buildInfoRow(
                context,
                '备注',
                work.remark!,
                onEdit: isEditMode ? () => _showRemarkEditor(context) : null,
              ),
          ],
        ),
      ),
    );
  }

  Widget _buildInfoRow(
    BuildContext context,
    String label,
    String value, {
    VoidCallback? onEdit,
  }) {
    final theme = Theme.of(context);

    return Padding(
      padding: const EdgeInsets.only(bottom: AppSizes.s),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          SizedBox(
            width: 80,
            child: Text(
              label,
              style: theme.textTheme.bodySmall?.copyWith(
                color: theme.colorScheme.onSurfaceVariant,
              ),
            ),
          ),
          Expanded(
            child: Text(value),
          ),
          if (onEdit != null)
            IconButton(
              onPressed: onEdit,
              icon: const Icon(Icons.edit, size: 16),
              visualDensity: VisualDensity.compact,
              padding: EdgeInsets.zero,
              constraints: const BoxConstraints(
                minWidth: 24,
                minHeight: 24,
              ),
            ),
        ],
      ),
    );
  }

  Widget _buildTextEditor(
    BuildContext context,
    String title,
    String initialValue, {
    int maxLines = 1,
  }) {
    final controller = TextEditingController(text: initialValue);
    return AlertDialog(
      title: Text(title),
      content: TextField(
        controller: controller,
        maxLines: maxLines,
        decoration: const InputDecoration(
          border: OutlineInputBorder(),
        ),
      ),
      actions: [
        TextButton(
          onPressed: () => Navigator.of(context).pop(),
          child: const Text('取消'),
        ),
        FilledButton(
          onPressed: () => Navigator.of(context).pop(controller.text),
          child: const Text('确定'),
        ),
      ],
    );
  }

  void _showAuthorEditor(BuildContext context) async {
    if (onAuthorEdit == null) return;
    final result = await showDialog<String>(
      context: context,
      builder: (context) => _buildTextEditor(
        context,
        '编辑作者',
        work.author ?? '',
      ),
    );
    if (result != null) {
      onAuthorEdit!(result);
    }
  }

  void _showDateEditor(BuildContext context) async {
    if (onDateEdit == null) return;
    final result = await showDatePicker(
      context: context,
      initialDate: work.creationDate ?? DateTime.now(),
      firstDate: DateTime(1900),
      lastDate: DateTime.now(),
    );
    if (result != null) {
      onDateEdit!(result);
    }
  }

  void _showRemarkEditor(BuildContext context) async {
    if (onRemarkEdit == null) return;
    final result = await showDialog<String>(
      context: context,
      builder: (context) => _buildTextEditor(
        context,
        '编辑备注',
        work.remark ?? '',
        maxLines: 5,
      ),
    );
    if (result != null) {
      onRemarkEdit!(result);
    }
  }

  void _showStyleEditor(BuildContext context) async {
    if (onStyleEdit == null) return;
    final result = await showDialog<String>(
      context: context,
      builder: (context) => _buildTextEditor(
        context,
        '编辑画风',
        work.style.toString().split('.').last,
      ),
    );
    if (result != null) {
      onStyleEdit!(result);
    }
  }

  void _showTitleEditor(BuildContext context) async {
    if (onTitleEdit == null) return;
    final result = await showDialog<String>(
      context: context,
      builder: (context) => _buildTextEditor(
        context,
        '编辑标题',
        work.title,
      ),
    );
    if (result != null) {
      onTitleEdit!(result);
    }
  }

  void _showToolEditor(BuildContext context) async {
    if (onToolEdit == null) return;
    final result = await showDialog<String>(
      context: context,
      builder: (context) => _buildTextEditor(
        context,
        '编辑工具',
        work.tool.toString().split('.').last,
      ),
    );
    if (result != null) {
      onToolEdit!(result);
    }
  }
}



=======================================
./lib/presentation/pages/works/components/layout/work_layout.dart
=======================================
import 'package:flutter/material.dart';

class WorkLayout extends StatelessWidget {
  final Widget child;
  final Widget filterPanel;

  const WorkLayout({
    super.key,
    required this.child,
    required this.filterPanel,
  });

  @override
  Widget build(BuildContext context) {
    return Row(
      crossAxisAlignment: CrossAxisAlignment.stretch,
      children: [
        Expanded(child: child),
        filterPanel,
      ],
    );
  }
}



=======================================
./lib/presentation/pages/works/components/loading_state.dart
=======================================
import 'package:flutter/material.dart';

class LoadingState extends StatelessWidget {
  final String? message;

  const LoadingState({
    super.key,
    this.message,
  });

  @override
  Widget build(BuildContext context) {
    return Center(
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          const CircularProgressIndicator(),
          if (message != null) ...[
            const SizedBox(height: 16),
            Text(message!),
          ],
        ],
      ),
    );
  }
}



=======================================
./lib/presentation/pages/works/components/thumbnail_strip.dart
=======================================
import 'dart:async';
import 'dart:io';
import 'dart:math' as math;

import 'package:flutter/gestures.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';

import '../../../../infrastructure/logging/logger.dart';
import '../../../../theme/app_sizes.dart';

/// 缩略图条组件
/// T 可以是 File 或 WorkImage
class ThumbnailStrip<T> extends StatefulWidget {
  final List<T> images;
  final int selectedIndex;
  final Function(int) onTap;
  final bool isEditable;
  final Function(int, int)? onReorder;
  final bool useOriginalImage;
  final String Function(T image) pathResolver;
  final String Function(T image) keyResolver;
  final Function(int)? onRemove;

  const ThumbnailStrip({
    super.key,
    required this.images,
    required this.selectedIndex,
    required this.onTap,
    required this.pathResolver,
    required this.keyResolver,
    this.isEditable = false,
    this.onReorder,
    this.onRemove,
    this.useOriginalImage = false,
  });

  @override
  State<ThumbnailStrip<T>> createState() => _ThumbnailStripState<T>();
}

class _FileStatus {
  final bool exists;
  final DateTime lastModified;
  int checkAttempts = 0;

  _FileStatus({required this.exists, DateTime? lastModified})
      : lastModified = lastModified ?? DateTime.now();
}

class _ThumbnailStripState<T> extends State<ThumbnailStrip<T>> {
  static const double _thumbWidth = 100.0;
  static const double _thumbHeight = 100.0;
  static const double _thumbSpacing = 8.0;
  static const int _maxRetryAttempts = 3;
  static const Duration _scrollAnimationDuration = Duration(milliseconds: 100);
  static const double _scrollMultiplier = 2.0;

  final ScrollController _scrollController = ScrollController();
  final Map<String, _FileStatus> _fileStatus = {};
  bool _isDragging = false;
  Timer? _retryTimer;

  @override
  Widget build(BuildContext context) {
    AppLogger.debug(
        'Building ThumbnailStrip with ${widget.images.length} images');
    final theme = Theme.of(context);

    if (!widget.isEditable) {
      return SizedBox(
        height: 120,
        child: Listener(
          onPointerSignal: _handlePointerSignal,
          child: ScrollConfiguration(
            behavior: ScrollConfiguration.of(context).copyWith(
              scrollbars: false,
              dragDevices: PointerDeviceKind.values.toSet(),
              physics: const BouncingScrollPhysics(),
            ),
            child: ListView.builder(
              controller: _scrollController,
              scrollDirection: Axis.horizontal,
              itemCount: widget.images.length,
              itemBuilder: (context, index) =>
                  _buildThumbnail(context, index, theme),
            ),
          ),
        ),
      );
    }

    // 编辑模式：可重排序的列表
    return SizedBox(
      height: 120,
      child: Listener(
        onPointerSignal: _handlePointerSignal,
        child: ScrollConfiguration(
          behavior: ScrollConfiguration.of(context).copyWith(
            scrollbars: false,
            dragDevices: PointerDeviceKind.values.toSet(),
            physics: const BouncingScrollPhysics(),
          ),
          child: ReorderableListView.builder(
            scrollController: _scrollController,
            scrollDirection: Axis.horizontal,
            buildDefaultDragHandles: false,
            onReorderStart: (index) {
              setState(() => _isDragging = true);
              HapticFeedback.selectionClick();
            },
            onReorderEnd: (_) {
              setState(() => _isDragging = false);
              HapticFeedback.lightImpact();
            },
            onReorder: (oldIndex, newIndex) {
              if (oldIndex < newIndex) newIndex--;
              widget.onReorder?.call(oldIndex, newIndex);
            },
            proxyDecorator: (child, index, animation) {
              return AnimatedBuilder(
                animation: animation,
                builder: (context, child) {
                  final elevationValue = animation.value * 8.0;
                  final scaleValue = 1.0 + math.min(0.2, animation.value * 0.1);
                  final rotateValue = (1.0 - animation.value) * 0.1;

                  return Transform(
                    transform: Matrix4.identity()
                      ..scale(scaleValue, scaleValue)
                      ..rotateZ(rotateValue),
                    alignment: Alignment.center,
                    child: Material(
                      elevation: elevationValue,
                      color: Colors.transparent,
                      shadowColor: Colors.black38,
                      borderRadius: BorderRadius.circular(4),
                      child: child,
                    ),
                  );
                },
                child: child,
              );
            },
            itemBuilder: (context, index) {
              final thumbnail = _buildThumbnail(context, index, theme);
              return ReorderableDragStartListener(
                key: ValueKey(widget.keyResolver(widget.images[index])),
                index: index,
                enabled: !_isDragging,
                child: MouseRegion(
                  cursor: _isDragging
                      ? SystemMouseCursors.grabbing
                      : SystemMouseCursors.grab,
                  child: thumbnail,
                ),
              );
            },
            itemCount: widget.images.length,
          ),
        ),
      ),
    );
  }

  @override
  void didUpdateWidget(ThumbnailStrip<T> oldWidget) {
    super.didUpdateWidget(oldWidget);

    if (widget.images.length != oldWidget.images.length ||
        !_listsEqual(widget.images, oldWidget.images, widget.keyResolver)) {
      _fileStatus.clear();
      _checkImageFiles();
    }
    if (widget.selectedIndex != oldWidget.selectedIndex) {
      _scrollToSelected();
    }
  }

  @override
  void dispose() {
    _scrollController.dispose();
    _retryTimer?.cancel();
    super.dispose();
  }

  @override
  void initState() {
    super.initState();
    _checkImageFiles();
    WidgetsBinding.instance.addPostFrameCallback((_) => _scrollToSelected());
  }

  Widget _buildThumbnail(BuildContext context, int index, ThemeData theme) {
    final image = widget.images[index];
    final isSelected = index == widget.selectedIndex;
    final path = widget.pathResolver(image);
    final status = _fileStatus[path];
    final fileExists = status?.exists ?? false;
    final attemptCount = status?.checkAttempts ?? 0;

    String errorMessage = '图片文件不存在';
    if (attemptCount > 0 && attemptCount < _maxRetryAttempts) {
      errorMessage = '正在重试加载图片 ($attemptCount/$_maxRetryAttempts)';
    } else if (attemptCount >= _maxRetryAttempts) {
      errorMessage = '图片加载失败，请检查文件路径';
    }

    final heroTag = fileExists
        ? '${path}_${status?.lastModified.millisecondsSinceEpoch}'
        : path;

    return GestureDetector(
      onTap: () {
        if (!_isDragging) {
          HapticFeedback.selectionClick();
          widget.onTap(index);
        }
      },
      child: Container(
        width: _thumbWidth,
        height: _thumbHeight,
        margin: const EdgeInsets.symmetric(horizontal: AppSizes.xs),
        decoration: BoxDecoration(
          border: Border.all(
            color: isSelected
                ? theme.colorScheme.primary
                : theme.colorScheme.outlineVariant,
            width: isSelected ? 2.0 : 1.0,
          ),
          borderRadius: BorderRadius.circular(4),
          boxShadow: [
            if (isSelected)
              BoxShadow(
                color: theme.colorScheme.primary.withOpacity(0.2),
                blurRadius: 4,
                spreadRadius: 1,
              ),
          ],
        ),
        child: ClipRRect(
          borderRadius: BorderRadius.circular(3),
          child: Stack(
            fit: StackFit.expand,
            children: [
              if (fileExists)
                Hero(
                  tag: heroTag,
                  child: Image.file(
                    File(path),
                    fit: BoxFit.cover,
                    frameBuilder:
                        (context, child, frame, wasSynchronouslyLoaded) {
                      if (wasSynchronouslyLoaded) return child;
                      return AnimatedSwitcher(
                        duration: const Duration(milliseconds: 200),
                        child: frame != null
                            ? child
                            : Container(
                                color:
                                    theme.colorScheme.surfaceContainerHighest,
                                child: const Center(
                                  child:
                                      CircularProgressIndicator(strokeWidth: 2),
                                ),
                              ),
                      );
                    },
                    errorBuilder: (context, error, stack) => Center(
                      child: Icon(Icons.broken_image,
                          size: 32, color: theme.colorScheme.error),
                    ),
                  ),
                )
              else
                Center(
                  child: Icon(Icons.image_not_supported,
                      size: 32,
                      color: theme.colorScheme.surfaceContainerHighest),
                ),

              // Index label
              Positioned(
                left: 4,
                top: 4,
                child: Container(
                  padding: const EdgeInsets.symmetric(
                    horizontal: 6,
                    vertical: 2,
                  ),
                  decoration: BoxDecoration(
                    color: Colors.black54,
                    borderRadius: BorderRadius.circular(2),
                  ),
                  child: Text(
                    '${index + 1}',
                    style: const TextStyle(
                      color: Colors.white,
                      fontSize: 12,
                    ),
                  ),
                ),
              ),

              // Selected indicator
              if (isSelected)
                Positioned(
                  top: 4,
                  right: 4,
                  child: Container(
                    padding: const EdgeInsets.all(2),
                    decoration: BoxDecoration(
                      color: theme.colorScheme.primary,
                      shape: BoxShape.circle,
                    ),
                    child: const Icon(
                      Icons.check,
                      size: 12,
                      color: Colors.white,
                    ),
                  ),
                ),

              // Remove button
              if (isSelected && widget.onRemove != null)
                Positioned(
                  bottom: 4,
                  right: 4,
                  child: IconButton.filled(
                    onPressed: () {
                      HapticFeedback.lightImpact();
                      widget.onRemove!(index);
                    },
                    icon: const Icon(Icons.close, size: 16),
                    style: IconButton.styleFrom(
                      backgroundColor: theme.colorScheme.error,
                      foregroundColor: theme.colorScheme.onError,
                      padding: const EdgeInsets.all(4),
                      minimumSize: const Size(24, 24),
                      tapTargetSize: MaterialTapTargetSize.shrinkWrap,
                      shape: RoundedRectangleBorder(
                        borderRadius: BorderRadius.circular(AppSizes.xxs),
                      ),
                    ),
                  ),
                ),

              // Drag handle
              if (widget.isEditable && !_isDragging)
                Positioned(
                  right: 4,
                  bottom: isSelected && widget.onRemove != null ? 32 : 4,
                  child: Container(
                    padding: const EdgeInsets.all(2),
                    decoration: BoxDecoration(
                      color: theme.colorScheme.surfaceContainerHighest
                          .withOpacity(0.8),
                      borderRadius: BorderRadius.circular(2),
                    ),
                    child: Icon(
                      Icons.drag_indicator,
                      size: 16,
                      color: theme.colorScheme.onSurfaceVariant,
                    ),
                  ),
                ),

              // Error indicator
              if (!fileExists)
                Center(
                  child: Tooltip(
                    message: errorMessage,
                    child: Column(
                      mainAxisSize: MainAxisSize.min,
                      children: [
                        Icon(
                          Icons.error_outline,
                          size: 24,
                          color: theme.colorScheme.error,
                        ),
                        if (attemptCount > 0 &&
                            attemptCount < _maxRetryAttempts)
                          const SizedBox(
                            width: 16,
                            height: 16,
                            child: CircularProgressIndicator(strokeWidth: 2),
                          ),
                      ],
                    ),
                  ),
                ),
            ],
          ),
        ),
      ),
    );
  }

  Future<void> _checkImageFiles() async {
    // Cancel any pending retries
    _retryTimer?.cancel();

    bool hasFailures = false;

    for (final image in widget.images) {
      try {
        final path = widget.pathResolver(image);

        try {
          final file = File(path);
          if (await file.exists()) {
            final randomAccessFile = await file.open(mode: FileMode.read);
            try {
              await randomAccessFile.read(4);
              _fileStatus[path] = _FileStatus(
                exists: true,
                lastModified: await file.lastModified(),
              );
            } finally {
              await randomAccessFile.close();
            }
          } else {
            final status = _fileStatus[path];
            final attempts = status?.checkAttempts ?? 0;

            _fileStatus[path] = _FileStatus(exists: false)
              ..checkAttempts = attempts + 1;

            if (attempts < _maxRetryAttempts) {
              hasFailures = true;
            }
          }
        } catch (e) {
          AppLogger.debug(
            'File exists but not accessible yet',
            tag: 'ThumbnailStrip',
            data: {'path': path, 'error': e.toString()},
          );

          final status = _fileStatus[path];
          final attempts = status?.checkAttempts ?? 0;

          _fileStatus[path] = _FileStatus(exists: false)
            ..checkAttempts = attempts + 1;

          if (attempts < _maxRetryAttempts) {
            hasFailures = true;
          }
        }
      } catch (e) {
        _fileStatus[widget.pathResolver(image)] = _FileStatus(exists: false);
        hasFailures = true;
      }
    }

    if (mounted) setState(() {});

    if (hasFailures) {
      _retryTimer = Timer(const Duration(milliseconds: 500), () {
        if (mounted) _checkImageFiles();
      });
    }
  }

  void _handlePointerSignal(PointerSignalEvent event) {
    AppLogger.debug('收到指针信号事件: ${event.runtimeType}');

    if (event is PointerScrollEvent) {
      AppLogger.debug('滚动事件: delta=${event.scrollDelta}, kind=${event.kind}');

      if (!mounted || !_scrollController.hasClients) {
        AppLogger.debug('组件未挂载或滚动控制器未就绪');
        return;
      }

      final delta = event.scrollDelta;
      // 如果是水平滚动则直接使用，如果是垂直滚动则转换为水平方向
      final adjustedDelta =
          (delta.dx != 0 ? delta.dx : -delta.dy) * _scrollMultiplier;

      AppLogger.debug('调整后的滚动增量: $adjustedDelta');

      final newOffset = (_scrollController.offset + adjustedDelta)
          .clamp(0.0, _scrollController.position.maxScrollExtent);

      _scrollController.animateTo(
        newOffset,
        duration: _scrollAnimationDuration,
        curve: Curves.easeOutCubic,
      );
    }
  }

  bool _listsEqual(List<T> a, List<T> b, String Function(T) keyResolver) {
    if (a.length != b.length) return false;
    for (int i = 0; i < a.length; i++) {
      if (keyResolver(a[i]) != keyResolver(b[i])) return false;
    }
    return true;
  }

  void _scrollToSelected() {
    if (!mounted || !_scrollController.hasClients) return;

    final itemWidth = _thumbWidth + _thumbSpacing * 2;
    final viewportWidth = MediaQuery.of(context).size.width;
    final targetOffset = widget.selectedIndex * itemWidth;

    final offset = (targetOffset - (viewportWidth - itemWidth) / 2)
        .clamp(0.0, _scrollController.position.maxScrollExtent);

    _scrollController.animateTo(
      offset,
      duration: const Duration(milliseconds: 300),
      curve: Curves.easeOutCubic,
    );
  }
}



=======================================
./lib/presentation/pages/works/components/toolbar/batch_mode.dart
=======================================
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../providers/work_browse_provider.dart';

class BatchModeSection extends ConsumerWidget {
  const BatchModeSection({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final viewModel = ref.read(workBrowseProvider.notifier);
    final state = ref.watch(workBrowseProvider);
    
    return Row(
      children: [
        TextButton.icon(
          icon: Icon(state.batchMode ? Icons.close : Icons.checklist),
          label: Text(state.batchMode ? '完成' : '批量处理'),
          onPressed: () => viewModel.toggleBatchMode(),
        ),
        if (state.batchMode && state.selectedWorks.isNotEmpty) ...[
          Text('已选择 ${state.selectedWorks.length} 项'),
          FilledButton.tonalIcon(
            icon: const Icon(Icons.delete),
            label: Text('删除${state.selectedWorks.length}项'),
            onPressed: () => viewModel.deleteSelected(),
          ),
        ],
      ],
    );
  }
}



=======================================
./lib/presentation/pages/works/components/toolbar/batch_mode_button.dart
=======================================
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../providers/work_browse_provider.dart';

class BatchModeButton extends ConsumerWidget {
  const BatchModeButton({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final viewModel = ref.read(workBrowseProvider.notifier);
    final state = ref.watch(workBrowseProvider);

    return TextButton.icon(
      icon: Icon(state.batchMode ? Icons.close : Icons.checklist),
      label: Text(state.batchMode ? '完成' : '批量处理'),
      onPressed: () {
        viewModel.toggleBatchMode();
        // 退出批量模式时清空选择
        if (state.batchMode) {
          viewModel.clearSelection();
        }
      },
    );
  }
}



=======================================
./lib/presentation/pages/works/components/toolbar/delete_button.dart
=======================================
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../providers/work_browse_provider.dart';

class DeleteButton extends ConsumerWidget {
  const DeleteButton({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final state = ref.watch(workBrowseProvider);
    final viewModel = ref.read(workBrowseProvider.notifier);

    if (!state.batchMode || state.selectedWorks.isEmpty) {
      return const SizedBox.shrink();
    }

    return FilledButton.tonalIcon(
      icon: const Icon(Icons.delete),
      label: Text('删除${state.selectedWorks.length}项'),
      onPressed: () async {
        final confirmed = await showDialog<bool>(
          context: context,
          builder: (context) => AlertDialog(
            title: const Text('确认删除'),
            content: Text('确定要删除选中的 ${state.selectedWorks.length} 个作品吗？'),
            actions: [
              TextButton(
                child: const Text('取消'),
                onPressed: () => Navigator.pop(context, false),
              ),
              FilledButton(
                child: const Text('删除'),
                onPressed: () => Navigator.pop(context, true),
              ),
            ],
          ),
        );

        if (confirmed == true) {
          await viewModel.deleteSelected();
        }
      },
    );
  }
}



=======================================
./lib/presentation/pages/works/components/toolbar/import_button.dart
=======================================
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../dialogs/work_import/work_import_dialog.dart';
import '../../../../providers/work_browse_provider.dart';
import '../../../../viewmodels/work_browse_view_model.dart';

class ImportButton extends ConsumerWidget {
  const ImportButton({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final viewModel = ref.read(workBrowseProvider.notifier);

    return FilledButton.icon(
      icon: const Icon(Icons.add),
      label: const Text('导入作品'),
      onPressed: () => _showImportDialog(context, viewModel),
    );
  }

  Future<void> _showImportDialog(
      BuildContext context, WorkBrowseViewModel viewModel) async {
    try {
      // 显示导入对话框
      final result = await showDialog<bool>(
        context: context,
        barrierDismissible: false,
        builder: (context) => const WorkImportDialog(),
      );

      if (result == true) {
        // 显示加载指示器
        if (context.mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(content: Text('正在刷新作品列表...')),
          );
        }

        // 刷新列表
        await viewModel.loadWorks();

        // 显示成功提示
        if (context.mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(content: Text('作品导入成功')),
          );
        }
      }
    } catch (e) {
      if (context.mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('导入失败: ${e.toString()}')),
        );
      }
    }
  }
}



=======================================
./lib/presentation/pages/works/components/toolbar/search_field.dart
=======================================
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../providers/work_browse_provider.dart';

class SearchField extends ConsumerWidget {
  const SearchField({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final viewModel = ref.read(workBrowseProvider.notifier);
    final state = ref.watch(workBrowseProvider);

    return SizedBox(
      width: 240,
      child: TextField(
        controller: state.searchController,
        decoration: InputDecoration(
          hintText: '搜索作品...',
          prefixIcon: const Icon(Icons.search),
          border: OutlineInputBorder(
            borderRadius: BorderRadius.circular(8),
          ),
          // 改进清空按钮逻辑
          suffixIcon: state.searchController.text.isNotEmpty
              ? IconButton(
                  icon: const Icon(Icons.clear),
                  onPressed: () {
                    state.searchController.clear();
                    viewModel.setSearchQuery('');
                    viewModel.loadWorks(); // 清空后重新加载
                  },
                )
              : null,
        ),
        // 使用 ViewModel 中的防抖方法
        onChanged: viewModel.setSearchQuery,
      ),
    );
  }
}



=======================================
./lib/presentation/pages/works/components/toolbar/view_mode_toggle.dart
=======================================
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../providers/work_browse_provider.dart';
import '../../../../viewmodels/states/work_browse_state.dart';

class ViewModeToggle extends ConsumerWidget {
  const ViewModeToggle({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final state = ref.watch(workBrowseProvider);
    final viewModel = ref.read(workBrowseProvider.notifier);

    return Tooltip(
      message: state.viewMode == ViewMode.grid ? '切换到列表视图' : '切换到网格视图',
      child: IconButton(
        icon: AnimatedSwitcher(
          duration: const Duration(milliseconds: 200),
          child: Icon(
            state.viewMode == ViewMode.grid ? Icons.view_list : Icons.grid_view,
            key: ValueKey(state.viewMode),
          ),
        ),
        onPressed: viewModel.toggleViewMode,
      ),
    );
  }
}



=======================================
./lib/presentation/pages/works/components/unified_work_detail_panel.dart
=======================================
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:intl/intl.dart';

import '../../../../domain/enums/work_style.dart';
import '../../../../domain/enums/work_tool.dart';
import '../../../../domain/models/work/work_entity.dart';
import '../../../../theme/app_sizes.dart';
import '../../../providers/work_detail_provider.dart';
import '../../../widgets/common/section_title.dart';
import '../../../widgets/common/tab_bar_theme_wrapper.dart';
import '../../../widgets/tag_editor.dart';

class UnifiedWorkDetailPanel extends ConsumerStatefulWidget {
  final WorkEntity work;
  final bool isEditing;

  const UnifiedWorkDetailPanel({
    super.key,
    required this.work,
    required this.isEditing,
  });

  @override
  ConsumerState<UnifiedWorkDetailPanel> createState() =>
      _UnifiedWorkDetailPanelState();
}

class _UnifiedWorkDetailPanelState extends ConsumerState<UnifiedWorkDetailPanel>
    with SingleTickerProviderStateMixin {
  late TabController _tabController;

  // Form controllers
  late TextEditingController _titleController;
  late TextEditingController _authorController;
  late TextEditingController _remarkController;

  // Form state
  WorkStyle? _selectedStyle;
  WorkTool? _selectedTool;
  DateTime? _selectedDate;
  List<String> _tags = [];

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Card(
      margin: const EdgeInsets.only(
        top: AppSizes.spacingMedium,
        right: AppSizes.spacingMedium,
        bottom: AppSizes.spacingMedium,
      ),
      clipBehavior: Clip.antiAlias,
      child: Column(
        children: [
          TabBarThemeWrapper(
            child: TabBar(
              controller: _tabController,
              tabs: const [
                Tab(text: '基本信息'),
                Tab(text: '标签'),
                Tab(text: '集字信息'),
              ],
              labelStyle: theme.textTheme.titleSmall,
              unselectedLabelStyle: theme.textTheme.bodyMedium,
              indicatorSize: TabBarIndicatorSize.tab,
            ),
          ),
          Expanded(
            child: TabBarView(
              controller: _tabController,
              children: [
                _buildBasicInfoTab(context),
                _buildTagsTab(context),
                _buildCharactersTab(context),
              ],
            ),
          ),
        ],
      ),
    );
  }

  @override
  void didUpdateWidget(UnifiedWorkDetailPanel oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (oldWidget.work != widget.work ||
        oldWidget.isEditing != widget.isEditing) {
      _initFormControllers();
    }
  }

  @override
  void dispose() {
    _tabController.dispose();
    _titleController.dispose();
    _authorController.dispose();
    _remarkController.dispose();
    super.dispose();
  }

  @override
  void initState() {
    super.initState();
    _tabController =
        TabController(length: 3, vsync: this); // Added tab for tags
    _initFormControllers();
  }

  Widget _buildBasicInfoDisplay(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        _buildInfoRow('标题', widget.work.title),
        _buildInfoRow('作者', widget.work.author),
        _buildInfoRow('风格', widget.work.style.label),
        _buildInfoRow('工具', widget.work.tool.label),
        _buildInfoRow('创作时间', _formatDate(widget.work.creationDate)),
        _buildInfoRow('图片数量', (widget.work.imageCount ?? 0).toString()),
        _buildInfoRow('创建时间', _formatDateTime(widget.work.createTime)),
        _buildInfoRow('修改时间', _formatDateTime(widget.work.updateTime)),
        if (widget.work.remark != null && widget.work.remark!.isNotEmpty)
          _buildRemarkSection(context),
      ],
    );
  }

  Widget _buildBasicInfoTab(BuildContext context) {
    return ListView(
      padding: const EdgeInsets.all(AppSizes.spacingMedium),
      children: [
        widget.isEditing
            ? _buildEditForm(context)
            : _buildBasicInfoDisplay(context),
      ],
    );
  }

  Widget _buildCharacterChip(BuildContext context) {
    return Chip(
      avatar: const CircleAvatar(
        child: Icon(Icons.text_fields, size: 14),
      ),
      label: const Text('字'),
      backgroundColor: Theme.of(context).colorScheme.surfaceContainerHighest,
    );
  }

  Widget _buildCharactersSection(BuildContext context) {
    final theme = Theme.of(context);
    final charCount = widget.work.collectedChars.length;

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text('$charCount 个', style: theme.textTheme.bodySmall),
        if (charCount == 0)
          const Padding(
            padding: EdgeInsets.symmetric(vertical: 16.0),
            child: Center(
              child: Text('尚未从此作品中提取字形'),
            ),
          )
        else
          Wrap(
            spacing: 8,
            runSpacing: 8,
            children: List.generate(
              charCount.clamp(0, 20),
              (index) => _buildCharacterChip(context),
            ),
          ),
        if (charCount > 20)
          Center(
            child: TextButton(
              onPressed: () {
                // TODO: Navigate to characters list page
              },
              child: const Text('查看全部'),
            ),
          ),
      ],
    );
  }

  Widget _buildCharactersTab(BuildContext context) {
    return ListView(
      padding: const EdgeInsets.all(AppSizes.spacingMedium),
      children: [
        _buildCharactersSection(context),
      ],
    );
  }

  Widget _buildDatePicker() {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        const Text(
          '创作日期',
          style: TextStyle(
            fontSize: 14,
            fontWeight: FontWeight.w500,
          ),
        ),
        const SizedBox(height: 4),
        InkWell(
          onTap: () async {
            final date = await showDatePicker(
              context: context,
              initialDate: _selectedDate ?? DateTime.now(),
              firstDate: DateTime(1500),
              lastDate: DateTime.now(),
            );
            if (date != null) {
              setState(() => _selectedDate = date);
              _updateWorkField('creationDate', date);
            }
          },
          child: InputDecorator(
            decoration: InputDecoration(
              isDense: true,
              contentPadding: const EdgeInsets.symmetric(
                horizontal: 12,
                vertical: 10,
              ),
              border: OutlineInputBorder(
                borderRadius: BorderRadius.circular(4),
                borderSide: BorderSide(color: Colors.grey.shade300),
              ),
              enabledBorder: OutlineInputBorder(
                borderRadius: BorderRadius.circular(4),
                borderSide: BorderSide(color: Colors.grey.shade300),
              ),
              suffixIcon: const Icon(Icons.calendar_today, size: 18),
            ),
            child: Text(
              _selectedDate != null
                  ? DateFormat('yyyy-MM-dd').format(_selectedDate!)
                  : '未设置',
            ),
          ),
        ),
      ],
    );
  }

  Widget _buildEditForm(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        const SectionTitle(title: '基本信息'),
        const SizedBox(height: AppSizes.spacingMedium),
        _buildFormField(
          label: '作品名称',
          controller: _titleController,
          onChanged: (value) => _updateWorkField('title', value),
        ),
        const SizedBox(height: AppSizes.spacingSmall),
        _buildFormField(
          label: '作者',
          controller: _authorController,
          onChanged: (value) => _updateWorkField('author', value),
        ),
        const SizedBox(height: AppSizes.spacingSmall),
        _buildStyleDropdown(),
        const SizedBox(height: AppSizes.spacingSmall),
        _buildToolDropdown(),
        const SizedBox(height: AppSizes.spacingSmall),
        _buildDatePicker(),
        const SizedBox(height: AppSizes.spacingSmall),
        _buildFormField(
          label: '备注',
          controller: _remarkController,
          onChanged: (value) => _updateWorkField('remark', value),
          maxLines: 3,
        ),
      ],
    );
  }

  Widget _buildFormField({
    required String label,
    required TextEditingController controller,
    required ValueChanged<String> onChanged,
    int maxLines = 1,
  }) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          label,
          style: const TextStyle(
            fontSize: 14,
            fontWeight: FontWeight.w500,
          ),
        ),
        const SizedBox(height: 4),
        TextFormField(
          controller: controller,
          maxLines: maxLines,
          decoration: InputDecoration(
            isDense: true,
            contentPadding: const EdgeInsets.symmetric(
              horizontal: 12,
              vertical: 10,
            ),
            border: OutlineInputBorder(
              borderRadius: BorderRadius.circular(4),
              borderSide: BorderSide(color: Colors.grey.shade300),
            ),
            enabledBorder: OutlineInputBorder(
              borderRadius: BorderRadius.circular(4),
              borderSide: BorderSide(color: Colors.grey.shade300),
            ),
          ),
          onChanged: onChanged,
        ),
      ],
    );
  }

  Widget _buildInfoRow(String label, String value) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 4),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          SizedBox(
            width: 80,
            child: Text(
              label,
              style: TextStyle(
                fontWeight: FontWeight.bold,
                color: Theme.of(context).colorScheme.primary,
              ),
            ),
          ),
          Expanded(
            child: Text(value),
          ),
        ],
      ),
    );
  }

  Widget _buildRemarkSection(BuildContext context) {
    final theme = Theme.of(context);
    return Padding(
      padding: const EdgeInsets.only(top: 8.0),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            '备注:',
            style: theme.textTheme.bodyMedium?.copyWith(
              fontWeight: FontWeight.bold,
            ),
          ),
          const SizedBox(height: 4),
          Container(
            padding: const EdgeInsets.all(12),
            decoration: BoxDecoration(
              color: theme.colorScheme.surfaceContainerHighest.withOpacity(0.3),
              borderRadius: BorderRadius.circular(8),
            ),
            child: Text(widget.work.remark!),
          ),
        ],
      ),
    );
  }

  Widget _buildStyleDropdown() {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        const Text(
          '作品风格',
          style: TextStyle(
            fontSize: 14,
            fontWeight: FontWeight.w500,
          ),
        ),
        const SizedBox(height: 4),
        DropdownButtonFormField<WorkStyle>(
          value: _selectedStyle,
          items: WorkStyle.values
              .map((style) => DropdownMenuItem(
                    value: style,
                    child: Text(style.label),
                  ))
              .toList(),
          onChanged: (value) {
            if (value != null) {
              setState(() => _selectedStyle = value);
              _updateWorkField('style', value);
            }
          },
          decoration: InputDecoration(
            isDense: true,
            contentPadding: const EdgeInsets.symmetric(
              horizontal: 12,
              vertical: 10,
            ),
            border: OutlineInputBorder(
              borderRadius: BorderRadius.circular(4),
              borderSide: BorderSide(color: Colors.grey.shade300),
            ),
            enabledBorder: OutlineInputBorder(
              borderRadius: BorderRadius.circular(4),
              borderSide: BorderSide(color: Colors.grey.shade300),
            ),
          ),
        ),
      ],
    );
  }

  Widget _buildTagsTab(BuildContext context) {
    final theme = Theme.of(context);

    return ListView(
      padding: const EdgeInsets.all(AppSizes.spacingMedium),
      children: [
        Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              '标签管理',
              style: theme.textTheme.titleMedium?.copyWith(
                fontWeight: FontWeight.w500,
              ),
            ),
            const SizedBox(height: AppSizes.spacingMedium),
            if (widget.isEditing)
              TagEditor(
                tags: _tags,
                suggestedTags: const [
                  '行书',
                  '楷书',
                  '隶书',
                  '草书',
                  '真迹',
                  '拓片',
                  '碑帖',
                  '字帖',
                  '宋代',
                  '元代',
                  '明代',
                  '清代',
                ],
                onTagsChanged: (updatedTags) {
                  setState(() => _tags = updatedTags);
                  ref
                      .read(workDetailProvider.notifier)
                      .updateWorkTags(updatedTags);
                },
                chipColor: theme.colorScheme.primaryContainer,
                textColor: theme.colorScheme.onPrimaryContainer,
              )
            else if (_tags.isEmpty)
              const Center(
                child: Padding(
                  padding: EdgeInsets.all(AppSizes.spacingLarge),
                  child: Text('没有标签'),
                ),
              )
            else
              Wrap(
                spacing: 8,
                runSpacing: 8,
                children: _tags
                    .map((tag) => Chip(
                          label: Text(tag),
                          backgroundColor:
                              theme.colorScheme.surfaceContainerHighest,
                        ))
                    .toList(),
              ),
          ],
        ),
      ],
    );
  }

  Widget _buildToolDropdown() {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        const Text(
          '使用工具',
          style: TextStyle(
            fontSize: 14,
            fontWeight: FontWeight.w500,
          ),
        ),
        const SizedBox(height: 4),
        DropdownButtonFormField<WorkTool>(
          value: _selectedTool,
          items: WorkTool.values
              .map((tool) => DropdownMenuItem(
                    value: tool,
                    child: Text(tool.label),
                  ))
              .toList(),
          onChanged: (value) {
            if (value != null) {
              setState(() => _selectedTool = value);
              _updateWorkField('tool', value);
            }
          },
          decoration: InputDecoration(
            isDense: true,
            contentPadding: const EdgeInsets.symmetric(
              horizontal: 12,
              vertical: 10,
            ),
            border: OutlineInputBorder(
              borderRadius: BorderRadius.circular(4),
              borderSide: BorderSide(color: Colors.grey.shade300),
            ),
            enabledBorder: OutlineInputBorder(
              borderRadius: BorderRadius.circular(4),
              borderSide: BorderSide(color: Colors.grey.shade300),
            ),
          ),
        ),
      ],
    );
  }

  String _formatDate(DateTime? date) {
    if (date == null) return '未知';
    return DateFormat('yyyy-MM-dd').format(date);
  }

  String _formatDateTime(DateTime? date) {
    if (date == null) return '未知';
    return DateFormat('yyyy-MM-dd HH:mm').format(date);
  }

  void _initFormControllers() {
    _titleController = TextEditingController(text: widget.work.title);
    _authorController = TextEditingController(text: widget.work.author);
    _remarkController = TextEditingController(text: widget.work.remark);
    _selectedStyle = widget.work.style;
    _selectedTool = widget.work.tool;
    _selectedDate = widget.work.creationDate;
    _tags = List.from(widget.work.tags);
  }

  void _updateWorkField(String field, dynamic value) {
    final notifier = ref.read(workDetailProvider.notifier);
    switch (field) {
      case 'title':
        notifier.updateWorkBasicInfo(title: value);
        break;
      case 'author':
        notifier.updateWorkBasicInfo(author: value);
        break;
      case 'style':
        notifier.updateWorkBasicInfo(style: value);
        break;
      case 'tool':
        notifier.updateWorkBasicInfo(tool: value);
        break;
      case 'creationDate':
        notifier.updateWorkBasicInfo(creationDate: value);
        break;
      case 'remark':
        notifier.updateWorkBasicInfo(remark: value);
        break;
    }
    notifier.markAsChanged();
  }
}



=======================================
./lib/presentation/pages/works/components/view_mode_image_preview.dart
=======================================
import 'dart:io';

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../domain/models/work/work_image.dart';
import '../../../../infrastructure/logging/logger.dart';
import '../../../widgets/common/zoomable_image_view.dart';
import 'thumbnail_strip.dart';

class ViewModeImagePreview extends ConsumerStatefulWidget {
  final List<WorkImage> images;
  final int selectedIndex;
  final Function(int) onImageSelect;

  const ViewModeImagePreview({
    super.key,
    required this.images,
    required this.selectedIndex,
    required this.onImageSelect,
  });

  @override
  ConsumerState<ViewModeImagePreview> createState() =>
      _ViewModeImagePreviewState();
}

class _ViewModeImagePreviewState extends ConsumerState<ViewModeImagePreview> {
  final Map<String, bool> _fileExistsCache = {};

  @override
  Widget build(BuildContext context) {
    if (widget.images.isEmpty) {
      return const Center(
        child: Text('没有可显示的图片'),
      );
    }

    // Get the current image
    final currentImage = widget.selectedIndex < widget.images.length
        ? widget.images[widget.selectedIndex]
        : widget.images.first;

    return Column(
      children: [
        // Main image display area
        Expanded(
          child: Center(
            child: FutureBuilder<bool>(
              // Check if file exists when building the widget
              future: _checkFileExists(currentImage.path),
              builder: (context, snapshot) {
                final fileExists = snapshot.data ?? false;

                if (!fileExists) {
                  return Column(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      Icon(
                        Icons.broken_image,
                        size: 64,
                        color: Theme.of(context).colorScheme.error,
                      ),
                      const SizedBox(height: 16),
                      Text(
                        '无法加载图片: ${currentImage.path}',
                        style: TextStyle(
                            color: Theme.of(context).colorScheme.error),
                      ),
                      const SizedBox(height: 16),
                      ElevatedButton(
                        onPressed: () {
                          _fileExistsCache.remove(currentImage.path);
                          setState(() {}); // Force rebuild
                        },
                        child: const Text('重试'),
                      ),
                    ],
                  );
                }

                return ZoomableImageView(
                  imagePath: currentImage.path,
                  enableMouseWheel: true,
                  minScale: 0.5,
                  maxScale: 4.0,
                );
              },
            ),
          ),
        ),

        // Thumbnail strip below the main image
        SizedBox(
          height: 120,
          child: ThumbnailStrip<WorkImage>(
            images: widget.images,
            selectedIndex: widget.selectedIndex,
            onTap: widget.onImageSelect,
            pathResolver: (image) => image.thumbnailPath,
            keyResolver: (image) => image.id,
          ),
        ),
      ],
    );
  }

  @override
  void didUpdateWidget(ViewModeImagePreview oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (widget.images != oldWidget.images) {
      _fileExistsCache.clear();
      _verifyImageFiles();
    }
  }

  @override
  void initState() {
    super.initState();
    _verifyImageFiles();
  }

  // Check if a file exists, using the cache when possible
  Future<bool> _checkFileExists(String path) async {
    if (_fileExistsCache.containsKey(path)) {
      return _fileExistsCache[path] ?? false;
    }

    try {
      final exists = await File(path).exists();
      _fileExistsCache[path] = exists;
      return exists;
    } catch (e) {
      _fileExistsCache[path] = false;
      return false;
    }
  }

  // Verify that image files exist and log any issues
  Future<void> _verifyImageFiles() async {
    for (final image in widget.images) {
      try {
        final file = File(image.path);
        final exists = await file.exists();
        _fileExistsCache[image.path] = exists;

        if (!exists) {
          AppLogger.warning(
            'Image file not found',
            tag: 'ViewModeImagePreview',
            data: {
              'path': image.path,
              'imageId': image.id,
              'workId': image.workId
            },
          );
        }
      } catch (e, stack) {
        AppLogger.error(
          'Error checking image file',
          tag: 'ViewModeImagePreview',
          error: e,
          stackTrace: stack,
          data: {'path': image.path},
        );
        _fileExistsCache[image.path] = false;
      }
    }
  }
}



=======================================
./lib/presentation/pages/works/components/work_browse_toolbar.dart
=======================================
import 'package:flutter/material.dart';

import '../../../../theme/app_sizes.dart';
import '../../../viewmodels/states/work_browse_state.dart';

class WorkBrowseToolbar extends StatefulWidget {
  // 改为 StatefulWidget
  final ViewMode viewMode;
  final ValueChanged<ViewMode> onViewModeChanged;
  final VoidCallback onImport;
  final ValueChanged<String> onSearch;
  final bool batchMode;
  final ValueChanged<bool> onBatchModeChanged;
  final int selectedCount;
  final VoidCallback onDeleteSelected;

  const WorkBrowseToolbar({
    super.key,
    required this.viewMode,
    required this.onViewModeChanged,
    required this.onImport,
    required this.onSearch,
    required this.batchMode,
    required this.onBatchModeChanged,
    required this.selectedCount,
    required this.onDeleteSelected,
  });

  @override
  State<WorkBrowseToolbar> createState() => _WorkBrowseToolbarState();
}

class _WorkBrowseToolbarState extends State<WorkBrowseToolbar> {
  late final TextEditingController _searchController;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Container(
      height: kToolbarHeight,
      padding: const EdgeInsets.symmetric(horizontal: AppSizes.m),
      decoration: BoxDecoration(
        color: theme.colorScheme.surface,
        border: Border(
          bottom: BorderSide(
            color: theme.colorScheme.outlineVariant.withOpacity(0.5),
          ),
        ),
      ),
      child: Row(
        children: [
          // 左侧按钮组
          FilledButton.icon(
            icon: const Icon(Icons.add),
            label: const Text('导入作品'),
            onPressed: widget.onImport,
          ),
          const SizedBox(width: AppSizes.s),
          OutlinedButton.icon(
            icon: Icon(widget.batchMode ? Icons.close : Icons.checklist),
            label: Text(widget.batchMode ? '完成' : '批量处理'),
            onPressed: () => widget.onBatchModeChanged(!widget.batchMode),
          ),

          // 批量操作状态 - 移到中间
          if (widget.batchMode) ...[
            const SizedBox(width: AppSizes.m),
            Text(
              '已选择 ${widget.selectedCount} 项',
              style: theme.textTheme.bodyMedium,
            ),
            if (widget.selectedCount > 0)
              Padding(
                padding: const EdgeInsets.only(left: AppSizes.s),
                child: FilledButton.tonalIcon(
                  icon: const Icon(Icons.delete),
                  label: Text('删除${widget.selectedCount}项'),
                  onPressed: widget.onDeleteSelected,
                ),
              ),
          ],

          const Spacer(),

          // 右侧控制组
          SizedBox(
            width: 240,
            child: TextField(
              controller: _searchController, // 使用控制器
              onChanged: widget.onSearch,
              decoration: InputDecoration(
                hintText: '搜索作品...',
                prefixIcon: Icon(
                  Icons.search,
                  size: 20,
                  color: theme.colorScheme.outline,
                ),
                suffixIcon: ValueListenableBuilder<TextEditingValue>(
                  valueListenable: _searchController, // 监听控制器
                  builder: (context, value, child) {
                    return AnimatedOpacity(
                      opacity: value.text.isNotEmpty ? 1.0 : 0.0,
                      duration: const Duration(milliseconds: 200),
                      child: IconButton(
                        icon: Icon(
                          Icons.clear,
                          size: 16,
                          color: theme.colorScheme.outline,
                        ),
                        onPressed: () {
                          _searchController.clear(); // 清除文本
                          widget.onSearch(''); // 触发搜索
                        },
                      ),
                    );
                  },
                ),
                isDense: true,
                filled: true,
                fillColor:
                    theme.colorScheme.surfaceContainerHighest.withOpacity(0.3),
                contentPadding: const EdgeInsets.symmetric(
                  horizontal: AppSizes.s,
                  vertical: AppSizes.xs,
                ),
                border: OutlineInputBorder(
                  borderRadius: BorderRadius.circular(AppSizes.m),
                  borderSide: BorderSide.none,
                ),
                focusedBorder: OutlineInputBorder(
                  borderRadius: BorderRadius.circular(AppSizes.m),
                  borderSide: BorderSide(
                    color: theme.colorScheme.primary,
                    width: 1.5,
                  ),
                ),
                hoverColor:
                    theme.colorScheme.surfaceContainerHighest.withOpacity(0.5),
              ),
            ),
          ),
          const SizedBox(width: AppSizes.m),

          // 视图切换按钮
          IconButton(
            icon: Icon(
              widget.viewMode == ViewMode.grid
                  ? Icons.view_list
                  : Icons.grid_view,
              color: theme.colorScheme.primary,
            ),
            style: IconButton.styleFrom(
              shape: RoundedRectangleBorder(
                borderRadius: BorderRadius.circular(AppSizes.s),
              ),
            ),
            onPressed: () => widget.onViewModeChanged(
                widget.viewMode == ViewMode.grid
                    ? ViewMode.list
                    : ViewMode.grid),
            tooltip: widget.viewMode == ViewMode.grid ? '列表视图' : '网格视图',
          ),
        ],
      ),
    );
  }

  @override
  void dispose() {
    _searchController.dispose();
    super.dispose();
  }

  @override
  void initState() {
    super.initState();
    _searchController = TextEditingController();
  }

  void _showDeleteConfirmation(BuildContext context) async {
    final confirmed = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('确认删除'),
        content: Text('确定要删除选中的 ${widget.selectedCount} 个作品吗？此操作不可恢复。'),
        actions: [
          TextButton(
            child: const Text('取消'),
            onPressed: () => Navigator.pop(context, false),
          ),
          FilledButton(
            child: const Text('删除'),
            onPressed: () => Navigator.pop(context, true),
          ),
        ],
      ),
    );

    if (confirmed == true) {
      widget.onDeleteSelected();
    }
  }
}



=======================================
./lib/presentation/pages/works/components/work_card.dart
=======================================
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../application/providers/service_providers.dart';
import '../../../../domain/models/work/work_entity.dart';
import '../../../../theme/app_colors.dart';
import '../../../../theme/app_sizes.dart';
import '../../../../theme/app_text_styles.dart';
import '../../../widgets/image/cached_image.dart';
import '../../../widgets/skeleton_loader.dart';
import '../../../widgets/tag_list.dart';

class WorkCard extends ConsumerWidget {
  final WorkEntity work;
  final void Function()? onTap;
  final bool selected;
  final double? width;
  final double? height;

  const WorkCard({
    super.key,
    required this.work,
    this.onTap,
    this.selected = false,
    this.width,
    this.height,
  });

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final storageService = ref.watch(workStorageProvider);

    return FutureBuilder<String>(
      future: Future.value(storageService.getWorkCoverThumbnailPath(work.id)),
      builder: (context, snapshot) {
        if (!snapshot.hasData) {
          return SkeletonLoader(
            width: width ?? 200,
            height: height ?? 280,
          );
        }

        final coverPath = snapshot.data!;

        return Card(
          clipBehavior: Clip.antiAlias,
          color: selected ? AppColors.selectedCard : null,
          child: InkWell(
            onTap: onTap,
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.stretch,
              children: [
                // 缩略图
                Expanded(
                  child: CachedImage(
                    path: coverPath,
                    width: width,
                    height: height,
                    cacheKey:
                        '${work.id}_${work.updateTime.millisecondsSinceEpoch}',
                    fit: BoxFit.cover,
                  ),
                ),
                // 标题和标签
                Padding(
                  padding: const EdgeInsets.all(AppSizes.p8),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                        work.title,
                        style: AppTextStyles.bodyMedium,
                        maxLines: 1,
                        overflow: TextOverflow.ellipsis,
                      ),
                      const SizedBox(height: AppSizes.p4),
                      if (work.tags.isNotEmpty)
                        TagList(
                          tags: work.tags,
                          maxLines: 1,
                        ),
                    ],
                  ),
                ),
              ],
            ),
          ),
        );
      },
    );
  }
}



=======================================
./lib/presentation/pages/works/components/work_grid.dart
=======================================
import 'package:demo/domain/models/work/work_entity.dart';
import 'package:flutter/material.dart';

import '../../../widgets/common/grid_placeholder.dart';
import 'work_card.dart';

class WorkGrid extends StatelessWidget {
  final List<WorkEntity> works;
  final Function(WorkEntity) onWorkTap;
  final bool isLoading;

  const WorkGrid({
    super.key,
    required this.works,
    required this.onWorkTap,
    this.isLoading = false,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return LayoutBuilder(
      builder: (context, constraints) {
        // Calculate optimal grid dimensions
        final double width = constraints.maxWidth;
        final int crossAxisCount = _calculateCrossAxisCount(width);
        final double itemWidth = width / crossAxisCount;
        final double itemHeight = itemWidth * 1.4; // 10:14 aspect ratio

        // Apply padding for smaller screens
        final double padding = width < 600 ? 8.0 : 16.0;

        return GridView.builder(
          padding: EdgeInsets.all(padding),
          gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(
            crossAxisCount: crossAxisCount,
            childAspectRatio: itemWidth / itemHeight,
            crossAxisSpacing: padding,
            mainAxisSpacing: padding,
          ),
          itemCount: works.length,
          cacheExtent: 500, // Increase cache to reduce rebuilds when scrolling
          itemBuilder: (context, index) {
            // Use indexed key to ensure proper recycling
            return WorkCard(
              key: ValueKey('work-${works[index].id}'),
              work: works[index],
              onTap: () => onWorkTap(works[index]),
            );
          },
        );
      },
    );
  }

  // Calculate optimal number of columns based on screen width
  int _calculateCrossAxisCount(double width) {
    if (width > 1200) return 6;
    if (width > 900) return 5;
    if (width > 600) return 4;
    if (width > 400) return 3;
    return 2;
  }
}

// A placeholder grid to show while loading
class WorkGridPlaceholder extends StatelessWidget {
  final int itemCount;

  const WorkGridPlaceholder({
    super.key,
    this.itemCount = 12,
  });

  @override
  Widget build(BuildContext context) {
    return LayoutBuilder(
      builder: (context, constraints) {
        final double width = constraints.maxWidth;
        final int crossAxisCount = _calculateCrossAxisCount(width);
        final double itemWidth = width / crossAxisCount;
        final double itemHeight = itemWidth * 1.4;
        final double padding = width < 600 ? 8.0 : 16.0;

        return GridView.builder(
          padding: EdgeInsets.all(padding),
          physics: const NeverScrollableScrollPhysics(),
          gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(
            crossAxisCount: crossAxisCount,
            childAspectRatio: itemWidth / itemHeight,
            crossAxisSpacing: padding,
            mainAxisSpacing: padding,
          ),
          itemCount: itemCount,
          itemBuilder: (context, index) {
            return const GridPlaceholder();
          },
        );
      },
    );
  }

  int _calculateCrossAxisCount(double width) {
    if (width > 1200) return 6;
    if (width > 900) return 5;
    if (width > 600) return 4;
    if (width > 400) return 3;
    return 2;
  }
}



=======================================
./lib/presentation/pages/works/components/work_images_management_view.dart
=======================================
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../domain/models/work/work_entity.dart';
import '../../../../infrastructure/logging/logger.dart';
import '../../../providers/work_detail_provider.dart';
import '../../../providers/work_image_editor_provider.dart';
import '../../../widgets/works/enhanced_work_preview.dart';
import 'image_operations_toolbar.dart';

/// 作品图片管理视图
class WorkImagesManagementView extends ConsumerWidget {
  final WorkEntity work;

  const WorkImagesManagementView({
    super.key,
    required this.work,
  });

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final state = ref.watch(workImageEditorProvider);
    final notifier = ref.read(workImageEditorProvider.notifier);
    final isProcessing = state.isProcessing;
    final currentIndex = ref.watch(currentWorkImageIndexProvider);
    final isInitialized = ref.watch(workImageInitializedProvider);

    // Add debugging to understand what state we're getting
    AppLogger.debug(
      'Building WorkImagesManagementView',
      tag: 'WorkImagesManagementView',
      data: {
        'imageCount': state.images.length,
        'selectedIndex': currentIndex,
        'isProcessing': isProcessing,
        'hasError': state.error != null,
        'workImagesCount': work.images.length,
        'isInitialized': isInitialized,
        'stateMatch': state.images.length == work.images.length,
        'deletedImageCount': state.deletedImageIds.length,
      },
    );

    // Detect inconsistent state with improved logic that accounts for deleted images
    final hasInconsistentState =
        _detectInconsistentState(state, work, isInitialized);

    if (hasInconsistentState) {
      AppLogger.warning(
        'Inconsistent state detected in WorkImagesManagementView',
        tag: 'WorkImagesManagementView',
        data: {
          'workId': work.id,
          'workImagesCount': work.images.length,
          'editorImagesCount': state.images.length,
          'isInitialized': isInitialized,
        },
      );

      // Force reinitialization to recover from inconsistent state
      WidgetsBinding.instance.addPostFrameCallback((_) {
        if (ref.exists(workImageEditorProvider)) {
          ref.read(workImageInitializedProvider.notifier).state = false;
          notifier.reset(); // Clear state first
          notifier.initialize(work.images);

          // After initialization, set the selected index
          final selectedIndex = ref.read(workDetailProvider).selectedImageIndex;
          notifier.updateSelectedIndex(selectedIndex);
        }
      });

      return const Center(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            CircularProgressIndicator(),
            SizedBox(height: 16),
            Text('正在恢复图片数据...'),
          ],
        ),
      );
    }

    // Check for normal initialization status
    if (!isInitialized && work.images.isNotEmpty) {
      AppLogger.debug(
        'Editor not initialized yet, initializing with work images',
        tag: 'WorkImagesManagementView',
        data: {
          'workId': work.id,
          'workImagesCount': work.images.length,
        },
      );

      // Try initializing the editor
      WidgetsBinding.instance.addPostFrameCallback((_) {
        if (ref.exists(workImageEditorProvider)) {
          notifier.initialize(work.images);

          // After initialization, set the selected index
          final selectedIndex = ref.read(workDetailProvider).selectedImageIndex;
          notifier.updateSelectedIndex(selectedIndex);
        }
      });

      return const Center(
        child: CircularProgressIndicator(),
      );
    }

    // If images are empty but should exist, provide a loading state
    // but don't try to reinitialize here - that's handled by the provider
    if (state.images.isEmpty && work.images.isNotEmpty) {
      AppLogger.warning(
        'Editor has no images but work does',
        tag: 'WorkImagesManagementView',
        data: {
          'workId': work.id,
          'workImageCount': work.images.length,
        },
      );

      return const Center(
        child: CircularProgressIndicator(),
      );
    }

    return LayoutBuilder(
      builder: (context, constraints) {
        final isSmallWidth = constraints.maxWidth < 500;

        return Stack(
          children: [
            // Enhanced Work Preview
            EnhancedWorkPreview(
              images: state.images,
              selectedIndex: currentIndex,
              isEditing: true,
              showToolbar: true,
              toolbarActions: [
                // 使用原有的工具栏操作，但根据屏幕尺寸进行调整
                isSmallWidth
                    ? _buildCompactToolbar(context, ref, state, notifier)
                    : ImageOperationsToolbar(
                        onAddImages:
                            isProcessing ? null : () => notifier.addImages(),
                        onDeleteImage: (isProcessing || state.images.isEmpty)
                            ? null
                            : () => _handleDeleteSelected(context, ref),
                        onSortImages: (isProcessing || state.images.isEmpty)
                            ? null
                            : () => notifier.sortImages(),
                      ),
              ],
              onIndexChanged: isProcessing
                  ? null
                  : (index) => _handleIndexChanged(ref, index),
              onImagesReordered: isProcessing
                  ? null
                  : (oldIndex, newIndex) =>
                      _handleReorder(ref, oldIndex, newIndex),
            ),

            // Error message display
            if (state.error != null)
              Positioned(
                bottom: 0,
                left: 0,
                right: 0,
                child: Material(
                  color: Theme.of(context).colorScheme.errorContainer,
                  child: Padding(
                    padding: const EdgeInsets.all(8.0),
                    child: Text(
                      state.error!,
                      style: TextStyle(
                        color: Theme.of(context).colorScheme.onErrorContainer,
                      ),
                      textAlign: TextAlign.center,
                    ),
                  ),
                ),
              ),

            // Processing overlay
            if (isProcessing)
              Positioned.fill(
                child: Container(
                  color: Colors.black.withOpacity(0.3),
                  child: const Center(
                    child: CircularProgressIndicator(),
                  ),
                ),
              ),
          ],
        );
      },
    );
  }

  // 构建小屏幕下的紧凑工具栏
  Widget _buildCompactToolbar(BuildContext context, WidgetRef ref,
      WorkImageEditorState state, dynamic notifier) {
    final theme = Theme.of(context);
    final isProcessing = state.isProcessing;

    return Row(
      children: [
        // 添加图片按钮 - simplified to a single button
        IconButton.filled(
          onPressed: isProcessing ? null : () => notifier.addImages(),
          icon: const Icon(Icons.add_photo_alternate),
          tooltip: '添加图片 (可按住Ctrl多选)',
        ),
        const SizedBox(width: 8),

        // 删除图片按钮
        IconButton.outlined(
          onPressed: (isProcessing || state.images.isEmpty)
              ? null
              : () => _handleDeleteSelected(context, ref),
          icon: const Icon(Icons.delete_outline),
          tooltip: '删除图片',
          style: IconButton.styleFrom(
            foregroundColor: theme.colorScheme.error,
            side: BorderSide(
              color: theme.colorScheme.error.withOpacity(
                (isProcessing || state.images.isEmpty) ? 0.38 : 1.0,
              ),
            ),
          ),
        ),
        const SizedBox(width: 8),

        // 排序图片按钮
        IconButton.outlined(
          onPressed: (isProcessing || state.images.isEmpty)
              ? null
              : () => notifier.sortImages(),
          icon: const Icon(Icons.sort),
          tooltip: '排序',
        ),
      ],
    );
  }

  /// Helper method to detect inconsistent state with better logic
  bool _detectInconsistentState(
      WorkImageEditorState state, WorkEntity work, bool isInitialized) {
    // If we're not initialized, can't be inconsistent yet
    if (!isInitialized) return false;

    // If we have no images in state but should have some, that's inconsistent
    if (state.images.isEmpty && work.images.isNotEmpty) return true;

    // When adding images, we expect editor to have more images than work entity
    // This is normal during editing and shouldn't trigger a reset
    if (state.images.length > work.images.length) {
      AppLogger.debug(
        'Editor has more images than work - this is expected during editing',
        tag: 'WorkImagesManagementView',
        data: {
          'editorImagesCount': state.images.length,
          'workImagesCount': work.images.length,
          'difference': state.images.length - work.images.length,
        },
      );
      return false; // Not inconsistent, just new images being added
    }

    // If there are deleted images, account for them in the comparison
    final expectedCount = work.images.length - state.deletedImageIds.length;

    // Calculate if we have a legitimate inconsistency
    // Only flag as inconsistent if the current count is less than expected
    // after accounting for deletions - missing images is a real inconsistency
    final countMismatch = state.images.length < expectedCount;

    // Log the decision factors for debugging
    if (countMismatch) {
      AppLogger.debug(
        'Image count mismatch after deletion checks',
        tag: 'WorkImagesManagementView',
        data: {
          'stateImagesCount': state.images.length,
          'workImagesCount': work.images.length,
          'deletedCount': state.deletedImageIds.length,
          'expectedCount': expectedCount,
        },
      );
    }

    return countMismatch;
  }

  /// 处理删除选中图片
  Future<void> _handleDeleteSelected(
      BuildContext context, WidgetRef ref) async {
    try {
      final state = ref.read(workImageEditorProvider);
      if (state.images.isEmpty) {
        AppLogger.warning('Attempted to delete image but no images exist',
            tag: 'WorkImagesManagementView');
        return;
      }

      final notifier = ref.read(workImageEditorProvider.notifier);
      final currentIndex = ref.read(currentWorkImageIndexProvider);

      // Ensure index is valid
      if (currentIndex < 0 || currentIndex >= state.images.length) {
        AppLogger.error('Invalid selected index for deletion',
            tag: 'WorkImagesManagementView',
            data: {
              'currentIndex': currentIndex,
              'imageCount': state.images.length
            });
        return;
      }

      final selectedImage = state.images[currentIndex];

      AppLogger.debug('Preparing to delete image',
          tag: 'WorkImagesManagementView',
          data: {'imageId': selectedImage.id, 'index': currentIndex});

      // 确认删除
      final shouldDelete = await showDialog<bool>(
        context: context,
        barrierDismissible: false, // Prevent dismiss by tapping outside
        builder: (context) => AlertDialog(
          title: const Text('确认删除'),
          content: const Text('确定要删除当前选中的图片吗？'),
          actions: [
            TextButton(
              onPressed: () => Navigator.of(context).pop(false),
              child: const Text('取消'),
            ),
            FilledButton(
              onPressed: () => Navigator.of(context).pop(true),
              style: FilledButton.styleFrom(
                backgroundColor: Theme.of(context).colorScheme.error,
                foregroundColor: Theme.of(context).colorScheme.onError,
              ),
              child: const Text('删除'),
            ),
          ],
        ),
      );

      AppLogger.debug('Delete confirmation result',
          tag: 'WorkImagesManagementView', data: {'confirmed': shouldDelete});

      if (shouldDelete == true) {
        // Immediately update UI to show processing state
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('正在删除图片...'),
            duration: Duration(seconds: 1),
          ),
        );

        await notifier.deleteImage(selectedImage.id);

        // 如果删除后没有图片了，标记作品详情发生了变化
        if (ref.read(workImageEditorProvider).images.isEmpty) {
          ref.read(workDetailProvider.notifier).markAsChanged();
        }
      }
    } catch (e, stack) {
      AppLogger.error('Error in delete operation',
          tag: 'WorkImagesManagementView', error: e, stackTrace: stack);

      if (context.mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('删除图片失败: ${e.toString()}'),
            backgroundColor: Theme.of(context).colorScheme.error,
          ),
        );
      }
    }
  }

  /// 处理图片索引变化
  void _handleIndexChanged(WidgetRef ref, int index) {
    ref.read(currentWorkImageIndexProvider.notifier).state = index;
  }

  /// 处理图片重新排序
  void _handleReorder(WidgetRef ref, int oldIndex, int newIndex) {
    ref
        .read(workImageEditorProvider.notifier)
        .reorderImages(oldIndex, newIndex);
    // 更新详情页状态，标记为已更改
    ref.read(workDetailProvider.notifier).markAsChanged();
  }
}



=======================================
./lib/presentation/pages/works/components/work_tabs.dart
=======================================
import 'package:flutter/material.dart';

/// 作品详情页的标签页组件
class WorkTabs extends StatelessWidget {
  /// 当前选中的标签页索引
  final int selectedIndex;

  /// 标签页切换回调
  final Function(int) onTabSelected;

  const WorkTabs({
    super.key,
    required this.selectedIndex,
    required this.onTabSelected,
  });

  @override
  Widget build(BuildContext context) {
    return DefaultTabController(
      length: 3,
      initialIndex: selectedIndex,
      child: TabBar(
        onTap: onTabSelected,
        tabs: const [
          Tab(text: '基本信息'),
          Tab(text: '标签管理'), // 原为"图片管理"
          Tab(text: '集字信息'), // 原为"字形标注"
        ],
      ),
    );
  }

  /// 构建单个标签页按钮
  Widget _buildTab(
      BuildContext context, int index, String label, IconData icon) {
    final theme = Theme.of(context);
    final isSelected = selectedIndex == index;

    return InkWell(
      onTap: () => onTabSelected(index),
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
        decoration: BoxDecoration(
          border: Border(
            bottom: BorderSide(
              color:
                  isSelected ? theme.colorScheme.primary : Colors.transparent,
              width: 2.0,
            ),
          ),
        ),
        child: Row(
          children: [
            Icon(
              icon,
              size: 18,
              color: isSelected
                  ? theme.colorScheme.primary
                  : theme.colorScheme.onSurface.withOpacity(0.7),
            ),
            const SizedBox(width: 8),
            Text(
              label,
              style: theme.textTheme.bodyMedium?.copyWith(
                color: isSelected
                    ? theme.colorScheme.primary
                    : theme.colorScheme.onSurface.withOpacity(0.7),
                fontWeight: isSelected ? FontWeight.bold : FontWeight.normal,
              ),
            ),
          ],
        ),
      ),
    );
  }
}



=======================================
./lib/presentation/pages/works/components/work_toolbar.dart
=======================================
import 'package:demo/domain/models/work/work_entity.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../infrastructure/logging/logger.dart';
import '../../../widgets/dialogs/confirmation_dialog.dart';

class WorkToolbar extends ConsumerWidget {
  final WorkEntity work;

  const WorkToolbar({
    super.key,
    required this.work,
  });

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return Row(
      children: [
        // 导出按钮
        IconButton(
          icon: const Icon(Icons.download),
          tooltip: '导出作品',
          onPressed: () => _exportWork(context),
        ),

        // 编辑按钮
        IconButton(
          icon: const Icon(Icons.edit),
          tooltip: '编辑作品',
          onPressed: () => _editWork(context),
        ),

        // 其他操作按钮
        PopupMenuButton<String>(
          icon: const Icon(Icons.more_vert),
          tooltip: '更多操作',
          onSelected: (value) => _handleMenuSelection(context, value),
          itemBuilder: (BuildContext context) => [
            const PopupMenuItem<String>(
              value: 'extract',
              child: Row(
                children: [
                  Icon(Icons.text_format, size: 20),
                  SizedBox(width: 8),
                  Text('提取字形'),
                ],
              ),
            ),
            const PopupMenuItem<String>(
              value: 'share',
              child: Row(
                children: [
                  Icon(Icons.share, size: 20),
                  SizedBox(width: 8),
                  Text('分享作品'),
                ],
              ),
            ),
            const PopupMenuItem<String>(
              value: 'delete',
              child: Row(
                children: [
                  Icon(Icons.delete, color: Colors.red, size: 20),
                  SizedBox(width: 8),
                  Text('删除作品', style: TextStyle(color: Colors.red)),
                ],
              ),
            ),
          ],
        ),
      ],
    );
  }

  Future<void> _confirmDelete(BuildContext context) async {
    final confirmed = await showDialog<bool>(
      context: context,
      builder: (context) => ConfirmationDialog(
        title: '删除作品',
        message: '确定要删除作品《${work.title}》吗？此操作不可撤销。',
        confirmText: '删除',
        cancelText: '取消',
        isDestructive: true,
      ),
    );

    if (confirmed == true) {
      // 执行删除操作
      try {
        await _deleteWork(context);
      } catch (e) {
        AppLogger.error('删除作品失败',
            tag: 'WorkToolbar', error: e, data: {'workId': work.id});

        if (context.mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(content: Text('删除作品失败: ${e.toString()}')),
          );
        }
      }
    }
  }

  Future<void> _deleteWork(BuildContext context) async {
    // 这里应该调用实际的删除逻辑
    // await ref.read(workServiceProvider).deleteWork(work.id!);

    ScaffoldMessenger.of(context).showSnackBar(
      const SnackBar(content: Text('删除功能尚未实现')),
    );
  }

  Future<void> _editWork(BuildContext context) async {
    try {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('编辑功能尚未实现')),
      );
    } catch (e) {
      AppLogger.error('编辑作品失败',
          tag: 'WorkToolbar', error: e, data: {'workId': work.id});
    }
  }

  Future<void> _exportWork(BuildContext context) async {
    try {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('导出功能尚未实现')),
      );
    } catch (e) {
      AppLogger.error('导出作品失败',
          tag: 'WorkToolbar', error: e, data: {'workId': work.id});
    }
  }

  Future<void> _extractCharacters(BuildContext context) async {
    ScaffoldMessenger.of(context).showSnackBar(
      const SnackBar(content: Text('提取字形功能尚未实现')),
    );
  }

  Future<void> _handleMenuSelection(BuildContext context, String value) async {
    switch (value) {
      case 'extract':
        _extractCharacters(context);
        break;
      case 'share':
        _shareWork(context);
        break;
      case 'delete':
        _confirmDelete(context);
        break;
    }
  }

  Future<void> _shareWork(BuildContext context) async {
    ScaffoldMessenger.of(context).showSnackBar(
      const SnackBar(content: Text('分享功能尚未实现')),
    );
  }
}



=======================================
./lib/presentation/pages/works/work_browse_page.dart
=======================================
import 'dart:async';

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../infrastructure/logging/logger.dart';
import '../../../routes/app_routes.dart';
import '../../dialogs/work_import/work_import_dialog.dart';
import '../../providers/work_browse_provider.dart';
import '../../providers/works_providers.dart';
import '../../viewmodels/states/work_browse_state.dart';
import '../../widgets/common/sidebar_toggle.dart';
import 'components/content/work_grid_view.dart';
import 'components/content/work_list_view.dart';
import 'components/filter/work_filter_panel.dart';
import 'components/work_browse_toolbar.dart';
// 添加这个导入

class WorkBrowsePage extends ConsumerStatefulWidget {
  const WorkBrowsePage({super.key});

  @override
  ConsumerState<WorkBrowsePage> createState() => _WorkBrowsePageState();
}

class _WorkBrowsePageState extends ConsumerState<WorkBrowsePage>
    with WidgetsBindingObserver {
  @override
  Widget build(BuildContext context) {
    final state = ref.watch(workBrowseProvider);
    final viewModel = ref.read(workBrowseProvider.notifier);
    debugPrint('WorkBrowsePage rebuild - filter: ${state.filter}');

    // 改进刷新监听器
    ref.listen(worksNeedsRefreshProvider, (previous, current) async {
      if (current == null) return;

      try {
        AppLogger.debug(
          '收到刷新请求',
          tag: 'WorkBrowsePage',
          data: {
            'reason': current.reason,
            'priority': current.priority,
            'force': current.force,
          },
        );

        await viewModel.loadWorks(forceRefresh: current.force);
      } catch (e) {
        AppLogger.error('刷新失败', tag: 'WorkBrowsePage', error: e);
      } finally {
        // 刷新完成后重置状态
        if (mounted) {
          ref.read(worksNeedsRefreshProvider.notifier).state = null;
        }
      }
    });

    return Scaffold(
      body: Column(
        children: [
          WorkBrowseToolbar(
              viewMode: state.viewMode,
              onViewModeChanged: (mode) => viewModel.setViewMode(mode),
              onImport: () => _showImportDialog(context),
              onSearch: viewModel.setSearchQuery,
              batchMode: state.batchMode,
              onBatchModeChanged: (_) => viewModel.toggleBatchMode(),
              selectedCount: state.selectedWorks.length,
              onDeleteSelected: () => {
                    ref.read(workBrowseProvider.notifier).deleteSelected(),
                    ref.read(worksNeedsRefreshProvider.notifier).state =
                        RefreshInfo.importCompleted()
                  }),
          Expanded(
            child: Row(
              children: [
                Expanded(
                  child: _buildMainContent(),
                ),
                SidebarToggle(
                  isOpen: state.isSidebarOpen,
                  onToggle: () => viewModel.toggleSidebar(),
                ),
                if (state.isSidebarOpen)
                  SizedBox(
                    width: 300,
                    child: WorkFilterPanel(
                      filter: state.filter,
                      onFilterChanged: viewModel.updateFilter,
                    ),
                  ),
              ],
            ),
          ),
        ],
      ),
      floatingActionButton: state.isLoading && state.works.isEmpty
          ? FloatingActionButton(
              onPressed: () {
                _loadWorks(force: true);
              },
              tooltip: '重新加载',
              child: const Icon(Icons.refresh),
            )
          : null,
    );
  }

  @override
  void didChangeAppLifecycleState(AppLifecycleState state) {
    // 简化生命周期管理，只在应用恢复时刷新
    if (state == AppLifecycleState.resumed) {
      try {
        // 应用恢复时触发刷新标志，而非直接调用
        ref.read(worksNeedsRefreshProvider.notifier).state =
            RefreshInfo.appResume(); // 使用工厂方法替代直接构造
      } catch (e) {
        // 添加错误处理，防止意外异常
        AppLogger.error('设置刷新标志失败', tag: 'WorkBrowsePage', error: e);
      }
    }
  }

  @override
  void dispose() {
    WidgetsBinding.instance.removeObserver(this);
    super.dispose();
  }

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addObserver(this);

    // 延迟执行初始加载，确保widget完全初始化
    Future.microtask(() {
      if (!mounted) return;
      ref.read(worksNeedsRefreshProvider.notifier).state = const RefreshInfo(
        reason: '应用启动初始化',
        force: true,
        priority: 10,
      );
    });
  }

  Widget _buildMainContent() {
    // 在这里监听状态变化
    final state = ref.watch(workBrowseProvider);
    debugPrint(
        '_buildMainContent rebuild - works count: ${state.works.length}');

    // 添加详细日志，追踪状态变化
    AppLogger.debug('构建浏览页主体内容', tag: 'WorkBrowsePage', data: {
      'isLoading': state.isLoading,
      'hasError': state.error != null,
      'worksCount': state.works.length
    });

    // 处理错误状态
    if (state.error != null) {
      return Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(Icons.error_outline,
                size: 48, color: Theme.of(context).colorScheme.error),
            const SizedBox(height: 16),
            Text('发生错误: ${state.error}',
                style: TextStyle(color: Theme.of(context).colorScheme.error)),
            const SizedBox(height: 24),
            ElevatedButton(
              onPressed: () => _loadWorks(force: true),
              child: const Text('重新加载'),
            ),
          ],
        ),
      );
    }

    return Column(
      children: [
        Expanded(
          child: state.isLoading
              ? const Center(child: CircularProgressIndicator())
              : state.works.isEmpty
                  ? Center(
                      child: Column(
                        mainAxisAlignment: MainAxisAlignment.center,
                        children: [
                          const Icon(Icons.inbox, size: 64, color: Colors.grey),
                          const SizedBox(height: 16),
                          const Text('没有找到作品', style: TextStyle(fontSize: 18)),
                          const SizedBox(height: 8),
                          const Text('尝试导入新作品或修改筛选条件',
                              style: TextStyle(color: Colors.grey)),
                          const SizedBox(height: 24),
                          ElevatedButton(
                            onPressed: () => _showImportDialog(context),
                            child: const Text('导入作品'),
                          ),
                        ],
                      ),
                    )
                  : state.viewMode == ViewMode.grid
                      ? WorkGridView(
                          works: state.works,
                          batchMode: state.batchMode,
                          selectedWorks: state.selectedWorks,
                          onSelectionChanged: (workId, selected) => ref
                              .read(workBrowseProvider.notifier)
                              .toggleSelection(workId),
                          onItemTap: (workId) =>
                              _handleWorkSelected(context, workId),
                        )
                      : WorkListView(
                          works: state.works,
                          batchMode: state.batchMode,
                          selectedWorks: state.selectedWorks,
                          onSelectionChanged: (workId, selected) => ref
                              .read(workBrowseProvider.notifier)
                              .toggleSelection(workId),
                          onItemTap: (workId) =>
                              _handleWorkSelected(context, workId),
                        ),
        ),
      ],
    );
  }

  void _handleWorkSelected(BuildContext context, String workId) async {
    // 导航到详情页并等待结果
    await Navigator.pushNamed(
      context,
      AppRoutes.workDetail,
      arguments: workId,
    );
  }

  // 增强错误处理的加载方法
  Future<void> _loadWorks({bool force = false}) async {
    try {
      if (!mounted) return;

      AppLogger.debug('出错后用户手动触发作品加载',
          tag: 'WorkBrowsePage', data: {'force': force});

      const refreshInfo = RefreshInfo(
        reason: '出错后用户手动刷新',
        force: true,
        priority: 10, // 高优先级
      );

      if (!mounted) return;
      ref.read(worksNeedsRefreshProvider.notifier).state = refreshInfo;
    } catch (e) {
      AppLogger.error('加载作品失败', tag: 'WorkBrowsePage', error: e);

      if (mounted) {
        final scaffoldMessenger = ScaffoldMessenger.of(context);
        // 先移除所有已有的SnackBar
        scaffoldMessenger.clearSnackBars();
        // 显示新的错误提示
        scaffoldMessenger.showSnackBar(
          SnackBar(content: Text('加载失败: $e')),
        );
      }
    }
  }

  // 简化为一个统一的导入对话框方法
  Future<void> _showImportDialog(BuildContext context) async {
    final result = await showDialog<bool>(
      context: context,
      barrierDismissible: false,
      builder: (context) => const WorkImportDialog(),
    );

    if (result == true) {
      AppLogger.debug('导入完成，准备刷新列表', tag: 'WorkBrowsePage');
      if (!mounted) return;

      ref.read(worksNeedsRefreshProvider.notifier).state = const RefreshInfo(
        reason: '导入完成后刷新',
        force: true,
        priority: 9,
      );
    }
  }
}



=======================================
./lib/presentation/pages/works/work_detail_page.dart
=======================================
import 'dart:async';

import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../application/providers/service_providers.dart';
import '../../../domain/models/work/work_entity.dart';
import '../../../infrastructure/logging/logger.dart';
import '../../../theme/app_sizes.dart';
import '../../providers/work_detail_provider.dart';
import '../../providers/work_image_editor_provider.dart';
import '../../providers/works_providers.dart';
import '../../widgets/common/error_display.dart';
import '../../widgets/common/loading_indicator.dart';
import '../../widgets/common/sidebar_toggle.dart';
import '../../widgets/page_layout.dart';
import './character_collection_page.dart';
import 'components/unified_work_detail_panel.dart';
import 'components/view_mode_image_preview.dart';
import 'components/work_images_management_view.dart';

class WorkDetailPage extends ConsumerStatefulWidget {
  final String workId;

  const WorkDetailPage({
    super.key,
    required this.workId,
  });

  @override
  ConsumerState<WorkDetailPage> createState() => _WorkDetailPageState();
}

class _WorkDetailPageState extends ConsumerState<WorkDetailPage>
    with WidgetsBindingObserver {
  bool _isPanelOpen = true;
  bool _hasCheckedStateRestoration = false;

  @override
  Widget build(BuildContext context) {
    final state = ref.watch(workDetailProvider);

    return WillPopScope(
      onWillPop: () async {
        if (state.isEditing) {
          return _handleBackButton();
        }
        return true;
      },
      child: KeyboardListener(
        focusNode: FocusNode(skipTraversal: true),
        onKeyEvent: (keyEvent) => _handleKeyboardShortcuts(keyEvent, state),
        child: PageLayout(
          toolbar: state.isEditing
              ? _buildEditModeToolbar(context, state)
              : _buildViewModeToolbar(context, state),
          body: _buildBody(context, state),
        ),
      ),
    );
  }

  @override
  Future<bool> didPopRoute() async {
    return _handleBackButton();
  }

  @override
  void dispose() {
    WidgetsBinding.instance.removeObserver(this);
    super.dispose();
  }

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addObserver(this);
    WidgetsBinding.instance.addPostFrameCallback((_) {
      _loadWorkDetails();
    });
  }

  Widget _buildBody(BuildContext context, WorkDetailState state) {
    if (state.isLoading) {
      return const Center(
        child: LoadingIndicator(message: '加载作品详情中...'),
      );
    }

    if (state.error != null) {
      AppLogger.error('Work detail error',
          tag: 'WorkDetailPage', error: state.error);
      return Center(
        child: ErrorDisplay(
          error: state.error!,
          onRetry: _loadWorkDetails,
        ),
      );
    }

    final work = state.isEditing ? state.editingWork : state.work;
    if (work == null) {
      return const Center(
        child: Text('作品不存在或已被删除'),
      );
    }

    return state.isEditing
        ? _buildEditModeContent(context, state, work)
        : _buildViewModeContent(context, work, state);
  }

  Widget _buildEditModeContent(
      BuildContext context, WorkDetailState state, WorkEntity work) {
    return Row(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        // 左侧图片预览和管理
        Expanded(
          flex: 7,
          child: Padding(
            padding: const EdgeInsets.all(AppSizes.spacingMedium),
            child: WorkImagesManagementView(
              work: work,
            ),
          ),
        ),

        // 右侧面板
        SizedBox(
          width: 350,
          child: UnifiedWorkDetailPanel(
            key: ValueKey('form_${work.id}'),
            work: work,
            isEditing: true,
          ),
        ),
      ],
    );
  }

  Widget _buildEditModeToolbar(BuildContext context, WorkDetailState state) {
    final theme = Theme.of(context);

    return Container(
      height: kToolbarHeight,
      padding: const EdgeInsets.symmetric(horizontal: AppSizes.spacingMedium),
      child: Row(
        children: [
          Text(
            '编辑作品',
            style: theme.textTheme.titleMedium?.copyWith(
              fontWeight: FontWeight.w500,
            ),
          ),
          if (state.work?.title != null) ...[
            const SizedBox(width: 8),
            Text(
              '- ${state.work!.title}',
              style: theme.textTheme.titleMedium?.copyWith(
                fontWeight: FontWeight.normal,
                color: theme.colorScheme.onSurface.withOpacity(0.7),
              ),
              overflow: TextOverflow.ellipsis,
            ),
          ],
          const Spacer(),
          FilledButton.icon(
            icon: const Icon(Icons.save),
            label: const Text('保存'),
            onPressed: state.hasChanges && !state.isSaving
                ? () => _saveChanges()
                : null,
          ),
          const SizedBox(width: 8),
          OutlinedButton(
            child: const Text('取消'),
            onPressed: () => _cancelEditing(),
          ),
        ],
      ),
    );
  }

  Widget _buildViewModeContent(
      BuildContext context, WorkEntity work, WorkDetailState state) {
    return Row(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Expanded(
          flex: 7,
          child: ViewModeImagePreview(
            images: work.images,
            selectedIndex: state.selectedImageIndex,
            onImageSelect: (index) =>
                ref.read(workDetailProvider.notifier).selectImage(index),
          ),
        ),
        SidebarToggle(
          isOpen: _isPanelOpen,
          onToggle: () {
            setState(() {
              _isPanelOpen = !_isPanelOpen;
            });
          },
          alignRight: true,
        ),
        if (_isPanelOpen)
          SizedBox(
            width: 350,
            child: UnifiedWorkDetailPanel(
              work: work,
              isEditing: false,
            ),
          ),
      ],
    );
  }

  Widget _buildViewModeToolbar(BuildContext context, WorkDetailState state) {
    final theme = Theme.of(context);
    final work = state.work;

    return Container(
      height: kToolbarHeight,
      padding: const EdgeInsets.symmetric(horizontal: AppSizes.spacingMedium),
      child: Row(
        children: [
          IconButton(
            icon: Icon(Icons.arrow_back, color: theme.colorScheme.onSurface),
            tooltip: '返回',
            onPressed: () => _handleBackButton(),
          ),
          Text(
            '作品详情',
            style: theme.textTheme.titleMedium?.copyWith(
              fontWeight: FontWeight.w500,
            ),
          ),
          if (work != null && work.title.isNotEmpty) ...[
            const SizedBox(width: 8),
            Text(
              '- ${work.title}',
              style: theme.textTheme.titleMedium?.copyWith(
                fontWeight: FontWeight.normal,
                color: theme.colorScheme.onSurface.withOpacity(0.7),
              ),
              overflow: TextOverflow.ellipsis,
            ),
          ],
          const SizedBox(width: AppSizes.spacingMedium),
          FilledButton.icon(
            onPressed: work != null ? _enterEditMode : null,
            icon: const Icon(Icons.edit, size: 18),
            label: const Text('编辑'),
            style: FilledButton.styleFrom(
              visualDensity: VisualDensity.compact,
              padding: const EdgeInsets.symmetric(horizontal: 12),
            ),
          ),
          const SizedBox(width: AppSizes.spacingMedium),
          FilledButton.tonal(
            onPressed: work != null ? () => _navigateToExtract(work.id) : null,
            style: FilledButton.styleFrom(
              visualDensity: VisualDensity.compact,
              padding: const EdgeInsets.symmetric(horizontal: 12),
            ),
            child: const Text('提取字形'),
          ),
        ],
      ),
    );
  }

  void _cancelEditing() {
    final hasChanges = ref.read(workDetailProvider).hasChanges;
    if (hasChanges) {
      showDialog(
        context: context,
        builder: (context) => AlertDialog(
          title: const Text('放弃更改？'),
          content: const Text('你有未保存的更改，确定要放弃吗？'),
          actions: [
            TextButton(
              onPressed: () => Navigator.of(context).pop(),
              child: const Text('取消'),
            ),
            FilledButton(
              onPressed: () {
                Navigator.of(context).pop();
                // Reset the image editor state first
                ref.read(workImageEditorProvider.notifier).reset();
                ref.read(workDetailProvider.notifier).cancelEditing();
              },
              child: const Text('放弃更改'),
            ),
          ],
        ),
      );
    } else {
      // Reset the image editor state first
      ref.read(workImageEditorProvider.notifier).reset();
      ref.read(workDetailProvider.notifier).cancelEditing();
    }
  }

  Future<void> _checkForUnfinishedEditSession() async {
    if (_hasCheckedStateRestoration) return;
    _hasCheckedStateRestoration = true;

    final stateRestorationService = ref.read(stateRestorationServiceProvider);
    final hasUnfinishedSession =
        await stateRestorationService.hasUnfinishedEditSession(widget.workId);

    if (hasUnfinishedSession && mounted) {
      final shouldRestore = await showDialog<bool>(
            context: context,
            barrierDismissible: false,
            builder: (context) => AlertDialog(
              title: const Text('恢复未完成的编辑'),
              content: const Text('检测到上次有未保存的编辑内容。是否恢复?'),
              actions: [
                TextButton(
                  onPressed: () => Navigator.of(context).pop(false),
                  child: const Text('放弃'),
                ),
                FilledButton(
                  onPressed: () => Navigator.of(context).pop(true),
                  child: const Text('恢复'),
                ),
              ],
            ),
          ) ??
          false;

      if (shouldRestore && mounted) {
        await ref
            .read(workDetailProvider.notifier)
            .tryRestoreEditState(widget.workId);

        if (ref.read(workDetailProvider).isEditing) {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(content: Text('已恢复上次的编辑状态')),
          );
        }
      }
    }
  }

  void _enterEditMode() {
    final detailNotifier = ref.read(workDetailProvider.notifier);
    final work = ref.read(workDetailProvider).work;

    if (work != null) {
      // Log the work images to verify they exist
      AppLogger.debug(
        'Entering edit mode with work',
        tag: 'WorkDetailPage',
        data: {
          'workId': work.id,
          'imageCount': work.images.length,
          'firstImageId': work.images.isNotEmpty ? work.images[0].id : 'none',
        },
      );

      // First enter edit mode to ensure the editingWork is set
      detailNotifier.enterEditMode();

      // Ensure image editor state is properly initialized
      if (work.images.isNotEmpty) {
        // Reset the editor provider state
        ref.read(workImageInitializedProvider.notifier).state = false;
        ref.read(workImageEditorProvider.notifier).reset();

        // Initialize with a microtask to ensure it happens after the current frame
        Future.microtask(() {
          // Verify the providers still exist
          if (!ref.exists(workImageEditorProvider)) return;
          if (!context.mounted) return;

          // Initialize the image editor with work images
          final editorNotifier = ref.read(workImageEditorProvider.notifier);
          editorNotifier.initialize(work.images);

          // Set selected index after initialization
          final selectedIndex = ref.read(workDetailProvider).selectedImageIndex;
          editorNotifier.updateSelectedIndex(selectedIndex);
        });
      } else {
        AppLogger.warning(
          'Entering edit mode with no images',
          tag: 'WorkDetailPage',
          data: {'workId': work.id},
        );
      }
    }
  }

  Future<bool> _handleBackButton() async {
    final hasChanges = ref.read(workDetailProvider).hasChanges;
    if (hasChanges) {
      final shouldSave = await showDialog<bool?>(
        context: context,
        builder: (context) => AlertDialog(
          title: const Text('保存更改？'),
          content: const Text('你有未保存的更改，是否保存？'),
          actions: [
            TextButton(
              onPressed: () => Navigator.of(context).pop(false),
              child: const Text('放弃更改'),
            ),
            TextButton(
              onPressed: () => Navigator.of(context).pop(null),
              child: const Text('取消'),
            ),
            FilledButton(
              onPressed: () => Navigator.of(context).pop(true),
              child: const Text('保存'),
            ),
          ],
        ),
      );

      if (shouldSave == null) {
        return false;
      }

      if (shouldSave) {
        try {
          await _saveChanges();
          return true;
        } catch (e) {
          if (mounted) {
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(content: Text('保存失败: $e')),
            );
          }
          return false;
        }
      }

      ref.read(workDetailProvider.notifier).cancelEditing();
    }

    if (mounted) {
      Navigator.of(context).pop();
    }
    return true;
  }

  void _handleKeyboardShortcuts(KeyEvent event, WorkDetailState state) {
    if (state.isEditing) {
      final isCtrlPressed = HardwareKeyboard.instance.isControlPressed ||
          HardwareKeyboard.instance.isMetaPressed;

      if (isCtrlPressed) {
        if (event.logicalKey.keyLabel == 's' ||
            event.logicalKey.keyLabel == 'S') {
          _handleSave(state);
        }
      }
    }
  }

  void _handleSave(WorkDetailState state) {
    if (!state.hasChanges || state.isSaving) return;
    _saveChanges();
  }

  Future<void> _loadWorkDetails() async {
    await ref.read(workDetailProvider.notifier).loadWorkDetails(widget.workId);

    // Verify all work images exist
    final work = ref.read(workDetailProvider).work;
    if (work != null) {
      final storageService = ref.read(workStorageProvider);
      await storageService.verifyWorkImages(widget.workId);
    }

    _checkForUnfinishedEditSession();
  }

  void _navigateToExtract(String workId) {
    final work = ref.read(workDetailProvider).work;
    if (work != null) {
      Navigator.of(context).push(
        MaterialPageRoute(
          builder: (context) => CharacterCollectionPage(
            imageId: workId,
            workTitle: work.title,
            images: work.images
                .where((img) => img.path != null)
                .map((img) => img.path.replaceAll('\\', '/'))
                .toList(),
          ),
        ),
      );
    }
  }

  Future<void> _saveChanges() async {
    final editingWork = ref.read(workDetailProvider).editingWork;
    AppLogger.debug('开始保存作品', tag: 'WorkDetailPage', data: {
      'workId': editingWork?.id,
      'hasImages': editingWork?.images.isNotEmpty ?? false,
      'firstImageId': editingWork?.images.isNotEmpty ?? false
          ? editingWork!.images[0].id
          : 'none',
    });

    if (!context.mounted) return;

    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (context) => WillPopScope(
        onWillPop: () async => false,
        child: const AlertDialog(
          content: Row(
            children: [
              CircularProgressIndicator(),
              SizedBox(width: 16),
              Text('正在保存...'),
            ],
          ),
        ),
      ),
    );

    try {
      // Log the state of the editor before saving
      final editorState = ref.read(workImageEditorProvider);
      AppLogger.debug('作品编辑器状态', tag: 'WorkDetailPage', data: {
        'imagesCount': editorState.images.length,
        'hasPendingAdditions': editorState.hasPendingAdditions,
        'deletedImageCount': editorState.deletedImageIds.length,
      });

      // Save images first - this should handle cover generation internally
      final workImageEditorNotifier =
          ref.read(workImageEditorProvider.notifier);
      await workImageEditorNotifier.saveChanges();

      // 获取保存后的图片列表
      final savedImages = ref.read(workImageEditorProvider).images;

      // 仅在有图片时处理封面
      if (savedImages.isNotEmpty && editingWork != null) {
        final imageService = ref.read(workImageServiceProvider);
        final storageService = ref.read(workStorageProvider);

        // 检查封面是否与当前首图匹配
        final coverPath =
            storageService.getWorkCoverImportedPath(editingWork.id);
        final coverExists =
            await storageService.verifyWorkImageExists(coverPath);

        if (!coverExists) {
          AppLogger.info('保存后封面不存在，重新生成',
              tag: 'WorkDetailPage', data: {'firstImageId': savedImages[0].id});

          await imageService.updateCover(editingWork.id, savedImages[0].id);
        } else {
          AppLogger.debug('保存后封面已存在', tag: 'WorkDetailPage');
        }
      }

      // Then save work details (which includes the updated image order)
      final success = await ref.read(workDetailProvider.notifier).saveChanges();
      if (!context.mounted) return;

      Navigator.of(context, rootNavigator: true).pop();

      if (success) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('保存成功')),
        );

        await Future.delayed(const Duration(milliseconds: 300));
        if (!context.mounted) return;

        // 标记作品列表需要刷新
        ref.read(worksNeedsRefreshProvider.notifier).state =
            RefreshInfo.dataChanged();

        // 重新加载作品详情以获取最新状态
        await _loadWorkDetails();
        ref.read(workDetailProvider.notifier).completeEditing();
      } else {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('保存失败')),
        );
      }
    } catch (e, stack) {
      AppLogger.error(
        '保存出错',
        tag: 'WorkDetailPage',
        error: e,
        stackTrace: stack,
      );

      if (context.mounted) {
        Navigator.of(context).pop();
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('保存出错: $e')),
        );
      }
    }
  }
}



=======================================
./lib/presentation/providers/character_collection_provider.dart
=======================================
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../application/providers/repository_providers.dart';
import '../../domain/models/character/character_filter.dart';
import '../../domain/repositories/character_repository.dart';
import '../viewmodels/states/character_collection_state.dart';

/// 提供CharacterCollectionState状态管理
final characterCollectionProvider = StateNotifierProvider<
    CharacterCollectionNotifier, CharacterCollectionState>(
  (ref) => CharacterCollectionNotifier(
    characterRepository: ref.watch(characterRepositoryProvider),
  ),
);

/// 提供CharacterRepository实例

class CharacterCollectionNotifier
    extends StateNotifier<CharacterCollectionState> {
  final CharacterRepository _characterRepository;

  CharacterCollectionNotifier({
    required CharacterRepository characterRepository,
  })  : _characterRepository = characterRepository,
        super(const CharacterCollectionState());

  Future<void> deleteSelected() async {
    if (state.selectedCharacters.isEmpty) return;

    try {
      state = state.copyWith(isLoading: true, error: null);

      await _characterRepository.deleteMany(
        state.selectedCharacters.toList(),
      );

      state = state.copyWith(
        selectedCharacters: {},
        batchMode: false,
        isLoading: false,
      );

      await loadCharacters(forceRefresh: true);
    } catch (e) {
      state = state.copyWith(
        isLoading: false,
        error: e.toString(),
      );
    }
  }

  Future<void> loadCharacters({bool forceRefresh = false}) async {
    try {
      state = state.copyWith(isLoading: true, error: null);

      final characters = await _characterRepository.query(
        state.filter,
      );

      state = state.copyWith(
        characters: characters,
        isLoading: false,
      );
    } catch (e) {
      state = state.copyWith(
        isLoading: false,
        error: e.toString(),
      );
    }
  }

  Future<void> loadStats() async {}

  void selectCharacter(String? characterId) {
    if (!state.batchMode) {
      state = state.copyWith(selectedCharacterId: characterId);
    }
  }

  void setSearchQuery(String query) {
    final newFilter = state.filter.copyWith(searchQuery: query);
    state = state.copyWith(filter: newFilter);
    loadCharacters();
  }

  void setViewMode(ViewMode mode) {
    state = state.copyWith(viewMode: mode);
  }

  void toggleBatchMode() {
    final newBatchMode = !state.batchMode;
    state = state.copyWith(
      batchMode: newBatchMode,
      // 退出批量模式时清空选择
      selectedCharacters: newBatchMode ? state.selectedCharacters : {},
    );
  }

  void toggleSelection(String characterId) {
    if (!state.batchMode) return;

    final selectedCharacters = Set<String>.from(state.selectedCharacters);
    if (selectedCharacters.contains(characterId)) {
      selectedCharacters.remove(characterId);
    } else {
      selectedCharacters.add(characterId);
    }

    state = state.copyWith(selectedCharacters: selectedCharacters);
  }

  void toggleSidebar() {
    state = state.copyWith(isSidebarOpen: !state.isSidebarOpen);
  }

  void updateFilter(CharacterFilter filter) {
    state = state.copyWith(filter: filter);
    loadCharacters();
  }
}



=======================================
./lib/presentation/providers/character_detail_provider.dart
=======================================
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../application/providers/repository_providers.dart';
import '../../domain/models/character/character_entity.dart';

/// 角色详情提供者
final characterDetailProvider =
    FutureProvider.family<CharacterEntity?, String>((ref, id) async {
  final repository = ref.watch(characterRepositoryProvider);
  return repository.get(id);
});

/// 角色服务提供者
// final characterServiceProvider = Provider<CharacterService>((ref) {
//   return CharacterService(
//     repository: ref.watch(characterRepositoryProvider),
//   );
// });



=======================================
./lib/presentation/providers/error_boundary_provider.dart
=======================================
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

final errorBoundaryProvider = Provider<ErrorBoundary>((ref) {
  return ErrorBoundary();
});

class ErrorBoundary {
  Future<T> runWithBoundary<T>(
    BuildContext context,
    Future<T> Function() operation,
  ) async {
    try {
      return await operation();
    } catch (e) {
      // 错误边界处理
      _showErrorDialog(context, e.toString());
      rethrow;
    }
  }

  void _showErrorDialog(BuildContext context, String message) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('操作失败'),
        content: Text(message),
        actions: [
          TextButton(
            child: const Text('确定'),
            onPressed: () => Navigator.pop(context),
          ),
        ],
      ),
    );
  }
}



=======================================
./lib/presentation/providers/error_handler_provider.dart
=======================================
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

final errorHandlerProvider = Provider<ErrorHandler>((ref) {
  return ErrorHandler();
});

class ErrorHandler {
  String getErrorMessage(Object error) {
    // 添加错误消息转换逻辑
    if (error is Exception) {
      return error.toString().replaceAll('Exception:', '');
    }
    return error.toString();
  }

  void handleError(Object error, StackTrace? stackTrace) {
    // 错误处理逻辑
  }

  Future<void> recoverFromError() async {
    // 错误恢复逻辑
  }

  void showErrorDialog(BuildContext context, String message) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('错误'),
        content: Text(message),
        actions: [
          TextButton(
            child: const Text('确定'),
            onPressed: () => Navigator.of(context).pop(),
          ),
        ],
      ),
    );
  }

  void showErrorSnackBar(BuildContext context, String message) {
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text(message),
        backgroundColor: Theme.of(context).colorScheme.error,
      ),
    );
  }
}



=======================================
./lib/presentation/providers/error_provider.dart
=======================================
import 'package:flutter_riverpod/flutter_riverpod.dart';

final errorProvider = StateNotifierProvider<ErrorNotifier, String?>((ref) {
  return ErrorNotifier();
});

class ErrorNotifier extends StateNotifier<String?> {
  ErrorNotifier() : super(null);

  void setError(String? error) => state = error;
  void clearError() => state = null;

  Future<T> handleError<T>(Future<T> Function() task) async {
    try {
      clearError();
      return await task();
    } catch (e) {
      setError(e.toString());
      rethrow;
    }
  }
}



=======================================
./lib/presentation/providers/loading_provider.dart
=======================================
import 'package:flutter_riverpod/flutter_riverpod.dart';

final loadingProvider = StateProvider<bool>((ref) => false);
final loadingMessageProvider = StateProvider<String?>((ref) => null);

class LoadingNotifier extends StateNotifier<bool> {
  LoadingNotifier() : super(false);

  void startLoading() => state = true;
  void stopLoading() => state = false;
  
  Future<T> runWithLoading<T>(Future<T> Function() task) async {
    try {
      startLoading();
      return await task();
    } finally {
      stopLoading();
    }
  }
}



=======================================
./lib/presentation/providers/practice_detail_provider.dart
=======================================
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../application/providers/repository_providers.dart';
import '../../application/services/practice/practice_service.dart';
import '../../domain/models/practice/practice_entity.dart';
import '../../domain/models/practice/practice_layer.dart';
import '../../domain/models/practice/practice_page.dart';

/// 练习详情Provider
final practiceDetailProvider = StateNotifierProvider.family<
    PracticeDetailNotifier, PracticeDetailState, String>(
  (ref, id) {
    final service =
        PracticeService(repository: ref.watch(practiceRepositoryProvider));
    return PracticeDetailNotifier(service: service)..loadPractice(id);
  },
);

/// 练习详情Notifier
class PracticeDetailNotifier extends StateNotifier<PracticeDetailState> {
  final PracticeService _service;
  String? _currentId;

  PracticeDetailNotifier({
    required PracticeService service,
  })  : _service = service,
        super(const PracticeDetailState());

  /// 添加图层
  Future<void> addLayer(int pageIndex, PracticeLayer layer) async {
    if (state.practice == null) return;
    try {
      final page =
          state.practice!.pages.firstWhere((p) => p.index == pageIndex);
      final updatedPage = page.addLayer(layer);
      final updated = state.practice!.updatePage(updatedPage);
      await _service.updatePractice(updated);
      state = state.copyWith(practice: updated);
    } catch (e) {
      state = state.copyWith(error: '添加图层失败: $e');
    }
  }

  /// 添加页面
  Future<void> addPage(PracticePage page) async {
    if (state.practice == null) return;

    try {
      final updated = state.practice!.addPage(page);
      await _service.updatePractice(updated);
      state = state.copyWith(practice: updated);
    } catch (e) {
      state = state.copyWith(error: '添加页面失败: $e');
    }
  }

  Future<void> deletePractice(String id) async {
    try {
      state = state.copyWith(isLoading: true);
      await _service.deletePractice(id);
      state = state.copyWith(isLoading: false);
    } catch (e) {
      state = state.copyWith(isLoading: false, error: e.toString());
      rethrow;
    }
  }

  /// 加载练习
  Future<void> loadPractice(String id) async {
    if (id == _currentId && state.practice != null) return;

    state = state.copyWith(isLoading: true, error: null);
    _currentId = id;

    try {
      final practice = await _service.getPractice(id);
      if (practice == null) {
        state = state.copyWith(
          isLoading: false,
          error: '练习不存在',
        );
        return;
      }

      state = state.copyWith(
        practice: practice,
        isLoading: false,
      );
    } catch (e) {
      state = state.copyWith(
        isLoading: false,
        error: '加载练习失败: $e',
      );
    }
  }

  /// 删除图层
  Future<void> removeLayer(int pageIndex, String layerId) async {
    if (state.practice == null) return;
    try {
      final page =
          state.practice!.pages.firstWhere((p) => p.index == pageIndex);
      final updatedPage = page.removeLayer(layerId);
      final updated = state.practice!.updatePage(updatedPage);
      await _service.updatePractice(updated);
      state = state.copyWith(practice: updated);
    } catch (e) {
      state = state.copyWith(error: '删除图层失败: $e');
    }
  }

  /// 删除页面
  Future<void> removePage(int index) async {
    if (state.practice == null) return;

    try {
      final updated = state.practice!.removePage(index);
      await _service.updatePractice(updated);
      state = state.copyWith(practice: updated);
    } catch (e) {
      state = state.copyWith(error: '删除页面失败: $e');
    }
  }

  /// 更新图层
  Future<void> updateLayer(int pageIndex, PracticeLayer layer) async {
    if (state.practice == null) return;
    try {
      final page =
          state.practice!.pages.firstWhere((p) => p.index == pageIndex);
      final updatedPage = page.updateLayer(layer);
      final updated = state.practice!.updatePage(updatedPage);
      await _service.updatePractice(updated);
      state = state.copyWith(practice: updated);
    } catch (e) {
      state = state.copyWith(error: '更新图层失败: $e');
    }
  }

  /// 更新页面
  Future<void> updatePage(PracticePage page) async {
    if (state.practice == null) return;

    try {
      final updated = state.practice!.updatePage(page);
      await _service.updatePractice(updated);
      state = state.copyWith(practice: updated);
    } catch (e) {
      state = state.copyWith(error: '更新页面失败: $e');
    }
  }
}

/// 练习详情状态
class PracticeDetailState {
  final PracticeEntity? practice;
  final bool isLoading;
  final String? error;

  const PracticeDetailState({
    this.practice,
    this.isLoading = false,
    this.error,
  });

  PracticeDetailState copyWith({
    PracticeEntity? practice,
    bool? isLoading,
    String? error,
  }) {
    return PracticeDetailState(
      practice: practice ?? this.practice,
      isLoading: isLoading ?? this.isLoading,
      error: error,
    );
  }
}



=======================================
./lib/presentation/providers/providers.dart
=======================================
export '../../application/providers/service_providers.dart';
export 'character_collection_provider.dart';
export 'character_detail_provider.dart';
export 'work_browse_provider.dart';
export 'work_detail_provider.dart';
export 'work_import_provider.dart';



=======================================
./lib/presentation/providers/settings_provider.dart
=======================================
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../domain/enums/app_theme_mode.dart';
import '../../infrastructure/providers/shared_preferences_provider.dart';

/// Provider for application settings
final settingsProvider =
    StateNotifierProvider<SettingsNotifier, SettingsState>((ref) {
  return SettingsNotifier(ref);
});

class SettingsNotifier extends StateNotifier<SettingsState> {
  final Ref ref;

  SettingsNotifier(this.ref) : super(const SettingsState()) {
    _loadSettings();
  }

  Future<void> setCustomFont(String? fontFamily) async {
    final prefs = ref.read(sharedPreferencesProvider);

    if (fontFamily == null) {
      await prefs.remove('custom_font_family');
      state = state.copyWith(clearCustomFont: true);
    } else {
      await prefs.setString('custom_font_family', fontFamily);
      state = state.copyWith(customFontFamily: fontFamily);
    }
  }

  Future<void> setScaleFactor(double factor) async {
    final prefs = ref.read(sharedPreferencesProvider);
    await prefs.setDouble('scale_factor', factor);

    state = state.copyWith(scaleFactor: factor);
  }

  Future<void> setThemeMode(AppThemeMode mode) async {
    final prefs = ref.read(sharedPreferencesProvider);
    await prefs.setString('theme_mode', mode.toStorageValue());

    state = state.copyWith(themeMode: mode);
  }

  Future<void> setUseSystemFont(bool value) async {
    final prefs = ref.read(sharedPreferencesProvider);
    await prefs.setBool('use_system_font', value);

    state = state.copyWith(useSystemFont: value);
  }

  Future<void> _loadSettings() async {
    final prefs = ref.read(sharedPreferencesProvider);

    final themeMode = AppThemeMode.fromString(
      prefs.getString('theme_mode'),
    );

    final useSystemFont = prefs.getBool('use_system_font') ?? true;
    final customFontFamily = prefs.getString('custom_font_family');
    final scaleFactor = prefs.getDouble('scale_factor') ?? 1.0;

    state = SettingsState(
      themeMode: themeMode,
      useSystemFont: useSystemFont,
      customFontFamily: customFontFamily,
      scaleFactor: scaleFactor,
    );
  }
}

/// Settings state model
class SettingsState {
  final AppThemeMode themeMode;
  final bool useSystemFont;
  final String? customFontFamily;
  final double scaleFactor;

  const SettingsState({
    this.themeMode = AppThemeMode.system,
    this.useSystemFont = true,
    this.customFontFamily,
    this.scaleFactor = 1.0,
  });

  SettingsState copyWith({
    AppThemeMode? themeMode,
    bool? useSystemFont,
    String? customFontFamily,
    double? scaleFactor,
    bool clearCustomFont = false,
  }) {
    return SettingsState(
      themeMode: themeMode ?? this.themeMode,
      useSystemFont: useSystemFont ?? this.useSystemFont,
      customFontFamily:
          clearCustomFont ? null : (customFontFamily ?? this.customFontFamily),
      scaleFactor: scaleFactor ?? this.scaleFactor,
    );
  }
}



=======================================
./lib/presentation/providers/storage_info_provider.dart
=======================================
import 'dart:io';

import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../application/providers/service_providers.dart';
import '../../infrastructure/providers/storage_providers.dart';

/// 存储信息提供者
final storageInfoProvider = FutureProvider<StorageInfo>((ref) async {
  final storage = ref.watch(initializedStorageProvider);
  final workService = ref.watch(workServiceProvider);

  // 获取应用数据目录
  final basePath = storage.getAppDataPath();
  final baseDir = Directory(basePath);

  // 获取作品数量
  final works = await workService.getAllWorks();
  final workCount = works.length;

  // 计算存储使用情况
  int totalSize = 0;
  int fileCount = 0;
  int cacheSize = 0;
  final subdirectories = <DirectoryInfo>[];

  if (await baseDir.exists()) {
    await for (final entity in baseDir.list()) {
      if (entity is Directory) {
        // 特别处理缓存目录
        if (entity.path.contains('temp') || entity.path.contains('cache')) {
          cacheSize += await _calculateDirectorySize(entity.path);
          continue;
        }

        final size = await _calculateDirectorySize(entity.path);
        totalSize += size;

        subdirectories.add(DirectoryInfo(
          name: entity.path.split(Platform.pathSeparator).last,
          path: entity.path,
          size: size,
        ));
      } else if (entity is File) {
        totalSize += await entity.length();
        fileCount++;
      }
    }
  }

  // 获取目标存储空间（100GB）
  const targetSize = 100 * 1024 * 1024 * 1024;
  final usagePercentage = (totalSize / targetSize) * 100;

  return StorageInfo(
    path: basePath,
    totalSize: targetSize,
    usedSize: totalSize,
    usagePercentage: usagePercentage,
    workCount: workCount,
    fileCount: fileCount,
    cacheSize: cacheSize,
    subdirectories: subdirectories,
  );
});

Future<int> _calculateDirectorySize(String dirPath) async {
  int size = 0;
  final dir = Directory(dirPath);

  try {
    if (await dir.exists()) {
      await for (final entity in dir.list(recursive: true)) {
        if (entity is File) {
          size += await entity.length();
        }
      }
    }
  } catch (e) {
    // 忽略权限等错误
  }

  return size;
}

class DirectoryInfo {
  final String name;
  final String path;
  final int size;

  DirectoryInfo({
    required this.name,
    required this.path,
    required this.size,
  });
}

class StorageInfo {
  final String path;
  final int totalSize;
  final int usedSize;
  final double usagePercentage;
  final int workCount;
  final int fileCount;
  final int cacheSize;
  final List<DirectoryInfo> subdirectories;

  StorageInfo({
    required this.path,
    required this.totalSize,
    required this.usedSize,
    required this.usagePercentage,
    required this.workCount,
    required this.fileCount,
    required this.cacheSize,
    required this.subdirectories,
  });
}



=======================================
./lib/presentation/providers/works_providers.dart
=======================================
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../application/providers/service_providers.dart';
import '../../domain/models/work/work_entity.dart';
import '../../infrastructure/logging/logger.dart';

// 修改为刷新信息提供器
final worksNeedsRefreshProvider = StateProvider<RefreshInfo?>((ref) => null);

// 作品列表提供器
final worksProvider = FutureProvider.autoDispose<List<WorkEntity>>((ref) async {
  AppLogger.debug('加载作品列表', tag: 'WorksProvider');

  // 设置缓存策略，使列表能够在返回时保留
  ref.keepAlive();

  final workService = ref.watch(workServiceProvider);
  return await workService.getAllWorks();
});

// 增强刷新标志，添加刷新原因和优先级信息
class RefreshInfo {
  final String reason;
  final int priority;
  final bool force;

  const RefreshInfo({
    required this.reason,
    this.priority = 0,
    this.force = false,
  });

  // 添加常用刷新原因作为工厂构造函数:
  factory RefreshInfo.appResume() =>
      const RefreshInfo(reason: '应用恢复', priority: 1);

  factory RefreshInfo.dataChanged() =>
      const RefreshInfo(reason: '数据变更', priority: 10, force: true);

  factory RefreshInfo.importCompleted() =>
      const RefreshInfo(reason: '导入完成', priority: 9, force: true);

  factory RefreshInfo.userInitiated() =>
      const RefreshInfo(reason: '用户请求', priority: 8, force: true);

  // 用于创建更高优先级的请求
  RefreshInfo asHighPriority() =>
      RefreshInfo(reason: reason, priority: priority + 5, force: true);

  // 比较优先级方法
  bool hasHigherPriorityThan(RefreshInfo other) => priority > other.priority;
}



=======================================
./lib/presentation/providers/works_state_providers.dart
=======================================
import 'package:flutter_riverpod/flutter_riverpod.dart';

import 'work_browse_provider.dart';

// 衍生状态 providers，依赖于 workBrowseProvider 但提供更具体的数据视图

/// 作品列表加载是否有错误
final hasErrorProvider = Provider<bool>((ref) {
  final state = ref.watch(workBrowseProvider);
  return !state.isLoading && state.error != null;
});

/// 是否有活动筛选器或搜索
final hasFilterProvider = Provider<bool>((ref) {
  final state = ref.watch(workBrowseProvider);
  return !state.filter.isEmpty || state.searchQuery.isNotEmpty;
});

/// 作品列表是否在加载中
final isLoadingWorksProvider = Provider<bool>((ref) {
  return ref.watch(workBrowseProvider).isLoading;
});

/// 已选择作品数量
final selectedWorksCountProvider = Provider<int>((ref) {
  return ref.watch(workBrowseProvider).selectedWorks.length;
});

/// 是否显示批量操作工具栏
final showBatchActionsProvider = Provider<bool>((ref) {
  final state = ref.watch(workBrowseProvider);
  return state.batchMode && state.selectedWorks.isNotEmpty;
});

/// 作品列表是否为空
final worksEmptyProvider = Provider<bool>((ref) {
  final state = ref.watch(workBrowseProvider);
  return !state.isLoading && state.works.isEmpty;
});



=======================================
./lib/presentation/providers/work_browse_provider.dart
=======================================
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../application/providers/service_providers.dart';
import '../../application/services/restoration/state_restoration_service.dart';
import '../viewmodels/states/work_browse_state.dart';
import '../viewmodels/work_browse_view_model.dart';

final workBrowseProvider =
    StateNotifierProvider<WorkBrowseViewModel, WorkBrowseState>((ref) {
  final workService = ref.watch(workServiceProvider);
  final stateRestorationService = ref.watch(stateRestorationServiceProvider);

  return WorkBrowseViewModel(workService, stateRestorationService);
});



=======================================
./lib/presentation/providers/work_detail_provider.dart
=======================================
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../application/providers/service_providers.dart';
import '../../application/services/work/work_service.dart';
import '../../domain/enums/work_style.dart';
import '../../domain/enums/work_tool.dart';
import '../../domain/models/work/work_entity.dart';
import '../../domain/models/work/work_image.dart';

/// 作品详情提供器
final workDetailProvider =
    StateNotifierProvider<WorkDetailNotifier, WorkDetailState>((ref) {
  final workService = ref.watch(workServiceProvider);
  return WorkDetailNotifier(workService);
});

/// 作品详情通知器
class WorkDetailNotifier extends StateNotifier<WorkDetailState> {
  final WorkService _workService;

  WorkDetailNotifier(this._workService) : super(const WorkDetailState());

  /// 取消编辑
  void cancelEditing() {
    state = state.copyWith(
      editingWork: state.work,
      isEditing: false,
      hasChanges: false,
    );
  }

  /// 完成编辑（从编辑模式切换回查看模式）
  void completeEditing() {
    state = state.copyWith(
      isEditing: false,
      hasChanges: false,
    );
  }

  /// 删除作品
  Future<bool> deleteWork(String workId) async {
    if (state.isSaving) return false;

    try {
      state = state.copyWith(isSaving: true, error: null);

      await _workService.deleteWork(workId);

      state = state.copyWith(isSaving: false);
      return true;
    } catch (e) {
      state = state.copyWith(
        isSaving: false,
        error: '删除失败: $e',
      );
      return false;
    }
  }

  /// 进入编辑模式
  void enterEditMode() {
    if (state.work == null) return;
    startEditing();
  }

  /// 加载作品
  Future<void> loadWork(String workId) async {
    if (state.isLoading) return;

    try {
      state = state.copyWith(isLoading: true, error: null);

      final work = await _workService.getWork(workId);
      state = state.copyWith(
        work: work,
        editingWork: work,
        isLoading: false,
      );
    } catch (e) {
      state = state.copyWith(
        isLoading: false,
        error: '加载失败: $e',
      );
    }
  }

  /// 加载作品详情
  Future<void> loadWorkDetails(String workId) async {
    await loadWork(workId);
  }

  /// 标记有更改
  void markAsChanged() {
    state = state.copyWith(hasChanges: true);
  }

  /// 保存作品
  Future<bool> saveChanges() async {
    if (state.isSaving || state.editingWork == null) return false;

    try {
      state = state.copyWith(isSaving: true, error: null);

      final updatedWork =
          await _workService.updateWorkEntity(state.editingWork!);

      state = state.copyWith(
        work: updatedWork,
        editingWork: updatedWork,
        isSaving: false,
        hasChanges: false,
      );

      return true;
    } catch (e) {
      state = state.copyWith(
        isSaving: false,
        error: '保存失败: $e',
      );
      return false;
    }
  }

  /// 选择图片
  void selectImage(int index) {
    if (index < 0 || index >= (state.work?.images.length ?? 0)) return;

    state = state.copyWith(
      selectedImageIndex: index,
    );
  }

  /// 开始编辑
  void startEditing() {
    if (state.work == null) return;
    state = state.copyWith(
      editingWork: state.work,
      isEditing: true,
      hasChanges: false,
    );
  }

  /// 尝试恢复编辑状态
  Future<void> tryRestoreEditState(String workId) async {
    try {
      await loadWork(workId);
      startEditing();
    } catch (e) {
      // 恢复失败，不处理
    }
  }

  void updateWorkBasicInfo({
    String title = '',
    String author = '',
    String remark = '',
    WorkStyle? style,
    WorkTool? tool,
    DateTime? creationDate,
  }) {
    if (state.editingWork == null) return;

    final updatedWork = WorkEntity(
      id: state.editingWork!.id,
      title: title.isEmpty ? state.editingWork!.title : title,
      author: author.isEmpty ? state.editingWork!.author : author,
      remark: remark.isEmpty ? state.editingWork!.remark : remark,
      style: style ?? state.editingWork!.style,
      tool: tool ?? state.editingWork!.tool,
      creationDate: creationDate ?? state.editingWork!.creationDate,
      createTime: state.editingWork!.createTime,
      updateTime: DateTime.now(),
      images: state.editingWork!.images,
      imageCount: state.editingWork!.imageCount,
      tags: state.editingWork!.tags,
      collectedChars: state.editingWork!.collectedChars,
    );

    state = state.copyWith(
      editingWork: updatedWork,
      hasChanges: true,
    );
  }

  /// 更新作品图片列表
  void updateWorkImages(List<WorkImage> images) {
    if (state.editingWork == null) return;

    final updatedWork = state.editingWork!.copyWith(
      images: images,
      imageCount: images.length,
      updateTime: DateTime.now(),
    );

    state = state.copyWith(
      editingWork: updatedWork,
      hasChanges: true,
    );
  }

  /// 更新作品标签
  void updateWorkTags(List<String> tags) {
    if (state.editingWork == null) return;

    final updatedWork = state.editingWork!.copyWith(
      tags: tags,
      updateTime: DateTime.now(),
    );

    state = state.copyWith(
      editingWork: updatedWork,
      hasChanges: true,
    );
  }
}

/// 作品详情状态
class WorkDetailState {
  final WorkEntity? work;
  final WorkEntity? editingWork;
  final bool isLoading;
  final bool isSaving;
  final bool isEditing;
  final bool hasChanges;
  final int historyIndex;
  final int selectedImageIndex;
  final String? error;

  const WorkDetailState({
    this.work,
    this.editingWork,
    this.isLoading = false,
    this.isSaving = false,
    this.isEditing = false,
    this.hasChanges = false,
    this.historyIndex = -1,
    this.selectedImageIndex = 0,
    this.error,
  });

  WorkDetailState copyWith({
    WorkEntity? work,
    WorkEntity? editingWork,
    bool? isLoading,
    bool? isSaving,
    bool? isEditing,
    bool? hasChanges,
    int? historyIndex,
    int? selectedImageIndex,
    String? error,
  }) {
    return WorkDetailState(
      work: work ?? this.work,
      editingWork: editingWork ?? this.editingWork,
      isLoading: isLoading ?? this.isLoading,
      isSaving: isSaving ?? this.isSaving,
      isEditing: isEditing ?? this.isEditing,
      hasChanges: hasChanges ?? this.hasChanges,
      historyIndex: historyIndex ?? this.historyIndex,
      selectedImageIndex: selectedImageIndex ?? this.selectedImageIndex,
      error: error,
    );
  }
}



=======================================
./lib/presentation/providers/work_filter_provider.dart
=======================================
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../domain/models/work/work_filter.dart';

final workFilterProvider =
    StateNotifierProvider<WorkFilterNotifier, WorkFilter>((ref) {
  return WorkFilterNotifier();
});

class WorkFilterNotifier extends StateNotifier<WorkFilter> {
  WorkFilterNotifier() : super(const WorkFilter());

  void resetFilter() {
    state = const WorkFilter();
  }

  void updateFilter(WorkFilter newFilter) {
    state = newFilter;
  }
}



=======================================
./lib/presentation/providers/work_image_editor_provider.dart
=======================================
import 'dart:io';

import 'package:file_picker/file_picker.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../application/providers/service_providers.dart';
import '../../domain/models/work/work_image.dart';
import '../../infrastructure/logging/logger.dart';
import './work_detail_provider.dart';

final currentWorkImageIndexProvider = StateProvider<int>((ref) => 0);

final workImageEditorProvider = StateNotifierProvider.autoDispose<
    WorkImageEditorNotifier, WorkImageEditorState>((ref) {
  // Create the notifier
  final notifier = WorkImageEditorNotifier(ref);

  // Setup disposal callback
  ref.onDispose(() {
    AppLogger.debug('WorkImageEditorProvider disposed', tag: 'WorkImageEditor');
  });

  // Important: Don't call initialize methods that modify other providers here!

  return notifier;
});

/// Flag to indicate if initial synchronization is complete
final workImageInitializedProvider = StateProvider<bool>((ref) => false);

class WorkImageEditorNotifier extends StateNotifier<WorkImageEditorState> {
  final Ref _ref;

  WorkImageEditorNotifier(this._ref) : super(const WorkImageEditorState());

  // For backward compatibility - just calls addImages()
  Future<void> addImage() async {
    await addImages();
  }

  /// Add one or more images
  /// This is the consolidated method for adding images - always allows multiple selection
  Future<void> addImages() async {
    try {
      state = state.copyWith(isProcessing: true, error: null);

      AppLogger.debug('Starting image selection', tag: 'WorkImageEditor');

      // Always use multiple selection - users can still select just one if they want
      final result = await FilePicker.platform.pickFiles(
        type: FileType.image,
        allowMultiple: true, // Always allow multiple selection
        withData: false,
        lockParentWindow: true,
        dialogTitle: '选择图片 (可按住Ctrl多选)',
      );

      AppLogger.debug('File picker result', tag: 'WorkImageEditor', data: {
        'hasResult': result != null,
        'fileCount': result?.files.length ?? 0
      });

      // Handle no selection case
      if (result == null || result.files.isEmpty) {
        AppLogger.debug('User cancelled file selection',
            tag: 'WorkImageEditor');
        state = state.copyWith(isProcessing: false);
        return;
      }

      final workId = _ref.read(workDetailProvider).work!.id;
      final newImages = <WorkImage>[];
      int successCount = 0;
      int errorCount = 0;

      // Process each selected file - works for single or multiple selection
      for (final file in result.files) {
        if (file.path == null) {
          errorCount++;
          continue;
        }

        try {
          final filePath = file.path!;
          final imageFile = File(filePath);

          // Basic verification
          if (!await imageFile.exists()) {
            AppLogger.warning('Selected file does not exist',
                tag: 'WorkImageEditor', data: {'path': filePath});
            errorCount++;
            continue;
          }

          // Create a unique ID that includes timestamp and counter
          final imageId =
              '${DateTime.now().millisecondsSinceEpoch}_$successCount';

          final newImage = WorkImage(
            id: imageId,
            workId: workId,
            path: imageFile.path,
            originalPath: imageFile.path,
            thumbnailPath: imageFile.path,
            format: imageFile.path.split('.').last.toLowerCase(),
            size: await imageFile.length(),
            width: 0,
            height: 0,
            index: state.images.length + newImages.length,
            createTime: DateTime.now(),
            updateTime: DateTime.now(),
          );

          newImages.add(newImage);
          successCount++;
        } catch (e) {
          AppLogger.error('Error processing file',
              tag: 'WorkImageEditor', error: e, data: {'path': file.path});
          errorCount++;
        }
      }

      if (newImages.isNotEmpty) {
        // Update state with all new images
        final allImages = [...state.images, ...newImages];

        AppLogger.debug('Adding images to state',
            tag: 'WorkImageEditor',
            data: {
              'newImagesCount': newImages.length,
              'totalImagesCount': allImages.length,
              'successCount': successCount,
              'errorCount': errorCount,
            });

        state = state.copyWith(
          images: allImages,
          isProcessing: false,
          hasPendingAdditions: true,
        );

        // Update selected index to the first new image
        _ref.read(currentWorkImageIndexProvider.notifier).state =
            state.images.length - newImages.length;

        // Mark work as changed
        _ref.read(workDetailProvider.notifier).markAsChanged();

        // Show user feedback about partial failures if any
        if (errorCount > 0 && successCount > 0) {
          state = state.copyWith(
              error: '已添加 $successCount 张图片，$errorCount 张图片无法处理');
        } else if (errorCount > 0 && successCount == 0) {
          state = state.copyWith(error: '无法处理所选图片');
        }
      } else {
        state = state.copyWith(isProcessing: false, error: '无法添加所选图片');
      }
    } catch (e, stackTrace) {
      AppLogger.error('Failed to add images',
          tag: 'WorkImageEditor', error: e, stackTrace: stackTrace);

      state = state.copyWith(
        isProcessing: false,
        error: '添加图片失败: ${e.toString()}',
      );
    }
  }

  Future<void> deleteImage(String imageId) async {
    try {
      AppLogger.debug('Starting image deletion', tag: 'WorkImageEditor', data: {
        'imageId': imageId,
        'currentImageCount': state.images.length,
      });

      state = state.copyWith(isProcessing: true, error: null);

      // Find the image in the current state
      final imageToDelete = state.images.firstWhere(
        (img) => img.id == imageId,
        orElse: () => throw Exception('Image not found: $imageId'),
      );

      AppLogger.debug('Found image to delete', tag: 'WorkImageEditor', data: {
        'imageId': imageId,
        'imagePath': imageToDelete.path,
      });

      final currentIndex = _ref.read(currentWorkImageIndexProvider);

      // Remove the image from the list and reindex
      final remainingImages =
          state.images.where((img) => img.id != imageId).toList();
      final reindexedImages = List<WorkImage>.generate(
        remainingImages.length,
        (index) => remainingImages[index].copyWith(
          index: index,
          updateTime: DateTime.now(),
        ),
      );

      // Add to deleted IDs list for tracking and future cleanup
      final updatedDeletedIds = [...state.deletedImageIds, imageId];

      // Update state with new image list and add deleted ID to tracking
      state = state.copyWith(
        images: reindexedImages,
        deletedImageIds: updatedDeletedIds,
        isProcessing: false,
      );

      // Log additional info about the deleted images tracking
      AppLogger.debug(
        'Updated deleted images tracking',
        tag: 'WorkImageEditor',
        data: {
          'deletedIds': updatedDeletedIds,
          'deletedCount': updatedDeletedIds.length,
        },
      );

      // Update selected index to prevent out-of-bounds access
      if (reindexedImages.isEmpty) {
        _ref.read(currentWorkImageIndexProvider.notifier).state = 0;
      } else if (currentIndex >= reindexedImages.length) {
        _ref.read(currentWorkImageIndexProvider.notifier).state =
            reindexedImages.length - 1;
      }

      // Mark the work as changed
      _ref.read(workDetailProvider.notifier).markAsChanged();

      AppLogger.debug('Image deleted successfully',
          tag: 'WorkImageEditor',
          data: {
            'remainingImageCount': reindexedImages.length,
            'deletedIdsCount': updatedDeletedIds.length,
          });
    } catch (e, stackTrace) {
      AppLogger.error('Failed to delete image',
          tag: 'WorkImageEditor', error: e, stackTrace: stackTrace);

      state = state.copyWith(
        isProcessing: false,
        error: '删除图片失败: ${e.toString()}',
      );
    }
  }

  /// Initialize the editor with images from a work
  /// This should only be called after provider creation, not during
  Future<void> initialize(List<WorkImage> images) async {
    // First check if still mounted before proceeding
    if (!mounted) {
      AppLogger.warning(
        'Attempted to initialize WorkImageEditor after disposal',
        tag: 'WorkImageEditor',
      );
      return;
    }

    // Reset initialized state to false at start of initialization
    _ref.read(workImageInitializedProvider.notifier).state = false;

    // Log the incoming images to verify they exist
    AppLogger.debug(
      'Initializing WorkImageEditor with images',
      tag: 'WorkImageEditor',
      data: {
        'imageCount': images.length,
        'imageIds': images.isNotEmpty
            ? images.map((img) => img.id).take(3).toList() +
                (images.length > 3 ? ['...'] : [])
            : [],
      },
    );

    if (images.isEmpty) {
      AppLogger.warning(
        'Attempted to initialize editor with empty images list',
        tag: 'WorkImageEditor',
      );
      return;
    }

    try {
      // Create a deep copy of images to prevent reference issues
      final imagesCopy = images.map((img) => img.copyWith()).toList();

      // Update our state with clean pending state
      state = WorkImageEditorState(
        images: imagesCopy,
        deletedImageIds: const [],
        isProcessing: false,
        error: null,
        hasPendingAdditions: false, // Reset pending state on initialization
      );

      // Verify images were properly loaded before marking as initialized
      if (state.images.isNotEmpty) {
        // Only mark as initialized if we actually have images
        _ref.read(workImageInitializedProvider.notifier).state = true;

        AppLogger.debug(
          'WorkImageEditor initialization successful',
          tag: 'WorkImageEditor',
          data: {
            'imageCount': state.images.length,
            'initialized': true,
          },
        );
      } else {
        AppLogger.error(
          'WorkImageEditor initialization failed - no images in state after update',
          tag: 'WorkImageEditor',
          data: {
            'providedImageCount': images.length,
          },
        );
      }
    } catch (e) {
      AppLogger.error(
        'Error during WorkImageEditor initialization',
        tag: 'WorkImageEditor',
        error: e,
      );
      // Ensure initialization flag is false on error
      _ref.read(workImageInitializedProvider.notifier).state = false;
    }
  }

  Future<void> reorderImages(int oldIndex, int newIndex) async {
    try {
      if (oldIndex < newIndex) {
        newIndex -= 1;
      }

      final items = List<WorkImage>.from(state.images);
      final item = items.removeAt(oldIndex);
      items.insert(newIndex, item);

      // 重新计算所有图片的索引
      final reindexedImages = List<WorkImage>.generate(
        items.length,
        (index) => items[index].copyWith(
          index: index,
          updateTime: DateTime.now(),
        ),
      );

      AppLogger.debug('重排序图片', tag: 'WorkImageEditor', data: {
        'oldIndex': oldIndex,
        'newIndex': newIndex,
        'firstImageId':
            reindexedImages.isNotEmpty ? reindexedImages[0].id : null,
      });

      state = state.copyWith(images: reindexedImages);

      // 更新选中索引
      _ref.read(currentWorkImageIndexProvider.notifier).state = newIndex;

      // 标记作品已更改
      _ref.read(workDetailProvider.notifier).markAsChanged();
    } catch (e) {
      AppLogger.error('重排序图片失败', tag: 'WorkImageEditor', error: e);
      state = state.copyWith(error: '重排序图片失败: $e');
      rethrow;
    }
  }

  /// Reset the state to initial empty state
  void reset() {
    // When resetting, make sure to clear the deleted images tracking
    state = const WorkImageEditorState();
    _ref.read(workImageInitializedProvider.notifier).state = false;
    AppLogger.debug(
      'Resetting WorkImageEditor state',
      tag: 'WorkImageEditor',
      data: {'deletedIdsCleared': true, 'pendingAdditionsCleared': true},
    );
  }

  Future<void> saveChanges() async {
    try {
      state = state.copyWith(isProcessing: true, error: null);

      final workId = _ref.read(workDetailProvider).work?.id;
      if (workId == null) return;

      AppLogger.debug('开始保存图片更改', tag: 'WorkImageEditor', data: {
        'workId': workId,
        'imageCount': state.images.length,
        'firstImageId': state.images.isNotEmpty ? state.images[0].id : null,
      });

      final workImageService = _ref.read(workImageServiceProvider);

      // 先删除标记为删除的图片
      for (final imageId in state.deletedImageIds) {
        try {
          await workImageService.deleteImage(workId, imageId);
        } catch (e) {
          AppLogger.warning('删除图片文件失败',
              tag: 'WorkImageEditor',
              error: e,
              data: {
                'imageId': imageId,
                'workId': workId,
              });
        }
      }

      // 保存所有图片
      final savedImages = await workImageService.saveChanges(
        workId,
        state.images,
        onProgress: (progress, message) {
          AppLogger.debug('保存进度', tag: 'WorkImageEditor', data: {
            'progress': progress,
            'message': message,
          });
        },
      );

      state = state.copyWith(
        images: savedImages,
        deletedImageIds: [],
        isProcessing: false,
        hasPendingAdditions: false, // Clear pending flag after successful save
      );

      AppLogger.debug('图片保存完成', tag: 'WorkImageEditor', data: {
        'savedCount': savedImages.length,
      });

      // 重新加载作品详情以获取最新状态
      await _ref.read(workDetailProvider.notifier).loadWorkDetails(workId);
    } catch (e) {
      AppLogger.error('保存图片更改失败', tag: 'WorkImageEditor', error: e);
      state = state.copyWith(
        isProcessing: false,
        error: '保存图片更改失败: $e',
      );
      rethrow;
    }
  }

  // 图片排序
  Future<void> sortImages() async {
    try {
      if (state.images.isEmpty || state.images.length <= 1) return;

      state = state.copyWith(isProcessing: true, error: null);

      // 根据文件名排序
      final sortedImages = List<WorkImage>.from(state.images)
        ..sort((a, b) => a.path.compareTo(b.path));

      // 重新计算索引
      final reindexedImages = List<WorkImage>.generate(
        sortedImages.length,
        (index) => sortedImages[index].copyWith(
          index: index,
          updateTime: DateTime.now(),
        ),
      );

      // 更新状态
      state = state.copyWith(
        images: reindexedImages,
        isProcessing: false,
      );

      // 如果当前选择的图片顺序变了，更新选择的索引到第一张
      _ref.read(currentWorkImageIndexProvider.notifier).state = 0;

      // 标记作品已更改
      _ref.read(workDetailProvider.notifier).markAsChanged();
    } catch (e) {
      AppLogger.error('图片排序失败', tag: 'WorkImageEditor', error: e);
      state = state.copyWith(
        isProcessing: false,
        error: '图片排序失败: $e',
      );
    }
  }

  /// Update the selected index (to be called after initialization)
  void updateSelectedIndex(int index) {
    if (!mounted) return;

    final maxIndex = state.images.length - 1;
    final safeIndex = index.clamp(0, maxIndex < 0 ? 0 : maxIndex);

    // Now we can safely update the index provider
    _ref.read(currentWorkImageIndexProvider.notifier).state = safeIndex;

    AppLogger.debug(
      'Updated selected index',
      tag: 'WorkImageEditor',
      data: {
        'requestedIndex': index,
        'actualIndex': safeIndex,
        'maxIndex': maxIndex,
      },
    );
  }
}

class WorkImageEditorState {
  final List<WorkImage> images;
  final List<String> deletedImageIds;
  final bool isProcessing;
  final String? error;
  final bool hasPendingAdditions; // Track if we've added new images

  const WorkImageEditorState({
    this.images = const [],
    this.deletedImageIds = const [],
    this.isProcessing = false,
    this.error,
    this.hasPendingAdditions = false,
  });

  WorkImageEditorState copyWith({
    List<WorkImage>? images,
    List<String>? deletedImageIds,
    bool? isProcessing,
    String? error,
    bool? hasPendingAdditions,
  }) {
    return WorkImageEditorState(
      images: images ?? this.images,
      deletedImageIds: deletedImageIds ?? this.deletedImageIds,
      isProcessing: isProcessing ?? this.isProcessing,
      error: error,
      hasPendingAdditions: hasPendingAdditions ?? this.hasPendingAdditions,
    );
  }
}



=======================================
./lib/presentation/providers/work_import_provider.dart
=======================================
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../application/providers/service_providers.dart';
import '../viewmodels/states/work_import_state.dart';
import '../viewmodels/work_import_view_model.dart';

final workImportProvider =
    StateNotifierProvider<WorkImportViewModel, WorkImportState>((ref) {
  final workService = ref.watch(workServiceProvider);
  final imageProcessor = ref.watch(imageProcessorProvider);
  return WorkImportViewModel(workService, imageProcessor);
});



=======================================
./lib/presentation/viewmodels/states/character_collection_state.dart
=======================================
import 'package:equatable/equatable.dart';

import '../../../domain/models/character/character_entity.dart';
import '../../../domain/models/character/character_filter.dart';

/// 集字管理页面状态
class CharacterCollectionState extends Equatable {
  /// 字形列表
  final List<CharacterEntity> characters;

  /// 视图模式
  final ViewMode viewMode;

  /// 选中的字形ID集合
  final Set<String> selectedCharacters;

  /// 过滤条件
  final CharacterFilter filter;

  /// 是否正在加载
  final bool isLoading;

  /// 侧边栏是否打开
  final bool isSidebarOpen;

  /// 是否批量操作模式
  final bool batchMode;

  /// 错误信息
  final String? error;

  /// 当前选中的字形ID
  final String? selectedCharacterId;

  /// 统计信息
  final Map<String, int> stats;

  const CharacterCollectionState({
    this.characters = const [],
    this.viewMode = ViewMode.grid,
    this.selectedCharacters = const {},
    this.filter = const CharacterFilter(),
    this.isLoading = false,
    this.isSidebarOpen = false,
    this.batchMode = false,
    this.error,
    this.selectedCharacterId,
    this.stats = const {},
  });

  /// 获取草书字数
  int get cursiveCount => stats['cursive'] ?? 0;

  @override
  List<Object?> get props => [
        characters,
        viewMode,
        selectedCharacters,
        filter,
        isLoading,
        isSidebarOpen,
        batchMode,
        error,
        selectedCharacterId,
        stats,
      ];

  /// 获取楷书字数
  int get regularCount => stats['regular'] ?? 0;

  /// 获取篆书字数
  int get sealCount => stats['seal'] ?? 0;

  /// 获取当前选中的字形
  CharacterEntity? get selectedCharacter => selectedCharacterId != null
      ? characters.firstWhere(
          (char) => char.id == selectedCharacterId,
          orElse: () => characters.first,
        )
      : null;

  /// 获取总字数
  int get totalCount => stats['total'] ?? 0;

  CharacterCollectionState copyWith({
    List<CharacterEntity>? characters,
    ViewMode? viewMode,
    Set<String>? selectedCharacters,
    CharacterFilter? filter,
    bool? isLoading,
    bool? isSidebarOpen,
    bool? batchMode,
    String? error,
    String? selectedCharacterId,
    Map<String, int>? stats,
  }) {
    return CharacterCollectionState(
      characters: characters ?? this.characters,
      viewMode: viewMode ?? this.viewMode,
      selectedCharacters: selectedCharacters ?? this.selectedCharacters,
      filter: filter ?? this.filter,
      isLoading: isLoading ?? this.isLoading,
      isSidebarOpen: isSidebarOpen ?? this.isSidebarOpen,
      batchMode: batchMode ?? this.batchMode,
      error: error ?? this.error,
      selectedCharacterId: selectedCharacterId ?? this.selectedCharacterId,
      stats: stats ?? this.stats,
    );
  }
}

/// 视图模式
enum ViewMode {
  /// 网格视图
  grid,

  /// 列表视图
  list,
}



=======================================
./lib/presentation/viewmodels/states/work_browse_state.dart
=======================================
import 'dart:convert';

import 'package:demo/domain/models/work/work_entity.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:shared_preferences/shared_preferences.dart';

import '../../../domain/models/common/sort_option.dart';
import '../../../domain/models/work/work_filter.dart';
import '../../../infrastructure/logging/logger.dart'; // 添加日志导入

enum LoadRequestStatus {
  idle, // 空闲
  throttled, // 节流中（已请求但等待执行）
  loading, // 加载中
}

enum ViewMode { grid, list }

class WorkBrowseState {
  // 视图状态
  final ViewMode viewMode;
  final bool isSidebarOpen;

  // 选择状态
  final bool batchMode;
  final Set<String> selectedWorks;

  // 搜索和过滤状态
  final String searchQuery;
  final WorkFilter filter;
  final SortOption sortOption;

  // 数据状态
  final bool isLoading;
  final List<WorkEntity> works;
  final String? error;
  final TextEditingController searchController;

  // 添加分页相关状态
  final int page;
  final int pageSize;
  final bool hasMore;
  final bool isLoadingMore;

  // 添加一个字段表示请求状态
  final LoadRequestStatus requestStatus;

  WorkBrowseState({
    this.isLoading = false,
    this.error,
    this.works = const [],
    this.searchQuery = '',
    this.viewMode = ViewMode.grid,
    this.sortOption = const SortOption(),
    this.filter = const WorkFilter(),
    this.isSidebarOpen = true, // 默认展开
    this.batchMode = false,
    this.selectedWorks = const {},
    TextEditingController? searchController,
    this.page = 1,
    this.pageSize = 20,
    this.hasMore = true,
    this.isLoadingMore = false,
    this.requestStatus = LoadRequestStatus.idle,
  }) : searchController = searchController ?? TextEditingController();

  @override
  int get hashCode => Object.hash(
        Object.hashAll(works),
        filter,
        viewMode,
        isLoading,
        error,
        batchMode,
        Object.hashAll(selectedWorks),
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    return other is WorkBrowseState &&
        listEquals(works, other.works) && // 使用 listEquals 比较列表
        filter == other.filter &&
        viewMode == other.viewMode &&
        isLoading == other.isLoading &&
        error == other.error &&
        batchMode == other.batchMode &&
        setEquals(selectedWorks, other.selectedWorks); // 使用 setEquals 比较集合
  }

  WorkBrowseState copyWith({
    bool? isLoading,
    String? error,
    List<WorkEntity>? works,
    String? searchQuery, // 添加 searchQuery
    ViewMode? viewMode,
    SortOption? sortOption,
    WorkFilter? filter,
    bool? isSidebarOpen, // 新增字段
    bool? batchMode,
    Set<String>? selectedWorks,
    TextEditingController? searchController,
    int? page,
    int? pageSize,
    bool? hasMore,
    bool? isLoadingMore,
    int? totalCount,
    LoadRequestStatus? requestStatus,
  }) {
    // Add debug print to verify state updates
    debugPrint(
        'WorkBrowseState.copyWith - new works count: ${works?.length ?? this.works.length}');

    return WorkBrowseState(
      isLoading: isLoading ?? this.isLoading,
      error: error ?? this.error,
      works: works ?? this.works,
      searchQuery: searchQuery ?? this.searchQuery, // 保持搜索条件
      viewMode: viewMode ?? this.viewMode,
      sortOption: sortOption ?? this.sortOption,
      filter: filter ?? this.filter,
      isSidebarOpen: isSidebarOpen ?? this.isSidebarOpen, // 复制 isSidebarOpen
      batchMode: batchMode ?? this.batchMode,
      selectedWorks: selectedWorks ?? this.selectedWorks,
      searchController: searchController ?? this.searchController,
      page: page ?? this.page,
      pageSize: pageSize ?? this.pageSize,
      hasMore: hasMore ?? this.hasMore,
      isLoadingMore: isLoadingMore ?? this.isLoadingMore,
      requestStatus: requestStatus ?? this.requestStatus,
    );
  }

  void dispose() {
    searchController.dispose();
  }

  // 添加 toJson 方法，用于序列化
  Map<String, dynamic> toJson() {
    AppLogger.debug('Serializing WorkBrowseState', tag: 'State');

    final result = {
      'viewMode': viewMode.index,
      'isSidebarOpen': isSidebarOpen,
      'searchQuery': searchQuery,
      'filter': filter.toJson(),
      'sortOption': sortOption.toJson(),
      'page': page,
      'pageSize': pageSize,
      'hasMore': hasMore,
      // 不序列化状态数据如 isLoading、works、error 等
      // 不序列化 TextEditingController
      // 不序列化 batchMode 和 selectedWorks，因为这些是临时选择状态
    };

    AppLogger.debug('WorkBrowseState serialized successfully', tag: 'State');
    return result;
  }

  // 添加 fromJson 静态方法，用于反序列化
  static WorkBrowseState fromJson(Map<String, dynamic> json) {
    try {
      AppLogger.debug('Deserializing WorkBrowseState',
          tag: 'State', data: {'json': json});

      final result = WorkBrowseState(
        viewMode: json['viewMode'] != null
            ? ViewMode.values[json['viewMode'] as int]
            : ViewMode.grid,
        isSidebarOpen: json['isSidebarOpen'] as bool? ?? true,
        searchQuery: json['searchQuery'] as String? ?? '',
        filter: json['filter'] != null
            ? WorkFilter.fromJson(json['filter'] as Map<String, dynamic>)
            : const WorkFilter(),
        sortOption: json['sortOption'] != null
            ? SortOption.fromJson(json['sortOption'] as Map<String, dynamic>)
            : const SortOption(),
        page: json['page'] as int? ?? 1,
        pageSize: json['pageSize'] as int? ?? 20,
        hasMore: json['hasMore'] as bool? ?? true,
        // 默认值
        isLoading: false,
        works: const [],
        selectedWorks: const {},
      );

      AppLogger.debug('WorkBrowseState deserialized successfully',
          tag: 'State',
          data: {
            'viewMode': result.viewMode.toString(),
            'isSidebarOpen': result.isSidebarOpen,
          });

      return result;
    } catch (e, stack) {
      AppLogger.error(
        'Error deserializing WorkBrowseState',
        tag: 'State',
        error: e,
        stackTrace: stack,
        data: {'json': json},
      );

      // 出错时返回默认状态
      return WorkBrowseState();
    }
  }
}

extension WorkBrowseStatePersistence on WorkBrowseState {
  static const String _keyWorkBrowseState = 'work_browse_state';

  Future<void> persist() async {
    try {
      AppLogger.debug('Persisting WorkBrowseState', tag: 'State');

      final prefs = await SharedPreferences.getInstance();
      final jsonData = toJson();
      final jsonString = jsonEncode(jsonData);
      await prefs.setString(_keyWorkBrowseState, jsonString);

      AppLogger.debug('WorkBrowseState persisted successfully', tag: 'State');
    } catch (e, stack) {
      AppLogger.error('Failed to persist WorkBrowseState',
          tag: 'State', error: e, stackTrace: stack);
    }
  }

  static Future<WorkBrowseState> restore() async {
    try {
      AppLogger.debug('Restoring WorkBrowseState', tag: 'State');

      final prefs = await SharedPreferences.getInstance();
      final jsonString = prefs.getString(_keyWorkBrowseState);

      if (jsonString == null) {
        AppLogger.debug('No saved WorkBrowseState found, using defaults',
            tag: 'State');
        return WorkBrowseState();
      }

      final jsonData = jsonDecode(jsonString) as Map<String, dynamic>;
      final state = WorkBrowseState.fromJson(jsonData);

      AppLogger.debug('WorkBrowseState restored successfully',
          tag: 'State', data: {'viewMode': state.viewMode.toString()});

      return state;
    } catch (e, stack) {
      AppLogger.error('Failed to restore WorkBrowseState',
          tag: 'State', error: e, stackTrace: stack);
      return WorkBrowseState();
    }
  }

  // 删除旧方法，我们现在使用更强大的JSON序列化方法
}



=======================================
./lib/presentation/viewmodels/states/work_import_state.dart
=======================================
import 'dart:io';

import '../../../domain/enums/work_style.dart';
import '../../../domain/enums/work_tool.dart';

/// 作品导入状态
class WorkImportState {
  final List<File> images;
  final File? selectedImage;
  final String title;
  final String? author;
  final WorkStyle? style;
  final WorkTool? tool;
  final DateTime? creationDate;
  final String? remark;
  final bool isProcessing;
  final String? error;
  final bool optimizeImages;
  final bool keepOriginals;
  final Map<String, double> imageRotations;
  final double scale;
  final double rotation;
  final int selectedImageIndex;

  const WorkImportState({
    this.images = const [],
    this.selectedImage,
    this.title = '',
    this.author = '',
    this.style,
    this.tool,
    this.creationDate,
    this.remark = '',
    this.isProcessing = false,
    this.error,
    this.optimizeImages = true,
    this.keepOriginals = false,
    this.imageRotations = const {},
    this.scale = 1.0,
    this.rotation = 0.0,
    this.selectedImageIndex = 0,
  });

  /// 获取干净的初始状态
  factory WorkImportState.clean() {
    return WorkImportState.initial().copyWith(
      images: const [],
      selectedImage: null,
      title: '',
      error: null,
      imageRotations: const {},
    );
  }

  factory WorkImportState.initial() {
    return WorkImportState(
      // 设置默认值
      style: WorkStyle.regular,
      tool: WorkTool.brush,
      creationDate: DateTime.now(), // 直接设置当前日期作为默认值
      author: '', // 提供空字符串而不是 null
      remark: '', // 提供空字符串而不是 null
      optimizeImages: true,
      keepOriginals: false,
      scale: 1.0,
      rotation: 0.0,
      selectedImageIndex: 0,
    );
  }
  bool get canSubmit => hasImages && !isProcessing;
  bool get hasError => error != null;
  bool get hasImages => images.isNotEmpty;

  bool get isDirty =>
      hasImages || title.isNotEmpty || author?.isNotEmpty == true;

  WorkImportState copyWith({
    List<File>? images,
    File? selectedImage,
    String? title,
    String? author,
    WorkStyle? style,
    WorkTool? tool,
    DateTime? creationDate,
    String? remark,
    bool? isProcessing,
    String? error,
    bool? optimizeImages,
    bool? keepOriginals,
    Map<String, double>? imageRotations,
    double? scale,
    double? rotation,
    int? selectedImageIndex,
  }) {
    return WorkImportState(
      images: images ?? this.images,
      selectedImage: selectedImage ?? this.selectedImage,
      title: title ?? this.title,
      author: author ?? this.author,
      style: style ?? this.style,
      tool: tool ?? this.tool,
      creationDate: creationDate ?? this.creationDate,
      remark: remark ?? this.remark,
      isProcessing: isProcessing ?? this.isProcessing,
      error: error,
      optimizeImages: optimizeImages ?? this.optimizeImages,
      keepOriginals: keepOriginals ?? this.keepOriginals,
      imageRotations: imageRotations ?? this.imageRotations,
      scale: scale ?? this.scale,
      rotation: rotation ?? this.rotation,
      selectedImageIndex: selectedImageIndex ?? this.selectedImageIndex,
    );
  }
}



=======================================
./lib/presentation/viewmodels/work_browse_view_model.dart
=======================================
import 'dart:async';

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../application/services/restoration/state_restoration_service.dart';
import '../../application/services/services.dart';
import '../../domain/models/common/date_range_filter.dart';
import '../../domain/models/work/work_filter.dart';
import '../../infrastructure/logging/logger.dart';
import '../../utils/throttle_helper.dart';
import 'states/work_browse_state.dart';

/// 作品浏览视图模型
class WorkBrowseViewModel extends StateNotifier<WorkBrowseState> {
  final WorkService _workService;
  final StateRestorationService _stateRestorationService;
  Timer? _searchDebounce;
  final ThrottleHelper _loadThrottler = ThrottleHelper(
    minInterval: const Duration(milliseconds: 500),
  );

  WorkBrowseViewModel(this._workService, this._stateRestorationService)
      : super(WorkBrowseState(
          isLoading: false,
          filter: const WorkFilter(),
          works: const [],
          requestStatus: LoadRequestStatus.idle,
          searchQuery: '',
        )) {
    Future.microtask(() => _initializeData());
  }

  void clearSelection() {
    state = state.copyWith(selectedWorks: {});
  }

  Future<void> deleteSelected() async {
    if (state.selectedWorks.isEmpty) return;

    AppLogger.debug('开始批量删除',
        tag: 'WorkBrowseViewModel',
        data: {'selectedCount': state.selectedWorks.length});

    try {
      state = state.copyWith(isLoading: true);

      // 1. 执行删除操作
      await Future.wait(
          state.selectedWorks.map((id) => _workService.deleteWork(id)));

      AppLogger.debug('删除完成，准备刷新列表', tag: 'WorkBrowseViewModel');

      // 2. 重新加载作品列表
      final works = await _workService.queryWorks(state.filter);

      // 3. 更新状态
      state = state.copyWith(
        isLoading: false,
        works: works,
        batchMode: false, // 删除后退出批量模式
        selectedWorks: {}, // 清空选择
      );
    } catch (e, stack) {
      AppLogger.error('批量删除失败',
          tag: 'WorkBrowseViewModel', error: e, stackTrace: stack);

      state = state.copyWith(
        isLoading: false,
        error: e.toString(),
      );
    }
  }

  @override
  void dispose() {
    _searchDebounce?.cancel();
    _loadThrottler.cancel();
    _saveState();
    super.dispose();
  }

  // 加载相关方法
  Future<void> loadWorks({bool forceRefresh = false}) async {
    if (state.isLoading && !forceRefresh) return;

    AppLogger.debug('触发加载流程',
        tag: 'WorkBrowseViewModel', data: {'forceRefresh': forceRefresh});

    state = state.copyWith(
      isLoading: true,
      error: null,
      requestStatus: LoadRequestStatus.loading,
    );

    try {
      final works = await _workService.queryWorks(state.filter);

      state = state.copyWith(
        works: works,
        isLoading: false,
        error: null,
        requestStatus: LoadRequestStatus.idle,
      );

      AppLogger.debug('加载完成',
          tag: 'WorkBrowseViewModel', data: {'worksCount': works.length});
    } catch (e, stack) {
      _handleLoadError(e, stack);
    }
  }

  // 搜索相关方法
  void setSearchQuery(String query) {
    AppLogger.debug('设置搜索关键词',
        tag: 'WorkBrowseViewModel', data: {'query': query});

    if (_searchDebounce?.isActive ?? false) {
      _searchDebounce?.cancel();
    }

    _searchDebounce = Timer(const Duration(milliseconds: 500), () {
      final newFilter = state.filter.copyWith(keyword: query.trim());
      updateFilter(newFilter);
    });
  }

  void setViewMode(ViewMode mode) {
    state = state.copyWith(viewMode: mode);
    _saveState();
  }

  // 批量操作相关方法
  void toggleBatchMode() {
    AppLogger.debug('切换批量模式',
        tag: 'WorkBrowseViewModel', data: {'currentMode': state.batchMode});

    state = state.copyWith(
      batchMode: !state.batchMode,
      selectedWorks: {}, // 退出批量模式时清空选择
    );
  }

  void toggleSelection(String workId) {
    final newSelection = Set<String>.from(state.selectedWorks);
    if (newSelection.contains(workId)) {
      newSelection.remove(workId);
    } else {
      newSelection.add(workId);
    }

    AppLogger.debug('切换选择状态',
        tag: 'WorkBrowseViewModel',
        data: {'workId': workId, 'selected': newSelection.contains(workId)});

    state = state.copyWith(selectedWorks: newSelection);
  }

  void toggleSidebar() {
    state = state.copyWith(isSidebarOpen: !state.isSidebarOpen);
    _saveState();
  }

  // 视图相关方法
  void toggleViewMode() {
    state = state.copyWith(
      viewMode: state.viewMode == ViewMode.grid ? ViewMode.list : ViewMode.grid,
    );
    _saveState();
  }

  void updateDatePreset(DateRangePreset? preset) {
    if (preset == null || preset == DateRangePreset.all) {
      // 清除所有日期相关的筛选条件
      final newFilter = state.filter.copyWith(
        datePreset: DateRangePreset.all,
        dateRange: null,
      );
      updateFilter(newFilter);
      return;
    }

    final newFilter = state.filter.copyWith(
      datePreset: preset,
      dateRange: null,
    );
    updateFilter(newFilter);
  }

  void updateDateRange(DateTimeRange? range) {
    if (range == null) {
      // 清除所有日期相关的筛选条件
      final newFilter = state.filter.copyWith(
        datePreset: DateRangePreset.all,
        dateRange: null,
      );
      updateFilter(newFilter);
      return;
    }

    final newFilter = state.filter.copyWith(
      dateRange: range,
      datePreset: DateRangePreset.all, // 使用自定义时需要清除预设
    );
    updateFilter(newFilter);
  }

  // 筛选相关方法
  void updateFilter(WorkFilter? filter) {
    AppLogger.debug(
      '更新筛选条件',
      tag: 'WorkBrowseViewModel',
      data: {
        'oldFilter': state.filter.toString(),
        'newFilter': filter?.toString() ?? 'null',
      },
    );

    if (filter == null) {
      // 清除所有筛选条件
      final newFilter = state.filter.copyWith(
        datePreset: DateRangePreset.all,
        dateRange: null,
        keyword: null, // 确保清除搜索关键词
      );

      state = state.copyWith(
        works: [],
        filter: newFilter,
        page: 1,
        hasMore: true,
        error: null,
      );
    } else {
      state = state.copyWith(
        works: [],
        filter: filter,
        page: 1,
        hasMore: true,
        error: null,
      );
    }

    loadWorks(forceRefresh: true);
  }

  void _handleLoadError(dynamic error, StackTrace stack) {
    AppLogger.error('加载作品列表失败',
        tag: 'WorkBrowseViewModel', error: error, stackTrace: stack);

    state = state.copyWith(
      isLoading: false,
      error: error.toString(),
      requestStatus: LoadRequestStatus.idle,
    );
  }

  Future<void> _initializeData() async {
    try {
      AppLogger.info('初始化作品浏览页数据',
          tag: 'WorkBrowseViewModel',
          data: {'initialFilter': state.filter.toString()});

      state = state.copyWith(
        isLoading: true,
        error: null,
        filter: const WorkFilter(),
        works: const [],
      );

      await loadWorks(forceRefresh: true);
    } catch (e, stack) {
      _handleLoadError(e, stack);
    }
  }

  void _saveState() {
    try {
      _stateRestorationService.saveWorkBrowseState(state);
    } catch (e, stack) {
      AppLogger.error(
        'Failed to save work browse state',
        tag: 'WorkBrowseViewModel',
        error: e,
        stackTrace: stack,
      );
    }
  }
}



=======================================
./lib/presentation/viewmodels/work_import_view_model.dart
=======================================
import 'dart:io';

import 'package:file_picker/file_picker.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:uuid/uuid.dart';

import '../../application/services/work/work_service.dart';
import '../../domain/enums/work_style.dart';
import '../../domain/enums/work_tool.dart';
import '../../domain/models/work/work_entity.dart';
import '../../infrastructure/image/image_processor.dart';
import 'states/work_import_state.dart';

/// 作品导入视图模型
class WorkImportViewModel extends StateNotifier<WorkImportState> {
  final WorkService _workService;
  final ImageProcessor _imageProcessor;

  WorkImportViewModel(this._workService, this._imageProcessor)
      : super(WorkImportState.initial());

  /// 判断是否可以保存
  bool get canSubmit {
    return state.hasImages &&
        state.title.trim().isNotEmpty &&
        !state.isProcessing;
  }

  /// 添加图片
  Future<void> addImages([List<File>? files]) async {
    try {
      state = state.copyWith(error: null);

      // 如果没有传入文件，则打开文件选择器
      if (files == null || files.isEmpty) {
        final result = await FilePicker.platform.pickFiles(
          type: FileType.image,
          allowMultiple: true,
        );

        if (result == null || result.files.isEmpty) {
          return;
        }

        files = result.files
            .where((file) => file.path != null)
            .map((file) => File(file.path!))
            .toList();

        if (files.isEmpty) return;
      }

      state = state.copyWith(
        isProcessing: true,
        error: null,
      );

      state = state.copyWith(
        images: [...state.images, ...files],
        isProcessing: false,
      );
    } catch (e) {
      state = state.copyWith(
        isProcessing: false,
        error: '添加图片失败: $e',
      );
    }
  }

  /// 清理状态（关闭对话框时调用）
  void cleanup() {
    reset();
  }

  /// 导入作品
  Future<bool> importWork() async {
    if (!canSubmit) return false;

    try {
      state = state.copyWith(isProcessing: true, error: null);

      // 创建新的作品实体
      final work = WorkEntity(
        id: const Uuid().v4(),
        title: state.title.trim(),
        author: state.author?.trim() ?? '',
        style: state.style ?? WorkStyle.other,
        tool: state.tool ?? WorkTool.other,
        creationDate: state.creationDate ?? DateTime.now(),
        remark: state.remark?.trim(),
        createTime: DateTime.now(),
        updateTime: DateTime.now(),
      );

      // 执行导入操作
      await _workService.importWork(state.images, work);

      // 导入成功后重置状态
      reset();
      return true;
    } catch (e) {
      state = state.copyWith(
        isProcessing: false,
        error: '导入失败: $e',
      );
      return false;
    }
  }

  /// 初始化现有作品的图片
  Future<void> initialize(List<File> images) async {
    if (images.isEmpty) return;

    try {
      state = state.copyWith(
        images: images,
        isProcessing: true,
        error: null,
      );

      state = state.copyWith(
        selectedImageIndex: 0,
        isProcessing: false,
      );
    } catch (e) {
      state = state.copyWith(
        isProcessing: false,
        error: '初始化图片失败: $e',
      );
    }
  }

  /// 删除图片
  void removeImage(int index) {
    if (index < 0 || index >= state.images.length) return;

    final newImages = List<File>.from(state.images);
    newImages.removeAt(index);

    // 如果删除的是当前选中项，需要更新选中索引
    final newSelectedIndex = _calculateNewSelectedIndex(
      oldIndex: index,
      maxIndex: newImages.length - 1,
    );

    state = state.copyWith(
      images: newImages,
      selectedImageIndex: newSelectedIndex,
    );
  }

  /// 重新排序图片
  void reorderImages(int oldIndex, int newIndex) {
    if (oldIndex < 0 ||
        oldIndex >= state.images.length ||
        newIndex < 0 ||
        newIndex > state.images.length) return;

    final images = List<File>.from(state.images);
    final item = images.removeAt(oldIndex);
    final adjustedNewIndex = newIndex > oldIndex ? newIndex - 1 : newIndex;
    images.insert(adjustedNewIndex, item);

    state = state.copyWith(
      images: images,
      selectedImageIndex: _calculateNewSelectedIndex(
        oldIndex: oldIndex,
        newIndex: adjustedNewIndex,
        maxIndex: images.length - 1,
      ),
    );
  }

  /// 重置状态
  void reset() {
    state = WorkImportState.clean();
  }

  /// 选择图片
  void selectImage(int index) {
    if (index < 0 || index >= state.images.length) return;
    state = state.copyWith(selectedImageIndex: index);
  }

  /// 设置作者
  void setAuthor(String? author) {
    state = state.copyWith(author: author?.trim() ?? '');
  }

  /// 设置创作日期
  void setCreationDate(DateTime? date) {
    state = state.copyWith(creationDate: date);
  }

  /// 设置备注
  void setRemark(String? remark) {
    state = state.copyWith(remark: remark?.trim() ?? '');
  }

  /// 设置画风
  void setStyle(String? styleStr) {
    if (styleStr == null) return;

    final style = WorkStyle.values.firstWhere(
      (s) => s.toString().split('.').last == styleStr,
      orElse: () => WorkStyle.other,
    );
    state = state.copyWith(style: style);
  }

  /// 设置标题
  void setTitle(String? title) {
    state = state.copyWith(title: title?.trim() ?? '');
  }

  /// 设置创作工具
  void setTool(String? toolStr) {
    if (toolStr == null) return;

    final tool = WorkTool.values.firstWhere(
      (t) => t.toString().split('.').last == toolStr,
      orElse: () => WorkTool.other,
    );
    state = state.copyWith(tool: tool);
  }

  /// 计算新的选中索引
  int _calculateNewSelectedIndex({
    required int oldIndex,
    int? newIndex,
    required int maxIndex,
  }) {
    int selectedIndex = state.selectedImageIndex;

    // 重新排序时的索引计算
    if (newIndex != null) {
      if (selectedIndex == oldIndex) {
        return newIndex;
      }
      if (selectedIndex > oldIndex && selectedIndex <= newIndex) {
        return selectedIndex - 1;
      }
      if (selectedIndex < oldIndex && selectedIndex >= newIndex) {
        return selectedIndex + 1;
      }
      return selectedIndex;
    }

    // 删除时的索引计算
    if (selectedIndex == oldIndex) {
      return maxIndex >= 0 ? maxIndex : 0;
    }
    if (selectedIndex > oldIndex) {
      return selectedIndex - 1;
    }
    return selectedIndex;
  }
}



=======================================
./lib/presentation/widgets/base_page.dart
=======================================
import 'package:flutter/material.dart';

import '../../theme/app_sizes.dart';

class BasePage extends StatelessWidget {
  final String title;
  final List<Widget>? actions;
  final Widget? toolbar;
  final Widget body;
  final Widget? sidebar;
  final Widget? footer;

  const BasePage({
    super.key,
    required this.title,
    this.actions,
    this.toolbar,
    required this.body,
    this.sidebar,
    this.footer,
  });

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text(title),
        actions: actions,
        toolbarHeight: AppSizes.appBarHeight,
      ),
      body: Row(
        children: [
          if (sidebar != null)
            SizedBox(
              width: AppSizes.sidebarWidth,
              child: sidebar!,
            ),
          Expanded(
            child: Column(
              children: [
                if (toolbar != null)
                  SizedBox(
                    height: AppSizes.appBarHeight,
                    child: toolbar!,
                  ),
                Expanded(child: body),
                if (footer != null)
                  SizedBox(
                    height: AppSizes.tableHeaderHeight,
                    child: footer!,
                  ),
              ],
            ),
          ),
        ],
      ),
    );
  }
}



=======================================
./lib/presentation/widgets/character/character_detail_view.dart
=======================================
import 'package:flutter/material.dart';

class CharacterDetailView extends StatelessWidget {
  final String charId;
  final bool showCloseButton;
  final VoidCallback? onClose;

  const CharacterDetailView({
    super.key,
    required this.charId,
    this.showCloseButton = false,
    this.onClose,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Container(
      color: theme.scaffoldBackgroundColor,
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          if (!showCloseButton) ...[
            Padding(
              padding: const EdgeInsets.all(16.0),
              child: Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  Text(
                    '字符详情',
                    style: theme.textTheme.titleLarge,
                  ),
                  ElevatedButton.icon(
                    onPressed: () {},
                    icon: const Icon(Icons.edit),
                    label: const Text('编辑'),
                  ),
                ],
              ),
            ),
            const Divider(height: 1),
          ],
          Expanded(
            child: ListView(
              padding: const EdgeInsets.all(16.0),
              children: [
                Card(
                  child: Padding(
                    padding: const EdgeInsets.all(16.0),
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text('基本信息', style: theme.textTheme.titleMedium),
                        const SizedBox(height: 16),
                        _buildInfoRow('Unicode', 'U+4E00', theme),
                        _buildInfoRow('拼音', 'yī', theme),
                        _buildInfoRow('笔画', '1', theme),
                      ],
                    ),
                  ),
                ),
                const SizedBox(height: 16),
                Card(
                  child: Padding(
                    padding: const EdgeInsets.all(16.0),
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text('出处信息', style: theme.textTheme.titleMedium),
                        const SizedBox(height: 16),
                        _buildInfoRow('作品', '兰亭集序', theme),
                        _buildInfoRow('作者', '王羲之', theme),
                        _buildInfoRow('朝代', '晋', theme),
                      ],
                    ),
                  ),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildInfoRow(String label, String value, ThemeData theme) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 8.0),
      child: Row(
        children: [
          SizedBox(
            width: 80,
            child: Text(
              label,
              style: theme.textTheme.bodyMedium?.copyWith(
                color: theme.textTheme.bodySmall?.color,
              ),
            ),
          ),
          Expanded(
            child: Text(
              value,
              style: theme.textTheme.bodyMedium,
            ),
          ),
        ],
      ),
    );
  }
}



=======================================
./lib/presentation/widgets/character/character_extraction_panel.dart
=======================================
import 'package:flutter/material.dart';

class CharacterExtractionPanel extends StatefulWidget {
  final String workId;
  final int imageIndex;
  
  const CharacterExtractionPanel({
    super.key,
    required this.workId,
    required this.imageIndex,
  });

  @override
  State<CharacterExtractionPanel> createState() => _CharacterExtractionPanelState();
}

class _CharacterExtractionPanelState extends State<CharacterExtractionPanel> {
  bool _autoRecognitionEnabled = true;
  double _noiseReduction = 0.5;
  double _binarization = 0.5;
  double _grayScale = 0.5;
  String _selectedTool = 'select'; // select, rect, lasso
  final List<Rect> _selectedRegions = [];
  final PageController _pageController = PageController();
  int _currentPage = 0;
  List<String> _pages = []; // 存储所有页面的图片路径

  @override
  void initState() {
    super.initState();
    // TODO: 加载实际的页面数据
    _pages = List.generate(5, (index) => 'Page ${index + 1}');
  }

  @override
  void dispose() {
    _pageController.dispose();
    super.dispose();
  }
  
  @override
  Widget build(BuildContext context) {
    return Material(
      child: Column(
        children: [
          _buildTopToolbar(),
          Expanded(
            child: Row(
              children: [
                _buildLeftToolbar(),
                Expanded(
                  child: _buildPreviewArea(),
                ),
                _buildRightPanel(),
              ],
            ),
          ),
          _buildStatusBar(),
        ],
      ),
    );
  }

  Widget _buildTopToolbar() {
    return Container(
      height: 48,
      padding: const EdgeInsets.symmetric(horizontal: 16),
      decoration: BoxDecoration(
        border: Border(bottom: BorderSide(color: Colors.grey[300]!)),
      ),
      child: Row(
        children: [
          IconButton(
            icon: const Icon(Icons.close),
            onPressed: () => Navigator.pop(context),
            tooltip: '退出',
          ),
          const VerticalDivider(),
          // 预处理工具组
          Row(
            children: [
              Switch(
                value: _autoRecognitionEnabled,
                onChanged: (value) => setState(() => _autoRecognitionEnabled = value),
              ),
              const Text('自动识别笔画'),
              const SizedBox(width: 16),
              _buildSlider('降噪', _noiseReduction),
              _buildSlider('二值化', _binarization),
              _buildSlider('灰度范围', _grayScale),
              TextButton(
                onPressed: _resetPreprocess,
                child: const Text('重置'),
              ),
            ],
          ),
          const Spacer(),
          // 操作工具组
          IconButton(
            icon: const Icon(Icons.clear),
            onPressed: _clearSelection,
            tooltip: '清空选择',
          ),
          IconButton(
            icon: const Icon(Icons.undo),
            onPressed: _undo,
            tooltip: '撤销',
          ),
          IconButton(
            icon: const Icon(Icons.redo),
            onPressed: _redo,
            tooltip: '重做',
          ),
        ],
      ),
    );
  }

  Widget _buildLeftToolbar() {
    return Container(
      width: 48,
      decoration: BoxDecoration(
        border: Border(right: BorderSide(color: Colors.grey[300]!)),
      ),
      child: Column(
        children: [
          // 选择工具
          IconButton(
            icon: const Icon(Icons.touch_app),
            onPressed: () => setState(() => _selectedTool = 'select'),
            isSelected: _selectedTool == 'select',
            tooltip: '点击选择',
          ),
          IconButton(
            icon: const Icon(Icons.crop_square),
            onPressed: () => setState(() => _selectedTool = 'rect'),
            isSelected: _selectedTool == 'rect',
            tooltip: '矩形框选',
          ),
          IconButton(
            icon: const Icon(Icons.gesture),
            onPressed: () => setState(() => _selectedTool = 'lasso'),
            isSelected: _selectedTool == 'lasso',
            tooltip: '套索选择',
          ),
          const Divider(),
          // 视图工具
          IconButton(
            icon: const Icon(Icons.zoom_in),
            onPressed: _zoomIn,
            tooltip: '放大',
          ),
          IconButton(
            icon: const Icon(Icons.zoom_out),
            onPressed: _zoomOut,
            tooltip: '缩小',
          ),
        ],
      ),
    );
  }

  Widget _buildPreviewArea() {
    return Column(
      children: [
        // 工具栏
        // ...existing code...

        // 主预览区（支持左右滑动）
        Expanded(
          child: Row(
            children: [
              // 左翻页按钮
              IconButton(
                icon: const Icon(Icons.chevron_left),
                onPressed: _currentPage > 0
                    ? () {
                        _pageController.previousPage(
                          duration: const Duration(milliseconds: 300),
                          curve: Curves.easeInOut,
                        );
                      }
                    : null,
              ),
              // 中央预览区
              Expanded(
                child: Stack(
                  children: [
                    PageView.builder(
                      controller: _pageController,
                      onPageChanged: (index) {
                        setState(() => _currentPage = index);
                      },
                      itemCount: _pages.length,
                      itemBuilder: (context, index) {
                        return Container(
                          color: Colors.grey[100],
                          child: Center(
                            child: Text('${_pages[index]} 预览区域'),
                          ),
                        );
                      },
                    ),
                    // 页码指示器
                    Positioned(
                      bottom: 16,
                      left: 0,
                      right: 0,
                      child: Row(
                        mainAxisAlignment: MainAxisAlignment.center,
                        children: [
                          Container(
                            padding: const EdgeInsets.symmetric(
                              horizontal: 12,
                              vertical: 4,
                            ),
                            decoration: BoxDecoration(
                              color: Colors.black54,
                              borderRadius: BorderRadius.circular(12),
                            ),
                            child: Text(
                              '${_currentPage + 1} / ${_pages.length}',
                              style: const TextStyle(
                                color: Colors.white,
                                fontSize: 12,
                              ),
                            ),
                          ),
                        ],
                      ),
                    ),
                  ],
                ),
              ),
              // 右翻页按钮
              IconButton(
                icon: const Icon(Icons.chevron_right),
                onPressed: _currentPage < _pages.length - 1
                    ? () {
                        _pageController.nextPage(
                          duration: const Duration(milliseconds: 300),
                          curve: Curves.easeInOut,
                        );
                      }
                    : null,
              ),
            ],
          ),
        ),
        // 底部缩略图导航栏
        SizedBox(
          height: 80,
          child: ListView.builder(
            scrollDirection: Axis.horizontal,
            itemCount: _pages.length,
            itemBuilder: (context, index) {
              final isSelected = index == _currentPage;
              return GestureDetector(
                onTap: () {
                  _pageController.animateToPage(
                    index,
                    duration: const Duration(milliseconds: 300),
                    curve: Curves.easeInOut,
                  );
                },
                child: Container(
                  width: 60,
                  margin: const EdgeInsets.all(4),
                  decoration: BoxDecoration(
                    border: Border.all(
                      color: isSelected
                          ? Theme.of(context).primaryColor
                          : Colors.transparent,
                      width: 2,
                    ),
                  ),
                  child: Center(
                    child: Text('${index + 1}'),
                  ),
                ),
              );
            },
          ),
        ),
      ],
    );
  }

  Widget _buildRightPanel() {
    return Container(
      width: 300,
      decoration: BoxDecoration(
        border: Border(left: BorderSide(color: Colors.grey[300]!)),
      ),
      child: Column(
        children: [
          // 结果预览
          Expanded(
            child: Container(
              padding: const EdgeInsets.all(16),
              child: Column(
                children: [
                  const Text('集字预览'),
                  Expanded(
                    child: Container(
                      margin: const EdgeInsets.all(16),
                      decoration: BoxDecoration(
                        color: Colors.white,
                        border: Border.all(color: Colors.grey[300]!),
                      ),
                      child: const Center(
                        child: Text('预览结果'),
                      ),
                    ),
                  ),
                ],
              ),
            ),
          ),
          const Divider(height: 1),
          // 登记信息
          Container(
            padding: const EdgeInsets.all(16),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.stretch,
              children: [
                const TextField(
                  decoration: InputDecoration(
                    labelText: '简体字 *',
                    border: OutlineInputBorder(),
                  ),
                  maxLength: 1,
                ),
                const SizedBox(height: 16),
                DropdownButtonFormField<String>(
                  decoration: const InputDecoration(
                    labelText: '风格',
                    border: OutlineInputBorder(),
                  ),
                  items: const [
                    DropdownMenuItem(value: 'kai', child: Text('楷书')),
                    DropdownMenuItem(value: 'xing', child: Text('行书')),
                  ],
                  onChanged: (value) {},
                ),
                const SizedBox(height: 16),
                DropdownButtonFormField<String>(
                  decoration: const InputDecoration(
                    labelText: '工具',
                    border: OutlineInputBorder(),
                  ),
                  items: const [
                    DropdownMenuItem(value: 'brush', child: Text('毛笔')),
                    DropdownMenuItem(value: 'pen', child: Text('硬笔')),
                  ],
                  onChanged: (value) {},
                ),
                const SizedBox(height: 24),
                ElevatedButton(
                  onPressed: _saveCharacter,
                  child: const Text('保存集字'),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildStatusBar() {
    return Container(
      height: 24,
      padding: const EdgeInsets.symmetric(horizontal: 16),
      decoration: BoxDecoration(
        border: Border(top: BorderSide(color: Colors.grey[300]!)),
      ),
      child: Row(
        children: [
          Text('当前工具: $_selectedTool'),
          const Spacer(),
          Text('已选择区域: ${_selectedRegions.length}'),
        ],
      ),
    );
  }

  Widget _buildSlider(String label, double value) {
    return Row(
      mainAxisSize: MainAxisSize.min,
      children: [
        Text(label),
        SizedBox(
          width: 100,
          child: Slider(
            value: value,
            onChanged: (v) => setState(() {
              switch (label) {
                case '降噪':
                  _noiseReduction = v;
                  break;
                case '二值化':
                  _binarization = v;
                  break;
                case '灰度范围':
                  _grayScale = v;
                  break;
              }
            }),
          ),
        ),
      ],
    );
  }

  void _resetPreprocess() {
    setState(() {
      _noiseReduction = 0.5;
      _binarization = 0.5;
      _grayScale = 0.5;
    });
  }

  void _clearSelection() {
    setState(() => _selectedRegions.clear());
  }

  void _undo() {
    // TODO: 实现撤销功能
  }

  void _redo() {
    // TODO: 实现重做功能
  }

  void _zoomIn() {
    // TODO: 实现放大功能
  }

  void _zoomOut() {
    // TODO: 实现缩小功能
  }

  void _handleTap(TapDownDetails details) {
    // TODO: 实现点击选择功能
  }

  void _handlePanStart(DragStartDetails details) {
    // TODO: 实现拖动开始
  }

  void _handlePanUpdate(DragUpdateDetails details) {
    // TODO: 实现拖动更新
  }

  void _handlePanEnd(DragEndDetails details) {
    // TODO: 实现拖动结束
  }

  void _saveCharacter() {
    // TODO: 实现保存集字功能
  }
}

class CharacterExtractionPainter extends CustomPainter {
  final List<Rect> regions;
  final String currentTool;

  CharacterExtractionPainter({
    required this.regions,
    required this.currentTool,
  });

  @override
  void paint(Canvas canvas, Size size) {
    // TODO: 实现绘制功能
  }

  @override
  bool shouldRepaint(covariant CustomPainter oldDelegate) => true;
}



=======================================
./lib/presentation/widgets/character_collection/character_collection_panel.dart
=======================================
import 'package:flutter/material.dart';

import '../../../domain/models/character/character_region.dart';
import './character_extraction_preview.dart';

class CharacterCollectionPanel extends StatefulWidget {
  final String imageId;
  final String workTitle;
  final List<String> images;

  const CharacterCollectionPanel({
    super.key,
    required this.imageId,
    required this.workTitle,
    required this.images,
  });

  @override
  State<CharacterCollectionPanel> createState() =>
      _CharacterCollectionPanelState();
}

class _CharacterCollectionPanelState extends State<CharacterCollectionPanel> {
  final List<CharacterRegion> _collectedRegions = [];

  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        // 工具栏
        Container(
          height: kToolbarHeight,
          padding: const EdgeInsets.symmetric(horizontal: 16),
          child: Row(
            children: [
              const BackButton(),
              Text(
                widget.workTitle,
                style: Theme.of(context).textTheme.titleMedium,
              ),
              const Spacer(),
              Text(
                '已提取: ${_collectedRegions.length}个字符',
                style: Theme.of(context).textTheme.bodyMedium,
              ),
            ],
          ),
        ),

        // 主要内容区域
        Expanded(
          child: CharacterExtractionPreview(
            imagePaths: widget.images,
            collectedRegions: _collectedRegions,
            onRegionCreated: (region) {
              setState(() {
                _collectedRegions.add(region);
              });
            },
            onRegionSelected: (region) {
              // 可以在这里处理区域选中事件
            },
            onRegionsDeleted: (regions) {
              setState(() {
                _collectedRegions.removeWhere((r) => regions.contains(r));
              });
            },
            workId: widget.imageId,
          ),
        ),
      ],
    );
  }
}



=======================================
./lib/presentation/widgets/character_collection/character_extraction_preview.dart
=======================================
import 'dart:io';
import 'dart:math' as math;

import 'package:flutter/material.dart';
import 'package:flutter/rendering.dart';
import 'package:flutter/services.dart';

import '../../../application/services/image/character_image_processor.dart';
import '../../../domain/models/character/character_region.dart';
import '../../../domain/repositories/character_repository.dart';
import 'character_preview_panel.dart';
import 'region_painter.dart';
import 'region_properties_dialog.dart';

class CharacterExtractionPreview extends StatefulWidget {
  final List<String> imagePaths;
  final int initialIndex;
  final Function(int)? onIndexChanged;
  final bool showThumbnails;
  final bool enableZoom;
  final BoxDecoration? previewDecoration;
  final EdgeInsets? padding;
  final List<CharacterRegion>? collectedRegions;
  final Function(CharacterRegion)? onRegionCreated;
  final Function(CharacterRegion)? onRegionSelected;
  final Function(List<CharacterRegion>)? onRegionsDeleted;
  final String? workId;

  const CharacterExtractionPreview({
    super.key,
    required this.imagePaths,
    this.initialIndex = 0,
    this.onIndexChanged,
    this.showThumbnails = true,
    this.enableZoom = true,
    this.previewDecoration,
    this.padding,
    this.collectedRegions,
    this.onRegionCreated,
    this.onRegionSelected,
    this.onRegionsDeleted,
    this.workId,
  });

  @override
  State<CharacterExtractionPreview> createState() =>
      _CharacterExtractionPreviewState();
}

class _CharacterExtractionPreviewState extends State<CharacterExtractionPreview>
    with WidgetsBindingObserver {
  static const double _minRegionSize = 20.0;
  static const double _minZoomScale = 0.1;
  static const double _maxZoomScale = 10.0;
  static const EdgeInsets _viewerPadding = EdgeInsets.all(20.0);

  final TransformationController _transformationController =
      TransformationController();
  final ScrollController _scrollController = ScrollController();
  final Set<CharacterRegion> _selectedRegions = {};

  final _state = _PreviewState();
  late final CharacterRepository _repository;

  @override
  Widget build(BuildContext context) {
    return Row(
      children: [
        // Main image preview area (takes 75% of the width)
        Expanded(
          flex: 75,
          child: Column(
            children: [
              _buildToolbar(),
              Expanded(
                child: _buildPreviewArea(),
              ),
            ],
          ),
        ),

        // Right preview panel (takes 25% of the width)
        SizedBox(
          width: 300, // Fixed width for preview panel
          child: Padding(
            padding: const EdgeInsets.all(16.0),
            child: CharacterPreviewPanel(
              region: _state.selectedRegion,
              label: _state.selectedRegion?.label,
              onClear: () {
                if (_state.selectedRegion == null) return;
                _handleRegionOperation(() {
                  _preserveAndUpdateState(() {
                    _state.selectedRegion = _state.selectedRegion!.copyWith(
                      isSaved: false,
                    );
                    if (widget.onRegionSelected != null) {
                      widget.onRegionSelected!(_state.selectedRegion!);
                    }
                  });
                  return Future<void>.value();
                }, errorMessage: '清除失败');
              },
              onSave: () => _showSaveDialog(_state.selectedRegion),
            ),
          ),
        ),
      ],
    );
  }

  @override
  void didChangeAppLifecycleState(AppLifecycleState state) {
    if (state == AppLifecycleState.paused) {
    } else if (state == AppLifecycleState.resumed) {}
  }

  @override
  void dispose() {
    WidgetsBinding.instance.removeObserver(this);
    _transformationController.dispose();
    _scrollController.dispose();
    _selectedRegions.clear();
    _state.reset();

    super.dispose();
  }

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addObserver(this);
    _initializeRepository();
    _state.currentIndex = widget.initialIndex;
  }

  void _announceStateChange(String message) {
    SemanticsService.announce(message, TextDirection.ltr);
  }

  Widget _buildBoxSelectionTool() {
    return MergeSemantics(
      child: Semantics(
        button: true,
        label: '框选工具',
        value: _state.isBoxSelectionMode ? '已开启' : '未开启',
        hint: _state.isBoxSelectionMode ? '点击关闭框选模式' : '点击开启框选模式',
        enabled: true,
        child: IconButton(
          icon: Icon(
            _state.isBoxSelectionMode ? Icons.crop_din : Icons.crop_free,
            color: _state.isBoxSelectionMode
                ? Theme.of(context).primaryColor
                : null,
          ),
          onPressed: () {
            HapticFeedback.selectionClick();
            _preserveAndUpdateState(() {
              _state.isBoxSelectionMode = !_state.isBoxSelectionMode;
              if (!_state.isBoxSelectionMode) {
                _clearSelection();
              }
              _announceStateChange(
                  '框选工具${_state.isBoxSelectionMode ? '已开启' : '已关闭'}');
            });
          },
          tooltip: '框选工具',
        ),
      ),
    );
  }

  Widget _buildDeleteButton() {
    return MergeSemantics(
      child: Semantics(
        button: true,
        label: '删除选中区域',
        value: '${_selectedRegions.length}个区域',
        hint: '点击删除所有选中的区域',
        enabled: true,
        child: IconButton(
          icon: const Icon(Icons.delete),
          onPressed: _deleteSelectedRegions,
          tooltip: '删除选中区域',
        ),
      ),
    );
  }

  Widget _buildImageViewer() {
    return MouseRegion(
      cursor: _getCursor(),
      child: GestureDetector(
        onTapDown: _handleTapDown,
        onTapUp: _handleTapUp,
        onDoubleTap: _handleDoubleTap,
        onPanStart:
            _state.isBoxSelectionMode ? _handlePanStart : _handleRegionStart,
        onPanUpdate:
            _state.isBoxSelectionMode ? _handlePanUpdate : _handleRegionUpdate,
        onPanEnd: _state.isBoxSelectionMode ? _handlePanEnd : _handleRegionEnd,
        onSecondaryTapDown: (_) {
          HapticFeedback.lightImpact();
          _cleanupState();
          _announceStateChange('清除所有状态');
        },
        child: InteractiveViewer(
          transformationController: _transformationController,
          boundaryMargin: _viewerPadding,
          minScale: _minZoomScale,
          maxScale: _maxZoomScale,
          constrained: widget.enableZoom,
          child: Stack(
            children: [
              Center(child: _buildMainImage()),
              if (widget.collectedRegions != null) ..._buildRegions(),
              if (_state.selectionStart != null &&
                  _state.selectionCurrent != null)
                _buildSelectionOverlay(),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildMainImage() {
    return Image.file(
      File(widget.imagePaths[_state.currentIndex]),
      fit: BoxFit.contain,
      errorBuilder: (context, error, stackTrace) {
        _showErrorMessage('图片加载失败');
        return const Center(
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              Icon(Icons.broken_image, size: 64, color: Colors.red),
              SizedBox(height: 16),
              Text('图片加载失败', style: TextStyle(color: Colors.red)),
            ],
          ),
        );
      },
    );
  }

  Widget _buildMultiSelectTool() {
    return MergeSemantics(
      child: Semantics(
        button: true,
        label: '多选工具',
        value: _state.isMultiSelectMode ? '已开启' : '未开启',
        hint: _state.isMultiSelectMode ? '点击关闭多选模式' : '点击开启多选模式',
        enabled: true,
        child: IconButton(
          icon: Icon(
            _state.isMultiSelectMode ? Icons.select_all : Icons.touch_app,
            color: _state.isMultiSelectMode
                ? Theme.of(context).primaryColor
                : null,
          ),
          onPressed: () {
            HapticFeedback.selectionClick();
            _preserveAndUpdateState(() {
              _state.isMultiSelectMode = !_state.isMultiSelectMode;
              if (!_state.isMultiSelectMode) {
                _selectedRegions.clear();
                _state.selectedRegion = null;
              }
              _announceStateChange(
                  '多选模式${_state.isMultiSelectMode ? '已开启' : '已关闭'}');
            });
          },
          tooltip: '多选工具',
        ),
      ),
    );
  }

  Widget _buildPreviewArea() {
    return Container(
      decoration: widget.previewDecoration ??
          BoxDecoration(
            border: Border.all(color: Colors.grey.shade300),
            borderRadius: BorderRadius.circular(4),
          ),
      child: widget.imagePaths.isNotEmpty
          ? _buildImageViewer()
          : const Center(child: Text('没有图片')),
    );
  }

  List<Widget> _buildRegions() {
    return widget.collectedRegions
            ?.where((region) => region.pageIndex == _state.currentIndex)
            .map((region) => MergeSemantics(
                  child: Semantics(
                    label: region.label ?? '未命名区域',
                    selected: _selectedRegions.contains(region),
                    enabled: true,
                    hint: _selectedRegions.contains(region)
                        ? '双击编辑区域属性'
                        : '点击选择区域',
                    value: _getRegionDescription(region),
                    child: ExcludeSemantics(
                      child: CustomPaint(
                        painter: RegionPainter(
                          region: region,
                          isSelected: _selectedRegions.contains(region),
                        ),
                      ),
                    ),
                  ),
                ))
            .toList() ??
        [];
  }

  Widget _buildSelectionCount() {
    return MergeSemantics(
      child: Semantics(
        label: '已选择区域数量',
        value: '${_selectedRegions.length}个',
        child: ExcludeSemantics(
          child: Padding(
            padding: const EdgeInsets.symmetric(horizontal: 8.0),
            child: Text(
              '已选择: ${_selectedRegions.length}',
              style: TextStyle(
                color: Theme.of(context).primaryColor,
                fontWeight: FontWeight.bold,
              ),
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildSelectionOverlay() {
    return CustomPaint(
      painter: RegionPainter(
        selectionStart: _state.selectionStart,
        selectionEnd: _state.selectionCurrent,
        isSelecting: true,
      ),
    );
  }

  Widget _buildToolbar() {
    return MergeSemantics(
      child: Semantics(
        container: true,
        label: '工具栏',
        child: Row(
          children: [
            _buildBoxSelectionTool(),
            _buildMultiSelectTool(),
            if (_selectedRegions.isNotEmpty) ...[
              _buildDeleteButton(),
              _buildSelectionCount(),
            ],
          ],
        ),
      ),
    );
  }

  void _cleanupState() {
    setState(() {
      _state.reset();
      _selectedRegions.clear();
    });
  }

  void _clearSelection() {
    setState(() {
      _state.selectionStart = null;
      _state.selectionCurrent = null;
      _state.selectedRegion = null;
      _selectedRegions.clear();
    });
  }

  Future<void> _deleteSelectedRegions() async {
    if (_selectedRegions.isEmpty) return;

    final confirmed = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('删除确认'),
        content: Text('确定要删除选中的${_selectedRegions.length}个区域吗？'),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(false),
            child: const Text('取消'),
          ),
          FilledButton(
            onPressed: () => Navigator.of(context).pop(true),
            style: FilledButton.styleFrom(
              backgroundColor: Colors.red,
            ),
            child: const Text('删除'),
          ),
        ],
      ),
    );

    if (confirmed != true) return;

    _showProcessingIndicator();
    try {
      await _repository.deleteMany(
          _selectedRegions.map((region) => region.label ?? '').toList());

      _preserveAndUpdateState(() {
        if (widget.onRegionsDeleted != null) {
          widget.onRegionsDeleted!(_selectedRegions.toList());
        }
        _selectedRegions.clear();
        _state.selectedRegion = null;
        _announceStateChange('删除成功');
      });
    } catch (e) {
      _showErrorMessage('删除失败: $e');
    } finally {
      _hideProcessingIndicator();
    }
  }

  MouseCursor _getCursor() {
    if (_state.isBoxSelectionMode) {
      return SystemMouseCursors.precise;
    } else if (_state.resizeHandleIndex != null) {
      return SystemMouseCursors.resizeUpDown;
    } else if (_state.isRotating) {
      return SystemMouseCursors.grab;
    }
    return SystemMouseCursors.basic;
  }

  String _getRegionDescription(CharacterRegion region) {
    final size = '${region.rect.width.toInt()}×${region.rect.height.toInt()}';
    final position =
        '位置(${region.rect.left.toInt()}, ${region.rect.top.toInt()})';
    return '${region.label ?? "未命名区域"}, 大小$size, $position';
  }

  void _handleDoubleTap() async {
    if (_state.selectedRegion == null) return;
    await _showSaveDialog(_state.selectedRegion);
  }

  void _handlePanEnd(DragEndDetails details) {
    if (!_state.isBoxSelectionMode) return;

    if (_state.selectionStart != null && _state.selectionCurrent != null) {
      final rect =
          Rect.fromPoints(_state.selectionStart!, _state.selectionCurrent!);

      if (rect.width >= _minRegionSize && rect.height >= _minRegionSize) {
        final region = CharacterRegion(
          pageIndex: _state.currentIndex,
          left: rect.left,
          top: rect.top,
          width: rect.width,
          height: rect.height,
          imagePath: widget.imagePaths[_state.currentIndex],
        );

        if (widget.onRegionCreated != null) {
          widget.onRegionCreated!(region);
          _announceStateChange('已创建新区域');
        }

        _preserveAndUpdateState(() {
          _state.selectedRegion = region;
          _selectedRegions.clear();
          _selectedRegions.add(region);
        });
      } else {
        _announceStateChange('选择区域太小');
      }
    }

    _preserveAndUpdateState(() {
      _state.selectionStart = null;
      _state.selectionCurrent = null;
    });
  }

  void _handlePanStart(DragStartDetails details) {
    if (!_state.isBoxSelectionMode) return;

    _preserveAndUpdateState(() {
      _state.selectionStart = details.localPosition;
      _state.selectionCurrent = details.localPosition;
      HapticFeedback.selectionClick();
    });
  }

  void _handlePanUpdate(DragUpdateDetails details) {
    if (!_state.isBoxSelectionMode) return;

    _preserveAndUpdateState(() {
      _state.selectionCurrent = details.localPosition;
    });
  }

  void _handleRegionEnd(DragEndDetails details) {
    if (_state.selectedRegion == null) return;

    _preserveAndUpdateState(() {
      if (_state.isRotating) {
        _announceStateChange('完成旋转');
      } else if (_state.resizeHandleIndex != null) {
        _announceStateChange('完成调整大小');
      } else if (_state.dragStartOffset != null) {
        _announceStateChange('完成移动');
      }

      _state.resetManipulation();
    });

    HapticFeedback.lightImpact();
  }

  Future<void> _handleRegionOperation(Future<void> Function() operation,
      {String? errorMessage}) {
    return operation().catchError((error) async {
      _showErrorMessage(errorMessage ?? '操作失败: $error');
      return Future<void>.value(); // Explicitly return a completed Future<void>
    });
  }

  void _handleRegionStart(DragStartDetails details) {
    if (_state.selectedRegion == null) return;

    final region = _state.selectedRegion!;
    final painter = RegionPainter(region: region, isSelected: true);

    final handleIndex =
        painter.getHandleAtPoint(details.localPosition, region.rect);

    if (handleIndex != null || region.rect.contains(details.localPosition)) {
      HapticFeedback.selectionClick();
    }

    _preserveAndUpdateState(() {
      if (handleIndex != null) {
        _state.resizeHandleIndex = handleIndex;
        _announceStateChange('开始调整区域大小');
      } else if (painter.isRotationHandle(details.localPosition, region.rect)) {
        _state.isRotating = true;
        _state.rotationStartAngle = region.rotation;
        _state.rotationCenter = region.rect.center;
        _announceStateChange('开始旋转区域');
      } else if (region.rect.contains(details.localPosition)) {
        _state.dragStartOffset = details.localPosition;
        _state.dragStartRect = region.rect;
        _announceStateChange('开始移动区域');
      }
    });
  }

  void _handleRegionUpdate(DragUpdateDetails details) {
    if (_state.selectedRegion == null) return;

    _preserveAndUpdateState(() {
      if (_state.resizeHandleIndex != null) {
        _handleResize(details, _state.selectedRegion!);
      } else if (_state.isRotating && _state.rotationCenter != null) {
        _handleRotate(details, _state.selectedRegion!);
      } else if (_state.dragStartOffset != null &&
          _state.dragStartRect != null) {
        final delta = details.localPosition - _state.dragStartOffset!;
        final rect = _state.dragStartRect!.translate(delta.dx, delta.dy);
        _state.selectedRegion = _state.selectedRegion!.copyWith(
          left: rect.left,
          top: rect.top,
          width: rect.width,
          height: rect.height,
        );
      }
    });
  }

  void _handleResize(DragUpdateDetails details, CharacterRegion region) {
    if (_state.resizeHandleIndex == null) return;

    final delta = details.delta;
    double newLeft = region.rect.left;
    double newTop = region.rect.top;
    double newWidth = region.rect.width;
    double newHeight = region.rect.height;

    switch (_state.resizeHandleIndex!) {
      case 0: // 左上
        newLeft += delta.dx;
        newTop += delta.dy;
        newWidth -= delta.dx;
        newHeight -= delta.dy;
        break;
      case 1: // 上
        newTop += delta.dy;
        newHeight -= delta.dy;
        break;
      case 2: // 右上
        newWidth += delta.dx;
        newTop += delta.dy;
        newHeight -= delta.dy;
        break;
      case 3: // 右
        newWidth += delta.dx;
        break;
      case 4: // 右下
        newWidth += delta.dx;
        newHeight += delta.dy;
        break;
      case 5: // 下
        newHeight += delta.dy;
        break;
      case 6: // 左下
        newLeft += delta.dx;
        newWidth -= delta.dx;
        newHeight += delta.dy;
        break;
      case 7: // 左
        newLeft += delta.dx;
        newWidth -= delta.dx;
        break;
    }

    if (newWidth >= _minRegionSize && newHeight >= _minRegionSize) {
      _state.selectedRegion = region.copyWith(
        left: newLeft,
        top: newTop,
        width: newWidth,
        height: newHeight,
      );
    }
  }

  void _handleRotate(DragUpdateDetails details, CharacterRegion region) {
    if (_state.rotationCenter == null) return;

    final angle = math.atan2(
      details.localPosition.dy - _state.rotationCenter!.dy,
      details.localPosition.dx - _state.rotationCenter!.dx,
    );

    _state.selectedRegion = region.copyWith(rotation: angle);
  }

  void _handleTapDown(TapDownDetails details) {
    if (_state.isBoxSelectionMode) return;

    final tappedRegions = widget.collectedRegions
        ?.where((region) =>
            region.pageIndex == _state.currentIndex &&
            region.rect.contains(details.localPosition))
        .toList();

    final tappedRegion =
        tappedRegions?.isNotEmpty == true ? tappedRegions!.first : null;

    if (tappedRegion != null) {
      HapticFeedback.selectionClick();
    }

    _preserveAndUpdateState(() {
      if (_state.isMultiSelectMode && tappedRegion != null) {
        if (_selectedRegions.contains(tappedRegion)) {
          _selectedRegions.remove(tappedRegion);
          _announceStateChange('取消选择: ${_getRegionDescription(tappedRegion)}');
        } else {
          _selectedRegions.add(tappedRegion);
          _announceStateChange('选择: ${_getRegionDescription(tappedRegion)}');
        }
        _state.selectedRegion = tappedRegion;
      } else {
        _selectedRegions.clear();
        _state.selectedRegion = tappedRegion;
        if (tappedRegion != null) {
          _selectedRegions.add(tappedRegion);
          _announceStateChange('选择: ${_getRegionDescription(tappedRegion)}');
        }
      }

      if (tappedRegion != null && widget.onRegionSelected != null) {
        widget.onRegionSelected!(tappedRegion);
      }
    });
  }

  void _handleTapUp(TapUpDetails details) {
    if (_state.isBoxSelectionMode) return;

    final tappedRegions = widget.collectedRegions
        ?.where((region) =>
            region.pageIndex == _state.currentIndex &&
            region.rect.contains(details.localPosition))
        .toList();

    if (tappedRegions?.isEmpty ?? true) {
      _preserveAndUpdateState(() {
        if (!_state.isMultiSelectMode) {
          _state.selectedRegion = null;
          _selectedRegions.clear();
          _announceStateChange('清除选择');
        }
      });
    }
  }

  void _hideProcessingIndicator() {
    if (!mounted) return;
    Navigator.of(context).pop();
  }

  Future<void> _initializeRepository() async {
    // Get repository from the provider without using watch
  }

  void _preserveAndUpdateState(VoidCallback operation) {
    setState(operation);
  }

  void _showErrorMessage(String message) {
    if (!mounted) return;
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text(message),
        backgroundColor: Colors.red,
      ),
    );
  }

  void _showProcessingIndicator() {
    if (!mounted) return;
    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (context) => const Center(
        child: Card(
          child: Padding(
            padding: EdgeInsets.all(16.0),
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                CircularProgressIndicator(),
                SizedBox(height: 16),
                Text('正在处理...'),
              ],
            ),
          ),
        ),
      ),
    );
  }

  Future<void> _showSaveDialog(CharacterRegion? region) async {
    if (region == null) return;

    _handleRegionOperation(() async {
      final result = await showDialog<Map<String, dynamic>>(
        context: context,
        builder: (context) => RegionPropertiesDialog(
          region: region,
          onSave: (label, color) async {
            try {
              _showProcessingIndicator();

              // 处理图片
              final processor = CharacterImageProcessor();
              const outputDir = '';
              final charId = label ?? DateTime.now().toIso8601String();

              final paths = await processor.processCharacterImage(
                sourcePath: region.imagePath,
                outputDir: outputDir,
                charId: charId,
                region: region.rect,
                rotation: region.rotation,
                erasePoints: _state.erasePoints,
              );

              _preserveAndUpdateState(() {
                _state.selectedRegion = region.copyWith(
                  label: label,
                  color: color,
                  isSaved: true,
                );

                // 清除擦除点
                _state.erasePoints = null;

                if (widget.onRegionSelected != null) {
                  widget.onRegionSelected!(_state.selectedRegion!);
                }
              });

              _announceStateChange('集字已保存: $label');
              Navigator.of(context).pop({'saved': true, 'paths': paths});
            } catch (e) {
              _showErrorMessage('保存失败: $e');
            } finally {
              _hideProcessingIndicator();
            }
          },
        ),
      );

      if (result?['saved'] == true) {
        setState(() {});
      }
    }, errorMessage: '保存操作失败');
  }
}

class _PreviewState {
  int currentIndex = 0;
  bool isDragging = false;
  bool isBoxSelectionMode = false;
  bool isMultiSelectMode = false;

  Offset? selectionStart;
  Offset? selectionCurrent;
  CharacterRegion? selectedRegion;

  int? resizeHandleIndex;
  bool isRotating = false;
  double rotationStartAngle = 0;
  Offset? rotationCenter;
  Offset? dragStartOffset;
  Rect? dragStartRect;

  List<Offset>? erasePoints;

  void reset() {
    isDragging = false;
    isBoxSelectionMode = false;
    isMultiSelectMode = false;
    selectionStart = null;
    selectionCurrent = null;
    selectedRegion = null;
    resetManipulation();
    erasePoints = null;
  }

  void resetManipulation() {
    resizeHandleIndex = null;
    isRotating = false;
    rotationStartAngle = 0;
    rotationCenter = null;
    dragStartOffset = null;
    dragStartRect = null;
  }
}



=======================================
./lib/presentation/widgets/character_collection/character_preview_panel.dart
=======================================
import 'package:flutter/material.dart';

import '../../../domain/models/character/character_region.dart';

class CharacterPreviewPanel extends StatelessWidget {
  final CharacterRegion? region;
  final String? label;
  final VoidCallback? onSave;
  final VoidCallback? onClear;

  const CharacterPreviewPanel({
    super.key,
    this.region,
    this.label,
    this.onSave,
    this.onClear,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    if (region == null) {
      return const Center(
        child: Text('请选择或者框选字符区域'),
      );
    }

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text('区域信息', style: theme.textTheme.titleMedium),
        const SizedBox(height: 16),

        // 区域尺寸信息
        Card(
          child: Padding(
            padding: const EdgeInsets.all(16),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                _buildInfoRow('位置',
                    'x: ${region!.rect.left.toInt()}, y: ${region!.rect.top.toInt()}'),
                const SizedBox(height: 8),
                _buildInfoRow('尺寸',
                    '${region!.rect.width.toInt()} × ${region!.rect.height.toInt()}'),
                if (region!.rotation != 0) ...[
                  const SizedBox(height: 8),
                  _buildInfoRow('旋转',
                      '${(region!.rotation * 180 / 3.14159).toStringAsFixed(1)}°'),
                ],
              ],
            ),
          ),
        ),

        const SizedBox(height: 16),

        // 操作按钮
        Row(
          children: [
            Expanded(
              child: FilledButton(
                onPressed: onSave,
                child: const Text('保存'),
              ),
            ),
            const SizedBox(width: 8),
            Expanded(
              child: OutlinedButton(
                onPressed: onClear,
                child: const Text('清除'),
              ),
            ),
          ],
        ),
      ],
    );
  }

  Widget _buildInfoRow(String label, String value) {
    return Row(
      mainAxisAlignment: MainAxisAlignment.spaceBetween,
      children: [
        Text(label, style: const TextStyle(fontWeight: FontWeight.w500)),
        Text(value),
      ],
    );
  }
}



=======================================
./lib/presentation/widgets/character_collection/collection_preview.dart
=======================================
import 'package:flutter/material.dart';

import '../common/image_preview.dart';
import '../common/sidebar_toggle.dart';
import './collection_result.dart';

class CollectionPreview extends StatefulWidget {
  final String workId;
  final List<String> images;

  const CollectionPreview({
    super.key,
    required this.workId,
    required this.images,
  });

  @override
  State<CollectionPreview> createState() => _CollectionPreviewState();
}

class _CollectionPreviewState extends State<CollectionPreview> {
  bool _isPanelOpen = true;
  int _currentImageIndex = 0;

  @override
  Widget build(BuildContext context) {
    return Container(
      decoration: BoxDecoration(
        color: Colors.grey[200],
        border: Border(
          right: BorderSide(
            color: Theme.of(context).dividerColor,
          ),
        ),
      ),
      child: Row(
        children: [
          // Main content area with image preview
          Expanded(
            child: ImagePreview(
              imagePaths: widget.images,
              initialIndex: _currentImageIndex,
              onIndexChanged: (index) =>
                  setState(() => _currentImageIndex = index),
              padding: const EdgeInsets.all(16),
            ),
          ),

          // Sidebar toggle button
          Material(
            elevation: 1,
            child: Container(
              width: 32,
              color: Theme.of(context).colorScheme.surface,
              height: MediaQuery.of(context).size.height,
              alignment: Alignment.center,
              child: SidebarToggle(
                isOpen: _isPanelOpen,
                onToggle: () {
                  setState(() {
                    _isPanelOpen = !_isPanelOpen;
                  });
                },
                alignRight: true,
              ),
            ),
          ),

          // Right panel - Results
          if (_isPanelOpen)
            Container(
              width: 350,
              decoration: BoxDecoration(
                color: Theme.of(context).colorScheme.surface,
                border: Border(
                  left: BorderSide(color: Theme.of(context).dividerColor),
                ),
              ),
              child: const CollectionResult(),
            ),
        ],
      ),
    );
  }
}



=======================================
./lib/presentation/widgets/character_collection/collection_result.dart
=======================================
import 'package:flutter/material.dart';

class CollectionResult extends StatefulWidget {
  const CollectionResult({super.key});

  @override
  State<CollectionResult> createState() => _CollectionResultState();
}

class _CollectionResultState extends State<CollectionResult> {
  final _formKey = GlobalKey<FormState>();
  final _simplifiedCharController = TextEditingController();
  String _selectedStyle = '楷书';
  String _selectedTool = '毛笔';
  final _remarkController = TextEditingController();

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: Theme.of(context).colorScheme.surface,
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.stretch,
        children: [
          // Preview section
          Container(
            height: 200,
            decoration: BoxDecoration(
              color: Colors.grey[200],
              borderRadius: BorderRadius.circular(8),
            ),
            child: const Center(
              child: Text('集字效果预览'),
            ),
          ),
          const SizedBox(height: 16),

          // Transform tools
          Row(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              IconButton(
                icon: const Icon(Icons.rotate_left),
                onPressed: () {
                  // Handle rotation
                },
                tooltip: '向左旋转',
              ),
              IconButton(
                icon: const Icon(Icons.rotate_right),
                onPressed: () {
                  // Handle rotation
                },
                tooltip: '向右旋转',
              ),
              IconButton(
                icon: const Icon(Icons.zoom_in),
                onPressed: () {
                  // Handle zoom
                },
                tooltip: '放大',
              ),
              IconButton(
                icon: const Icon(Icons.zoom_out),
                onPressed: () {
                  // Handle zoom
                },
                tooltip: '缩小',
              ),
              IconButton(
                icon: const Icon(Icons.color_lens),
                onPressed: () {
                  // Handle color
                },
                tooltip: '字体颜色',
              ),
            ],
          ),
          const SizedBox(height: 16),

          // Size info
          Text(
            '当前尺寸：200x200像素',
            style: Theme.of(context).textTheme.bodySmall,
            textAlign: TextAlign.center,
          ),
          const SizedBox(height: 24),

          // Registration form
          Expanded(
            child: SingleChildScrollView(
              child: Form(
                key: _formKey,
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    TextFormField(
                      controller: _simplifiedCharController,
                      decoration: const InputDecoration(
                        labelText: '对应简体字 *',
                        hintText: '输入汉字',
                      ),
                      validator: (value) {
                        if (value == null || value.isEmpty) {
                          return '请输入对应简体字';
                        }
                        return null;
                      },
                    ),
                    const SizedBox(height: 16),
                    DropdownButtonFormField<String>(
                      value: _selectedStyle,
                      decoration: const InputDecoration(
                        labelText: '书法风格',
                      ),
                      items: ['楷书', '行书', '草书', '隶书', '篆书']
                          .map((style) => DropdownMenuItem(
                                value: style,
                                child: Text(style),
                              ))
                          .toList(),
                      onChanged: (value) {
                        if (value != null) {
                          setState(() {
                            _selectedStyle = value;
                          });
                        }
                      },
                    ),
                    const SizedBox(height: 16),
                    DropdownButtonFormField<String>(
                      value: _selectedTool,
                      decoration: const InputDecoration(
                        labelText: '书写工具',
                      ),
                      items: ['毛笔', '硬笔']
                          .map((tool) => DropdownMenuItem(
                                value: tool,
                                child: Text(tool),
                              ))
                          .toList(),
                      onChanged: (value) {
                        if (value != null) {
                          setState(() {
                            _selectedTool = value;
                          });
                        }
                      },
                    ),
                    const SizedBox(height: 16),
                    TextFormField(
                      controller: _remarkController,
                      decoration: const InputDecoration(
                        labelText: '备注',
                        hintText: '可选',
                      ),
                      maxLines: 3,
                    ),
                  ],
                ),
              ),
            ),
          ),
          const SizedBox(height: 16),

          // Action buttons
          Row(
            children: [
              Expanded(
                child: FilledButton(
                  onPressed: () {
                    if (_formKey.currentState?.validate() ?? false) {
                      // Handle save
                    }
                  },
                  child: const Text('保存集字'),
                ),
              ),
              const SizedBox(width: 8),
              OutlinedButton(
                onPressed: () {
                  // Handle clear selection
                },
                child: const Text('清空选择'),
              ),
            ],
          ),
        ],
      ),
    );
  }

  @override
  void dispose() {
    _simplifiedCharController.dispose();
    _remarkController.dispose();
    super.dispose();
  }
}



=======================================
./lib/presentation/widgets/character_collection/collection_toolbar.dart
=======================================
import 'package:flutter/material.dart';

class CollectionToolbar extends StatelessWidget {
  final String title;
  final bool autoDetectStrokes;
  final double noiseReduction;
  final double binarization;
  final double grayscaleRange;
  final ValueChanged<bool> onAutoDetectStrokesChanged;
  final ValueChanged<double> onNoiseReductionChanged;
  final ValueChanged<double> onBinarizationChanged;
  final ValueChanged<double> onGrayscaleRangeChanged;
  final VoidCallback onReset;
  final VoidCallback onClose;

  const CollectionToolbar({
    super.key,
    required this.title,
    required this.autoDetectStrokes,
    required this.noiseReduction,
    required this.binarization,
    required this.grayscaleRange,
    required this.onAutoDetectStrokesChanged,
    required this.onNoiseReductionChanged,
    required this.onBinarizationChanged,
    required this.onGrayscaleRangeChanged,
    required this.onReset,
    required this.onClose,
  });

  @override
  Widget build(BuildContext context) {
    return Container(
      height: 56,
      padding: const EdgeInsets.symmetric(horizontal: 16),
      decoration: BoxDecoration(
        color: Theme.of(context).colorScheme.surface,
        border: Border(
          bottom: BorderSide(
            color: Theme.of(context).dividerColor,
          ),
        ),
      ),
      child: Row(
        children: [
          // Left: Close button and title
          IconButton(
            icon: const Icon(Icons.close),
            onPressed: onClose,
            tooltip: '退出集字模式',
          ),
          const SizedBox(width: 16),
          Text(
            title,
            style: Theme.of(context).textTheme.titleMedium,
          ),
          const SizedBox(width: 32),

          // Center: Preprocessing tools group
          Expanded(
            child: Row(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                // Auto detect strokes switch
                Row(
                  children: [
                    const Text('自动识别笔画'),
                    const SizedBox(width: 8),
                    Switch(
                      value: autoDetectStrokes,
                      onChanged: onAutoDetectStrokesChanged,
                    ),
                  ],
                ),
                const SizedBox(width: 24),

                // Noise reduction slider
                Flexible(
                  child: Row(
                    children: [
                      const Text('降噪'),
                      const SizedBox(width: 8),
                      Expanded(
                        child: Slider(
                          value: noiseReduction,
                          onChanged: onNoiseReductionChanged,
                        ),
                      ),
                    ],
                  ),
                ),

                // Binarization slider
                Flexible(
                  child: Row(
                    children: [
                      const Text('二值化'),
                      const SizedBox(width: 8),
                      Expanded(
                        child: Slider(
                          value: binarization,
                          onChanged: onBinarizationChanged,
                        ),
                      ),
                    ],
                  ),
                ),

                // Grayscale range slider
                Flexible(
                  child: Row(
                    children: [
                      const Text('灰度范围'),
                      const SizedBox(width: 8),
                      Expanded(
                        child: Slider(
                          value: grayscaleRange,
                          onChanged: onGrayscaleRangeChanged,
                        ),
                      ),
                    ],
                  ),
                ),

                // Reset button
                TextButton.icon(
                  onPressed: onReset,
                  icon: const Icon(Icons.refresh),
                  label: const Text('重置'),
                ),
              ],
            ),
          ),

          // Right: Operation tools group
          Row(
            children: [
              IconButton(
                icon: const Icon(Icons.undo),
                onPressed: () {
                  // Handle undo
                },
                tooltip: '撤销',
              ),
              IconButton(
                icon: const Icon(Icons.redo),
                onPressed: () {
                  // Handle redo
                },
                tooltip: '重做',
              ),
            ],
          ),
        ],
      ),
    );
  }
}



=======================================
./lib/presentation/widgets/character_collection/collection_tools.dart
=======================================
import 'package:flutter/material.dart';

class CollectionTools extends StatefulWidget {
  final Function(dynamic) onToolSelected;

  const CollectionTools({
    super.key,
    required this.onToolSelected,
  });

  @override
  State<CollectionTools> createState() => _CollectionToolsState();
}

enum SelectionTool {
  click,
  rectangle,
  lasso,
}

enum ViewTool {
  zoom,
  pan,
}

class _CollectionToolsState extends State<CollectionTools> {
  SelectionTool _currentSelectionTool = SelectionTool.click;
  ViewTool _currentViewTool = ViewTool.pan;

  @override
  Widget build(BuildContext context) {
    return Container(
      width: 56,
      decoration: BoxDecoration(
        border: Border(
          right: BorderSide(
            color: Theme.of(context).dividerColor,
          ),
        ),
      ),
      child: Column(
        children: [
          const Padding(
            padding: EdgeInsets.symmetric(vertical: 8),
            child: Text('选择工具'),
          ),
          // Selection tools
          _buildToolButton(
            icon: Icons.touch_app,
            tooltip: '点击选择',
            isSelected: _currentSelectionTool == SelectionTool.click,
            onPressed: () {
              setState(() {
                _currentSelectionTool = SelectionTool.click;
              });
              widget.onToolSelected(SelectionTool.click);
            },
          ),
          _buildToolButton(
            icon: Icons.crop_square,
            tooltip: '矩形框选',
            isSelected: _currentSelectionTool == SelectionTool.rectangle,
            onPressed: () {
              setState(() {
                _currentSelectionTool = SelectionTool.rectangle;
              });
              widget.onToolSelected(SelectionTool.rectangle);
            },
          ),
          _buildToolButton(
            icon: Icons.gesture,
            tooltip: '套索选择',
            isSelected: _currentSelectionTool == SelectionTool.lasso,
            onPressed: () {
              setState(() {
                _currentSelectionTool = SelectionTool.lasso;
              });
              widget.onToolSelected(SelectionTool.lasso);
            },
          ),
          const Divider(height: 16),
          const Padding(
            padding: EdgeInsets.symmetric(vertical: 8),
            child: Text('视图工具'),
          ),
          // View tools
          _buildToolButton(
            icon: Icons.zoom_in,
            tooltip: '缩放',
            isSelected: _currentViewTool == ViewTool.zoom,
            onPressed: () {
              setState(() {
                _currentViewTool = ViewTool.zoom;
              });
              widget.onToolSelected(ViewTool.zoom);
            },
          ),
          _buildToolButton(
            icon: Icons.pan_tool,
            tooltip: '平移',
            isSelected: _currentViewTool == ViewTool.pan,
            onPressed: () {
              setState(() {
                _currentViewTool = ViewTool.pan;
              });
              widget.onToolSelected(ViewTool.pan);
            },
          ),
        ],
      ),
    );
  }

  Widget _buildToolButton({
    required IconData icon,
    required String tooltip,
    required bool isSelected,
    required VoidCallback onPressed,
  }) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 4),
      child: IconButton(
        icon: Icon(
          icon,
          color: isSelected ? Theme.of(context).colorScheme.primary : null,
        ),
        tooltip: tooltip,
        onPressed: onPressed,
        style: IconButton.styleFrom(
          backgroundColor: isSelected
              ? Theme.of(context).colorScheme.primaryContainer
              : null,
        ),
      ),
    );
  }
}



=======================================
./lib/presentation/widgets/character_collection/region_painter.dart
=======================================
import 'package:flutter/material.dart';

import '../../../domain/models/character/character_region.dart';

class RegionPainter extends CustomPainter {
  static const double handleSize = 8.0;
  static const double rotationHandleOffset = 20.0;
  final CharacterRegion? region;
  final bool isSelected;
  final Offset? selectionStart;

  final Offset? selectionEnd;
  final bool isSelecting;

  const RegionPainter({
    this.region,
    this.isSelected = false,
    this.selectionStart,
    this.selectionEnd,
    this.isSelecting = false,
  });

  int? getHandleAtPoint(Offset point, Rect rect) {
    final handles = <Offset>[
      rect.topLeft,
      Offset(rect.left + rect.width / 2, rect.top),
      rect.topRight,
      Offset(rect.right, rect.top + rect.height / 2),
      rect.bottomRight,
      Offset(rect.left + rect.width / 2, rect.bottom),
      rect.bottomLeft,
      Offset(rect.left, rect.top + rect.height / 2),
    ];

    for (var i = 0; i < handles.length; i++) {
      if (_isPointNearHandle(point, handles[i])) {
        return i;
      }
    }
    return null;
  }

  bool isRotationHandle(Offset point, Rect rect) {
    final center = Offset(
      rect.left + rect.width / 2,
      rect.top - rotationHandleOffset,
    );
    return _isPointNearHandle(point, center);
  }

  @override
  void paint(Canvas canvas, Size size) {
    if (isSelecting && selectionStart != null && selectionEnd != null) {
      _drawSelectionRect(canvas, selectionStart!, selectionEnd!);
    }

    if (region != null) {
      _drawRegion(canvas, region!);
    }
  }

  @override
  bool shouldRepaint(RegionPainter oldDelegate) {
    return region != oldDelegate.region ||
        isSelected != oldDelegate.isSelected ||
        selectionStart != oldDelegate.selectionStart ||
        selectionEnd != oldDelegate.selectionEnd ||
        isSelecting != oldDelegate.isSelecting;
  }

  void _drawHandle(Canvas canvas, Offset position) {
    final paint = Paint()
      ..color = Colors.white
      ..style = PaintingStyle.fill;

    canvas.drawCircle(position, handleSize, paint);

    paint.color = Colors.blue;
    paint.style = PaintingStyle.stroke;
    paint.strokeWidth = 1.5;

    canvas.drawCircle(position, handleSize, paint);
  }

  void _drawRegion(Canvas canvas, CharacterRegion region) {
    final paint = Paint()
      ..color = isSelected
          ? Colors.blue.withOpacity(0.3)
          : Colors.grey.withOpacity(0.2)
      ..style = PaintingStyle.fill;

    final rect = region.rect;
    canvas.drawRect(rect, paint);

    paint
      ..color = isSelected ? Colors.blue : Colors.grey
      ..style = PaintingStyle.stroke
      ..strokeWidth = 1.5;

    canvas.drawRect(rect, paint);

    if (isSelected) {
      _drawResizeHandles(canvas, rect);
      _drawRotationHandle(canvas, rect);
    }
  }

  void _drawResizeHandles(Canvas canvas, Rect rect) {
    final handles = <Offset>[
      rect.topLeft,
      Offset(rect.left + rect.width / 2, rect.top),
      rect.topRight,
      Offset(rect.right, rect.top + rect.height / 2),
      rect.bottomRight,
      Offset(rect.left + rect.width / 2, rect.bottom),
      rect.bottomLeft,
      Offset(rect.left, rect.top + rect.height / 2),
    ];

    for (final handle in handles) {
      _drawHandle(canvas, handle);
    }
  }

  void _drawRotationHandle(Canvas canvas, Rect rect) {
    final center = Offset(
      rect.left + rect.width / 2,
      rect.top - rotationHandleOffset,
    );

    final paint = Paint()
      ..color = Colors.blue
      ..style = PaintingStyle.stroke
      ..strokeWidth = 1.5;

    // Draw connecting line
    canvas.drawLine(
      Offset(rect.left + rect.width / 2, rect.top),
      center,
      paint,
    );

    // Draw rotation handle
    _drawHandle(canvas, center);
  }

  void _drawSelectionRect(Canvas canvas, Offset start, Offset end) {
    final paint = Paint()
      ..color = Colors.blue.withOpacity(0.2)
      ..style = PaintingStyle.fill;

    final rect = Rect.fromPoints(start, end);
    canvas.drawRect(rect, paint);

    paint
      ..color = Colors.blue
      ..style = PaintingStyle.stroke
      ..strokeWidth = 1;

    canvas.drawRect(rect, paint);
  }

  bool _isPointNearHandle(Offset point, Offset handle) {
    return (point - handle).distance <= handleSize;
  }
}



=======================================
./lib/presentation/widgets/character_collection/region_properties_dialog.dart
=======================================
import 'package:flutter/material.dart';

import '../../../domain/models/character/character_region.dart';

typedef OnSaveCallback = Future<void> Function(String? label, Color? color);

class RegionPropertiesDialog extends StatefulWidget {
  final CharacterRegion region;
  final OnSaveCallback onSave;

  const RegionPropertiesDialog({
    super.key,
    required this.region,
    required this.onSave,
  });

  @override
  State<RegionPropertiesDialog> createState() => _RegionPropertiesDialogState();
}

class _RegionPropertiesDialogState extends State<RegionPropertiesDialog> {
  final _labelController = TextEditingController();
  Color _selectedColor = Colors.blue;
  bool _processing = false;

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      title: const Text('区域属性'),
      content: SingleChildScrollView(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            // 标签输入
            TextField(
              controller: _labelController,
              decoration: const InputDecoration(
                labelText: '标签',
                hintText: '输入字符标签',
              ),
              maxLength: 10,
              enabled: !_processing,
            ),
            const SizedBox(height: 16),

            // 颜色选择
            const Text('选择颜色标记'),
            const SizedBox(height: 8),
            _buildColorPicker(),
          ],
        ),
      ),
      actions: [
        TextButton(
          onPressed: _processing ? null : () => Navigator.of(context).pop(),
          child: const Text('取消'),
        ),
        FilledButton(
          onPressed: _processing ? null : _handleSave,
          child: _processing
              ? const SizedBox(
                  width: 20,
                  height: 20,
                  child: CircularProgressIndicator(
                    strokeWidth: 2,
                  ),
                )
              : const Text('保存'),
        ),
      ],
    );
  }

  @override
  void dispose() {
    _labelController.dispose();
    super.dispose();
  }

  @override
  void initState() {
    super.initState();
    _labelController.text = widget.region.label ?? '';
    _selectedColor = widget.region.color ?? Colors.blue;
  }

  Widget _buildColorPicker() {
    final colors = [
      Colors.red,
      Colors.pink,
      Colors.purple,
      Colors.deepPurple,
      Colors.indigo,
      Colors.blue,
      Colors.lightBlue,
      Colors.cyan,
      Colors.teal,
      Colors.green,
      Colors.lightGreen,
      Colors.lime,
      Colors.yellow,
      Colors.amber,
      Colors.orange,
      Colors.deepOrange,
      Colors.brown,
      Colors.grey,
      Colors.blueGrey,
    ];

    return Wrap(
      spacing: 8,
      runSpacing: 8,
      children: colors.map((color) {
        final isSelected = color.value == _selectedColor.value;
        return GestureDetector(
          onTap:
              _processing ? null : () => setState(() => _selectedColor = color),
          child: Container(
            width: 32,
            height: 32,
            decoration: BoxDecoration(
              color: color,
              shape: BoxShape.circle,
              border: Border.all(
                color: isSelected ? Colors.white : Colors.transparent,
                width: 2,
              ),
              boxShadow: [
                if (isSelected)
                  BoxShadow(
                    color: color.withOpacity(0.4),
                    blurRadius: 8,
                    spreadRadius: 2,
                  ),
              ],
            ),
          ),
        );
      }).toList(),
    );
  }

  Future<void> _handleSave() async {
    final label = _labelController.text.trim();
    if (label.isEmpty) {
      // 显示错误提示
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('请输入标签')),
      );
      return;
    }

    setState(() => _processing = true);

    try {
      await widget.onSave(label, _selectedColor);
    } finally {
      if (mounted) {
        setState(() => _processing = false);
      }
    }
  }
}



=======================================
./lib/presentation/widgets/common/base_card.dart
=======================================
import 'package:flutter/material.dart';

class BaseCard extends StatelessWidget {
  final Widget child;
  final EdgeInsets? padding;
  final Color? color;

  const BaseCard({
    super.key,
    required this.child,
    this.padding,
    this.color,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Container(
      decoration: BoxDecoration(
        color: color ?? theme.cardColor,
        borderRadius: BorderRadius.circular(8),
        border: Border.all(color: theme.dividerColor),
      ),
      clipBehavior: Clip.antiAlias,
      child: padding != null ? Padding(padding: padding!, child: child) : child,
    );
  }
}



=======================================
./lib/presentation/widgets/common/base_image_preview.dart
=======================================
import 'dart:io';

import 'package:flutter/material.dart';

import '../../../infrastructure/logging/logger.dart';

class BaseImagePreview extends StatefulWidget {
  final List<String> imagePaths;
  final int initialIndex;
  final Function(int)? onIndexChanged;
  final bool showThumbnails;
  final bool enableZoom;
  final BoxDecoration? previewDecoration;
  final EdgeInsets? padding;

  const BaseImagePreview({
    super.key,
    required this.imagePaths,
    this.initialIndex = 0,
    this.onIndexChanged,
    this.showThumbnails = true,
    this.enableZoom = true,
    this.previewDecoration,
    this.padding,
  });

  @override
  State<BaseImagePreview> createState() => _BaseImagePreviewState();
}

class _BaseImagePreviewState extends State<BaseImagePreview> {
  static const double _minZoomScale = 0.1;
  static const double _maxZoomScale = 10.0;
  static const EdgeInsets _viewerPadding = EdgeInsets.all(20.0);
  final Map<String, bool> _fileExistsCache = {};

  final TransformationController _transformationController =
      TransformationController();
  late int _currentIndex;
  bool _isZoomed = false;

  @override
  Widget build(BuildContext context) {
    AppLogger.debug('BaseImagePreview build', tag: 'BaseImagePreview', data: {
      'hasPaths': widget.imagePaths.isNotEmpty,
      'pathCount': widget.imagePaths.length,
      'currentIndex': _currentIndex,
      'currentPath': widget.imagePaths.isNotEmpty
          ? widget.imagePaths[_currentIndex]
          : null,
    });

    return Container(
      decoration: widget.previewDecoration ??
          BoxDecoration(
            border: Border.all(color: Colors.grey.shade300),
            borderRadius: BorderRadius.circular(4),
          ),
      child: widget.imagePaths.isEmpty
          ? const Center(child: Text('没有图片'))
          : _buildImageViewer(),
    );
  }

  @override
  void dispose() {
    _transformationController.dispose();
    super.dispose();
  }

  @override
  void initState() {
    super.initState();
    _currentIndex = widget.imagePaths.isEmpty
        ? 0
        : widget.initialIndex.clamp(0, widget.imagePaths.length - 1);
    _checkImageFiles();
  }

  Widget _buildImageViewer() {
    final currentPath = widget.imagePaths[_currentIndex];
    final fileExists = _fileExistsCache[currentPath] ?? false;

    if (!fileExists) {
      return const Center(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Icon(Icons.broken_image, size: 64, color: Colors.grey),
            SizedBox(height: 16),
            Text('图片文件不存在'),
          ],
        ),
      );
    }

    final file = File(currentPath);

    return GestureDetector(
      onHorizontalDragEnd: (details) {
        if (_isZoomed) return; // 如果已缩放则不切换图片

        if (details.primaryVelocity == null) return;
        if (details.primaryVelocity! > 0 && _currentIndex > 0) {
          // 向右滑动，显示上一张
          _updateIndex(_currentIndex - 1);
        } else if (details.primaryVelocity! < 0 &&
            _currentIndex < widget.imagePaths.length - 1) {
          // 向左滑动，显示下一张
          _updateIndex(_currentIndex + 1);
        }
      },
      onTapDown: (details) {
        if (_isZoomed) return; // 如果已缩放则不切换图片

        final x = details.localPosition.dx;
        final screenWidth = context.size?.width ?? 0;
        if (x < screenWidth / 3) {
          // 点击左侧三分之一区域，显示上一张
          if (_currentIndex > 0) {
            _updateIndex(_currentIndex - 1);
          }
        } else if (x > screenWidth * 2 / 3) {
          // 点击右侧三分之一区域，显示下一张
          if (_currentIndex < widget.imagePaths.length - 1) {
            _updateIndex(_currentIndex + 1);
          }
        }
      },
      child: InteractiveViewer(
        transformationController: _transformationController,
        boundaryMargin: _viewerPadding,
        minScale: _minZoomScale,
        maxScale: _maxZoomScale,
        onInteractionStart: (details) {
          if (details.pointerCount > 1) {
            _isZoomed = true;
          }
        },
        onInteractionEnd: (details) {
          // 检查是否恢复到原始大小
          final matrix = _transformationController.value;
          if (matrix == Matrix4.identity()) {
            _isZoomed = false;
          }
        },
        child: Center(
          child: AnimatedSwitcher(
            duration: const Duration(milliseconds: 200),
            child: Image.file(
              file,
              key: ValueKey(currentPath),
              fit: BoxFit.contain,
              errorBuilder: (context, error, stackTrace) {
                AppLogger.error(
                  '图片加载失败',
                  tag: 'BaseImagePreview',
                  error: error,
                  stackTrace: stackTrace,
                  data: {'path': currentPath},
                );
                return const Center(
                  child: Column(
                    mainAxisSize: MainAxisSize.min,
                    children: [
                      Icon(Icons.broken_image, size: 64, color: Colors.red),
                      SizedBox(height: 16),
                      Text('图片加载失败', style: TextStyle(color: Colors.red)),
                    ],
                  ),
                );
              },
            ),
          ),
        ),
      ),
    );
  }

  Future<void> _checkImageFiles() async {
    for (final path in widget.imagePaths) {
      try {
        final file = File(path);
        _fileExistsCache[path] = await file.exists();
      } catch (e) {
        _fileExistsCache[path] = false;
        AppLogger.error('检查图片文件失败',
            tag: 'BaseImagePreview', error: e, data: {'path': path});
      }
    }
    if (mounted) {
      setState(() {});
    }
  }

  void _updateIndex(int newIndex) {
    if (newIndex != _currentIndex &&
        newIndex >= 0 &&
        newIndex < widget.imagePaths.length) {
      setState(() {
        _currentIndex = newIndex;
        // 重置缩放
        _transformationController.value = Matrix4.identity();
        _isZoomed = false;
      });
      widget.onIndexChanged?.call(_currentIndex);
    }
  }
}



=======================================
./lib/presentation/widgets/common/character_preview.dart
=======================================
import 'package:flutter/material.dart';

import '../../../domain/models/character/character_entity.dart';

/// 字形预览组件
class CharacterPreview extends StatelessWidget {
  final CharacterEntity character;
  final bool showGrid;
  final double initialScale;
  final void Function(double)? onScaleChanged;

  const CharacterPreview({
    super.key,
    required this.character,
    this.showGrid = false,
    this.initialScale = 1.0,
    this.onScaleChanged,
  });

  @override
  Widget build(BuildContext context) {
    return RepaintBoundary(
      child: InteractiveViewer(
        minScale: 0.1,
        maxScale: 5.0,
        onInteractionUpdate: (details) {
          if (onScaleChanged != null) {
            onScaleChanged!(details.scale);
          }
        },
        child: Stack(
          children: [
            // 字形图片
            const Icon(
              Icons.broken_image,
              size: 48,
              color: Colors.red,
            ),

            // 参考网格
            if (showGrid)
              CustomPaint(
                painter: GridPainter(),
                size: Size.infinite,
              ),
          ],
        ),
      ),
    );
  }
}

/// 网格绘制器
class GridPainter extends CustomPainter {
  @override
  void paint(Canvas canvas, Size size) {
    final paint = Paint()
      ..color = Colors.grey.withOpacity(0.3)
      ..strokeWidth = 0.5;

    const gridSize = 50.0;

    for (var i = 0.0; i < size.width; i += gridSize) {
      canvas.drawLine(
        Offset(i, 0),
        Offset(i, size.height),
        paint,
      );
    }

    for (var i = 0.0; i < size.height; i += gridSize) {
      canvas.drawLine(
        Offset(0, i),
        Offset(size.width, i),
        paint,
      );
    }
  }

  @override
  bool shouldRepaint(CustomPainter oldDelegate) => false;
}



=======================================
./lib/presentation/widgets/common/character_preview_panel.dart
=======================================
import 'dart:io';
import 'dart:math' as math;
import 'dart:ui' as ui;

import 'package:flutter/material.dart';

import '../../../domain/models/character/character_region.dart';

class CharacterPreviewPanel extends StatelessWidget {
  final CharacterRegion? region;
  final String? label;
  final VoidCallback? onClear;
  final VoidCallback? onSave;

  const CharacterPreviewPanel({
    super.key,
    this.region,
    this.label,
    this.onClear,
    this.onSave,
  });

  @override
  Widget build(BuildContext context) {
    if (region == null) {
      return const Center(child: Text('请选择或框选字符区域'));
    }

    return Column(
      crossAxisAlignment: CrossAxisAlignment.stretch,
      children: [
        if (label != null) ...[
          Text(
            label!,
            style: const TextStyle(
              fontSize: 16,
              fontWeight: FontWeight.bold,
            ),
          ),
          const SizedBox(height: 8),
        ],
        Expanded(
          child: Container(
            decoration: BoxDecoration(
              border: Border.all(color: Colors.grey.shade300),
              borderRadius: BorderRadius.circular(4),
            ),
            child: ClipRRect(
              borderRadius: BorderRadius.circular(4),
              child: _buildPreview(),
            ),
          ),
        ),
        const SizedBox(height: 16),
        Row(
          children: [
            Expanded(
              child: FilledButton.icon(
                onPressed: onSave,
                icon: const Icon(Icons.save),
                label: const Text('保存'),
              ),
            ),
            const SizedBox(width: 8),
            IconButton(
              onPressed: onClear,
              icon: const Icon(Icons.refresh),
              tooltip: '清除',
            ),
          ],
        ),
      ],
    );
  }

  Widget _buildPreview() {
    if (region == null) return const SizedBox();

    return FutureBuilder<ui.Image>(
      future: _loadImage(),
      builder: (context, snapshot) {
        if (snapshot.connectionState == ConnectionState.waiting) {
          return const Center(
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                CircularProgressIndicator(),
                SizedBox(height: 16),
                Text('加载预览...'),
              ],
            ),
          );
        }

        if (snapshot.hasError || !snapshot.hasData) {
          return const Center(
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                Icon(Icons.broken_image, size: 48, color: Colors.red),
                SizedBox(height: 8),
                Text('图片加载失败', style: TextStyle(color: Colors.red)),
              ],
            ),
          );
        }

        return Container(
          color: Colors.white,
          child: CustomPaint(
            painter: _CharacterPreviewPainter(
              image: snapshot.data!,
              region: region!,
            ),
            size: Size.infinite,
          ),
        );
      },
    );
  }

  Future<ui.Image> _loadImage() async {
    final file = File(region!.imagePath);
    final bytes = await file.readAsBytes();
    final codec = await ui.instantiateImageCodec(bytes);
    final frame = await codec.getNextFrame();
    return frame.image;
  }
}

class _CharacterPreviewPainter extends CustomPainter {
  final ui.Image image;
  final CharacterRegion region;

  _CharacterPreviewPainter({
    required this.image,
    required this.region,
  });

  @override
  void paint(Canvas canvas, Size size) {
    final paint = Paint()
      ..color = Colors.white
      ..style = PaintingStyle.fill;

    // Fill background
    canvas.drawRect(Offset.zero & size, paint);

    // Calculate scale to fit
    final scale = math.min(
      size.width / region.rect.width,
      size.height / region.rect.height,
    );

    // Center the image
    final centeredRect = Rect.fromCenter(
      center: size.center(Offset.zero),
      width: region.rect.width * scale,
      height: region.rect.height * scale,
    );

    // Apply transformations
    canvas.save();
    canvas.translate(centeredRect.center.dx, centeredRect.center.dy);
    canvas.rotate(region.rotation);
    canvas.translate(-centeredRect.center.dx, -centeredRect.center.dy);

    // Draw the image section
    paint.filterQuality = FilterQuality.high;
    canvas.drawImageRect(
      image,
      region.rect,
      centeredRect,
      paint,
    );

    canvas.restore();
  }

  @override
  bool shouldRepaint(_CharacterPreviewPainter oldDelegate) {
    return image != oldDelegate.image || region != oldDelegate.region;
  }
}



=======================================
./lib/presentation/widgets/common/confirm_dialog.dart
=======================================
import 'package:flutter/material.dart';

import '../../../theme/app_sizes.dart';

/// 通用确认对话框
class ConfirmDialog extends StatelessWidget {
  final String title;
  final String content;
  final VoidCallback onConfirm;
  final VoidCallback? onCancel;
  final String? confirmText;
  final String? cancelText;
  final bool isDestructive;

  const ConfirmDialog({
    super.key,
    required this.title,
    required this.content,
    required this.onConfirm,
    this.onCancel,
    this.confirmText,
    this.cancelText,
    this.isDestructive = false,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return AlertDialog(
      title: Text(title),
      content: Text(content),
      contentPadding: const EdgeInsets.fromLTRB(
        AppSizes.l,
        AppSizes.m,
        AppSizes.l,
        0,
      ),
      actionsPadding: const EdgeInsets.all(AppSizes.m),
      actions: [
        TextButton(
          onPressed: () {
            onCancel?.call();
            Navigator.of(context).pop(false);
          },
          child: Text(cancelText ?? '取消'),
        ),
        FilledButton(
          onPressed: () {
            onConfirm();
            Navigator.of(context).pop(true);
          },
          style: isDestructive
              ? FilledButton.styleFrom(
                  backgroundColor: theme.colorScheme.error,
                  foregroundColor: theme.colorScheme.onError,
                )
              : null,
          child: Text(confirmText ?? '确定'),
        ),
      ],
    );
  }
}



=======================================
./lib/presentation/widgets/common/data_list.dart
=======================================
import 'package:flutter/material.dart';

class DataList extends StatelessWidget {
  final bool isGridView;
  final int itemCount;
  final IndexedWidgetBuilder itemBuilder;
  final double gridSpacing;
  final int gridCrossAxisCount;

  const DataList({
    super.key,
    this.isGridView = true,
    required this.itemCount,
    required this.itemBuilder,
    this.gridSpacing = 16.0,
    this.gridCrossAxisCount = 4,
  });

  @override
  Widget build(BuildContext context) {
    if (isGridView) {
      return GridView.builder(
        padding: const EdgeInsets.all(16),
        gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(
          crossAxisCount: gridCrossAxisCount,
          mainAxisSpacing: gridSpacing,
          crossAxisSpacing: gridSpacing,
          childAspectRatio: 1,
        ),
        itemCount: itemCount,
        itemBuilder: itemBuilder,
      );
    }
    
    return ListView.builder(
      padding: const EdgeInsets.all(16),
      itemCount: itemCount,
      itemBuilder: itemBuilder,
    );
  }
}



=======================================
./lib/presentation/widgets/common/detail_toolbar.dart
=======================================
import 'package:flutter/material.dart';

import '../../../theme/app_colors.dart';
import '../../../theme/app_sizes.dart';

class DetailBadge {
  final String text;
  final Color? backgroundColor;
  final Color? textColor;

  const DetailBadge({
    required this.text,
    this.backgroundColor,
    this.textColor,
  });
}

class DetailToolbar extends StatelessWidget implements PreferredSizeWidget {
  final String title;
  final IconData? leadingIcon;
  final String? subtitle;
  final DetailBadge? badge;
  final List<DetailToolbarAction> actions;
  final VoidCallback? onBack;

  const DetailToolbar({
    super.key,
    required this.title,
    this.leadingIcon,
    this.subtitle,
    this.badge,
    this.actions = const [],
    this.onBack,
  });

  @override
  Size get preferredSize => const Size.fromHeight(kToolbarHeight);

  @override
  Widget build(BuildContext context) {
    return AppBar(
      leading: IconButton(
        icon: const Icon(Icons.arrow_back),
        onPressed: onBack ?? () => Navigator.of(context).pop(),
      ),
      title: Row(
        children: [
          if (leadingIcon != null) ...[
            Icon(
              leadingIcon!,
              size: 24,
              color: Theme.of(context).primaryColor,
            ),
            const SizedBox(width: AppSizes.s),
          ],
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              mainAxisSize: MainAxisSize.min,
              children: [
                Text(title),
                if (subtitle != null)
                  Text(
                    subtitle!,
                    style: Theme.of(context).textTheme.bodySmall,
                  ),
              ],
            ),
          ),
          if (badge != null)
            Container(
              padding: const EdgeInsets.symmetric(
                horizontal: AppSizes.s,
                vertical: AppSizes.xxs,
              ),
              decoration: BoxDecoration(
                color: badge!.backgroundColor ?? AppColors.primary,
                borderRadius: BorderRadius.circular(12),
              ),
              child: Text(
                badge!.text,
                style: Theme.of(context).textTheme.bodySmall?.copyWith(
                      color: badge!.textColor ?? Colors.white,
                    ),
              ),
            ),
        ],
      ),
      actions: actions.map((action) {
        return IconButton(
          icon: Icon(
            action.icon,
            color: action.color,
          ),
          tooltip: action.tooltip,
          onPressed: action.onPressed,
        );
      }).toList(),
    );
  }
}

class DetailToolbarAction {
  final IconData icon;
  final String tooltip;
  final VoidCallback onPressed;
  final Color? color;
  final bool primary;

  const DetailToolbarAction({
    required this.icon,
    required this.tooltip,
    required this.onPressed,
    this.color,
    this.primary = false,
  });
}



=======================================
./lib/presentation/widgets/common/empty_state.dart
=======================================
import 'package:flutter/material.dart';

import '../../../theme/app_sizes.dart';

class EmptyState extends StatelessWidget {
  final EmptyStateType type;
  final String? message;
  final IconData? icon;
  final String? actionLabel;
  final VoidCallback? onAction;
  final Widget? customContent;

  const EmptyState({
    super.key,
    this.type = EmptyStateType.noResults,
    this.message,
    this.icon,
    this.actionLabel,
    this.onAction,
    this.customContent,
  });

  @override
  Widget build(BuildContext context) {
    return Center(
      child: Padding(
        padding: const EdgeInsets.all(AppSizes.spacingLarge),
        child: customContent ?? _buildDefaultContent(context),
      ),
    );
  }

  Widget _buildDefaultContent(BuildContext context) {
    final theme = Theme.of(context);

    // 根据类型设置默认图标和消息
    final IconData defaultIcon = _getDefaultIcon();
    final String defaultMessage = _getDefaultMessage();

    return Column(
      mainAxisSize: MainAxisSize.min,
      children: [
        Icon(
          icon ?? defaultIcon,
          size: 64,
          color: theme.colorScheme.onSurfaceVariant.withOpacity(0.5),
        ),
        const SizedBox(height: AppSizes.spacingMedium),
        Text(
          message ?? defaultMessage,
          style: theme.textTheme.bodyLarge?.copyWith(
            color: theme.colorScheme.onSurfaceVariant,
          ),
          textAlign: TextAlign.center,
        ),
        if (actionLabel != null && onAction != null) ...[
          const SizedBox(height: AppSizes.spacingLarge),
          FilledButton.icon(
            onPressed: onAction,
            icon: const Icon(Icons.add),
            label: Text(actionLabel!),
          ),
        ],
      ],
    );
  }

  IconData _getDefaultIcon() {
    switch (type) {
      case EmptyStateType.noWorks:
        return Icons.collections_outlined;
      case EmptyStateType.noCharacters:
        return Icons.text_fields_outlined;
      case EmptyStateType.noPractices:
        return Icons.edit_note_outlined;
      case EmptyStateType.noResults:
        return Icons.search_off_outlined;
      case EmptyStateType.noSelection:
        return Icons.select_all_outlined;
      case EmptyStateType.error:
        return Icons.error_outline;
      case EmptyStateType.custom:
        return Icons.info_outline;
    }
  }

  String _getDefaultMessage() {
    switch (type) {
      case EmptyStateType.noWorks:
        return '没有作品\n点击添加按钮导入作品';
      case EmptyStateType.noCharacters:
        return '没有字形\n从作品中提取字形后可在此查看';
      case EmptyStateType.noPractices:
        return '没有练习\n点击添加按钮创建新练习';
      case EmptyStateType.noResults:
        return '没有找到匹配的结果\n尝试更改搜索条件';
      case EmptyStateType.noSelection:
        return '未选择任何项目\n点击项目以选择';
      case EmptyStateType.error:
        return '加载失败\n请稍后再试';
      case EmptyStateType.custom:
        return '';
    }
  }
}

enum EmptyStateType {
  noWorks,
  noCharacters,
  noPractices,
  noResults,
  noSelection,
  error,
  custom,
}



=======================================
./lib/presentation/widgets/common/error_display.dart
=======================================
import 'package:flutter/material.dart';

import '../../../theme/app_colors.dart';
import '../../../theme/app_sizes.dart';

class ErrorDisplay extends StatelessWidget {
  final String error;
  final VoidCallback? onRetry;
  final IconData? icon;

  const ErrorDisplay({
    super.key,
    required this.error,
    this.onRetry,
    this.icon = Icons.error_outline,
  });

  @override
  Widget build(BuildContext context) {
    return Center(
      child: Padding(
        padding: const EdgeInsets.all(AppSizes.l),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Icon(
              icon,
              size: 48,
              color: AppColors.error,
            ),
            const SizedBox(height: AppSizes.m),
            Text(
              error,
              style: Theme.of(context).textTheme.titleMedium,
              textAlign: TextAlign.center,
            ),
            if (onRetry != null) ...[
              const SizedBox(height: AppSizes.l),
              ElevatedButton(
                onPressed: onRetry,
                child: const Text('重试'),
              ),
            ],
          ],
        ),
      ),
    );
  }
}



=======================================
./lib/presentation/widgets/common/error_view.dart
=======================================
import 'package:flutter/material.dart';

import '../../../theme/app_sizes.dart';

/// 通用错误视图
class ErrorView extends StatelessWidget {
  final String message;
  final VoidCallback? onRetry;
  final bool showBackground;
  final Color? backgroundColor;
  final IconData? icon;

  const ErrorView({
    super.key,
    required this.message,
    this.onRetry,
    this.showBackground = false,
    this.backgroundColor,
    this.icon,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final bgColor = backgroundColor ?? theme.colorScheme.surface;

    Widget content = Column(
      mainAxisSize: MainAxisSize.min,
      children: [
        Icon(
          icon ?? Icons.error_outline,
          size: 48,
          color: theme.colorScheme.error,
        ),
        const SizedBox(height: AppSizes.m),
        Text(
          message,
          style: TextStyle(color: theme.colorScheme.error),
          textAlign: TextAlign.center,
        ),
        if (onRetry != null) ...[
          const SizedBox(height: AppSizes.m),
          FilledButton.icon(
            onPressed: onRetry,
            icon: const Icon(Icons.refresh),
            label: const Text('重试'),
          ),
        ],
      ],
    );

    if (showBackground) {
      content = Container(
        color: bgColor,
        padding: const EdgeInsets.all(AppSizes.m),
        child: content,
      );
    }

    return Center(child: content);
  }
}



=======================================
./lib/presentation/widgets/common/grid_placeholder.dart
=======================================
import 'package:flutter/material.dart';

/// A placeholder widget for grid items during loading
class GridPlaceholder extends StatelessWidget {
  const GridPlaceholder({super.key});

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Card(
      clipBehavior: Clip.antiAlias,
      elevation: 1,
      color: theme.colorScheme.surface,
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Image placeholder
          Expanded(
            flex: 3,
            child: Container(
              color: theme.colorScheme.surfaceContainerHighest.withOpacity(0.5),
            ),
          ),

          // Title placeholder
          Padding(
            padding: const EdgeInsets.all(8.0),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Container(
                  height: 16,
                  width: double.infinity,
                  decoration: BoxDecoration(
                    color: theme.colorScheme.surfaceContainerHighest
                        .withOpacity(0.7),
                    borderRadius: BorderRadius.circular(4),
                  ),
                ),
                const SizedBox(height: 8),
                Row(
                  children: [
                    // Author placeholder
                    Expanded(
                      child: Container(
                        height: 12,
                        decoration: BoxDecoration(
                          color: theme.colorScheme.surfaceContainerHighest
                              .withOpacity(0.5),
                          borderRadius: BorderRadius.circular(4),
                        ),
                      ),
                    ),
                    const SizedBox(width: 8),
                    // Style placeholder
                    Container(
                      height: 12,
                      width: 40,
                      decoration: BoxDecoration(
                        color:
                            theme.colorScheme.primaryContainer.withOpacity(0.5),
                        borderRadius: BorderRadius.circular(4),
                      ),
                    ),
                  ],
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }
}



=======================================
./lib/presentation/widgets/common/image_preview.dart
=======================================
import 'dart:io';
import 'dart:math' as math;

import 'package:flutter/material.dart';
import 'package:flutter/rendering.dart';
import 'package:flutter/services.dart';

import '../../../application/services/image/character_image_processor.dart';
import '../../../domain/models/character/character_region.dart';
import '../../../domain/repositories/character_repository.dart';
import 'character_preview_panel.dart';
import 'region_painter.dart';
import 'region_properties_dialog.dart';

class ImagePreview extends StatefulWidget {
  final List<String> imagePaths;
  final int initialIndex;
  final Function(int)? onIndexChanged;
  final bool showThumbnails;
  final bool enableZoom;
  final BoxDecoration? previewDecoration;
  final EdgeInsets? padding;
  final List<CharacterRegion>? collectedRegions;
  final Function(CharacterRegion)? onRegionCreated;
  final Function(CharacterRegion)? onRegionSelected;
  final Function(List<CharacterRegion>)? onRegionsDeleted;
  final String? workId;

  const ImagePreview({
    super.key,
    required this.imagePaths,
    this.initialIndex = 0,
    this.onIndexChanged,
    this.showThumbnails = true,
    this.enableZoom = true,
    this.previewDecoration,
    this.padding,
    this.collectedRegions,
    this.onRegionCreated,
    this.onRegionSelected,
    this.onRegionsDeleted,
    this.workId,
  });

  @override
  State<ImagePreview> createState() => _ImagePreviewState();
}

class _ImagePreviewState extends State<ImagePreview>
    with WidgetsBindingObserver {
  static const double _minRegionSize = 20.0;
  static const double _minZoomScale = 0.1;
  static const double _maxZoomScale = 10.0;
  static const EdgeInsets _viewerPadding = EdgeInsets.all(20.0);

  final TransformationController _transformationController =
      TransformationController();
  final ScrollController _scrollController = ScrollController();
  final Set<CharacterRegion> _selectedRegions = {};

  final _state = _PreviewState();
  late final CharacterRepository _repository;

  @override
  Widget build(BuildContext context) {
    return Row(
      children: [
        // Main image preview area (takes 75% of the width)
        Expanded(
          flex: 75,
          child: Column(
            children: [
              _buildToolbar(),
              Expanded(
                child: _buildPreviewArea(),
              ),
            ],
          ),
        ),

        // Right preview panel (takes 25% of the width)
        SizedBox(
          width: 300, // Fixed width for preview panel
          child: Padding(
            padding: const EdgeInsets.all(16.0),
            child: CharacterPreviewPanel(
              region: _state.selectedRegion,
              label: _state.selectedRegion?.label,
              onClear: () {
                if (_state.selectedRegion == null) return;
                _handleRegionOperation(() {
                  _preserveAndUpdateState(() {
                    _state.selectedRegion = _state.selectedRegion!.copyWith(
                      isSaved: false,
                    );
                    if (widget.onRegionSelected != null) {
                      widget.onRegionSelected!(_state.selectedRegion!);
                    }
                  });
                  return Future<void>.value();
                }, errorMessage: '清除失败');
              },
              onSave: () => _showSaveDialog(_state.selectedRegion),
            ),
          ),
        ),
      ],
    );
  }

  @override
  void didChangeAppLifecycleState(AppLifecycleState state) {
    if (state == AppLifecycleState.paused) {
    } else if (state == AppLifecycleState.resumed) {}
  }

  @override
  void dispose() {
    WidgetsBinding.instance.removeObserver(this);
    _transformationController.dispose();
    _scrollController.dispose();
    _selectedRegions.clear();
    _state.reset();

    super.dispose();
  }

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addObserver(this);
    _initializeRepository();
    _state.currentIndex = widget.initialIndex;
  }

  void _announceStateChange(String message) {
    SemanticsService.announce(message, TextDirection.ltr);
  }

  Widget _buildBoxSelectionTool() {
    return MergeSemantics(
      child: Semantics(
        button: true,
        label: '框选工具',
        value: _state.isBoxSelectionMode ? '已开启' : '未开启',
        hint: _state.isBoxSelectionMode ? '点击关闭框选模式' : '点击开启框选模式',
        enabled: true,
        child: IconButton(
          icon: Icon(
            _state.isBoxSelectionMode ? Icons.crop_din : Icons.crop_free,
            color: _state.isBoxSelectionMode
                ? Theme.of(context).primaryColor
                : null,
          ),
          onPressed: () {
            HapticFeedback.selectionClick();
            _preserveAndUpdateState(() {
              _state.isBoxSelectionMode = !_state.isBoxSelectionMode;
              if (!_state.isBoxSelectionMode) {
                _clearSelection();
              }
              _announceStateChange(
                  '框选工具${_state.isBoxSelectionMode ? '已开启' : '已关闭'}');
            });
          },
          tooltip: '框选工具',
        ),
      ),
    );
  }

  Widget _buildDeleteButton() {
    return MergeSemantics(
      child: Semantics(
        button: true,
        label: '删除选中区域',
        value: '${_selectedRegions.length}个区域',
        hint: '点击删除所有选中的区域',
        enabled: true,
        child: IconButton(
          icon: const Icon(Icons.delete),
          onPressed: _deleteSelectedRegions,
          tooltip: '删除选中区域',
        ),
      ),
    );
  }

  Widget _buildImageViewer() {
    return MouseRegion(
      cursor: _getCursor(),
      child: GestureDetector(
        onTapDown: _handleTapDown,
        onTapUp: _handleTapUp,
        onDoubleTap: _handleDoubleTap,
        onPanStart:
            _state.isBoxSelectionMode ? _handlePanStart : _handleRegionStart,
        onPanUpdate:
            _state.isBoxSelectionMode ? _handlePanUpdate : _handleRegionUpdate,
        onPanEnd: _state.isBoxSelectionMode ? _handlePanEnd : _handleRegionEnd,
        onSecondaryTapDown: (_) {
          HapticFeedback.lightImpact();
          _cleanupState();
          _announceStateChange('清除所有状态');
        },
        child: InteractiveViewer(
          transformationController: _transformationController,
          boundaryMargin: _viewerPadding,
          minScale: _minZoomScale,
          maxScale: _maxZoomScale,
          constrained: widget.enableZoom,
          child: Stack(
            children: [
              Center(child: _buildMainImage()),
              if (widget.collectedRegions != null) ..._buildRegions(),
              if (_state.selectionStart != null &&
                  _state.selectionCurrent != null)
                _buildSelectionOverlay(),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildMainImage() {
    return Image.file(
      File(widget.imagePaths[_state.currentIndex]),
      fit: BoxFit.contain,
      errorBuilder: (context, error, stackTrace) {
        _showErrorMessage('图片加载失败');
        return const Center(
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              Icon(Icons.broken_image, size: 64, color: Colors.red),
              SizedBox(height: 16),
              Text('图片加载失败', style: TextStyle(color: Colors.red)),
            ],
          ),
        );
      },
    );
  }

  Widget _buildMultiSelectTool() {
    return MergeSemantics(
      child: Semantics(
        button: true,
        label: '多选工具',
        value: _state.isMultiSelectMode ? '已开启' : '未开启',
        hint: _state.isMultiSelectMode ? '点击关闭多选模式' : '点击开启多选模式',
        enabled: true,
        child: IconButton(
          icon: Icon(
            _state.isMultiSelectMode ? Icons.select_all : Icons.touch_app,
            color: _state.isMultiSelectMode
                ? Theme.of(context).primaryColor
                : null,
          ),
          onPressed: () {
            HapticFeedback.selectionClick();
            _preserveAndUpdateState(() {
              _state.isMultiSelectMode = !_state.isMultiSelectMode;
              if (!_state.isMultiSelectMode) {
                _selectedRegions.clear();
                _state.selectedRegion = null;
              }
              _announceStateChange(
                  '多选模式${_state.isMultiSelectMode ? '已开启' : '已关闭'}');
            });
          },
          tooltip: '多选工具',
        ),
      ),
    );
  }

  Widget _buildPreviewArea() {
    return Container(
      decoration: widget.previewDecoration ??
          BoxDecoration(
            border: Border.all(color: Colors.grey.shade300),
            borderRadius: BorderRadius.circular(4),
          ),
      child: widget.imagePaths.isNotEmpty
          ? _buildImageViewer()
          : const Center(child: Text('没有图片')),
    );
  }

  List<Widget> _buildRegions() {
    return widget.collectedRegions
            ?.where((region) => region.pageIndex == _state.currentIndex)
            .map((region) => MergeSemantics(
                  child: Semantics(
                    label: region.label ?? '未命名区域',
                    selected: _selectedRegions.contains(region),
                    enabled: true,
                    hint: _selectedRegions.contains(region)
                        ? '双击编辑区域属性'
                        : '点击选择区域',
                    value: _getRegionDescription(region),
                    child: ExcludeSemantics(
                      child: CustomPaint(
                        painter: RegionPainter(
                          region: region,
                          isSelected: _selectedRegions.contains(region),
                        ),
                      ),
                    ),
                  ),
                ))
            .toList() ??
        [];
  }

  Widget _buildSelectionCount() {
    return MergeSemantics(
      child: Semantics(
        label: '已选择区域数量',
        value: '${_selectedRegions.length}个',
        child: ExcludeSemantics(
          child: Padding(
            padding: const EdgeInsets.symmetric(horizontal: 8.0),
            child: Text(
              '已选择: ${_selectedRegions.length}',
              style: TextStyle(
                color: Theme.of(context).primaryColor,
                fontWeight: FontWeight.bold,
              ),
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildSelectionOverlay() {
    return CustomPaint(
      painter: RegionPainter(
        selectionStart: _state.selectionStart,
        selectionEnd: _state.selectionCurrent,
        isSelecting: true,
      ),
    );
  }

  Widget _buildToolbar() {
    return MergeSemantics(
      child: Semantics(
        container: true,
        label: '工具栏',
        child: Row(
          children: [
            _buildBoxSelectionTool(),
            _buildMultiSelectTool(),
            if (_selectedRegions.isNotEmpty) ...[
              _buildDeleteButton(),
              _buildSelectionCount(),
            ],
          ],
        ),
      ),
    );
  }

  void _cleanupState() {
    setState(() {
      _state.reset();
      _selectedRegions.clear();
    });
  }

  void _clearSelection() {
    setState(() {
      _state.selectionStart = null;
      _state.selectionCurrent = null;
      _state.selectedRegion = null;
      _selectedRegions.clear();
    });
  }

  Future<void> _deleteSelectedRegions() async {
    if (_selectedRegions.isEmpty) return;

    final confirmed = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('删除确认'),
        content: Text('确定要删除选中的${_selectedRegions.length}个区域吗？'),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(false),
            child: const Text('取消'),
          ),
          FilledButton(
            onPressed: () => Navigator.of(context).pop(true),
            style: FilledButton.styleFrom(
              backgroundColor: Colors.red,
            ),
            child: const Text('删除'),
          ),
        ],
      ),
    );

    if (confirmed != true) return;

    _showProcessingIndicator();
    try {
      await _repository.deleteMany(
          _selectedRegions.map((region) => region.label ?? '').toList());

      _preserveAndUpdateState(() {
        if (widget.onRegionsDeleted != null) {
          widget.onRegionsDeleted!(_selectedRegions.toList());
        }
        _selectedRegions.clear();
        _state.selectedRegion = null;
        _announceStateChange('删除成功');
      });
    } catch (e) {
      _showErrorMessage('删除失败: $e');
    } finally {
      _hideProcessingIndicator();
    }
  }

  MouseCursor _getCursor() {
    if (_state.isBoxSelectionMode) {
      return SystemMouseCursors.precise;
    } else if (_state.resizeHandleIndex != null) {
      return SystemMouseCursors.resizeUpDown;
    } else if (_state.isRotating) {
      return SystemMouseCursors.grab;
    }
    return SystemMouseCursors.basic;
  }

  String _getRegionDescription(CharacterRegion region) {
    final size = '${region.rect.width.toInt()}×${region.rect.height.toInt()}';
    final position =
        '位置(${region.rect.left.toInt()}, ${region.rect.top.toInt()})';
    return '${region.label ?? "未命名区域"}, 大小$size, $position';
  }

  void _handleDoubleTap() async {
    if (_state.selectedRegion == null) return;
    await _showSaveDialog(_state.selectedRegion);
  }

  void _handlePanEnd(DragEndDetails details) {
    if (!_state.isBoxSelectionMode) return;

    if (_state.selectionStart != null && _state.selectionCurrent != null) {
      final rect =
          Rect.fromPoints(_state.selectionStart!, _state.selectionCurrent!);

      if (rect.width >= _minRegionSize && rect.height >= _minRegionSize) {
        final region = CharacterRegion(
          pageIndex: _state.currentIndex,
          left: rect.left,
          top: rect.top,
          width: rect.width,
          height: rect.height,
          imagePath: widget.imagePaths[_state.currentIndex],
        );

        if (widget.onRegionCreated != null) {
          widget.onRegionCreated!(region);
          _announceStateChange('已创建新区域');
        }

        _preserveAndUpdateState(() {
          _state.selectedRegion = region;
          _selectedRegions.clear();
          _selectedRegions.add(region);
        });
      } else {
        _announceStateChange('选择区域太小');
      }
    }

    _preserveAndUpdateState(() {
      _state.selectionStart = null;
      _state.selectionCurrent = null;
    });
  }

  void _handlePanStart(DragStartDetails details) {
    if (!_state.isBoxSelectionMode) return;

    _preserveAndUpdateState(() {
      _state.selectionStart = details.localPosition;
      _state.selectionCurrent = details.localPosition;
      HapticFeedback.selectionClick();
    });
  }

  void _handlePanUpdate(DragUpdateDetails details) {
    if (!_state.isBoxSelectionMode) return;

    _preserveAndUpdateState(() {
      _state.selectionCurrent = details.localPosition;
    });
  }

  void _handleRegionEnd(DragEndDetails details) {
    if (_state.selectedRegion == null) return;

    _preserveAndUpdateState(() {
      if (_state.isRotating) {
        _announceStateChange('完成旋转');
      } else if (_state.resizeHandleIndex != null) {
        _announceStateChange('完成调整大小');
      } else if (_state.dragStartOffset != null) {
        _announceStateChange('完成移动');
      }

      _state.resetManipulation();
    });

    HapticFeedback.lightImpact();
  }

  Future<void> _handleRegionOperation(Future<void> Function() operation,
      {String? errorMessage}) {
    return operation().catchError((error) async {
      _showErrorMessage(errorMessage ?? '操作失败: $error');
      return Future<void>.value(); // Explicitly return a completed Future<void>
    });
  }

  void _handleRegionStart(DragStartDetails details) {
    if (_state.selectedRegion == null) return;

    final region = _state.selectedRegion!;
    final painter = RegionPainter(region: region, isSelected: true);

    final handleIndex =
        painter.getHandleAtPoint(details.localPosition, region.rect);

    if (handleIndex != null || region.rect.contains(details.localPosition)) {
      HapticFeedback.selectionClick();
    }

    _preserveAndUpdateState(() {
      if (handleIndex != null) {
        _state.resizeHandleIndex = handleIndex;
        _announceStateChange('开始调整区域大小');
      } else if (painter.isRotationHandle(details.localPosition, region.rect)) {
        _state.isRotating = true;
        _state.rotationStartAngle = region.rotation;
        _state.rotationCenter = region.rect.center;
        _announceStateChange('开始旋转区域');
      } else if (region.rect.contains(details.localPosition)) {
        _state.dragStartOffset = details.localPosition;
        _state.dragStartRect = region.rect;
        _announceStateChange('开始移动区域');
      }
    });
  }

  void _handleRegionUpdate(DragUpdateDetails details) {
    if (_state.selectedRegion == null) return;

    _preserveAndUpdateState(() {
      if (_state.resizeHandleIndex != null) {
        _handleResize(details, _state.selectedRegion!);
      } else if (_state.isRotating && _state.rotationCenter != null) {
        _handleRotate(details, _state.selectedRegion!);
      } else if (_state.dragStartOffset != null &&
          _state.dragStartRect != null) {
        final delta = details.localPosition - _state.dragStartOffset!;
        final rect = _state.dragStartRect!.translate(delta.dx, delta.dy);
        _state.selectedRegion = _state.selectedRegion!.copyWith(
          left: rect.left,
          top: rect.top,
          width: rect.width,
          height: rect.height,
        );
      }
    });
  }

  void _handleResize(DragUpdateDetails details, CharacterRegion region) {
    if (_state.resizeHandleIndex == null) return;

    final delta = details.delta;
    double newLeft = region.rect.left;
    double newTop = region.rect.top;
    double newWidth = region.rect.width;
    double newHeight = region.rect.height;

    switch (_state.resizeHandleIndex!) {
      case 0: // 左上
        newLeft += delta.dx;
        newTop += delta.dy;
        newWidth -= delta.dx;
        newHeight -= delta.dy;
        break;
      case 1: // 上
        newTop += delta.dy;
        newHeight -= delta.dy;
        break;
      case 2: // 右上
        newWidth += delta.dx;
        newTop += delta.dy;
        newHeight -= delta.dy;
        break;
      case 3: // 右
        newWidth += delta.dx;
        break;
      case 4: // 右下
        newWidth += delta.dx;
        newHeight += delta.dy;
        break;
      case 5: // 下
        newHeight += delta.dy;
        break;
      case 6: // 左下
        newLeft += delta.dx;
        newWidth -= delta.dx;
        newHeight += delta.dy;
        break;
      case 7: // 左
        newLeft += delta.dx;
        newWidth -= delta.dx;
        break;
    }

    if (newWidth >= _minRegionSize && newHeight >= _minRegionSize) {
      _state.selectedRegion = region.copyWith(
        left: newLeft,
        top: newTop,
        width: newWidth,
        height: newHeight,
      );
    }
  }

  void _handleRotate(DragUpdateDetails details, CharacterRegion region) {
    if (_state.rotationCenter == null) return;

    final angle = math.atan2(
      details.localPosition.dy - _state.rotationCenter!.dy,
      details.localPosition.dx - _state.rotationCenter!.dx,
    );

    _state.selectedRegion = region.copyWith(rotation: angle);
  }

  void _handleTapDown(TapDownDetails details) {
    if (_state.isBoxSelectionMode) return;

    final tappedRegions = widget.collectedRegions
        ?.where((region) =>
            region.pageIndex == _state.currentIndex &&
            region.rect.contains(details.localPosition))
        .toList();

    final tappedRegion =
        tappedRegions?.isNotEmpty == true ? tappedRegions!.first : null;

    if (tappedRegion != null) {
      HapticFeedback.selectionClick();
    }

    _preserveAndUpdateState(() {
      if (_state.isMultiSelectMode && tappedRegion != null) {
        if (_selectedRegions.contains(tappedRegion)) {
          _selectedRegions.remove(tappedRegion);
          _announceStateChange('取消选择: ${_getRegionDescription(tappedRegion)}');
        } else {
          _selectedRegions.add(tappedRegion);
          _announceStateChange('选择: ${_getRegionDescription(tappedRegion)}');
        }
        _state.selectedRegion = tappedRegion;
      } else {
        _selectedRegions.clear();
        _state.selectedRegion = tappedRegion;
        if (tappedRegion != null) {
          _selectedRegions.add(tappedRegion);
          _announceStateChange('选择: ${_getRegionDescription(tappedRegion)}');
        }
      }

      if (tappedRegion != null && widget.onRegionSelected != null) {
        widget.onRegionSelected!(tappedRegion);
      }
    });
  }

  void _handleTapUp(TapUpDetails details) {
    if (_state.isBoxSelectionMode) return;

    final tappedRegions = widget.collectedRegions
        ?.where((region) =>
            region.pageIndex == _state.currentIndex &&
            region.rect.contains(details.localPosition))
        .toList();

    if (tappedRegions?.isEmpty ?? true) {
      _preserveAndUpdateState(() {
        if (!_state.isMultiSelectMode) {
          _state.selectedRegion = null;
          _selectedRegions.clear();
          _announceStateChange('清除选择');
        }
      });
    }
  }

  void _hideProcessingIndicator() {
    if (!mounted) return;
    Navigator.of(context).pop();
  }

  Future<void> _initializeRepository() async {
    // Get repository from the provider without using watch
  }

  void _preserveAndUpdateState(VoidCallback operation) {
    setState(operation);
  }

  void _showErrorMessage(String message) {
    if (!mounted) return;
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text(message),
        backgroundColor: Colors.red,
      ),
    );
  }

  void _showProcessingIndicator() {
    if (!mounted) return;
    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (context) => const Center(
        child: Card(
          child: Padding(
            padding: EdgeInsets.all(16.0),
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                CircularProgressIndicator(),
                SizedBox(height: 16),
                Text('正在处理...'),
              ],
            ),
          ),
        ),
      ),
    );
  }

  Future<void> _showSaveDialog(CharacterRegion? region) async {
    if (region == null) return;

    _handleRegionOperation(() async {
      final result = await showDialog<Map<String, dynamic>>(
        context: context,
        builder: (context) => RegionPropertiesDialog(
          region: region,
          onSave: (label, color) async {
            try {
              _showProcessingIndicator();

              // 处理图片
              final processor = CharacterImageProcessor();
              const outputDir = '';
              final charId = label ?? DateTime.now().toIso8601String();

              final paths = await processor.processCharacterImage(
                sourcePath: region.imagePath,
                outputDir: outputDir,
                charId: charId,
                region: region.rect,
                rotation: region.rotation,
                erasePoints: _state.erasePoints,
              );

              _preserveAndUpdateState(() {
                _state.selectedRegion = region.copyWith(
                  label: label,
                  color: color,
                  isSaved: true,
                );

                // 清除擦除点
                _state.erasePoints = null;

                if (widget.onRegionSelected != null) {
                  widget.onRegionSelected!(_state.selectedRegion!);
                }
              });

              _announceStateChange('集字已保存: $label');
              Navigator.of(context).pop({'saved': true, 'paths': paths});
            } catch (e) {
              _showErrorMessage('保存失败: $e');
            } finally {
              _hideProcessingIndicator();
            }
          },
        ),
      );

      if (result?['saved'] == true) {
        setState(() {});
      }
    }, errorMessage: '保存操作失败');
  }
}

class _PreviewState {
  int currentIndex = 0;
  bool isDragging = false;
  bool isBoxSelectionMode = false;
  bool isMultiSelectMode = false;

  Offset? selectionStart;
  Offset? selectionCurrent;
  CharacterRegion? selectedRegion;

  int? resizeHandleIndex;
  bool isRotating = false;
  double rotationStartAngle = 0;
  Offset? rotationCenter;
  Offset? dragStartOffset;
  Rect? dragStartRect;

  List<Offset>? erasePoints;

  void reset() {
    isDragging = false;
    isBoxSelectionMode = false;
    isMultiSelectMode = false;
    selectionStart = null;
    selectionCurrent = null;
    selectedRegion = null;
    resetManipulation();
    erasePoints = null;
  }

  void resetManipulation() {
    resizeHandleIndex = null;
    isRotating = false;
    rotationStartAngle = 0;
    rotationCenter = null;
    dragStartOffset = null;
    dragStartRect = null;
  }
}



=======================================
./lib/presentation/widgets/common/loading_indicator.dart
=======================================
import 'package:flutter/material.dart';

import '../../../theme/app_sizes.dart';

class LoadingIndicator extends StatelessWidget {
  final String? message;
  final double size;

  const LoadingIndicator({
    super.key,
    this.message,
    this.size = 24.0,
  });

  @override
  Widget build(BuildContext context) {
    return Center(
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          const CircularProgressIndicator(
            strokeWidth: 3.0,
          ),
          if (message != null) ...[
            const SizedBox(height: AppSizes.m),
            Text(
              message!,
              style: Theme.of(context).textTheme.bodyMedium,
            ),
          ],
        ],
      ),
    );
  }
}



=======================================
./lib/presentation/widgets/common/loading_view.dart
=======================================
import 'package:flutter/material.dart';

import '../../../theme/app_sizes.dart';

/// 通用加载视图
class LoadingView extends StatelessWidget {
  final String? message;
  final double? size;
  final double? strokeWidth;
  final bool showBackground;
  final Color? backgroundColor;

  const LoadingView({
    super.key,
    this.message,
    this.size,
    this.strokeWidth,
    this.showBackground = false,
    this.backgroundColor,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final bgColor = backgroundColor ?? theme.colorScheme.surface;

    Widget content = Column(
      mainAxisSize: MainAxisSize.min,
      children: [
        SizedBox(
          width: size ?? 32,
          height: size ?? 32,
          child: CircularProgressIndicator(
            strokeWidth: strokeWidth ?? 2,
          ),
        ),
        if (message != null) ...[
          const SizedBox(height: AppSizes.s),
          Text(message!),
        ],
      ],
    );

    if (showBackground) {
      content = Container(
        color: bgColor,
        child: content,
      );
    }

    return Center(child: content);
  }
}



=======================================
./lib/presentation/widgets/common/region_painter.dart
=======================================
import 'package:flutter/material.dart';

import '../../../domain/models/character/character_region.dart';

class RegionPainter extends CustomPainter {
  static const double handleSize = 8.0;
  static const double rotationHandleOffset = 24.0;
  static const double labelFontSize = 12.0;

  static const Color savedColor = Colors.green;
  static const Color unsavedColor = Colors.blue;
  static const Color selectedColor = Colors.blue;

  final CharacterRegion? region;
  final bool isSelected;
  final bool isSelecting;
  final Offset? selectionStart;
  final Offset? selectionEnd;

  RegionPainter({
    this.region,
    this.isSelected = false,
    this.isSelecting = false,
    this.selectionStart,
    this.selectionEnd,
  });

  Color get _fillColor => _regionColor.withOpacity(0.2);

  Color get _regionColor {
    if (isSelecting) return selectedColor;
    if (region == null) return unsavedColor;
    if (isSelected) return selectedColor;
    return region!.isSaved ? savedColor : unsavedColor;
  }

  int? getHandleAtPoint(Offset point, Rect rect) {
    final points = [
      rect.topLeft,
      Offset(rect.center.dx, rect.top),
      rect.topRight,
      Offset(rect.right, rect.center.dy),
      rect.bottomRight,
      Offset(rect.center.dx, rect.bottom),
      rect.bottomLeft,
      Offset(rect.left, rect.center.dy),
    ];

    for (int i = 0; i < points.length; i++) {
      if ((point - points[i]).distance <= handleSize) {
        return i;
      }
    }
    return null;
  }

  bool isRotationHandle(Offset point, Rect rect) {
    final center = Offset(rect.center.dx, rect.top - rotationHandleOffset);
    return (point - center).distance <= handleSize;
  }

  @override
  void paint(Canvas canvas, Size size) {
    if (isSelecting && selectionStart != null && selectionEnd != null) {
      _drawSelectionBox(canvas, selectionStart!, selectionEnd!);
    }

    if (region != null) {
      _drawRegion(canvas, region!);
    }
  }

  @override
  bool shouldRepaint(RegionPainter oldDelegate) {
    return oldDelegate.region != region ||
        oldDelegate.isSelected != isSelected ||
        oldDelegate.isSelecting != isSelecting ||
        oldDelegate.selectionStart != selectionStart ||
        oldDelegate.selectionEnd != selectionEnd;
  }

  void _drawHandles(Canvas canvas, Rect rect) {
    final points = [
      rect.topLeft,
      Offset(rect.center.dx, rect.top),
      rect.topRight,
      Offset(rect.right, rect.center.dy),
      rect.bottomRight,
      Offset(rect.center.dx, rect.bottom),
      rect.bottomLeft,
      Offset(rect.left, rect.center.dy),
    ];

    final paint = Paint()
      ..color = Colors.white
      ..style = PaintingStyle.fill;
    final borderPaint = Paint()
      ..color = _regionColor
      ..style = PaintingStyle.stroke
      ..strokeWidth = 1;

    for (final point in points) {
      canvas.drawRect(
        Rect.fromCenter(
          center: point,
          width: handleSize,
          height: handleSize,
        ),
        paint,
      );
      canvas.drawRect(
        Rect.fromCenter(
          center: point,
          width: handleSize,
          height: handleSize,
        ),
        borderPaint,
      );
    }
  }

  void _drawLabel(Canvas canvas, Rect rect, String label) {
    final textPainter = TextPainter(
      text: TextSpan(
        text: label,
        style: const TextStyle(
          color: Colors.white,
          fontSize: labelFontSize,
          backgroundColor: Colors.black54,
        ),
      ),
      textDirection: TextDirection.ltr,
    );

    textPainter.layout();
    textPainter.paint(
      canvas,
      Offset(
        rect.left,
        rect.top - textPainter.height - 4,
      ),
    );
  }

  void _drawRegion(Canvas canvas, CharacterRegion region) {
    final rect = region.rect;
    final paint = Paint()
      ..color = _fillColor
      ..style = PaintingStyle.fill;

    canvas.save();
    canvas.translate(rect.center.dx, rect.center.dy);
    canvas.rotate(region.rotation);
    canvas.translate(-rect.center.dx, -rect.center.dy);

    canvas.drawRect(rect, paint);

    paint
      ..color = _regionColor
      ..style = PaintingStyle.stroke
      ..strokeWidth = isSelected ? 2 : 1;
    canvas.drawRect(rect, paint);

    if (isSelected) {
      _drawHandles(canvas, rect);
      _drawRotationHandle(canvas, rect);
    }

    if (region.label != null) {
      _drawLabel(canvas, rect, region.label!);
    }

    canvas.restore();
  }

  void _drawRotationHandle(Canvas canvas, Rect rect) {
    final center = Offset(rect.center.dx, rect.top - rotationHandleOffset);
    final paint = Paint()
      ..color = Colors.white
      ..style = PaintingStyle.fill;
    final borderPaint = Paint()
      ..color = _regionColor
      ..style = PaintingStyle.stroke
      ..strokeWidth = 1;

    canvas.drawCircle(center, handleSize / 2, paint);
    canvas.drawCircle(center, handleSize / 2, borderPaint);
    canvas.drawLine(
      Offset(rect.center.dx, rect.top),
      center,
      borderPaint,
    );
  }

  void _drawSelectionBox(Canvas canvas, Offset start, Offset end) {
    final rect = Rect.fromPoints(start, end);
    final paint = Paint()
      ..color = _fillColor
      ..style = PaintingStyle.fill;
    canvas.drawRect(rect, paint);

    paint
      ..color = _regionColor
      ..style = PaintingStyle.stroke
      ..strokeWidth = 1;
    canvas.drawRect(rect, paint);
  }
}



=======================================
./lib/presentation/widgets/common/region_properties_dialog.dart
=======================================
import 'package:flutter/material.dart';

import '../../../domain/models/character/character_region.dart';

class RegionPropertiesDialog extends StatefulWidget {
  final CharacterRegion region;
  final Function(String label, Color color) onSave;

  const RegionPropertiesDialog({
    super.key,
    required this.region,
    required this.onSave,
  });

  @override
  State<RegionPropertiesDialog> createState() => _RegionPropertiesDialogState();
}

class _RegionPropertiesDialogState extends State<RegionPropertiesDialog> {
  late TextEditingController _labelController;
  late Color _selectedColor;

  final List<Color> _predefinedColors = [
    Colors.blue,
    Colors.red,
    Colors.green,
    Colors.orange,
    Colors.purple,
    Colors.teal,
    Colors.pink,
    Colors.brown,
  ];

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      title: const Text('编辑区域属性'),
      content: Column(
        mainAxisSize: MainAxisSize.min,
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          TextField(
            controller: _labelController,
            decoration: const InputDecoration(
              labelText: '标签',
              hintText: '输入区域标签',
            ),
          ),
          const SizedBox(height: 16),
          const Text('颜色'),
          const SizedBox(height: 8),
          Wrap(
            spacing: 8,
            runSpacing: 8,
            children: [
              ..._predefinedColors.map((color) => _buildColorOption(color)),
            ],
          ),
        ],
      ),
      actions: [
        TextButton(
          onPressed: () => Navigator.of(context).pop(),
          child: const Text('取消'),
        ),
        ElevatedButton(
          onPressed: () {
            widget.onSave(_labelController.text, _selectedColor);
            Navigator.of(context).pop();
          },
          child: const Text('保存'),
        ),
      ],
    );
  }

  @override
  void dispose() {
    _labelController.dispose();
    super.dispose();
  }

  @override
  void initState() {
    super.initState();
    _labelController = TextEditingController(text: widget.region.label);
    _selectedColor = widget.region.color ?? Colors.blue;
  }

  Widget _buildColorOption(Color color) {
    final isSelected = _selectedColor == color;
    return GestureDetector(
      onTap: () => setState(() => _selectedColor = color),
      child: Container(
        width: 32,
        height: 32,
        decoration: BoxDecoration(
          color: color,
          shape: BoxShape.circle,
          border: Border.all(
            color: isSelected ? Colors.white : Colors.transparent,
            width: 2,
          ),
          boxShadow: [
            if (isSelected)
              BoxShadow(
                color: color.withOpacity(0.5),
                blurRadius: 8,
                spreadRadius: 1,
              ),
          ],
        ),
      ),
    );
  }
}



=======================================
./lib/presentation/widgets/common/section_title.dart
=======================================
import 'package:flutter/material.dart';

/// 一个简单的部分标题组件，用于在表单或页面的不同部分之间提供分隔和标题
class SectionTitle extends StatelessWidget {
  final String title;
  final EdgeInsetsGeometry? padding;
  final Color? color;
  final TextStyle? textStyle;
  final Widget? trailing;

  const SectionTitle({
    super.key,
    required this.title,
    this.padding = const EdgeInsets.only(bottom: 8.0),
    this.color,
    this.textStyle,
    this.trailing,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Padding(
      padding: padding ?? EdgeInsets.zero,
      child: Row(
        children: [
          Expanded(
            child: Text(
              title,
              style: textStyle ??
                  theme.textTheme.titleMedium?.copyWith(
                    fontWeight: FontWeight.bold,
                    color: color ?? theme.colorScheme.primary,
                  ),
            ),
          ),
          if (trailing != null) trailing!,
        ],
      ),
    );
  }
}

/// 一个带有底部分隔线的部分标题
class SectionTitleWithDivider extends StatelessWidget {
  final String title;
  final EdgeInsetsGeometry? padding;
  final Color? color;
  final TextStyle? textStyle;
  final Widget? trailing;
  final Color? dividerColor;

  const SectionTitleWithDivider({
    super.key,
    required this.title,
    this.padding = const EdgeInsets.only(bottom: 8.0),
    this.color,
    this.textStyle,
    this.trailing,
    this.dividerColor,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        SectionTitle(
          title: title,
          padding: padding,
          color: color,
          textStyle: textStyle,
          trailing: trailing,
        ),
        Divider(
          height: 1,
          thickness: 1,
          color: dividerColor ?? theme.dividerColor.withOpacity(0.5),
        ),
      ],
    );
  }
}



=======================================
./lib/presentation/widgets/common/sidebar_toggle.dart
=======================================
import 'package:flutter/material.dart';

import '../../../theme/app_sizes.dart';

class SidebarToggle extends StatelessWidget {
  final bool isOpen;
  final VoidCallback onToggle;
  final bool alignRight; // 新增参数，控制箭头方向和对齐方式

  const SidebarToggle({
    super.key,
    required this.isOpen,
    required this.onToggle,
    this.alignRight = false, // 默认左对齐（用于浏览页）
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Container(
      margin: const EdgeInsets.symmetric(vertical: AppSizes.spacingMedium),
      child: Material(
        color: theme.colorScheme.surfaceContainerHighest,
        // 根据alignRight参数调整圆角位置
        borderRadius: BorderRadius.horizontal(
          left: alignRight ? const Radius.circular(8) : Radius.zero,
          right: alignRight ? Radius.zero : const Radius.circular(8),
        ),
        clipBehavior: Clip.antiAlias,
        child: InkWell(
          onTap: onToggle,
          child: SizedBox(
            width: 20,
            child: Center(
              child: Padding(
                padding: const EdgeInsets.symmetric(vertical: 16.0),
                child: Icon(
                  // 修复图标方向逻辑
                  alignRight
                      // 右侧面板（详情页）
                      ? (isOpen ? Icons.chevron_right : Icons.chevron_left)
                      // 右侧面板（浏览页）- 这里是反的，需要修复
                      : (isOpen ? Icons.chevron_right : Icons.chevron_left),
                  size: 16,
                  color: theme.colorScheme.onSurfaceVariant,
                ),
              ),
            ),
          ),
        ),
      ),
    );
  }
}



=======================================
./lib/presentation/widgets/common/tab_bar_theme_wrapper.dart
=======================================
import 'package:flutter/material.dart';

class TabBarThemeWrapper extends StatelessWidget {
  final Widget child;

  const TabBarThemeWrapper({
    super.key,
    required this.child,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Theme(
      data: theme.copyWith(
        tabBarTheme: TabBarTheme(
          labelColor: theme.colorScheme.primary,
          unselectedLabelColor: theme.colorScheme.onSurface.withOpacity(0.7),
          dividerColor: theme.dividerColor,
          indicatorColor: theme.colorScheme.primary,
          // 添加一些水平内边距，使标签页标题不会靠得太近
          indicatorSize: TabBarIndicatorSize.tab,
          // 轻微提升标签切换的动画时长
          labelPadding: const EdgeInsets.symmetric(horizontal: 16.0),
        ),
        dividerTheme: const DividerThemeData(
          thickness: 1,
          space: 1,
        ),
      ),
      child: child,
    );
  }
}



=======================================
./lib/presentation/widgets/common/toolbar_action_button.dart
=======================================
import 'package:flutter/material.dart';

/// A standardized button for use in toolbars
class ToolbarActionButton extends StatelessWidget {
  /// The child widget to display (usually an Icon)
  final Widget child;

  /// Callback when button is pressed
  final VoidCallback? onPressed;

  /// Tooltip text to show on hover
  final String? tooltip;

  /// Whether the button is enabled
  final bool enabled;

  /// Whether to show a loading indicator instead of the child
  final bool isLoading;

  const ToolbarActionButton({
    super.key,
    required this.child,
    this.onPressed,
    this.tooltip,
    this.enabled = true,
    this.isLoading = false,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Tooltip(
      message: tooltip ?? '',
      child: Container(
        width: 40,
        height: 40,
        margin: const EdgeInsets.symmetric(horizontal: 4.0),
        decoration: BoxDecoration(
          color: enabled
              ? theme.colorScheme.primaryContainer.withOpacity(0.1)
              : theme.colorScheme.surfaceContainerHighest.withOpacity(0.2),
          borderRadius: BorderRadius.circular(20),
        ),
        child: Material(
          type: MaterialType.transparency,
          child: InkWell(
            borderRadius: BorderRadius.circular(20),
            onTap: enabled && !isLoading ? onPressed : null,
            child: Center(
              child: isLoading
                  ? SizedBox(
                      width: 20,
                      height: 20,
                      child: CircularProgressIndicator(
                        strokeWidth: 2,
                        color: theme.colorScheme.primary,
                      ),
                    )
                  : IconTheme(
                      data: IconThemeData(
                        color: enabled
                            ? theme.colorScheme.primary
                            : theme.colorScheme.onSurface.withOpacity(0.38),
                        size: 20,
                      ),
                      child: child,
                    ),
            ),
          ),
        ),
      ),
    );
  }
}



=======================================
./lib/presentation/widgets/common/zoomable_image_view.dart
=======================================
import 'dart:io';

import 'package:flutter/gestures.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';

/// A widget that displays an image with zoom and pan capabilities
class ZoomableImageView extends StatefulWidget {
  /// Path to the image file
  final String imagePath;

  /// Whether to enable mouse wheel zoom
  final bool enableMouseWheel;

  /// Minimum allowed scale
  final double minScale;

  /// Maximum allowed scale
  final double maxScale;

  /// Called when scale changes
  final Function(double)? onScaleChanged;

  /// Custom error widget builder
  final Widget Function(BuildContext, Object, StackTrace?)? errorBuilder;

  /// Custom loading widget builder
  final Widget Function(BuildContext)? loadingBuilder;

  /// Optional tap down callback for specialized interactions
  final Function(Offset)? onTapDown;

  /// Whether to enable gesture interactions
  final bool enableGestures;

  /// Called when zoom is reset
  final VoidCallback? onResetZoom;

  /// Whether to show zoom control buttons
  final bool showControls;

  const ZoomableImageView({
    super.key,
    required this.imagePath,
    this.enableMouseWheel = true,
    this.minScale = 0.5,
    this.maxScale = 4.0,
    this.onScaleChanged,
    this.errorBuilder,
    this.loadingBuilder,
    this.onTapDown,
    this.onResetZoom,
    this.enableGestures = true,
    this.showControls = false,
  });

  @override
  State<ZoomableImageView> createState() => _ZoomableImageViewState();
}

class _ZoomableImageViewState extends State<ZoomableImageView> {
  final TransformationController _transformationController =
      TransformationController();
  bool _isZoomed = false;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Stack(
      fit: StackFit.expand,
      children: [
        // Main image with zoom
        Listener(
          onPointerSignal:
              widget.enableMouseWheel ? _handlePointerSignal : null,
          child: GestureDetector(
            onTapDown: widget.onTapDown != null
                ? (details) => widget.onTapDown!(details.localPosition)
                : null,
            child: InteractiveViewer(
              panEnabled: widget.enableGestures,
              transformationController: _transformationController,
              minScale: widget.minScale,
              maxScale: widget.maxScale,
              onInteractionStart: _handleInteractionStart,
              onInteractionEnd: _handleInteractionEnd,
              child: Image.file(
                File(widget.imagePath),
                fit: BoxFit.contain,
                frameBuilder: (context, child, frame, wasSynchronouslyLoaded) {
                  if (wasSynchronouslyLoaded) return child;

                  return AnimatedSwitcher(
                    duration: const Duration(milliseconds: 200),
                    child: frame != null
                        ? child
                        : widget.loadingBuilder?.call(context) ??
                            Container(
                              color: theme.colorScheme.surfaceContainerHighest,
                              child: const Center(
                                child:
                                    CircularProgressIndicator(strokeWidth: 2),
                              ),
                            ),
                  );
                },
                errorBuilder: widget.errorBuilder ??
                    (context, error, stackTrace) => Center(
                          child: Column(
                            mainAxisSize: MainAxisSize.min,
                            children: [
                              Icon(
                                Icons.broken_image,
                                size: 64,
                                color: theme.colorScheme.error,
                              ),
                              const SizedBox(height: 16),
                              Text(
                                '无法加载图片',
                                style: TextStyle(
                                  color: theme.colorScheme.error,
                                ),
                              ),
                            ],
                          ),
                        ),
              ),
            ),
          ),
        ),

        // Zoom controls
        if (widget.showControls && _isZoomed)
          Positioned(
            right: 16,
            bottom: 16,
            child: FloatingActionButton.small(
              onPressed: _resetZoom,
              tooltip: '重置缩放',
              child: const Icon(Icons.zoom_out_map),
            ),
          ),
      ],
    );
  }

  @override
  void dispose() {
    _transformationController.dispose();
    super.dispose();
  }

  void _handleInteractionEnd(ScaleEndDetails details) {
    final matrix = _transformationController.value;
    if (matrix == Matrix4.identity()) {
      setState(() => _isZoomed = false);
      widget.onScaleChanged?.call(1.0);
    }
  }

  void _handleInteractionStart(ScaleStartDetails details) {
    if (details.pointerCount > 1) {
      setState(() => _isZoomed = true);
    }
  }

  void _handlePointerSignal(PointerSignalEvent event) {
    if (event is PointerScrollEvent &&
        HardwareKeyboard.instance.isControlPressed) {
      final delta = event.scrollDelta.dy * 0.001;
      final currentScale = _transformationController.value.getMaxScaleOnAxis();
      final newScale =
          (currentScale - delta).clamp(widget.minScale, widget.maxScale);

      _transformationController.value = Matrix4.identity()..scale(newScale);

      setState(() => _isZoomed = newScale > 1.0);
      widget.onScaleChanged?.call(newScale);
    }
  }

  void _resetZoom() {
    _transformationController.value = Matrix4.identity();
    setState(() => _isZoomed = false);
    widget.onScaleChanged?.call(1.0);
    widget.onResetZoom?.call();
  }
}



=======================================
./lib/presentation/widgets/date_range_picker.dart
=======================================
import 'package:flutter/material.dart';

import '../../domain/models/common/date_range_filter.dart';
import '../../theme/app_sizes.dart';

class DateRangePicker extends StatefulWidget {
  final DateTimeRange? initialDateRange;
  final DateTime firstDate;
  final DateTime lastDate;
  final ValueChanged<DateTimeRange> onDateRangeChanged;

  const DateRangePicker({
    super.key,
    this.initialDateRange,
    required this.firstDate,
    required this.lastDate,
    required this.onDateRangeChanged,
  });

  @override
  State<DateRangePicker> createState() => _DateRangePickerState();
}

class _DateRangePickerState extends State<DateRangePicker> {
  late DateTime _startDate;
  late DateTime _endDate;
  DateTime? _selectedDate;

  bool get _isSelectingStart => _selectedDate == null;

  @override
  Widget build(BuildContext context) {
    return Row(
      children: [
        Expanded(
          child: Column(
            children: [
              _buildDateHeader(),
              Expanded(
                child: CalendarDatePicker(
                  initialDate: _selectedDate ?? _startDate,
                  firstDate: widget.firstDate,
                  lastDate: widget.lastDate,
                  onDateChanged: _handleDateSelected,
                ),
              ),
            ],
          ),
        ),
        const VerticalDivider(width: 1),
        SizedBox(
          width: 200,
          child: _buildQuickSelections(),
        ),
      ],
    );
  }

  @override
  void initState() {
    super.initState();
    _startDate = widget.initialDateRange?.start ?? widget.lastDate;
    _endDate = widget.initialDateRange?.end ?? widget.lastDate;
  }

  Widget _buildDateButton({
    required String label,
    required DateTime date,
    required bool isSelected,
    required VoidCallback onPressed,
  }) {
    final theme = Theme.of(context);

    return InkWell(
      onTap: onPressed,
      borderRadius: BorderRadius.circular(4),
      child: Container(
        padding: const EdgeInsets.all(AppSizes.s),
        decoration: BoxDecoration(
          border: Border.all(
            color: isSelected ? theme.colorScheme.primary : theme.dividerColor,
          ),
          borderRadius: BorderRadius.circular(4),
        ),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              label,
              style: theme.textTheme.bodySmall,
            ),
            const SizedBox(height: AppSizes.xs),
            Text(
              _formatDate(date),
              style: theme.textTheme.bodyMedium,
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildDateHeader() {
    final theme = Theme.of(context);

    return Padding(
      padding: const EdgeInsets.all(AppSizes.m),
      child: Row(
        children: [
          _buildDateButton(
            label: '开始日期',
            date: _startDate,
            isSelected: _selectedDate == null || _isSelectingStart,
            onPressed: () => _handleModeChange(true),
          ),
          const SizedBox(width: AppSizes.m),
          Text('至', style: theme.textTheme.bodyMedium),
          const SizedBox(width: AppSizes.m),
          _buildDateButton(
            label: '结束日期',
            date: _endDate,
            isSelected: _selectedDate != null && !_isSelectingStart,
            onPressed: () => _handleModeChange(false),
          ),
        ],
      ),
    );
  }

  Widget _buildDateTypeSection() {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        ListTile(
          dense: true,
          title: const Text('某个日期之前'),
          onTap: () => _showSingleDatePicker(
            title: '选择日期',
            initialDate: _endDate,
            onDateSelected: (date) {
              setState(() {
                _endDate = date;
                _startDate = widget.firstDate;
                widget.onDateRangeChanged(DateTimeRange(
                  start: _startDate,
                  end: _endDate,
                ));
              });
            },
          ),
        ),
        ListTile(
          dense: true,
          title: const Text('某个日期之后'),
          onTap: () => _showSingleDatePicker(
            title: '选择日期',
            initialDate: _startDate,
            onDateSelected: (date) {
              setState(() {
                _startDate = date;
                _endDate = widget.lastDate;
                widget.onDateRangeChanged(DateTimeRange(
                  start: _startDate,
                  end: _endDate,
                ));
              });
            },
          ),
        ),
      ],
    );
  }

  Widget _buildQuickSelections() {
    return ListView(
      padding: const EdgeInsets.all(AppSizes.m),
      children: [
        Text(
          '快捷选择',
          style: Theme.of(context).textTheme.titleSmall,
        ),
        const SizedBox(height: AppSizes.m),
        _buildDateTypeSection(),
        const Divider(),
        ...DateRangePreset.values.map(
          (preset) => ListTile(
            dense: true,
            title: Text(_getPresetLabel(preset)),
            onTap: () => _handlePresetSelected(preset),
          ),
        ),
      ],
    );
  }

  String _formatDate(DateTime date) {
    return '${date.year}-${date.month.toString().padLeft(2, '0')}-${date.day.toString().padLeft(2, '0')}';
  }

  String _getPresetLabel(DateRangePreset preset) {
    // Convert the preset enum value to a readable label.
    return preset.toString().split('.').last;
  }

  void _handleDateSelected(DateTime date) {
    if (_isSelectingStart) {
      setState(() {
        _startDate = date;
        _selectedDate = date;
      });
    } else {
      setState(() {
        _endDate = date;
        _selectedDate = null;
        widget.onDateRangeChanged(DateTimeRange(
          start: _startDate,
          end: _endDate,
        ));
      });
    }
  }

  void _handleModeChange(bool selectingStart) {
    setState(() {
      _selectedDate = selectingStart ? null : _startDate;
    });
  }

  void _handlePresetSelected(DateRangePreset preset) {
    final range = preset.getRange();
    setState(() {
      _startDate = range.start;
      _endDate = range.end;
      _selectedDate = null;
      widget.onDateRangeChanged(range);
    });
  }

  Future<void> _showSingleDatePicker({
    required String title,
    required DateTime initialDate,
    required ValueChanged<DateTime> onDateSelected,
  }) async {
    final date = await showDialog<DateTime>(
      context: context,
      builder: (context) => Dialog(
        child: ConstrainedBox(
          constraints: const BoxConstraints(
            maxWidth: 400,
            maxHeight: 480,
          ),
          child: Padding(
            padding: const EdgeInsets.all(AppSizes.m),
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                Row(
                  children: [
                    Text(
                      title,
                      style: Theme.of(context).textTheme.titleMedium,
                    ),
                    const Spacer(),
                    IconButton(
                      icon: const Icon(Icons.close),
                      onPressed: () => Navigator.of(context).pop(),
                    ),
                  ],
                ),
                Expanded(
                  child: CalendarDatePicker(
                    initialDate: initialDate,
                    firstDate: widget.firstDate,
                    lastDate: widget.lastDate,
                    onDateChanged: (date) => Navigator.of(context).pop(date),
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );

    if (date != null) {
      onDateSelected(date);
    }
  }
}



=======================================
./lib/presentation/widgets/dialogs/confirmation_dialog.dart
=======================================
import 'package:flutter/material.dart';

class ConfirmationDialog extends StatelessWidget {
  final String title;
  final String message;
  final String confirmText;
  final String cancelText;
  final bool isDestructive;
  final VoidCallback? onConfirm;

  const ConfirmationDialog({
    super.key,
    required this.title,
    required this.message,
    this.confirmText = '确认',
    this.cancelText = '取消',
    this.isDestructive = false,
    this.onConfirm,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return AlertDialog(
      title: Row(
        children: [
          Icon(
            isDestructive ? Icons.warning_amber_rounded : Icons.help_outline,
            color: isDestructive
                ? theme.colorScheme.error
                : theme.colorScheme.primary,
            size: 24,
          ),
          const SizedBox(width: 12),
          Text(title),
        ],
      ),
      content: Text(message),
      actions: [
        TextButton(
          onPressed: () => Navigator.of(context).pop(false),
          child: Text(cancelText),
        ),
        FilledButton(
          onPressed: () {
            if (onConfirm != null) onConfirm!();
            Navigator.of(context).pop(true);
          },
          style: FilledButton.styleFrom(
            backgroundColor: isDestructive
                ? theme.colorScheme.error
                : theme.colorScheme.primary,
            foregroundColor: isDestructive
                ? theme.colorScheme.onError
                : theme.colorScheme.onPrimary,
          ),
          child: Text(confirmText),
        ),
      ],
    );
  }
}



=======================================
./lib/presentation/widgets/dialog_container.dart
=======================================
import 'package:flutter/material.dart';

import '../../theme/app_sizes.dart';

class DialogContainer extends StatelessWidget {
  final String title;
  final Widget child;
  final List<Widget>? actions;
  final EdgeInsets? padding;
  final double? width;
  final double? height;
  final VoidCallback? onClose;

  const DialogContainer({
    super.key,
    required this.title,
    required this.child,
    this.actions,
    this.padding,
    this.width,
    this.height,
    this.onClose,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Dialog(
      child: Container(
        width: width,
        height: height,
        padding: padding ?? const EdgeInsets.all(AppSizes.spacingLarge),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                Text(
                  title,
                  style: theme.textTheme.titleLarge,
                ),
                const Spacer(),
                if (onClose != null)
                  IconButton(
                    icon: const Icon(Icons.close),
                    onPressed: onClose,
                  ),
              ],
            ),
            if (onClose != null) const Divider(height: 24),
            Expanded(child: child),
            if (actions != null) ...[
              const SizedBox(height: AppSizes.spacingMedium),
              Row(
                mainAxisAlignment: MainAxisAlignment.end,
                children: actions!,
              ),
            ],
          ],
        ),
      ),
    );
  }
}



=======================================
./lib/presentation/widgets/displays/error_text.dart
=======================================
import 'package:flutter/material.dart';

class ErrorText extends StatelessWidget {
  final String text;
  final int? maxLines;
  final TextStyle? style;

  const ErrorText({
    super.key,
    required this.text,
    this.maxLines = 2,
    this.style,
  });

  @override
  Widget build(BuildContext context) {
    final defaultStyle = Theme.of(context).textTheme.bodyMedium?.copyWith(
      color: Theme.of(context).colorScheme.error,
    );

    return Tooltip(
      message: text,
      waitDuration: const Duration(milliseconds: 500),
      child: Text(
        text,
        style: style ?? defaultStyle,
        maxLines: maxLines,
        overflow: TextOverflow.ellipsis,
      ),
    );
  }
}


=======================================
./lib/presentation/widgets/error_boundary.dart
=======================================
import 'package:flutter/material.dart';

class ErrorBoundary extends StatefulWidget {
  final Widget child;
  final Widget Function(FlutterErrorDetails)? errorBuilder;

  const ErrorBoundary({
    super.key,
    required this.child,
    this.errorBuilder,
  });

  @override
  State<ErrorBoundary> createState() => _ErrorBoundaryState();
}

class _ErrorBoundaryState extends State<ErrorBoundary> {
  FlutterErrorDetails? _error;

  @override
  Widget build(BuildContext context) {
    if (_error != null) {
      return widget.errorBuilder?.call(_error!) ??
          Center(
            child: Padding(
              padding: const EdgeInsets.all(16.0),
              child: Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  const Icon(Icons.error_outline, size: 48, color: Colors.red),
                  const SizedBox(height: 16),
                  const Text('发生了意外错误'),
                  const SizedBox(height: 8),
                  Text(
                    _error!.exception.toString(),
                    style: const TextStyle(fontSize: 12),
                  ),
                  const SizedBox(height: 16),
                  ElevatedButton(
                    onPressed: () {
                      setState(() {
                        _error = null;
                      });
                    },
                    child: const Text('重试'),
                  ),
                ],
              ),
            ),
          );
    }

    ErrorWidget.builder = (FlutterErrorDetails details) {
      setState(() {
        _error = details;
      });
      return const SizedBox.shrink();
    };
    return widget.child;
  }
}



=======================================
./lib/presentation/widgets/filter/filter_panel.dart
=======================================
import 'package:flutter/material.dart';

import '../../../theme/app_sizes.dart';

class FilterPanel extends StatelessWidget {
  final String title;
  final List<dynamic> items;
  final dynamic selectedValue;
  final ValueChanged<dynamic> onSelected;

  const FilterPanel({
    super.key,
    required this.title,
    required this.items,
    required this.selectedValue,
    required this.onSelected,
  });

  @override
  Widget build(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(title, style: Theme.of(context).textTheme.titleMedium),
        const SizedBox(height: AppSizes.s),
        Wrap(
          spacing: AppSizes.s,
          runSpacing: AppSizes.xs,
          children: items.map((item) {
            final bool isSelected = item == selectedValue;
            return FilterChip(
              label: Text(item.label),
              selected: isSelected,
              onSelected: (_) => onSelected(item),
            );
          }).toList(),
        ),
      ],
    );
  }
}

class FilterSection extends StatelessWidget {
  final String title;
  final Widget child;

  const FilterSection({
    super.key,
    required this.title,
    required this.child,
  });

  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: const EdgeInsets.all(AppSizes.spacingMedium),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            title,
            style: Theme.of(context).textTheme.titleSmall,
          ),
          const SizedBox(height: AppSizes.spacingSmall),
          child,
        ],
      ),
    );
  }
}



=======================================
./lib/presentation/widgets/forms/date_picker_field.dart
=======================================
import 'package:flutter/material.dart';
import 'package:intl/intl.dart';

class DatePickerField extends StatelessWidget {
  final DateTime? value;
  final ValueChanged<DateTime?>? onChanged;
  final String? hint;
  final DateTime? firstDate;
  final DateTime? lastDate;

  const DatePickerField({
    super.key,
    this.value,
    this.onChanged,
    this.hint,
    this.firstDate,
    this.lastDate,
  });

  @override
  Widget build(BuildContext context) {
    final dateFormatter = DateFormat('yyyy-MM-dd');

    return TextFormField(
      controller: TextEditingController(
        text: value != null ? dateFormatter.format(value!) : '',
      ),
      readOnly: true,
      onTap: () => _showDatePicker(context),
      decoration: InputDecoration(
        border: const OutlineInputBorder(),
        hintText: hint,
        suffixIcon: const Icon(Icons.calendar_today),
        contentPadding: const EdgeInsets.symmetric(
          horizontal: 12,
          vertical: 0,
        ),
      ),
    );
  }

  Future<void> _showDatePicker(BuildContext context) async {
    final picked = await showDatePicker(
      context: context,
      initialDate: value ?? DateTime.now(),
      firstDate: firstDate ?? DateTime(1900),
      lastDate: lastDate ?? DateTime.now(),
    );

    if (picked != null) {
      onChanged?.call(picked);
    }
  }
}


=======================================
./lib/presentation/widgets/forms/dropdown_field.dart
=======================================
import 'package:flutter/material.dart';

class DropdownField<T> extends StatelessWidget {
  final T? value;
  final List<T> items;
  final ValueChanged<T?>? onChanged;
  final Widget Function(T)? itemBuilder;
  final String? hint;
  final bool isExpanded;
  final bool isDense;

  const DropdownField({
    super.key,
    this.value,
    required this.items,
    this.onChanged,
    this.itemBuilder,
    this.hint,
    this.isExpanded = true,
    this.isDense = true,
  });

  @override
  Widget build(BuildContext context) {
    return DropdownButtonFormField<T>(
      value: value,
      items: items.map((item) {
        return DropdownMenuItem<T>(
          value: item,
          child: itemBuilder?.call(item) ?? Text(item.toString()),
        );
      }).toList(),
      onChanged: onChanged,
      hint: hint != null ? Text(hint!) : null,
      isExpanded: isExpanded,
      isDense: isDense,
      decoration: const InputDecoration(
        border: OutlineInputBorder(),
        contentPadding: EdgeInsets.symmetric(
          horizontal: 12,
          vertical: 12,
        ),
      ),
    );
  }
}


=======================================
./lib/presentation/widgets/forms/form_field_wrapper.dart
=======================================
import 'package:flutter/material.dart';

import '../../../theme/app_sizes.dart';

class FormFieldWrapper extends StatelessWidget {
  final String label;
  final Widget child;
  final bool required;
  final String? tooltip;

  const FormFieldWrapper({
    super.key,
    required this.label,
    required this.child,
    this.required = false,
    this.tooltip,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      mainAxisSize: MainAxisSize.min,
      children: [
        Row(
          children: [
            Text(
              label,
              style: theme.textTheme.bodyMedium,
            ),
            if (required)
              Text(
                ' *',
                style: theme.textTheme.bodyMedium?.copyWith(
                  color: theme.colorScheme.error,
                ),
              ),
            if (tooltip != null) ...[
              const SizedBox(width: AppSizes.xs),
              Tooltip(
                message: tooltip!,
                child: Icon(
                  Icons.info_outline,
                  size: 16,
                  color: theme.colorScheme.outline,
                ),
              ),
            ],
          ],
        ),
        const SizedBox(height: AppSizes.formFieldSpacing),
        child,
      ],
    );
  }
}



=======================================
./lib/presentation/widgets/forms/tag_editor.dart
=======================================
import 'package:flutter/material.dart';

class TagEditor extends StatefulWidget {
  final List<String> tags;
  final List<String> suggestedTags;
  final ValueChanged<List<String>> onTagsChanged;
  final Color? chipColor;
  final Color? textColor;

  const TagEditor({
    super.key,
    required this.tags,
    this.suggestedTags = const [],
    required this.onTagsChanged,
    this.chipColor,
    this.textColor,
  });

  @override
  State<TagEditor> createState() => _TagEditorState();
}

class _TagEditorState extends State<TagEditor> {
  final TextEditingController _controller = TextEditingController();
  final FocusNode _focusNode = FocusNode();
  List<String> _tags = [];

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        // 现有标签显示
        if (_tags.isNotEmpty)
          Wrap(
            spacing: 8,
            runSpacing: 8,
            children: _tags.map((tag) {
              return Chip(
                label: Text(
                  tag,
                  style: TextStyle(
                    color: widget.textColor ?? theme.colorScheme.onSurface,
                  ),
                ),
                backgroundColor: widget.chipColor ?? theme.colorScheme.surface,
                deleteIconColor:
                    widget.textColor ?? theme.colorScheme.onSurface,
                onDeleted: () => _removeTag(tag),
              );
            }).toList(),
          ),

        const SizedBox(height: 8),

        // 添加新标签的输入框
        Row(
          children: [
            Expanded(
              child: TextField(
                controller: _controller,
                focusNode: _focusNode,
                decoration: const InputDecoration(
                  hintText: '输入新标签...',
                  isDense: true,
                ),
                onSubmitted: _addTag,
              ),
            ),
            IconButton(
              icon: const Icon(Icons.add),
              onPressed: () => _addTag(_controller.text),
              tooltip: '添加标签',
            ),
          ],
        ),

        const SizedBox(height: 16),

        // 常用标签建议
        if (widget.suggestedTags.isNotEmpty) ...[
          const Text('常用标签:'),
          const SizedBox(height: 8),
          Wrap(
            spacing: 8,
            runSpacing: 8,
            children: widget.suggestedTags
                .where((tag) => !_tags.contains(tag))
                .map((tag) {
              return ActionChip(
                label: Text(tag),
                onPressed: () => _addTag(tag),
              );
            }).toList(),
          ),
        ],
      ],
    );
  }

  @override
  void didUpdateWidget(TagEditor oldWidget) {
    super.didUpdateWidget(oldWidget);

    if (oldWidget.tags != widget.tags) {
      _tags = List.from(widget.tags);
    }
  }

  @override
  void dispose() {
    _controller.dispose();
    _focusNode.dispose();
    super.dispose();
  }

  @override
  void initState() {
    super.initState();
    _tags = List.from(widget.tags);
  }

  void _addTag(String tag) {
    if (tag.isEmpty) return;

    // 移除前后空格
    final trimmedTag = tag.trim();
    if (trimmedTag.isEmpty) return;

    // 检查标签是否已存在
    if (_tags.contains(trimmedTag)) return;

    setState(() {
      _tags.add(trimmedTag);
      _controller.clear();
      widget.onTagsChanged(_tags);
    });

    // 保持焦点在输入框
    _focusNode.requestFocus();
  }

  void _removeTag(String tag) {
    setState(() {
      _tags.remove(tag);
      widget.onTagsChanged(_tags);
    });
  }
}



=======================================
./lib/presentation/widgets/image/cached_image.dart
=======================================
import 'dart:io';

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../infrastructure/providers/storage_providers.dart';
import '../skeleton_loader.dart';

class CachedImage extends ConsumerWidget {
  final String path;
  final double? width;
  final double? height;
  final BoxFit? fit;
  final BorderRadius? borderRadius;
  final String? cacheKey;

  const CachedImage({
    super.key,
    required this.path,
    this.width,
    this.height,
    this.fit,
    this.borderRadius,
    this.cacheKey,
  });

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final storage = ref.watch(initializedStorageProvider);

    return FutureBuilder<bool>(
      // Add cache key to trigger rebuild when needed
      key: ValueKey('cached_image_${path}_${cacheKey ?? ''}'),
      future: _checkFile(storage),
      builder: (context, snapshot) {
        if (!snapshot.hasData || !snapshot.data!) {
          return SkeletonLoader(
            width: width ?? 200,
            height: height ?? 200,
            borderRadius: borderRadius,
          );
        }

        return _buildImage();
      },
    );
  }

  Widget _buildImage() {
    return ClipRRect(
      borderRadius: borderRadius ?? BorderRadius.zero,
      child: Image.file(
        File(path),
        width: width,
        height: height,
        fit: fit,
        cacheWidth: width?.toInt(),
        cacheHeight: height?.toInt(),
        errorBuilder: (context, error, stackTrace) {
          return SkeletonLoader(
            width: width ?? 200,
            height: height ?? 200,
            borderRadius: borderRadius,
          );
        },
      ),
    );
  }

  Future<bool> _checkFile(storage) async {
    return await storage.fileExists(path);
  }
}



=======================================
./lib/presentation/widgets/indicators/button_progress_indicator.dart
=======================================
import 'package:flutter/material.dart';

class ButtonProgressIndicator extends StatelessWidget {
  final double size;
  final double strokeWidth;
  final Color? color;

  const ButtonProgressIndicator({
    super.key,
    this.size = 20,
    this.strokeWidth = 2,
    this.color,
  });

  @override
  Widget build(BuildContext context) {
    return SizedBox(
      width: size,
      height: size,
      child: CircularProgressIndicator(
        strokeWidth: strokeWidth,
        valueColor: AlwaysStoppedAnimation<Color>(
          color ?? Theme.of(context).colorScheme.onPrimary,
        ),
      ),
    );
  }
}


=======================================
./lib/presentation/widgets/info_card.dart
=======================================
import 'package:flutter/material.dart';

import '../../theme/app_sizes.dart';

class InfoCard extends StatelessWidget {
  final String title;
  final IconData? icon;
  final Widget content;
  final bool initiallyExpanded;
  final EdgeInsetsGeometry? padding;

  const InfoCard({
    super.key,
    required this.title,
    this.icon,
    required this.content,
    this.initiallyExpanded = true,
    this.padding,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Card(
      margin: EdgeInsets.zero,
      elevation: 0,
      color: theme.colorScheme.surface,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(AppSizes.radiusMedium),
        side: BorderSide(
          color: theme.colorScheme.outlineVariant,
          width: 1.0,
        ),
      ),
      child: ExpansionTile(
        title: Row(
          children: [
            if (icon != null) ...[
              Icon(
                icon,
                size: 18,
                color: theme.colorScheme.primary,
              ),
              const SizedBox(width: 8),
            ],
            Text(
              title,
              style: theme.textTheme.titleMedium?.copyWith(
                fontWeight: FontWeight.w500,
              ),
            ),
          ],
        ),
        initiallyExpanded: initiallyExpanded,
        childrenPadding:
            padding ?? const EdgeInsets.all(AppSizes.spacingMedium),
        expandedAlignment: Alignment.topLeft,
        expandedCrossAxisAlignment: CrossAxisAlignment.start,
        children: [content],
      ),
    );
  }
}



=======================================
./lib/presentation/widgets/inputs/date_input_field.dart
=======================================
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:intl/intl.dart';

class DateInputField extends StatefulWidget {
  final String label;
  final DateTime? value;
  final ValueChanged<DateTime?>? onChanged;
  final DateFormat? format;
  final bool isRequired;
  final String? Function(DateTime?)? validator;
  final TextInputAction? textInputAction;
  final VoidCallback? onEditingComplete;
  final bool enabled;

  const DateInputField({
    super.key,
    required this.label,
    required this.value,
    required this.onChanged,
    this.format,
    this.isRequired = false,
    this.validator,
    this.textInputAction,
    this.onEditingComplete,
    this.enabled = true,
  });

  @override
  State<DateInputField> createState() => _DateInputFieldState();
}

class _DateInputFieldState extends State<DateInputField> {
  final _focusNode = FocusNode();
  bool _hasFocus = false;
  late final DateFormat _format;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final isEnabled = widget.enabled;

    return FormField<DateTime>(
      initialValue: widget.value,
      validator:
          widget.validator ?? (widget.isRequired ? _requiredValidator : null),
      builder: (FormFieldState<DateTime> field) {
        return InputDecorator(
          decoration: InputDecoration(
            labelText: widget.label,
            errorText: field.errorText,
            suffixText: _hasFocus && isEnabled ? 'Enter 选择' : null,
            suffixIcon: Icon(
              Icons.calendar_today,
              color: _hasFocus && isEnabled ? theme.colorScheme.primary : null,
            ),
            focusedBorder: OutlineInputBorder(
              borderSide: BorderSide(
                color: theme.colorScheme.primary,
                width: 2,
              ),
            ),
            enabledBorder: OutlineInputBorder(
              borderSide: BorderSide(
                color: theme.colorScheme.outline,
              ),
            ),
            disabledBorder: OutlineInputBorder(
              borderSide: BorderSide(
                color: theme.colorScheme.outline.withOpacity(0.5),
              ),
            ),
            filled: _hasFocus && isEnabled,
            fillColor: _hasFocus && isEnabled
                ? theme.colorScheme.primaryContainer.withOpacity(0.1)
                : null,
            enabled: isEnabled,
          ),
          isEmpty: widget.value == null,
          isFocused: _hasFocus,
          child: Focus(
            focusNode: _focusNode,
            onKeyEvent: isEnabled
                ? (_, event) {
                    if (event is KeyDownEvent &&
                        (event.logicalKey == LogicalKeyboardKey.enter ||
                            event.logicalKey == LogicalKeyboardKey.space)) {
                      _showDatePicker(context, field);
                      return KeyEventResult.handled;
                    }
                    if (event is KeyDownEvent &&
                        event.logicalKey == LogicalKeyboardKey.tab) {
                      if (widget.onEditingComplete != null) {
                        widget.onEditingComplete!();
                      }
                      return KeyEventResult.handled;
                    }
                    return KeyEventResult.ignored;
                  }
                : null,
            child: GestureDetector(
              onTap: isEnabled ? () => _showDatePicker(context, field) : null,
              behavior: HitTestBehavior.opaque,
              child: Container(
                padding: const EdgeInsets.symmetric(vertical: 8.0),
                child: DefaultTextStyle(
                  style: widget.value != null
                      ? theme.textTheme.bodyMedium!.copyWith(
                          color: isEnabled ? null : theme.disabledColor,
                        )
                      : theme.textTheme.bodyMedium!.copyWith(
                          color: theme.hintColor,
                        ),
                  child: Text(
                    widget.value != null
                        ? _format.format(widget.value!)
                        : '选择日期',
                  ),
                ),
              ),
            ),
          ),
        );
      },
    );
  }

  @override
  void dispose() {
    _focusNode.removeListener(_handleFocusChange);
    _focusNode.dispose();
    super.dispose();
  }

  @override
  void initState() {
    super.initState();
    _format = widget.format ?? DateFormat('yyyy-MM-dd');
    _focusNode.addListener(_handleFocusChange);
  }

  void _handleFocusChange() {
    if (mounted) {
      setState(() => _hasFocus = _focusNode.hasFocus);
    }
  }

  String? _requiredValidator(DateTime? value) {
    if (widget.isRequired && value == null) {
      return '请选择${widget.label}';
    }
    return null;
  }

  Future<void> _showDatePicker(
      BuildContext context, FormFieldState<DateTime> field) async {
    if (!widget.enabled || widget.onChanged == null) return;

    final initialDate = widget.value ?? DateTime.now();
    final firstDate = DateTime(1000); // 支持古代作品
    final lastDate = DateTime.now().add(const Duration(days: 365)); // 允许未来一年

    final picked = await showDatePicker(
      context: context,
      initialDate: initialDate,
      firstDate: firstDate,
      lastDate: lastDate,
    );

    if (picked != null && picked != widget.value) {
      field.didChange(picked);
      widget.onChanged!(picked);
    }

    // 选择完日期后继续 Tab 导航
    if (widget.onEditingComplete != null) {
      widget.onEditingComplete!();
    }
  }
}



=======================================
./lib/presentation/widgets/inputs/dropdown_field.dart
=======================================
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';

class DropdownField<T> extends StatefulWidget {
  final String label;
  final T? value;
  final List<DropdownMenuItem<T>> items;
  final ValueChanged<T?>? onChanged;
  final bool isRequired;
  final String? Function(T?)? validator;
  final String? hintText;
  final TextInputAction? textInputAction;
  final VoidCallback? onEditingComplete;
  final bool enabled;

  const DropdownField({
    super.key,
    required this.label,
    required this.value,
    required this.items,
    required this.onChanged,
    this.isRequired = false,
    this.validator,
    this.hintText,
    this.textInputAction,
    this.onEditingComplete,
    this.enabled = true,
  });

  @override
  State<DropdownField<T>> createState() => _DropdownFieldState<T>();
}

class _DropdownFieldState<T> extends State<DropdownField<T>> {
  final _focusNode = FocusNode();
  bool _hasFocus = false;
  bool _isDropdownOpen = false;
  final LayerLink _layerLink = LayerLink();
  OverlayEntry? _overlayEntry;
  int _selectedIndex = -1;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final isEnabled = widget.enabled && widget.onChanged != null;

    return FormField<T>(
      initialValue: widget.value,
      validator:
          widget.validator ?? (widget.isRequired ? _requiredValidator : null),
      builder: (FormFieldState<T> field) {
        return CompositedTransformTarget(
          link: _layerLink,
          child: InputDecorator(
            decoration: InputDecoration(
              labelText: widget.label,
              errorText: field.errorText,
              focusedBorder: OutlineInputBorder(
                borderSide: BorderSide(
                  color: theme.colorScheme.primary,
                  width: 2,
                ),
              ),
              enabledBorder: OutlineInputBorder(
                borderSide: BorderSide(
                  color: theme.colorScheme.outline,
                ),
              ),
              disabledBorder: OutlineInputBorder(
                borderSide: BorderSide(
                  color: theme.colorScheme.outline.withOpacity(0.5),
                ),
              ),
              suffixIcon: Icon(
                Icons.arrow_drop_down,
                color:
                    _hasFocus && isEnabled ? theme.colorScheme.primary : null,
              ),
              filled: _hasFocus && isEnabled,
              fillColor: _hasFocus && isEnabled
                  ? theme.colorScheme.primaryContainer.withOpacity(0.1)
                  : null,
              enabled: isEnabled,
            ),
            isEmpty: widget.value == null,
            isFocused: _hasFocus,
            child: Focus(
              focusNode: _focusNode,
              onKeyEvent: isEnabled ? _handleKeyEvent : null,
              child: GestureDetector(
                onTap: isEnabled ? _showDropdown : null,
                behavior: HitTestBehavior.opaque,
                child: Container(
                  padding: const EdgeInsets.symmetric(vertical: 8.0),
                  child: _buildText(theme, isEnabled),
                ),
              ),
            ),
          ),
        );
      },
    );
  }

  @override
  void didUpdateWidget(DropdownField<T> oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (oldWidget.value != widget.value) {
      _updateSelectedIndex();
    }
  }

  @override
  void dispose() {
    _focusNode.removeListener(_handleFocusChange);
    if (_overlayEntry != null) {
      _overlayEntry?.remove();
      _overlayEntry = null;
      _isDropdownOpen = false;
    }
    _focusNode.dispose();
    super.dispose();
  }

  @override
  void initState() {
    super.initState();
    _focusNode.addListener(_handleFocusChange);
    _updateSelectedIndex();
  }

  Widget _buildText(ThemeData theme, bool isEnabled) {
    if (widget.value != null) {
      final selectedItem = widget.items.firstWhere(
        (item) => item.value == widget.value,
        orElse: () => widget.items.first,
      );
      return DefaultTextStyle(
        style: theme.textTheme.bodyMedium!.copyWith(
          color: isEnabled ? null : theme.disabledColor,
        ),
        child: selectedItem.child,
      );
    }
    return Text(
      widget.hintText ?? '',
      style: theme.textTheme.bodyMedium?.copyWith(
        color: theme.hintColor,
      ),
    );
  }

  void _handleFocusChange() {
    if (mounted) {
      setState(() {
        _hasFocus = _focusNode.hasFocus;
        if (!_hasFocus) {
          _hideDropdown();
        }
      });
    }
  }

  KeyEventResult _handleKeyEvent(FocusNode node, KeyEvent event) {
    if (event is! KeyDownEvent) return KeyEventResult.ignored;

    if (event.logicalKey == LogicalKeyboardKey.arrowDown) {
      if (!_isDropdownOpen) {
        _showDropdown();
      } else {
        _selectNextItem();
      }
      return KeyEventResult.handled;
    }

    if (event.logicalKey == LogicalKeyboardKey.arrowUp && _isDropdownOpen) {
      _selectPreviousItem();
      return KeyEventResult.handled;
    }

    if (event.logicalKey == LogicalKeyboardKey.enter ||
        event.logicalKey == LogicalKeyboardKey.space) {
      if (_isDropdownOpen && _selectedIndex >= 0) {
        _selectCurrentItem();
      } else {
        _showDropdown();
      }
      return KeyEventResult.handled;
    }

    if (event.logicalKey == LogicalKeyboardKey.escape && _isDropdownOpen) {
      _hideDropdown();
      return KeyEventResult.handled;
    }

    return KeyEventResult.ignored;
  }

  void _hideDropdown() {
    if (_overlayEntry != null) {
      _overlayEntry?.remove();
      _overlayEntry = null;
      if (mounted) {
        setState(() => _isDropdownOpen = false);
      }
    }
  }

  String? _requiredValidator(T? value) {
    if (widget.isRequired && value == null) {
      return '请选择${widget.label}';
    }
    return null;
  }

  void _selectCurrentItem() {
    if (_selectedIndex >= 0 && _selectedIndex < widget.items.length) {
      final selectedItem = widget.items[_selectedIndex];
      widget.onChanged!(selectedItem.value);
      _hideDropdown();
      if (widget.onEditingComplete != null) {
        widget.onEditingComplete!();
      }
    }
  }

  void _selectNextItem() {
    if (_selectedIndex < widget.items.length - 1) {
      setState(() {
        _selectedIndex++;
        _updateOverlay();
      });
    }
  }

  void _selectPreviousItem() {
    if (_selectedIndex > 0) {
      setState(() {
        _selectedIndex--;
        _updateOverlay();
      });
    }
  }

  void _showDropdown() {
    if (!widget.enabled || widget.onChanged == null) return;

    if (_isDropdownOpen) {
      _hideDropdown();
      return;
    }

    final overlay = Overlay.of(context);
    final renderBox = context.findRenderObject() as RenderBox;
    final size = renderBox.size;

    _overlayEntry = OverlayEntry(
      builder: (context) {
        return Positioned(
          width: size.width,
          child: CompositedTransformFollower(
            link: _layerLink,
            showWhenUnlinked: false,
            offset: Offset(0.0, size.height + 5.0),
            child: Material(
              elevation: 4.0,
              child: Container(
                padding: const EdgeInsets.symmetric(vertical: 8.0),
                decoration: BoxDecoration(
                  color: Theme.of(context).colorScheme.surface,
                  border:
                      Border.all(color: Theme.of(context).colorScheme.outline),
                  borderRadius: BorderRadius.circular(4.0),
                ),
                child: Column(
                  mainAxisSize: MainAxisSize.min,
                  children: widget.items.asMap().entries.map((entry) {
                    final index = entry.key;
                    final item = entry.value;
                    final isSelected = index == _selectedIndex;

                    return InkWell(
                      onTap: () {
                        widget.onChanged!(item.value);
                        _hideDropdown();
                        if (widget.onEditingComplete != null) {
                          widget.onEditingComplete!();
                        }
                      },
                      child: Container(
                        padding: const EdgeInsets.symmetric(
                          horizontal: 16.0,
                          vertical: 12.0,
                        ),
                        color: isSelected
                            ? Theme.of(context).colorScheme.primaryContainer
                            : null,
                        child: DefaultTextStyle(
                          style:
                              Theme.of(context).textTheme.bodyMedium!.copyWith(
                                    color: isSelected
                                        ? Theme.of(context)
                                            .colorScheme
                                            .onPrimaryContainer
                                        : null,
                                  ),
                          child: item.child,
                        ),
                      ),
                    );
                  }).toList(),
                ),
              ),
            ),
          ),
        );
      },
    );

    setState(() => _isDropdownOpen = true);
    overlay.insert(_overlayEntry!);
  }

  void _updateOverlay() {
    if (_overlayEntry != null) {
      _overlayEntry!.markNeedsBuild();
    }
  }

  void _updateSelectedIndex() {
    if (widget.value != null) {
      _selectedIndex =
          widget.items.indexWhere((item) => item.value == widget.value);
    }
  }
}



=======================================
./lib/presentation/widgets/layouts/sidebar_page.dart
=======================================



=======================================
./lib/presentation/widgets/layouts/work_layout.dart
=======================================



=======================================
./lib/presentation/widgets/list/grouped_list_view.dart
=======================================
import 'package:flutter/material.dart';

import '../../../theme/app_sizes.dart';

class GroupedListView<T> extends StatelessWidget {
  final List<ListGroup<T>> groups;
  final Widget Function(BuildContext, T) itemBuilder;
  final Widget Function(BuildContext, ListGroup<T>)? headerBuilder;
  final EdgeInsetsGeometry? padding;
  final ScrollController? controller;
  final bool showDividers;

  const GroupedListView({
    super.key,
    required this.groups,
    required this.itemBuilder,
    this.headerBuilder,
    this.padding,
    this.controller,
    this.showDividers = true,
  });

  @override
  Widget build(BuildContext context) {
    return ListView.builder(
      controller: controller,
      padding: padding,
      itemCount: _calculateItemCount(),
      itemBuilder: (context, index) {
        final groupInfo = _getItemForIndex(index);
        if (groupInfo.isHeader) {
          return headerBuilder?.call(context, groupInfo.group!) ??
              _defaultHeaderBuilder(context, groupInfo.group!);
        }
        return itemBuilder(context, groupInfo.item as T);
      },
    );
  }

  int _calculateItemCount() {
    return groups.fold(0, (sum, group) => sum + group.items.length + 1);
  }

  Widget _defaultHeaderBuilder(BuildContext context, ListGroup<T> group) {
    return Container(
      padding: const EdgeInsets.all(AppSizes.spacingMedium),
      color: Theme.of(context).colorScheme.surfaceContainerHighest,
      child: Text(
        group.header,
        style: Theme.of(context).textTheme.titleSmall,
      ),
    );
  }

  _GroupedItemInfo<T> _getItemForIndex(int index) {
    int currentIndex = 0;
    for (var group in groups) {
      if (index == currentIndex) {
        return _GroupedItemInfo(isHeader: true, group: group);
      }
      if (index <= currentIndex + group.items.length) {
        return _GroupedItemInfo(
          isHeader: false,
          item: group.items[index - currentIndex - 1],
        );
      }
      currentIndex += group.items.length + 1;
    }
    throw RangeError('Index out of range');
  }
}

class ListGroup<T> {
  final String header;
  final List<T> items;

  const ListGroup({
    required this.header,
    required this.items,
  });
}

class _GroupedItemInfo<T> {
  final bool isHeader;
  final ListGroup<T>? group;
  final T? item;

  _GroupedItemInfo({
    required this.isHeader,
    this.group,
    this.item,
  });
}



=======================================
./lib/presentation/widgets/list/selectable_list_item.dart
=======================================
import 'package:flutter/material.dart';

import '../../../theme/app_sizes.dart';

class SelectableListItem extends StatelessWidget {
  final Widget? leading;
  final Widget title;
  final Widget? subtitle;
  final List<Widget>? actions;
  final VoidCallback? onTap;
  final bool selected;
  final ValueChanged<bool>? onSelected;
  final bool showDivider;

  const SelectableListItem({
    super.key,
    this.leading,
    required this.title,
    this.subtitle,
    this.actions,
    this.onTap,
    this.selected = false,
    this.onSelected,
    this.showDivider = true,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Column(
      mainAxisSize: MainAxisSize.min,
      children: [
        InkWell(
          onTap: onSelected != null ? () => onSelected!(!selected) : onTap,
          child: Container(
            padding: const EdgeInsets.all(AppSizes.spacingMedium),
            color: selected ? theme.colorScheme.primary.withOpacity(0.1) : null,
            child: Row(
              children: [
                if (onSelected != null)
                  Padding(
                    padding: const EdgeInsets.only(
                      right: AppSizes.spacingMedium,
                    ),
                    child: Checkbox(
                      value: selected,
                      onChanged: (value) => onSelected?.call(value ?? false),
                    ),
                  ),
                if (leading != null) ...[
                  leading!,
                  const SizedBox(width: AppSizes.spacingMedium),
                ],
                Expanded(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      DefaultTextStyle(
                        style: theme.textTheme.titleMedium!,
                        child: title,
                      ),
                      if (subtitle != null) ...[
                        const SizedBox(height: AppSizes.spacingTiny),
                        DefaultTextStyle(
                          style: theme.textTheme.bodyMedium!,
                          child: subtitle!,
                        ),
                      ],
                    ],
                  ),
                ),
                if (actions != null) ...[
                  const SizedBox(width: AppSizes.spacingMedium),
                  ...actions!,
                ],
              ],
            ),
          ),
        ),
        if (showDivider) const Divider(height: 1),
      ],
    );
  }
}



=======================================
./lib/presentation/widgets/loading/loading_overlay.dart
=======================================
import 'package:flutter/material.dart';

class LoadingOverlay extends StatelessWidget {
  final Widget child;
  final bool isLoading;
  final String? message;
  final Color? backgroundColor;

  const LoadingOverlay({
    super.key,
    required this.child,
    required this.isLoading,
    this.message,
    this.backgroundColor,
  });

  @override
  Widget build(BuildContext context) {
    return Stack(
      children: [
        child,
        if (isLoading)
          Container(
            color: backgroundColor ?? Colors.black26,
            child: Center(
              child: Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  const CircularProgressIndicator(),
                  if (message != null) ...[
                    const SizedBox(height: 16),
                    Text(
                      message!,
                      style: const TextStyle(color: Colors.white),
                    ),
                  ],
                ],
              ),
            ),
          ),
      ],
    );
  }
}



=======================================
./lib/presentation/widgets/loading_overlay.dart
=======================================
import 'package:flutter/material.dart';

class LoadingOverlay extends StatelessWidget {
  const LoadingOverlay({super.key});

  @override
  Widget build(BuildContext context) {
    return Container(
      color: Colors.black26,
      child: const Center(
        child: CircularProgressIndicator(),
      ),
    );
  }
}


=======================================
./lib/presentation/widgets/message_bar.dart
=======================================
import 'package:flutter/material.dart';

import '../../theme/app_sizes.dart';

class MessageBar extends StatelessWidget {
  final String message;
  final Color? backgroundColor;
  final Color? textColor;
  final IconData? icon;
  final VoidCallback? onDismiss;

  const MessageBar({
    super.key,
    required this.message,
    this.backgroundColor,
    this.textColor,
    this.icon,
    this.onDismiss,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Material(
      color: backgroundColor ?? theme.colorScheme.secondary,
      child: Padding(
        padding: const EdgeInsets.all(AppSizes.spacingMedium),
        child: Row(
          children: [
            if (icon != null) ...[
              Icon(
                icon,
                color: textColor ?? Colors.white,
                size: AppSizes.iconMedium,
              ),
              const SizedBox(width: AppSizes.spacingSmall),
            ],
            Expanded(
              child: Text(
                message,
                style: theme.textTheme.bodyMedium?.copyWith(
                  color: textColor ?? Colors.white,
                ),
              ),
            ),
            if (onDismiss != null)
              IconButton(
                icon: Icon(
                  Icons.close,
                  color: textColor ?? Colors.white,
                  size: AppSizes.iconSmall,
                ),
                onPressed: onDismiss,
              ),
          ],
        ),
      ),
    );
  }
}



=======================================
./lib/presentation/widgets/navigation/side_nav.dart
=======================================
import 'package:flutter/material.dart';

import '../../../theme/app_sizes.dart';

class SideNavigation extends StatelessWidget {
  final int selectedIndex;
  final ValueChanged<int> onDestinationSelected;

  const SideNavigation({
    super.key,
    required this.selectedIndex,
    required this.onDestinationSelected,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return NavigationRail(
      selectedIndex: selectedIndex,
      onDestinationSelected: onDestinationSelected,
      backgroundColor: theme.scaffoldBackgroundColor,
      minWidth: AppSizes.navigationRailWidth,
      selectedIconTheme: IconThemeData(
        size: AppSizes.iconMedium,
        color: theme.primaryColor,
      ),
      unselectedIconTheme: IconThemeData(
        size: AppSizes.iconMedium,
        color: theme.unselectedWidgetColor,
      ),
      labelType: NavigationRailLabelType.all,
      destinations: const [
        NavigationRailDestination(
          icon: Icon(Icons.image),
          label: Text('作品'),
        ),
        NavigationRailDestination(
          icon: Icon(Icons.font_download),
          label: Text('集字'),
        ),
        NavigationRailDestination(
          icon: Icon(Icons.article),
          label: Text('字帖'),
        ),
        NavigationRailDestination(
          icon: Icon(Icons.settings),
          label: Text('设置'),
        ),
      ],
    );
  }
}



=======================================
./lib/presentation/widgets/page_bar.dart
=======================================
import 'package:flutter/material.dart';

import '../../theme/app_sizes.dart';

class PageBar extends StatelessWidget implements PreferredSizeWidget {
  final Widget? title;
  final List<Widget>? actions;
  final double? toolbarHeight;
  final Color? backgroundColor;
  final Color? foregroundColor;

  const PageBar({
    super.key,
    this.title,
    this.actions,
    this.toolbarHeight,
    this.backgroundColor,
    this.foregroundColor,
  });

  @override
  Size get preferredSize =>
      Size.fromHeight(toolbarHeight ?? AppSizes.pageToolbarHeight);

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Container(
      height: preferredSize.height,
      padding: const EdgeInsets.symmetric(horizontal: AppSizes.spacingMedium),
      decoration: BoxDecoration(
        color: backgroundColor ?? theme.primaryColor,
        border: Border(
          bottom: BorderSide(
            color: theme.dividerColor,
            width: 1,
          ),
        ),
      ),
      child: Row(
        children: [
          if (title != null)
            DefaultTextStyle(
              style: theme.textTheme.titleLarge!.copyWith(
                color: foregroundColor ?? Colors.white,
              ),
              child: title!,
            ),
          const Spacer(),
          if (actions != null) Row(children: actions!),
        ],
      ),
    );
  }
}



=======================================
./lib/presentation/widgets/page_layout.dart
=======================================
import 'package:flutter/material.dart';

/// A simplified standard page layout with consistent structure.
/// Only includes toolbar and body areas - the toolbar should include
/// all title/navigation/action elements combined.
class PageLayout extends StatelessWidget {
  /// The toolbar widget that appears at the top of the page
  /// This should contain all title elements and action buttons
  final Widget? toolbar;

  /// The main content of the page
  final Widget body;

  /// Optional floating action button
  final Widget? floatingActionButton;

  /// Height of the toolbar. If null, toolbar will size to its content.
  final double? toolbarHeight;

  const PageLayout({
    super.key,
    this.toolbar,
    required this.body,
    this.floatingActionButton,
    this.toolbarHeight,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Scaffold(
      // No AppBar, using our own toolbar
      body: SafeArea(
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            // Toolbar with bottom border (if provided)
            if (toolbar != null)
              Container(
                height: toolbarHeight ??
                    kToolbarHeight, // Use standard toolbar height if not specified
                decoration: BoxDecoration(
                  border: Border(
                    bottom: BorderSide(
                      color: theme.dividerColor.withOpacity(0.5),
                      width: 1,
                    ),
                  ),
                ),
                child: toolbar!,
              ),

            // Main content
            Expanded(child: body),
          ],
        ),
      ),
      floatingActionButton: floatingActionButton,
    );
  }
}



=======================================
./lib/presentation/widgets/page_toolbar.dart
=======================================
import 'package:flutter/material.dart';
import '../../theme/app_sizes.dart';

class PageToolbar extends StatelessWidget {
  final List<Widget>? leading;
  final List<Widget>? trailing;
  final double? height;

  const PageToolbar({
    super.key,
    this.leading,
    this.trailing,
    this.height,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Container(
      height: height ?? AppSizes.pageToolbarHeight,
      padding: const EdgeInsets.symmetric(
        horizontal: AppSizes.spacingMedium,
        vertical: AppSizes.spacingSmall,
      ),
      decoration: BoxDecoration(
        color: theme.scaffoldBackgroundColor,
        border: Border(
          bottom: BorderSide(color: theme.dividerColor),
        ),
      ),
      child: Row(
        children: [
          if (leading != null) ...[
            ...leading!,
            const Spacer(),
          ],
          if (trailing != null) ...trailing!,
        ],
      ),
    );
  }
}



=======================================
./lib/presentation/widgets/practice/practice_layer_panel.dart
=======================================
import 'package:flutter/material.dart';

class PracticeLayerPanel extends StatefulWidget {
  final List<Map<String, dynamic>> layers;
  final Function(int) onLayerSelected;
  final Function(int, bool) onLayerVisibilityChanged;
  final Function(int, bool) onLayerLockChanged;
  final Function(int) onLayerDeleted;
  final Function(int, int) onLayerReordered;

  const PracticeLayerPanel({
    super.key,
    required this.layers,
    required this.onLayerSelected,
    required this.onLayerVisibilityChanged,
    required this.onLayerLockChanged,
    required this.onLayerDeleted,
    required this.onLayerReordered,
  });

  @override
  State<PracticeLayerPanel> createState() => _PracticeLayerPanelState();
}

class _PracticeLayerPanelState extends State<PracticeLayerPanel> {
  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        Container(
          height: 48,
          padding: const EdgeInsets.symmetric(horizontal: 16),
          child: Row(
            children: [
              const Text('图层'),
              const Spacer(),
              IconButton(
                icon: const Icon(Icons.add),
                onPressed: () {
                  // TODO: 添加新图层
                },
                tooltip: '添加图层',
              ),
            ],
          ),
        ),
        Expanded(
          child: ReorderableListView(
            padding: const EdgeInsets.symmetric(vertical: 8),
            onReorder: widget.onLayerReordered,
            children: [
              for (var i = 0; i < widget.layers.length; i++)
                ListTile(
                  key: ValueKey(widget.layers[i]['id']),
                  leading: Row(
                    mainAxisSize: MainAxisSize.min,
                    children: [
                      IconButton(
                        icon: Icon(
                          widget.layers[i]['visible'] as bool
                              ? Icons.visibility
                              : Icons.visibility_off,
                        ),
                        onPressed: () => widget.onLayerVisibilityChanged(
                          i,
                          !(widget.layers[i]['visible'] as bool),
                        ),
                      ),
                      IconButton(
                        icon: Icon(
                          widget.layers[i]['locked'] as bool
                              ? Icons.lock
                              : Icons.lock_open,
                        ),
                        onPressed: () => widget.onLayerLockChanged(
                          i,
                          !(widget.layers[i]['locked'] as bool),
                        ),
                      ),
                    ],
                  ),
                  title: Text(widget.layers[i]['name'] as String),
                  trailing: IconButton(
                    icon: const Icon(Icons.delete),
                    onPressed: () => widget.onLayerDeleted(i),
                  ),
                  selected: widget.layers[i]['selected'] as bool,
                  onTap: () => widget.onLayerSelected(i),
                ),
            ],
          ),
        ),
      ],
    );
  }
}



=======================================
./lib/presentation/widgets/practice/practice_property_panel.dart
=======================================
import 'package:flutter/material.dart';

class PracticePropertyPanel extends StatelessWidget {
  final Map<String, dynamic>? selectedElement;
  final Function(Map<String, dynamic>) onPropertyChanged;

  const PracticePropertyPanel({
    super.key,
    this.selectedElement,
    required this.onPropertyChanged,
  });

  @override
  Widget build(BuildContext context) {
    if (selectedElement == null) {
      return const Center(
        child: Text('请选择一个元素'),
      );
    }

    // 根据选中元素类型显示不同的属性编辑器
    switch (selectedElement!['type']) {
      case 'chars':
        return _buildCharsProperties(context);
      case 'text':
        return _buildTextProperties(context);
      case 'image':
        return _buildImageProperties(context);
      default:
        return const Center(
          child: Text('未知元素类型'),
        );
    }
  }

  Widget _buildCharsProperties(BuildContext context) {
    return SingleChildScrollView(
      padding: const EdgeInsets.all(16),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // 基本属性
          _buildSection(
            '基本属性',
            [
              TextField(
                decoration: const InputDecoration(labelText: '内容'),
                onChanged: (value) => _updateProperty('content', value),
              ),
              const SizedBox(height: 16),
              Row(
                children: [
                  Expanded(
                    child: TextField(
                      decoration: const InputDecoration(labelText: '字号'),
                      keyboardType: TextInputType.number,
                      onChanged: (value) => _updateProperty('fontSize', int.tryParse(value)),
                    ),
                  ),
                  const SizedBox(width: 16),
                  Expanded(
                    child: TextField(
                      decoration: const InputDecoration(labelText: '间距'),
                      keyboardType: TextInputType.number,
                      onChanged: (value) => _updateProperty('spacing', int.tryParse(value)),
                    ),
                  ),
                ],
              ),
            ],
          ),
          // 位置和尺寸
          _buildSection(
            '位置和尺寸',
            [
              Row(
                children: [
                  Expanded(
                    child: TextField(
                      decoration: const InputDecoration(labelText: 'X'),
                      keyboardType: TextInputType.number,
                      onChanged: (value) => _updateProperty('x', double.tryParse(value)),
                    ),
                  ),
                  const SizedBox(width: 16),
                  Expanded(
                    child: TextField(
                      decoration: const InputDecoration(labelText: 'Y'),
                      keyboardType: TextInputType.number,
                      onChanged: (value) => _updateProperty('y', double.tryParse(value)),
                    ),
                  ),
                ],
              ),
              const SizedBox(height: 16),
              Row(
                children: [
                  Expanded(
                    child: TextField(
                      decoration: const InputDecoration(labelText: '宽度'),
                      keyboardType: TextInputType.number,
                      onChanged: (value) => _updateProperty('width', double.tryParse(value)),
                    ),
                  ),
                  const SizedBox(width: 16),
                  Expanded(
                    child: TextField(
                      decoration: const InputDecoration(labelText: '高度'),
                      keyboardType: TextInputType.number,
                      onChanged: (value) => _updateProperty('height', double.tryParse(value)),
                    ),
                  ),
                ],
              ),
            ],
          ),
          // 样式
          _buildSection(
            '样式',
            [
              // TODO: 添加颜色选择器和其他样式属性
            ],
          ),
        ],
      ),
    );
  }

  Widget _buildTextProperties(BuildContext context) {
    // TODO: 实现文本元素属性编辑器
    return Container();
  }

  Widget _buildImageProperties(BuildContext context) {
    // TODO: 实现图片元素属性编辑器
    return Container();
  }

  Widget _buildSection(String title, List<Widget> children) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          title,
          style: const TextStyle(
            fontSize: 16,
            fontWeight: FontWeight.bold,
          ),
        ),
        const SizedBox(height: 16),
        ...children,
        const SizedBox(height: 24),
      ],
    );
  }

  void _updateProperty(String key, dynamic value) {
    final updatedElement = Map<String, dynamic>.from(selectedElement!);
    updatedElement[key] = value;
    onPropertyChanged(updatedElement);
  }
}



=======================================
./lib/presentation/widgets/practice/practice_tool_panel.dart
=======================================
import 'package:flutter/material.dart';

class PracticeToolPanel extends StatelessWidget {
  final Function(String) onToolSelected;

  const PracticeToolPanel({
    super.key,
    required this.onToolSelected,
  });

  @override
  Widget build(BuildContext context) {
    return ListView(
      padding: const EdgeInsets.all(16),
      children: [
        Text('页面设置', style: Theme.of(context).textTheme.titleSmall),
        const SizedBox(height: 8),
        Wrap(
          spacing: 8,
          runSpacing: 8,
          children: [
            _buildToolButton(
              context,
              icon: Icons.crop_landscape,
              label: '页面大小',
              onPressed: () => onToolSelected('page_size'),
            ),
            _buildToolButton(
              context,
              icon: Icons.space_bar,
              label: '页边距',
              onPressed: () => onToolSelected('margins'),
            ),
            _buildToolButton(
              context,
              icon: Icons.grid_on,
              label: '背景',
              onPressed: () => onToolSelected('background'),
            ),
          ],
        ),
        const Divider(height: 32),
        Text('内容工具', style: Theme.of(context).textTheme.titleSmall),
        const SizedBox(height: 8),
        Wrap(
          spacing: 8,
          runSpacing: 8,
          children: [
            _buildToolButton(
              context,
              icon: Icons.font_download,
              label: '集字填充',
              onPressed: () => onToolSelected('chars'),
            ),
            _buildToolButton(
              context,
              icon: Icons.text_fields,
              label: '文本',
              onPressed: () => onToolSelected('text'),
            ),
            _buildToolButton(
              context,
              icon: Icons.image,
              label: '图片',
              onPressed: () => onToolSelected('image'),
            ),
          ],
        ),
        const Divider(height: 32),
        Text('辅助工具', style: Theme.of(context).textTheme.titleSmall),
        const SizedBox(height: 8),
        Wrap(
          spacing: 8,
          runSpacing: 8,
          children: [
            _buildToolButton(
              context,
              icon: Icons.grid_4x4,
              label: '参考线',
              onPressed: () => onToolSelected('guides'),
            ),
            _buildToolButton(
              context,
              icon: Icons.straighten,
              label: '标尺',
              onPressed: () => onToolSelected('ruler'),
            ),
          ],
        ),
      ],
    );
  }

  Widget _buildToolButton(
    BuildContext context, {
    required IconData icon,
    required String label,
    required VoidCallback onPressed,
  }) {
    return ElevatedButton.icon(
      onPressed: onPressed,
      icon: Icon(icon, size: 18),
      label: Text(label),
      style: ElevatedButton.styleFrom(
        padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
      ),
    );
  }
}



=======================================
./lib/presentation/widgets/preview/image_preview.dart
=======================================
import 'dart:io';

import 'package:flutter/material.dart';

import '../../../theme/app_sizes.dart';

class ImagePreview extends StatelessWidget {
  final File? file;
  final String? networkUrl;
  final double? width;
  final double? height;
  final BoxFit fit;
  final Widget? placeholder;
  final Widget? errorWidget;

  const ImagePreview({
    super.key,
    this.file,
    this.networkUrl,
    this.width,
    this.height,
    this.fit = BoxFit.cover,
    this.placeholder,
    this.errorWidget,
  }) : assert(file != null || networkUrl != null);

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Container(
      width: width,
      height: height,
      decoration: BoxDecoration(
        color: theme.colorScheme.surfaceContainerHighest,
        borderRadius: BorderRadius.circular(AppSizes.radiusSmall),
      ),
      child: ClipRRect(
        borderRadius: BorderRadius.circular(AppSizes.radiusSmall),
        child: _buildImage(theme),
      ),
    );
  }

  Widget _buildError(ThemeData theme) {
    return errorWidget ??
        Center(
          child: Icon(
            Icons.broken_image_outlined,
            color: theme.colorScheme.error,
          ),
        );
  }

  Widget _buildImage(ThemeData theme) {
    if (file != null) {
      return Image.file(
        file!,
        fit: fit,
        errorBuilder: (_, __, ___) => _buildError(theme),
      );
    }

    if (networkUrl != null) {
      return Image.network(
        networkUrl!,
        fit: fit,
        loadingBuilder: (_, child, progress) {
          if (progress == null) return child;
          return _buildPlaceholder(theme);
        },
        errorBuilder: (_, __, ___) => _buildError(theme),
      );
    }

    return _buildError(theme);
  }

  Widget _buildPlaceholder(ThemeData theme) {
    return placeholder ??
        Center(
          child: CircularProgressIndicator(
            color: theme.primaryColor,
          ),
        );
  }
}



=======================================
./lib/presentation/widgets/preview/practice_preview.dart
=======================================
import 'dart:io';

import 'package:flutter/material.dart';

import '../../../theme/app_sizes.dart';
import 'image_preview.dart';

class PracticePreview extends StatelessWidget {
  final String? imagePath;
  final String? backgroundImagePath;
  final double opacity;
  final VoidCallback? onRefresh;

  const PracticePreview({
    super.key,
    this.imagePath,
    this.backgroundImagePath,
    this.opacity = 0.5,
    this.onRefresh,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Stack(
      children: [
        // 背景图层
        if (backgroundImagePath != null)
          Opacity(
            opacity: opacity,
            child: ImagePreview(
              file: File(backgroundImagePath!),
              width: double.infinity,
              height: double.infinity,
            ),
          ),
        // 练习图层
        if (imagePath != null)
          ImagePreview(
            file: File(imagePath!),
            width: double.infinity,
            height: double.infinity,
          ),
        // 无内容时的占位
        if (imagePath == null && backgroundImagePath == null)
          Center(
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                Icon(
                  Icons.image_outlined,
                  size: 48,
                  color: theme.colorScheme.outline,
                ),
                const SizedBox(height: AppSizes.spacingSmall),
                Text(
                  '暂无预览内容',
                  style: theme.textTheme.bodyMedium?.copyWith(
                    color: theme.colorScheme.outline,
                  ),
                ),
              ],
            ),
          ),
        // 刷新按钮
        if (onRefresh != null)
          Positioned(
            top: AppSizes.spacingSmall,
            right: AppSizes.spacingSmall,
            child: IconButton(
              icon: const Icon(Icons.refresh),
              onPressed: onRefresh,
              tooltip: '刷新预览',
            ),
          ),
      ],
    );
  }
}



=======================================
./lib/presentation/widgets/responsive_builder.dart
=======================================
import 'package:flutter/material.dart';

import '../../theme/app_sizes.dart';

enum ResponsiveBreakpoint { xs, sm, md, lg }

class ResponsiveBuilder extends StatelessWidget {
  final Widget Function(BuildContext, ResponsiveBreakpoint) builder;

  const ResponsiveBuilder({
    super.key,
    required this.builder,
  });

  @override
  Widget build(BuildContext context) {
    return LayoutBuilder(
      builder: (context, constraints) {
        final breakpoint = _getBreakpoint(constraints.maxWidth);
        return builder(context, breakpoint);
      },
    );
  }

  ResponsiveBreakpoint _getBreakpoint(double width) {
    if (width < AppSizes.breakpointXs) return ResponsiveBreakpoint.xs;
    if (width < AppSizes.breakpointMd) return ResponsiveBreakpoint.sm;
    if (width < AppSizes.breakpointLg) return ResponsiveBreakpoint.md;
    return ResponsiveBreakpoint.lg;
  }
}



=======================================
./lib/presentation/widgets/scroll/scrollable_container.dart
=======================================
import 'package:flutter/material.dart';

import '../../../theme/app_sizes.dart';

class ScrollableContainer extends StatelessWidget {
  final Widget child;
  final EdgeInsets? padding;
  final ScrollController? controller;
  final bool showScrollbar;

  const ScrollableContainer({
    super.key,
    required this.child,
    this.padding,
    this.controller,
    this.showScrollbar = true,
  });

  @override
  Widget build(BuildContext context) {
    Widget content = SingleChildScrollView(
      controller: controller,
      padding: padding ?? const EdgeInsets.all(AppSizes.spacingMedium),
      child: child,
    );

    if (showScrollbar) {
      content = Scrollbar(
        controller: controller,
        child: content,
      );
    }

    return content;
  }
}



=======================================
./lib/presentation/widgets/search/search_box.dart
=======================================
import 'package:flutter/material.dart';

import '../../../theme/app_sizes.dart';

class SearchBox extends StatelessWidget {
  final String? hintText;
  final ValueChanged<String>? onChanged;
  final VoidCallback? onSubmitted;
  final TextEditingController? controller;
  final double? width;

  const SearchBox({
    super.key,
    this.hintText,
    this.onChanged,
    this.onSubmitted,
    this.controller,
    this.width,
  });

  @override
  Widget build(BuildContext context) {
    return SizedBox(
      width: width ?? 240,
      child: SearchBar(
        controller: controller,
        hintText: hintText,
        leading: const Icon(Icons.search),
        padding: const WidgetStatePropertyAll(
          EdgeInsets.symmetric(
            horizontal: AppSizes.spacingMedium,
          ),
        ),
        onChanged: onChanged,
        onSubmitted: (value) => onSubmitted?.call(),
      ),
    );
  }
}



=======================================
./lib/presentation/widgets/section_header.dart
=======================================
import 'package:flutter/material.dart';
import '../../theme/app_sizes.dart';

class SectionHeader extends StatelessWidget {
  final String title;
  final List<Widget>? actions;
  final EdgeInsets? padding;

  const SectionHeader({
    super.key,
    required this.title,
    this.actions,
    this.padding,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    
    return Padding(
      padding: padding ?? const EdgeInsets.all(AppSizes.spacingMedium),
      child: Row(
        children: [
          Text(
            title,
            style: theme.textTheme.titleMedium?.copyWith(
              fontWeight: FontWeight.bold,
            ),
          ),
          if (actions != null) ...[
            const Spacer(),
            ...actions!,
          ],
        ],
      ),
    );
  }
}



=======================================
./lib/presentation/widgets/settings/settings_section.dart
=======================================
import 'package:flutter/material.dart';

class SettingsSection extends StatelessWidget {
  final String title;
  final IconData? icon;
  final List<Widget> children;
  final bool initiallyExpanded;

  const SettingsSection({
    super.key,
    required this.title,
    this.icon,
    required this.children,
    this.initiallyExpanded = true,
  });

  @override
  Widget build(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Padding(
          padding: const EdgeInsets.fromLTRB(16, 16, 16, 8),
          child: Row(
            children: [
              if (icon != null) ...[
                Icon(
                  icon,
                  size: 20,
                  color: Theme.of(context).colorScheme.primary,
                ),
                const SizedBox(width: 8),
              ],
              Text(
                title,
                style: TextStyle(
                  fontSize: 16,
                  fontWeight: FontWeight.bold,
                  color: Theme.of(context).colorScheme.primary,
                ),
              ),
            ],
          ),
        ),
        ...children,
        const SizedBox(height: 8),
      ],
    );
  }
}



=======================================
./lib/presentation/widgets/skeleton_loader.dart
=======================================
import 'package:flutter/material.dart';

class SkeletonLoader extends StatefulWidget {
  final double width;
  final double height;
  final BorderRadius? borderRadius;

  const SkeletonLoader({
    super.key,
    required this.width,
    required this.height,
    this.borderRadius,
  });

  @override
  State<SkeletonLoader> createState() => _SkeletonLoaderState();
}

class _SkeletonLoaderState extends State<SkeletonLoader>
    with SingleTickerProviderStateMixin {
  late AnimationController _controller;
  late Animation<double> _animation;

  @override
  Widget build(BuildContext context) {
    return AnimatedBuilder(
      animation: _animation,
      builder: (context, child) {
        return Container(
          width: widget.width,
          height: widget.height,
          decoration: BoxDecoration(
            borderRadius: widget.borderRadius ?? BorderRadius.circular(8),
            color: Colors.grey[300]?.withOpacity(_animation.value),
          ),
        );
      },
    );
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  @override
  void initState() {
    super.initState();
    _controller = AnimationController(
      duration: const Duration(seconds: 1),
      vsync: this,
    )..repeat(reverse: true);

    _animation = Tween<double>(begin: 0.5, end: 1.0).animate(_controller);
  }
}



=======================================
./lib/presentation/widgets/tag_editor.dart
=======================================
import 'package:flutter/material.dart';

class TagEditor extends StatefulWidget {
  final List<String> tags;
  final List<String> suggestedTags;
  final Function(List<String>) onTagsChanged;
  final Color? chipColor;
  final Color? textColor;

  const TagEditor({
    super.key,
    required this.tags,
    required this.onTagsChanged,
    this.suggestedTags = const [],
    this.chipColor,
    this.textColor,
  });

  @override
  State<TagEditor> createState() => _TagEditorState();
}

class _TagEditorState extends State<TagEditor> {
  final TextEditingController _controller = TextEditingController();
  final FocusNode _focusNode = FocusNode();
  List<String> _tags = [];

  @override
  Widget build(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        // 标签输入
        Row(
          children: [
            Expanded(
              child: TextField(
                controller: _controller,
                focusNode: _focusNode,
                decoration: InputDecoration(
                  hintText: '输入标签后按Enter添加',
                  isDense: true,
                  border: OutlineInputBorder(
                    borderRadius: BorderRadius.circular(4),
                  ),
                  suffixIcon: IconButton(
                    icon: const Icon(Icons.add),
                    onPressed: () {
                      if (_controller.text.isNotEmpty) {
                        _addTag(_controller.text);
                      }
                    },
                  ),
                ),
                onSubmitted: (value) {
                  _addTag(value);
                  _focusNode.requestFocus(); // 保持焦点
                },
              ),
            ),
          ],
        ),

        const SizedBox(height: 8),

        // 当前标签显示
        Wrap(
          spacing: 8,
          runSpacing: 8,
          children: _tags.map((tag) {
            return Chip(
              label: Text(
                tag,
                style: TextStyle(color: widget.textColor),
              ),
              backgroundColor: widget.chipColor,
              deleteIcon: const Icon(Icons.close, size: 16),
              onDeleted: () => _removeTag(tag),
            );
          }).toList(),
        ),

        if (widget.suggestedTags.isNotEmpty) ...[
          const SizedBox(height: 16),
          const Text('建议标签:', style: TextStyle(fontWeight: FontWeight.bold)),
          const SizedBox(height: 8),

          // 建议标签
          Wrap(
            spacing: 8,
            runSpacing: 8,
            children: widget.suggestedTags
                .where((tag) => !_tags.contains(tag))
                .map((tag) {
              return ActionChip(
                label: Text(tag),
                onPressed: () => _addTag(tag),
              );
            }).toList(),
          ),
        ],
      ],
    );
  }

  @override
  void didUpdateWidget(covariant TagEditor oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (oldWidget.tags != widget.tags) {
      setState(() {
        _tags = List.from(widget.tags);
      });
    }
  }

  @override
  void dispose() {
    _controller.dispose();
    _focusNode.dispose();
    super.dispose();
  }

  @override
  void initState() {
    super.initState();
    _tags = List.from(widget.tags);
  }

  void _addTag(String tag) {
    tag = tag.trim();
    if (tag.isNotEmpty && !_tags.contains(tag)) {
      setState(() {
        _tags.add(tag);
        _controller.clear();
      });
      widget.onTagsChanged(_tags);
    }
  }

  void _removeTag(String tag) {
    setState(() {
      _tags.remove(tag);
    });
    widget.onTagsChanged(_tags);
  }
}



=======================================
./lib/presentation/widgets/tag_list.dart
=======================================
import 'package:flutter/material.dart';

import '../../theme/app_colors.dart';
import '../../theme/app_sizes.dart';
import '../../theme/app_text_styles.dart';

class TagList extends StatelessWidget {
  final List<String> tags;
  final int? maxLines;
  final void Function(String)? onTagTap;

  const TagList({
    super.key,
    required this.tags,
    this.maxLines,
    this.onTagTap,
  });

  @override
  Widget build(BuildContext context) {
    if (maxLines == 1) {
      return SingleChildScrollView(
        scrollDirection: Axis.horizontal,
        child: _buildTagRow(),
      );
    }

    return Wrap(
      spacing: AppSizes.p4,
      runSpacing: AppSizes.p4,
      children: tags.map(_buildTag).toList(),
    );
  }

  Widget _buildTag(String tag) {
    return InkWell(
      onTap: onTagTap != null ? () => onTagTap!(tag) : null,
      child: Container(
        padding: const EdgeInsets.symmetric(
          horizontal: AppSizes.p8,
          vertical: AppSizes.p4,
        ),
        decoration: BoxDecoration(
          color: AppColors.background,
          borderRadius: BorderRadius.circular(AppSizes.r4),
        ),
        child: Text(
          '#$tag',
          style: AppTextStyles.bodySmall,
          maxLines: 1,
          overflow: TextOverflow.ellipsis,
        ),
      ),
    );
  }

  Widget _buildTagRow() {
    return Row(
      children: [
        for (var i = 0; i < tags.length; i++) ...[
          if (i > 0) const SizedBox(width: AppSizes.p4),
          _buildTag(tags[i]),
        ],
      ],
    );
  }
}



=======================================
./lib/presentation/widgets/upload/image_upload.dart
=======================================
import 'dart:io';

import 'package:flutter/material.dart';

import '../../../theme/app_sizes.dart';
import '../preview/image_preview.dart';

class ImageUpload extends StatelessWidget {
  final File? file;
  final VoidCallback onUpload;
  final VoidCallback? onRemove;
  final double? width;
  final double? height;
  final String? uploadHint;
  final bool showPreview;

  const ImageUpload({
    super.key,
    this.file,
    required this.onUpload,
    this.onRemove,
    this.width,
    this.height,
    this.uploadHint,
    this.showPreview = true,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Container(
      width: width,
      height: height,
      decoration: BoxDecoration(
        border: Border.all(color: theme.dividerColor),
        borderRadius: BorderRadius.circular(AppSizes.radiusMedium),
      ),
      child: file != null && showPreview
          ? _buildPreview(context)
          : _buildUploadButton(context),
    );
  }

  Widget _buildPreview(BuildContext context) {
    return Stack(
      children: [
        ImagePreview(file: file),
        if (onRemove != null)
          Positioned(
            top: AppSizes.spacingSmall,
            right: AppSizes.spacingSmall,
            child: IconButton(
              icon: const Icon(Icons.close),
              onPressed: onRemove,
              style: IconButton.styleFrom(
                backgroundColor: Colors.black38,
                foregroundColor: Colors.white,
              ),
            ),
          ),
      ],
    );
  }

  Widget _buildUploadButton(BuildContext context) {
    final theme = Theme.of(context);

    return InkWell(
      onTap: onUpload,
      borderRadius: BorderRadius.circular(AppSizes.radiusMedium),
      child: Center(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Icon(
              Icons.cloud_upload_outlined,
              size: 32,
              color: theme.colorScheme.primary,
            ),
            const SizedBox(height: AppSizes.spacingSmall),
            Text(
              uploadHint ?? '点击上传图片',
              style: theme.textTheme.bodyMedium?.copyWith(
                color: theme.colorScheme.primary,
              ),
            ),
          ],
        ),
      ),
    );
  }
}



=======================================
./lib/presentation/widgets/window/title_bar.dart
=======================================
import 'package:flutter/material.dart';
import 'package:window_manager/window_manager.dart';

import '../../../theme/app_sizes.dart';

class TitleBar extends StatefulWidget {
  final String? title;

  const TitleBar({super.key, this.title});

  @override
  State<TitleBar> createState() => _TitleBarState();
}

class WindowButtons extends StatefulWidget {
  const WindowButtons({super.key});

  @override
  State<WindowButtons> createState() => _WindowButtonsState();
}

class _TitleBarState extends State<TitleBar> with WindowListener {
  bool _isMaximized = false;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return GestureDetector(
      onDoubleTap: _handleDoubleClick,
      child: Container(
        height: AppSizes.appBarHeight,
        decoration: BoxDecoration(
          color: theme.colorScheme.surface,
          border: Border(
            bottom: BorderSide(
              color: theme.dividerColor,
              width: AppSizes.dividerThickness,
            ),
          ),
          boxShadow: [
            BoxShadow(
              color: theme.shadowColor.withOpacity(0.05),
              blurRadius: 2,
              offset: const Offset(0, 1),
            ),
          ],
        ),
        child: Row(
          children: [
            // 应用图标
            Padding(
              padding: const EdgeInsets.symmetric(horizontal: AppSizes.s),
              child: Icon(
                Icons.brush_outlined,
                color: theme.colorScheme.primary,
                size: AppSizes.iconMedium,
              ),
            ),
            // 标题拖动区域
            Expanded(
              child: DragToMoveArea(
                child: Padding(
                  padding: const EdgeInsets.symmetric(horizontal: AppSizes.s),
                  child: Text(
                    widget.title ?? '书法集字',
                    style: theme.textTheme.titleMedium?.copyWith(
                      fontWeight: FontWeight.w500,
                      color: theme.colorScheme.onSurface,
                    ),
                    overflow: TextOverflow.ellipsis,
                  ),
                ),
              ),
            ),
            // 窗口按钮
            const WindowButtons(),
          ],
        ),
      ),
    );
  }

  @override
  void dispose() {
    windowManager.removeListener(this);
    super.dispose();
  }

  @override
  void initState() {
    super.initState();
    windowManager.addListener(this);
    _init();
  }

  @override
  void onWindowMaximize() {
    setState(() {
      _isMaximized = true;
    });
  }

  @override
  void onWindowRestore() {
    setState(() {
      _isMaximized = false;
    });
  }

  @override
  void onWindowUnmaximize() {
    setState(() {
      _isMaximized = false;
    });
  }

  Future<void> _handleDoubleClick() async {
    if (_isMaximized) {
      await windowManager.unmaximize();
    } else {
      await windowManager.maximize();
    }
  }

  void _init() async {
    _isMaximized = await windowManager.isMaximized();
    if (mounted) setState(() {});
  }
}

class _WindowButton extends StatelessWidget {
  final IconData icon;
  final String tooltip;
  final VoidCallback onPressed;
  final bool isClose;

  const _WindowButton({
    required this.icon,
    required this.tooltip,
    required this.onPressed,
    this.isClose = false,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Tooltip(
      message: tooltip,
      preferBelow: false,
      child: SizedBox(
        height: AppSizes.appBarHeight,
        width: 46,
        child: Material(
          color: Colors.transparent,
          child: InkWell(
            onTap: onPressed,
            hoverColor: isClose
                ? theme.colorScheme.error.withOpacity(0.1)
                : theme.colorScheme.onSurface.withOpacity(0.05),
            child: Icon(
              icon,
              size: AppSizes.iconSmall,
              color: isClose
                  ? theme.colorScheme.error
                  : theme.colorScheme.onSurfaceVariant,
            ),
          ),
        ),
      ),
    );
  }
}

class _WindowButtonsState extends State<WindowButtons> with WindowListener {
  bool _isMaximized = false;

  @override
  Widget build(BuildContext context) {
    return Row(
      children: [
        _WindowButton(
          icon: Icons.remove,
          tooltip: '最小化',
          onPressed: () async {
            await windowManager.minimize();
          },
        ),
        _WindowButton(
          icon: _isMaximized ? Icons.filter_none : Icons.crop_square,
          tooltip: _isMaximized ? '还原' : '最大化',
          onPressed: () async {
            if (_isMaximized) {
              await windowManager.unmaximize();
            } else {
              await windowManager.maximize();
            }
          },
        ),
        _WindowButton(
          icon: Icons.close,
          tooltip: '关闭',
          isClose: true,
          onPressed: () async {
            await windowManager.close();
          },
        ),
      ],
    );
  }

  @override
  void dispose() {
    windowManager.removeListener(this);
    super.dispose();
  }

  @override
  void initState() {
    super.initState();
    windowManager.addListener(this);
    _init();
  }

  @override
  void onWindowMaximize() {
    setState(() => _isMaximized = true);
  }

  @override
  void onWindowRestore() {
    setState(() => _isMaximized = false);
  }

  @override
  void onWindowUnmaximize() {
    setState(() => _isMaximized = false);
  }

  Future<void> _init() async {
    _isMaximized = await windowManager.isMaximized();
    if (mounted) setState(() {});
  }
}



=======================================
./lib/presentation/widgets/workbench/workbench_container.dart
=======================================
import 'package:flutter/material.dart';

import '../../../theme/app_sizes.dart';

class WorkbenchContainer extends StatelessWidget {
  final Widget? toolbar;
  final Widget body;
  final Widget? sidebar;
  final double? sidebarWidth;
  final Widget? footer;

  const WorkbenchContainer({
    super.key,
    this.toolbar,
    required this.body,
    this.sidebar,
    this.sidebarWidth = 320.0,
    this.footer,
  });

  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        if (toolbar != null)
          Container(
            height: AppSizes.pageToolbarHeight,
            decoration: BoxDecoration(
              border: Border(
                bottom: BorderSide(color: Theme.of(context).dividerColor),
              ),
            ),
            child: toolbar,
          ),
        Expanded(
          child: Row(
            children: [
              Expanded(child: body),
              if (sidebar != null) ...[
                VerticalDivider(
                    width: 1, color: Theme.of(context).dividerColor),
                SizedBox(
                  width: sidebarWidth,
                  child: sidebar!,
                ),
              ],
            ],
          ),
        ),
        if (footer != null)
          Container(
            decoration: BoxDecoration(
              border: Border(
                top: BorderSide(color: Theme.of(context).dividerColor),
              ),
            ),
            child: footer,
          ),
      ],
    );
  }
}



=======================================
./lib/presentation/widgets/workbench/workbench_toolbar.dart
=======================================
import 'package:flutter/material.dart';

import '../../../theme/app_sizes.dart';

class WorkbenchToolbar extends StatelessWidget {
  final String? title;
  final List<Widget>? actions;
  final List<Widget>? tools;
  final EdgeInsetsGeometry? padding;

  const WorkbenchToolbar({
    super.key,
    this.title,
    this.actions,
    this.tools,
    this.padding,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Container(
      padding: padding ?? const EdgeInsets.all(AppSizes.spacingMedium),
      child: Row(
        children: [
          if (title != null) Text(title!, style: theme.textTheme.titleMedium),
          if (tools != null) ...[
            const SizedBox(width: AppSizes.spacingMedium),
            ...tools!,
          ],
          const Spacer(),
          if (actions != null)
            Row(
              mainAxisSize: MainAxisSize.min,
              children: actions!,
            ),
        ],
      ),
    );
  }
}



=======================================
./lib/presentation/widgets/works/enhanced_work_preview.dart
=======================================
import 'package:flutter/material.dart';

import '../../../domain/models/work/work_image.dart';
import '../../../infrastructure/logging/logger.dart';
import '../../pages/works/components/thumbnail_strip.dart';
import '../common/zoomable_image_view.dart';

/// An enhanced work preview component that combines image viewing and thumbnails
class EnhancedWorkPreview extends StatefulWidget {
  /// List of work images to display
  final List<WorkImage> images;

  /// Currently selected image index
  final int selectedIndex;

  /// Whether the preview is in editing mode
  final bool isEditing;

  /// Whether to show the toolbar
  final bool showToolbar;

  /// Optional toolbar actions
  final List<Widget>? toolbarActions;

  /// Called when selected image index changes
  final Function(int)? onIndexChanged;

  /// Called when a new image is added
  final Function(WorkImage)? onImageAdded;

  /// Called when an image is deleted
  final Function(String)? onImageDeleted;

  /// Called when images are reordered
  final Function(int, int)? onImagesReordered;

  const EnhancedWorkPreview({
    super.key,
    required this.images,
    required this.selectedIndex,
    this.isEditing = false,
    this.showToolbar = false,
    this.toolbarActions,
    this.onIndexChanged,
    this.onImageAdded,
    this.onImageDeleted,
    this.onImagesReordered,
  });

  @override
  State<EnhancedWorkPreview> createState() => _EnhancedWorkPreviewState();
}

class _EnhancedWorkPreviewState extends State<EnhancedWorkPreview> {
  @override
  Widget build(BuildContext context) {
    AppLogger.debug(
        'Building EnhancedWorkPreview with ${widget.images.length} images');
    final currentImage = widget.selectedIndex < widget.images.length
        ? widget.images[widget.selectedIndex]
        : null;
    final theme = Theme.of(context);

    return LayoutBuilder(builder: (context, constraints) {
      final availableHeight = constraints.maxHeight;
      final toolbarHeight = widget.showToolbar ? 56.0 : 0.0;
      final thumbnailHeight = widget.images.isNotEmpty ? 120.0 : 0.0;
      final imageHeight = availableHeight - toolbarHeight - thumbnailHeight;

      return Column(
        children: [
          // 工具栏 - 采用更轻量化的设计
          if (widget.showToolbar && widget.toolbarActions != null)
            Container(
              height: toolbarHeight,
              decoration: BoxDecoration(
                color: theme.colorScheme.surface, // Use surface color instead
                border: Border(
                  bottom: BorderSide(
                    color: theme.colorScheme.outlineVariant
                        .withOpacity(0.3), // Softer line
                    width: 1,
                  ),
                ),
              ),
              padding:
                  const EdgeInsets.symmetric(horizontal: 16.0, vertical: 8.0),
              child: Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  Expanded(
                    child: SingleChildScrollView(
                      scrollDirection: Axis.horizontal,
                      child: Row(
                        children: widget.toolbarActions!.map((widget) {
                          // Make sure buttons stay enabled unless explicitly disabled
                          if (widget is IconButton) {
                            return IconButton(
                              icon: widget.icon,
                              onPressed: widget.onPressed,
                              tooltip: widget.tooltip,
                              style: widget.style,
                            );
                          }
                          return widget;
                        }).toList(),
                      ),
                    ),
                  ),
                ],
              ),
            ),

          // 主图片显示区域
          Expanded(
            child: currentImage != null
                ? ZoomableImageView(
                    imagePath: currentImage.path,
                    enableMouseWheel: true,
                    minScale: 0.5,
                    maxScale: 4.0,
                    showControls: true,
                  )
                : Center(
                    child: Column(
                      mainAxisAlignment: MainAxisAlignment.center,
                      children: [
                        Icon(Icons.image_not_supported,
                            size: 48, color: theme.colorScheme.outline),
                        const SizedBox(height: 16),
                        Text('没有可显示的图片',
                            style: TextStyle(color: theme.colorScheme.outline)),
                      ],
                    ),
                  ),
          ),

          // 缩略图条 - 仅在有图片时显示
          if (widget.images.isNotEmpty)
            SizedBox(
              height: thumbnailHeight,
              child: ThumbnailStrip<WorkImage>(
                images: widget.images,
                selectedIndex: widget.selectedIndex,
                isEditable: widget.isEditing,
                onTap: (index) {
                  AppLogger.debug('EnhancedWorkPreview onTap: $index');
                  widget.onIndexChanged?.call(index);
                },
                onReorder: (oldIndex, newIndex) {
                  AppLogger.debug(
                      'EnhancedWorkPreview onReorder: $oldIndex -> $newIndex');
                  widget.onImagesReordered?.call(oldIndex, newIndex);
                },
                pathResolver: (image) => image.path,
                keyResolver: (image) => image.id,
              ),
            ),
        ],
      );
    });
  }
}



=======================================
./lib/presentation/widgets/works/preview_mode_config.dart
=======================================
import 'package:flutter/material.dart';

import 'preview_types.dart';

class PreviewModeConfig {
  /// Edit mode configuration
  static PreviewModeConfig get edit => PreviewModeConfig(
        toolbarActions: [
          ToolbarAction(
            icon: Icons.add_photo_alternate,
            tooltip: '添加图片',
            onPressed: () {}, // Will be set by consumer
          ),
          ToolbarAction(
            icon: Icons.save,
            tooltip: '保存更改',
            onPressed: () {}, // Will be set by consumer
            placement: ToolbarActionPlacement.right,
          ),
          ToolbarAction(
            icon: Icons.delete,
            tooltip: '删除图片',
            onPressed: () {}, // Will be set by consumer
          ),
        ],
        allowReordering: true,
        enableDeletion: true,
      );

  /// Extract mode configuration
  static PreviewModeConfig get extract => PreviewModeConfig(
        toolbarActions: [
          ToolbarAction(
            icon: Icons.crop_free,
            tooltip: '框选工具',
            onPressed: () {}, // Will be set by consumer
          ),
          ToolbarAction(
            icon: Icons.select_all,
            tooltip: '多选工具',
            onPressed: () {}, // Will be set by consumer
          ),
          ToolbarAction(
            icon: Icons.delete,
            tooltip: '删除选中区域',
            onPressed: () {}, // Will be set by consumer
          ),
        ],
        showControls: false,
        allowReordering: false,
      );

  /// Import mode configuration
  static PreviewModeConfig get import => PreviewModeConfig(
        toolbarActions: [
          ToolbarAction(
            icon: Icons.add_photo_alternate,
            tooltip: '添加图片',
            onPressed: () {}, // Will be set by consumer
          ),
          ToolbarAction(
            icon: Icons.delete,
            tooltip: '删除图片',
            onPressed: () {}, // Will be set by consumer
          ),
        ],
        allowReordering: true,
        enableDeletion: true,
        emptyStateMessage: '点击添加或拖放图片',
      );

  /// View mode configuration
  static PreviewModeConfig get view => const PreviewModeConfig(
        toolbarActions: [],
        showControls: true,
        showToolbar: false,
      );
  final List<ToolbarAction> toolbarActions;
  final bool allowReordering;
  final bool showControls;

  final bool showToolbar;

  final bool showThumbnails;

  final bool enableDeletion;

  final String emptyStateMessage;

  const PreviewModeConfig({
    required this.toolbarActions,
    this.allowReordering = false,
    this.showControls = true,
    this.showToolbar = true,
    this.showThumbnails = true,
    this.enableDeletion = false,
    this.emptyStateMessage = '无图片',
  });

  /// Create a copy with updated action handlers
  PreviewModeConfig copyWithActions({
    VoidCallback? onAdd,
    VoidCallback? onDelete,
    VoidCallback? onSave,
    VoidCallback? onBoxSelect,
    VoidCallback? onMultiSelect,
  }) {
    return PreviewModeConfig(
      toolbarActions: toolbarActions.map((action) {
        if (action.icon == Icons.add_photo_alternate && onAdd != null) {
          return action.copyWith(onPressed: onAdd);
        }
        if (action.icon == Icons.delete && onDelete != null) {
          return action.copyWith(onPressed: onDelete);
        }
        if (action.icon == Icons.save && onSave != null) {
          return action.copyWith(onPressed: onSave);
        }
        if (action.icon == Icons.crop_free && onBoxSelect != null) {
          return action.copyWith(onPressed: onBoxSelect);
        }
        if (action.icon == Icons.select_all && onMultiSelect != null) {
          return action.copyWith(onPressed: onMultiSelect);
        }
        return action;
      }).toList(),
      allowReordering: allowReordering,
      showControls: showControls,
      showToolbar: showToolbar,
      showThumbnails: showThumbnails,
      enableDeletion: enableDeletion,
      emptyStateMessage: emptyStateMessage,
    );
  }

  /// Get configuration for specific mode
  static PreviewModeConfig forMode(PreviewMode mode) {
    switch (mode) {
      case PreviewMode.import:
        return import;
      case PreviewMode.edit:
        return edit;
      case PreviewMode.view:
        return view;
      case PreviewMode.extract:
        return extract;
    }
  }
}



=======================================
./lib/presentation/widgets/works/preview_types.dart
=======================================
import 'package:flutter/material.dart';

/// 预览模式枚举
enum PreviewMode {
  /// 导入模式
  import,

  /// 编辑模式
  edit,

  /// 查看模式
  view,

  /// 提取模式
  extract,
}

/// 工具栏操作项
class ToolbarAction {
  /// 图标
  final IconData icon;

  /// 标题
  final String? tooltip;

  /// 是否可用
  final bool enabled;

  /// 操作回调
  final VoidCallback? onPressed;

  /// 位置
  final ToolbarActionPlacement placement;

  const ToolbarAction({
    required this.icon,
    this.tooltip,
    this.enabled = true,
    this.onPressed,
    this.placement = ToolbarActionPlacement.left,
  });

  /// 创建一个新的 ToolbarAction 实例，可选择性地覆盖现有属性
  ToolbarAction copyWith({
    IconData? icon,
    String? tooltip,
    bool? enabled,
    VoidCallback? onPressed,
    ToolbarActionPlacement? placement,
  }) {
    return ToolbarAction(
      icon: icon ?? this.icon,
      tooltip: tooltip ?? this.tooltip,
      enabled: enabled ?? this.enabled,
      onPressed: onPressed ?? this.onPressed,
      placement: placement ?? this.placement,
    );
  }
}

/// 工具栏操作位置枚举
enum ToolbarActionPlacement {
  /// 左侧
  left,

  /// 右侧
  right,

  /// 居中
  center,
}



=======================================
./lib/providers.dart
=======================================
// Re-export providers
export 'application/providers/providers.dart';
export 'domain/repositories/repositories.dart';



=======================================
./lib/routes/app_routes.dart
=======================================
import 'package:go_router/go_router.dart';

import '../presentation/pages/home_page.dart';

/// The route configuration.
final routes = <RouteBase>[
  GoRoute(
    path: AppRoutes.home,
    builder: (context, state) =>
        const HomePagePlaceholder(), // Placeholder for home page
  ),
];

/// App route definitions
class AppRoutes {
  static const home = '/';
  static const workBrowse = '/work_browse';
  static const workDetail = '/work_detail';
  static const workImport = '/work_import';
  static const characterList = '/character_list';
  static const characterDetail = '/character_detail';
  static const practiceList = '/practice_list';
  static const practiceDetail = '/practice_detail';
  static const practiceEdit = '/practice_edit';
  static const settings = '/settings';
  static const String workEdit = '/work/edit';
  static const String workExtract = '/work/extract';
}



=======================================
./lib/theme/app_colors.dart
=======================================
import 'package:flutter/material.dart';

class AppColors {
  // Primary colors
  static const primary = Color(0xFF2196F3);
  static const primaryLight = Color(0xFF64B5F6);
  static const primaryDark = Color(0xFF1976D2);

  // Secondary colors
  static const secondary = Color(0xFF4CAF50);
  static const secondaryLight = Color(0xFF81C784);
  static const secondaryDark = Color(0xFF388E3C);

  // Background colors
  static const background = Color(0xFFF5F5F5);
  static const surface = Colors.white;
  static const selectedCard = Color(0xFFE3F2FD);

  // Text colors
  static const textPrimary = Color(0xFF212121);
  static const textSecondary = Color(0xFF757575);
  static const textHint = Color(0xFFBDBDBD);

  // Status colors
  static const success = Color(0xFF4CAF50);
  static const warning = Color(0xFFFFC107);
  static const error = Color(0xFFF44336);
  static const info = Color(0xFF2196F3);

  // Card colors
  static const cardShadow = Color(0x1F000000);
  static const divider = Color(0xFFE0E0E0);

  // Icon colors
  static const iconPrimary = Color(0xFF616161);
  static const iconSecondary = Color(0xFF9E9E9E);
  static const iconDisabled = Color(0xFFBDBDBD);
}



=======================================
./lib/theme/app_images.dart
=======================================
class AppImages {
  // 图标尺寸
  static const double iconSizeSmall = 16;
  static const double iconSizeMedium = 24;
  static const double iconSizeLarge = 32;

  // 预览图尺寸
  static const double thumbnailSizeSmall = 100;
  static const double thumbnailSizeMedium = 150;
  static const double thumbnailSizeLarge = 200;

  // 占位图样式
  static const double placeholderOpacity = 0.1;
  static const double placeholderIconSize = 48;
}



=======================================
./lib/theme/app_sizes.dart
=======================================
/// 应用尺寸常量
class AppSizes {
  // Padding
  static const double p2 = 2.0;
  static const double p4 = 4.0;
  static const double p8 = 8.0;
  static const double p12 = 12.0;
  static const double p16 = 16.0;
  static const double p24 = 24.0;
  static const double p32 = 32.0;
  static const double p48 = 48.0;
  static const double p64 = 64.0;

  // Margin
  static const double m2 = 2.0;
  static const double m4 = 4.0;
  static const double m8 = 8.0;
  static const double m12 = 12.0;
  static const double m16 = 16.0;
  static const double m24 = 24.0;
  static const double m32 = 32.0;
  static const double m48 = 48.0;
  static const double m64 = 64.0;

  // Spacing
  static const double xxs = 2.0;
  static const double xs = 4.0;
  static const double s = 8.0;
  static const double m = 16.0;
  static const double l = 24.0;
  static const double xl = 32.0;
  static const double xxl = 48.0;

  // Component specific
  static const double spacingTiny = 2.0;
  static const double spacingSmall = 8.0;
  static const double spacingMedium = 16.0;
  static const double spacingLarge = 24.0;

  // Border radius
  static const double r4 = 4.0;
  static const double r8 = 8.0;
  static const double r12 = 12.0;
  static const double r16 = 16.0;
  static const double r24 = 24.0;

  static const double radiusSmall = 4.0;
  static const double radiusMedium = 8.0;
  static const double radiusLarge = 12.0;

  // Card
  static const double cardRadius = 8.0;
  static const double cardElevation = 1.0;
  static const double cardElevationSelected = 4.0;

  // Icon sizes
  static const double iconSmall = 16.0;
  static const double iconMedium = 24.0;
  static const double iconLarge = 32.0;

  // Layout
  static const double appBarHeight = 48.0;
  static const double sidebarWidth = 256.0;
  static const double navigationRailWidth = 72.0;
  static const double dividerThickness = 1.0;
  static const double pageToolbarHeight = 48.0;
  static const double dialogHeaderHeight = 48.0;
  static const double tableHeaderHeight = 48.0;

  // Grid
  static const double gridCardWidth = 280.0;
  static const double gridCardImageHeight = 200.0;
  static const double gridCardInfoHeight = 80.0;
  static const int gridCrossAxisCount = 4;
  static const double gridMainAxisSpacing = 16.0;
  static const double gridCrossAxisSpacing = 16.0;

  // Form
  static const double formFieldSpacing = 16.0;

  // Breakpoints
  static const double breakpointXs = 600.0;
  static const double breakpointMd = 905.0;
  static const double breakpointLg = 1240.0;
  static const double breakpointXl = 1440.0;
}



=======================================
./lib/theme/app_text_styles.dart
=======================================
import 'package:flutter/material.dart';

import 'app_colors.dart';

class AppTextStyles {
  static const displayLarge = TextStyle(
    fontSize: 57,
    fontWeight: FontWeight.normal,
    color: AppColors.textPrimary,
  );

  static const displayMedium = TextStyle(
    fontSize: 45,
    fontWeight: FontWeight.normal,
    color: AppColors.textPrimary,
  );

  static const displaySmall = TextStyle(
    fontSize: 36,
    fontWeight: FontWeight.normal,
    color: AppColors.textPrimary,
  );

  static const headlineLarge = TextStyle(
    fontSize: 32,
    fontWeight: FontWeight.normal,
    color: AppColors.textPrimary,
  );

  static const headlineMedium = TextStyle(
    fontSize: 28,
    fontWeight: FontWeight.normal,
    color: AppColors.textPrimary,
  );

  static const headlineSmall = TextStyle(
    fontSize: 24,
    fontWeight: FontWeight.normal,
    color: AppColors.textPrimary,
  );

  static const titleLarge = TextStyle(
    fontSize: 22,
    fontWeight: FontWeight.w500,
    color: AppColors.textPrimary,
  );

  static const titleMedium = TextStyle(
    fontSize: 16,
    fontWeight: FontWeight.w500,
    color: AppColors.textPrimary,
  );

  static const titleSmall = TextStyle(
    fontSize: 14,
    fontWeight: FontWeight.w500,
    color: AppColors.textPrimary,
  );

  static const bodyLarge = TextStyle(
    fontSize: 16,
    fontWeight: FontWeight.normal,
    color: AppColors.textPrimary,
  );

  static const bodyMedium = TextStyle(
    fontSize: 14,
    fontWeight: FontWeight.normal,
    color: AppColors.textPrimary,
  );

  static const bodySmall = TextStyle(
    fontSize: 12,
    fontWeight: FontWeight.normal,
    color: AppColors.textSecondary,
  );

  static const labelLarge = TextStyle(
    fontSize: 14,
    fontWeight: FontWeight.w500,
    color: AppColors.textPrimary,
  );

  static const labelMedium = TextStyle(
    fontSize: 12,
    fontWeight: FontWeight.w500,
    color: AppColors.textPrimary,
  );

  static const labelSmall = TextStyle(
    fontSize: 11,
    fontWeight: FontWeight.w500,
    color: AppColors.textSecondary,
  );
}



=======================================
./lib/theme/app_theme.dart
=======================================
import 'package:flutter/material.dart';

import 'app_colors.dart';
import 'app_sizes.dart';
import 'app_text_styles.dart';

/// Application Theme
class AppTheme {
  /// 获取暗色主题
  static ThemeData dark() {
    return ThemeData.dark().copyWith(
      colorScheme: ColorScheme.dark(
        primary: AppColors.primary,
        onPrimary: Colors.white,
        secondary: AppColors.secondary,
        onSecondary: Colors.white,
        surface: Colors.grey[850]!,
        onSurface: Colors.white,
        error: AppColors.error,
        onError: Colors.white,
      ),
    );
  }

  /// 获取亮色主题
  static ThemeData light() {
    return ThemeData.light().copyWith(
      colorScheme: const ColorScheme.light(
        primary: AppColors.primary,
        onPrimary: Colors.white,
        secondary: AppColors.secondary,
        onSecondary: Colors.white,
        surface: AppColors.surface,
        onSurface: AppColors.textPrimary,
        error: AppColors.error,
        onError: Colors.white,
      ),
      scaffoldBackgroundColor: AppColors.background,
      cardTheme: CardTheme(
        elevation: AppSizes.cardElevation,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(AppSizes.cardRadius),
        ),
      ),
      textTheme: const TextTheme(
        displayLarge: AppTextStyles.displayLarge,
        displayMedium: AppTextStyles.displayMedium,
        displaySmall: AppTextStyles.displaySmall,
        headlineLarge: AppTextStyles.headlineLarge,
        headlineMedium: AppTextStyles.headlineMedium,
        headlineSmall: AppTextStyles.headlineSmall,
        titleLarge: AppTextStyles.titleLarge,
        titleMedium: AppTextStyles.titleMedium,
        titleSmall: AppTextStyles.titleSmall,
        bodyLarge: AppTextStyles.bodyLarge,
        bodyMedium: AppTextStyles.bodyMedium,
        bodySmall: AppTextStyles.bodySmall,
        labelLarge: AppTextStyles.labelLarge,
        labelMedium: AppTextStyles.labelMedium,
        labelSmall: AppTextStyles.labelSmall,
      ),
      dividerTheme: const DividerThemeData(
        color: AppColors.divider,
        space: 1,
      ),
      iconTheme: const IconThemeData(
        color: AppColors.iconPrimary,
        size: AppSizes.iconMedium,
      ),
      inputDecorationTheme: InputDecorationTheme(
        border: OutlineInputBorder(
          borderRadius: BorderRadius.circular(AppSizes.r4),
        ),
        contentPadding: const EdgeInsets.symmetric(
          horizontal: AppSizes.p12,
          vertical: AppSizes.p8,
        ),
      ),
    );
  }
}



=======================================
./lib/utils/chinese_helper.dart
=======================================
/// Utility class for handling Chinese character operations
class ChineseHelper {
  /// The regular expression pattern for matching Chinese characters using Unicode ranges
  static final RegExp _chineseRegex = RegExp(
    r'[\u{4E00}-\u{9FFF}\u{3400}-\u{4DBF}\u{20000}-\u{2A6DF}\u{2A700}-\u{2B73F}\u{2B740}-\u{2B81F}\u{2B820}-\u{2CEAF}]',
    unicode: true,
  );

  /// Checks if a string contains Chinese characters
  static bool containsChinese(String text) {
    if (text.isEmpty) return false;
    return _chineseRegex.hasMatch(text);
  }

  /// Counts the number of Chinese characters in a string
  static int countChineseCharacters(String text) {
    if (text.isEmpty) return 0;
    return _chineseRegex.allMatches(text).length;
  }

  /// Extracts Chinese characters from the given text
  /// Returns a string containing only Chinese characters
  static String extractChineseCharacters(String text) {
    if (text.isEmpty) return '';

    StringBuffer result = StringBuffer();
    Iterable<Match> matches = _chineseRegex.allMatches(text);

    for (Match match in matches) {
      result.write(match.group(0));
    }

    return result.toString();
  }
}



=======================================
./lib/utils/date_formatter.dart
=======================================
import 'package:intl/intl.dart';

class DateFormatter {
  static final _compactFormatter = DateFormat('yyyy/MM/dd');
  static final _fullFormatter = DateFormat('yyyy年MM月dd日');
  static final _timeFormatter = DateFormat('HH:mm');

  /// Format date to compact format: 2024/02/22
  static String formatCompact(DateTime date) {
    return _compactFormatter.format(date);
  }

  /// Format date to full format: 2024年02月22日
  static String formatFull(DateTime date) {
    return _fullFormatter.format(date);
  }

  /// Format date with time: 2024/02/22 14:30
  static String formatWithTime(DateTime date) {
    return '${formatCompact(date)} ${_timeFormatter.format(date)}';
  }

  /// Format relative date: 今天/昨天/前天/日期
  static String formatRelative(DateTime date) {
    final now = DateTime.now();
    final difference = now.difference(date);

    if (difference.inDays == 0) {
      return '今天';
    } else if (difference.inDays == 1) {
      return '昨天';
    } else if (difference.inDays == 2) {
      return '前天';
    } else {
      return formatCompact(date);
    }
  }
}


=======================================
./lib/utils/date_time_helper.dart
=======================================
/// UTC日期时间处理工具类
class DateTimeHelper {
  /// 格式化日期范围查询条件
  static Map<String, String> formatDateRange(DateTime start, DateTime end) {
    return {
      'start': toStorageFormat(start)!,
      'end': toStorageFormat(end)!,
    };
  }

  /// 从存储格式解析
  static DateTime? fromStorageFormat(String? utcString) {
    if (utcString == null) return null;
    return DateTime.parse(utcString).toLocal();
  }

  /// 获取当前UTC时间字符串
  static String getCurrentUtc() {
    return DateTime.now().toUtc().toIso8601String();
  }

  /// 检查是否为有效的UTC ISO8601字符串
  static bool isValidUtcString(String? value) {
    if (value == null) return false;
    try {
      DateTime.parse(value);
      return value.endsWith('Z');
    } catch (e) {
      return false;
    }
  }

  /// 时间戳转UTC字符串
  static String? timestampToUtc(int? timestamp) {
    if (timestamp == null) return null;
    return DateTime.fromMillisecondsSinceEpoch(timestamp)
        .toUtc()
        .toIso8601String();
  }

  /// 转换为存储格式(UTC ISO8601)
  static String? toStorageFormat(DateTime? dateTime) {
    if (dateTime == null) return null;
    return dateTime.toUtc().toIso8601String();
  }

  /// UTC字符串转时间戳
  static int? utcToTimestamp(String? utcString) {
    if (utcString == null) return null;
    return DateTime.parse(utcString).millisecondsSinceEpoch;
  }
}



=======================================
./lib/utils/diagnostic_helper.dart
=======================================
import 'dart:async';

import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../infrastructure/logging/logger.dart';
import '../presentation/providers/work_browse_provider.dart';

/// 帮助诊断应用程序问题的工具类
class DiagnosticHelper {
  /// 诊断WorkBrowseProvider的状态
  static void diagnoseWorkBrowseState(WidgetRef ref) {
    final state = ref.read(workBrowseProvider);

    AppLogger.info('WorkBrowseState诊断', tag: 'Diagnostics', data: {
      'isLoading': state.isLoading,
      'hasError': state.error != null,
      'errorMsg': state.error,
      'worksCount': state.works.length,
      'viewMode': state.viewMode.toString(),
      'isSidebarOpen': state.isSidebarOpen,
      'searchQuery': state.searchQuery,
    });

    // 尝试检查数据加载问题
    try {
      // 尝试直接加载
      ref.read(workBrowseProvider.notifier).loadWorks(forceRefresh: true);
    } catch (e, stack) {
      AppLogger.error('诊断时重新加载失败',
          tag: 'Diagnostics', error: e, stackTrace: stack);
    }
  }

  /// 获取应用状态快照
  static Map<String, dynamic> getAppStateSnapshot(WidgetRef ref) {
    final snapshot = <String, dynamic>{};

    try {
      final browseState = ref.read(workBrowseProvider);
      snapshot['workBrowseState'] = {
        'isLoading': browseState.isLoading,
        'hasError': browseState.error != null,
        'worksCount': browseState.works.length,
      };
    } catch (e) {
      snapshot['workBrowseStateError'] = e.toString();
    }

    return snapshot;
  }

  /// 运行诊断任务，包含超时保护
  static Future<T> runWithDiagnostics<T>(
    Future<T> Function() task, {
    String taskName = '未命名任务',
    Duration timeout = const Duration(seconds: 10),
  }) async {
    try {
      AppLogger.debug('开始任务: $taskName', tag: 'Diagnostics');
      final Stopwatch stopwatch = Stopwatch()..start();

      final result = await task().timeout(timeout, onTimeout: () {
        AppLogger.warning('任务超时: $taskName', tag: 'Diagnostics');
        throw TimeoutException('任务 $taskName 超时');
      });

      stopwatch.stop();
      AppLogger.debug('完成任务: $taskName',
          tag: 'Diagnostics', data: {'耗时(ms)': stopwatch.elapsedMilliseconds});

      return result;
    } catch (e, stack) {
      AppLogger.error('任务执行失败: $taskName',
          tag: 'Diagnostics', error: e, stackTrace: stack);
      rethrow;
    }
  }
}



=======================================
./lib/utils/file_size_formatter.dart
=======================================
import 'dart:math' as math;

/// 文件大小格式化工具
class FileSizeFormatter {
  /// 格式化文件大小
  ///
  /// [bytes] 字节数
  /// [decimals] 小数位数
  static String format(int bytes, [int decimals = 2]) {
    if (bytes <= 0) return '0 B';

    const suffixes = ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];
    var i = (math.log(bytes) / math.log(1024)).floor();
    i = i < suffixes.length ? i : suffixes.length - 1;

    return '${(bytes / math.pow(1024, i)).toStringAsFixed(decimals)} ${suffixes[i]}';
  }

  /// 以字节为单位格式化
  static String formatBytes(int bytes) => '$bytes B';

  /// 以GB为单位格式化
  static String formatGB(int bytes) =>
      '${(bytes / (1024 * 1024 * 1024)).toStringAsFixed(2)} GB';

  /// 以KB为单位格式化
  static String formatKB(int bytes) =>
      '${(bytes / 1024).toStringAsFixed(2)} KB';

  /// 以MB为单位格式化
  static String formatMB(int bytes) =>
      '${(bytes / (1024 * 1024)).toStringAsFixed(2)} MB';
}



=======================================
./lib/utils/route_observer_helper.dart
=======================================
import 'package:flutter/material.dart';

import '../infrastructure/logging/logger.dart';

/// 路由观察者，用于诊断导航问题
class AppRouteObserver extends NavigatorObserver {
  @override
  void didPop(Route<dynamic> route, Route<dynamic>? previousRoute) {
    AppLogger.debug('路由被弹出', tag: 'Navigation', data: {
      'route': route.settings.name ?? route.toString(),
      'previousRoute': previousRoute?.settings.name ?? previousRoute.toString(),
    });
    super.didPop(route, previousRoute);
  }

  @override
  void didPush(Route<dynamic> route, Route<dynamic>? previousRoute) {
    AppLogger.debug('路由被推入', tag: 'Navigation', data: {
      'route': route.settings.name ?? route.toString(),
      'previousRoute': previousRoute?.settings.name ?? previousRoute.toString(),
    });
    super.didPush(route, previousRoute);
  }

  @override
  void didRemove(Route<dynamic> route, Route<dynamic>? previousRoute) {
    AppLogger.debug('路由被移除', tag: 'Navigation', data: {
      'route': route.settings.name ?? route.toString(),
      'previousRoute': previousRoute?.settings.name ?? previousRoute.toString(),
    });
    super.didRemove(route, previousRoute);
  }

  @override
  void didReplace({Route<dynamic>? newRoute, Route<dynamic>? oldRoute}) {
    AppLogger.debug('路由被替换', tag: 'Navigation', data: {
      'newRoute': newRoute?.settings.name ?? newRoute.toString(),
      'oldRoute': oldRoute?.settings.name ?? oldRoute.toString(),
    });
    super.didReplace(newRoute: newRoute, oldRoute: oldRoute);
  }
}



=======================================
./lib/utils/safe_metadata_helper.dart
=======================================
import 'dart:convert';

import 'package:flutter/foundation.dart';

/// 用于安全处理元数据的工具类
class SafeMetadataHelper {
  /// 安全地获取标签列表
  static List<String> getTags(dynamic metadata) {
    try {
      if (metadata == null) {
        return [];
      }

      Map<String, dynamic> metadataMap;

      if (metadata is String) {
        metadataMap = parseMetadata(metadata);
      } else if (metadata is Map) {
        metadataMap = Map<String, dynamic>.from(metadata);
      } else {
        return [];
      }

      if (metadataMap.containsKey('tags') && metadataMap['tags'] is List) {
        final dynamicTags = metadataMap['tags'] as List;
        // 显式转换为 List<String>
        return dynamicTags.map<String>((item) => item.toString()).toList();
      }
    } catch (e) {
      debugPrint('Error getting tags: $e');
    }

    return [];
  }

  /// 安全地解析元数据 JSON 字符串
  static Map<String, dynamic> parseMetadata(dynamic rawMetadata) {
    if (rawMetadata == null) {
      return {'tags': []};
    }

    try {
      if (rawMetadata is String) {
        if (rawMetadata.isEmpty || rawMetadata == 'null') {
          return {'tags': []};
        }
        return jsonDecode(rawMetadata) as Map<String, dynamic>;
      } else if (rawMetadata is Map) {
        return Map<String, dynamic>.from(rawMetadata);
      }
    } catch (e) {
      debugPrint('Error parsing metadata: $e');
    }

    return {'tags': []};
  }
}



=======================================
./lib/utils/throttle_helper.dart
=======================================
import 'dart:async';

/// 用于控制频繁操作的节流助手类
class ThrottleHelper {
  Timer? _throttleTimer;
  DateTime _lastExecutionTime =
      DateTime.now().subtract(const Duration(minutes: 1));
  bool _isExecuting = false;
  final Duration _minInterval;

  ThrottleHelper({Duration minInterval = const Duration(milliseconds: 300)})
      : _minInterval = minInterval;

  /// 取消当前预定的节流操作
  void cancel() {
    _throttleTimer?.cancel();
  }

  /// 重置节流器状态
  void reset() {
    _throttleTimer?.cancel();
    _lastExecutionTime = DateTime.now().subtract(const Duration(minutes: 1));
    _isExecuting = false;
  }

  /// 执行节流操作，防止短时间内重复执行
  ///
  /// [operation] 要执行的操作
  /// [priority] 优先级，较高的优先级可以打断低优先级
  /// [forceExecute] 是否强制执行，忽略节流限制
  Future<T> throttle<T>(
    Future<T> Function() operation, {
    int priority = 0,
    bool forceExecute = false,
    String? operationName,
  }) async {
    // 取消任何现有的定时器
    _throttleTimer?.cancel();

    // 检查是否可以立即执行
    final now = DateTime.now();
    final timeSinceLastExecution = now.difference(_lastExecutionTime);
    final canExecuteNow = forceExecute ||
        (!_isExecuting && timeSinceLastExecution > _minInterval);

    if (canExecuteNow) {
      try {
        _isExecuting = true;
        _lastExecutionTime = now;
        return await operation();
      } finally {
        _isExecuting = false;
      }
    } else {
      // 如果不能立即执行，设置定时器
      final completer = Completer<T>();
      final remainingTime = _minInterval - timeSinceLastExecution;

      _throttleTimer = Timer(remainingTime, () async {
        try {
          if (!completer.isCompleted) {
            _isExecuting = true;
            _lastExecutionTime = DateTime.now();
            final result = await operation();
            completer.complete(result);
          }
        } catch (e) {
          if (!completer.isCompleted) {
            completer.completeError(e);
          }
        } finally {
          _isExecuting = false;
        }
      });

      return completer.future;
    }
  }
}



