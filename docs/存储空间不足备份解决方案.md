# å­˜å‚¨ç©ºé—´ä¸è¶³å¤‡ä»½è§£å†³æ–¹æ¡ˆè®¾è®¡ï¼ˆé…ç½®æ–‡ä»¶ç»Ÿä¸€ç®¡ç†ç‰ˆï¼‰

## é—®é¢˜åˆ†æ

### å½“å‰é—®é¢˜

- æ•°æ®è·¯å¾„æ‰€åœ¨å­˜å‚¨è®¾å¤‡ç©ºé—´æ»¡äº†
- å¤‡ä»½è·¯å¾„ä¹Ÿåœ¨æ•°æ®è·¯å¾„ä¹‹ä¸‹
- æ— æ³•è¿›è¡Œæ­£å¸¸çš„å¤‡ä»½æ“ä½œ
- éœ€è¦è¿ç§»åˆ°æ–°çš„å­˜å‚¨ä½ç½®

### å½“å‰å¤‡ä»½è·¯å¾„å®ç°

ç»è¿‡ä»£ç æ£€ç´¢ç¡®è®¤ï¼Œå½“å‰çš„é»˜è®¤å¤‡ä»½è·¯å¾„ä¸ºï¼š

```dart
// lib/application/services/backup_service.dart
BackupService({
  required IStorage storage,
  required DatabaseInterface database,
})  : _storage = storage,
      _database = database {
  _backupDir = p.join(_storage.getAppDataPath(), 'backups');
}
```

**é»˜è®¤å¤‡ä»½è·¯å¾„**ï¼š`{appDataPath}/backups`

- é€šå¸¸ä½äºï¼š`{åº”ç”¨æ•°æ®ç›®å½•}/backups`
- å¦‚ï¼š`C:\Users\{ç”¨æˆ·å}\AppData\Roaming\{åº”ç”¨}\charasgem\backups`ï¼ˆWindowsï¼‰

**æ ¸å¿ƒé—®é¢˜**ï¼šå¤‡ä»½ç›®å½•ä¸æ•°æ®ç›®å½•åœ¨åŒä¸€ç£ç›˜ï¼Œå½“ç£ç›˜ç©ºé—´ä¸è¶³æ—¶ï¼Œå¤‡ä»½æ— æ³•å®Œæˆã€‚

## è§£å†³æ–¹æ¡ˆ

### æ ¸å¿ƒæ€è·¯ï¼šåŸºäºé…ç½®æ–‡ä»¶çš„ç»Ÿä¸€å¤‡ä»½ç®¡ç†

**åœ¨æ–°çš„å¤‡ä»½è·¯å¾„ä¸‹åˆ›å»ºé…ç½®æ–‡ä»¶ï¼Œè®°å½•æ‰€æœ‰å¤‡ä»½ä¿¡æ¯ï¼ˆåŒ…æ‹¬å†å²å¤‡ä»½ï¼‰ï¼Œé€šè¿‡é…ç½®æ–‡ä»¶ç»Ÿä¸€ç®¡ç†æ‰€æœ‰å¤‡ä»½ï¼Œæ— éœ€å¤æ‚çš„è¿ç§»æ“ä½œã€‚**

### 1. æ ¸å¿ƒåŸç†

#### 1.1 é…ç½®æ–‡ä»¶ä½œä¸ºç»Ÿä¸€ç®¡ç†å…¥å£

- **æ–°å¤‡ä»½è·¯å¾„**ï¼šç”¨æˆ·é€‰æ‹©çš„ç‹¬ç«‹å­˜å‚¨ä½ç½®ï¼ˆå¦‚ `D:\CharasGemå¤‡ä»½`ï¼‰
- **é…ç½®æ–‡ä»¶**ï¼š`backup_registry.json` å­˜å‚¨åœ¨æ–°å¤‡ä»½è·¯å¾„ä¸‹
- **ç»Ÿä¸€ç®¡ç†**ï¼šæ‰€æœ‰å¤‡ä»½ä¿¡æ¯ï¼ˆåŒ…æ‹¬å†å²å¤‡ä»½ï¼‰éƒ½è®°å½•åœ¨é…ç½®æ–‡ä»¶ä¸­
- **æŒ‰éœ€åˆ é™¤**ï¼šé€šè¿‡é…ç½®æ–‡ä»¶ç®¡ç†å¤‡ä»½ï¼Œæ”¯æŒåˆ é™¤æ“ä½œ

#### 1.2 å·¥ä½œæµç¨‹

1. **ç”¨æˆ·é€‰æ‹©æ–°å¤‡ä»½è·¯å¾„**ï¼šå¦‚ `D:\CharasGemå¤‡ä»½`
2. **åˆ›å»ºé…ç½®æ–‡ä»¶**ï¼šåœ¨æ–°è·¯å¾„ä¸‹åˆ›å»º `backup_registry.json`
3. **è®°å½•ç°æœ‰å¤‡ä»½**ï¼šæ‰«æåŸé»˜è®¤è·¯å¾„ï¼Œå°†æ‰€æœ‰å¤‡ä»½ä¿¡æ¯è®°å½•åˆ°é…ç½®æ–‡ä»¶
4. **ç»Ÿä¸€ç®¡ç†**ï¼šæ‰€æœ‰å¤‡ä»½æ“ä½œéƒ½é€šè¿‡é…ç½®æ–‡ä»¶è¿›è¡Œ
5. **æŒ‰éœ€ä½¿ç”¨**ï¼šç”¨æˆ·å¯ä»¥æŸ¥çœ‹ã€æ¢å¤ã€åˆ é™¤ä»»æ„å¤‡ä»½

### 2. é…ç½®æ–‡ä»¶è®¾è®¡

#### 2.1 é…ç½®æ–‡ä»¶ç»“æ„

åœ¨æ–°å¤‡ä»½è·¯å¾„ä¸‹åˆ›å»º `backup_registry.json`ï¼š

```json
{
  "backup_location": {
    "path": "D:\\CharasGemå¤‡ä»½",
    "created_time": "2025-07-10T12:00:00Z",
    "description": "ä¸»è¦å¤‡ä»½ä½ç½®",
    "version": "1.0"
  },
  "backup_registry": [
    {
      "id": "backup_001",
      "filename": "backup_2025-07-10_120000.zip",
      "full_path": "D:\\CharasGemå¤‡ä»½\\backup_2025-07-10_120000.zip",
      "size": 1048576,
      "created_time": "2025-07-10T12:00:00Z",
      "checksum": "sha256:abc123...",
      "app_version": "1.2.3",
      "description": "ç”¨æˆ·æ‰‹åŠ¨åˆ›å»ºçš„å¤‡ä»½",
      "location": "current"
    },
    {
      "id": "backup_002",
      "filename": "backup_2025-07-09_180000.zip",
      "full_path": "C:\\Users\\wailik\\AppData\\Roaming\\charasgem\\backups\\backup_2025-07-09_180000.zip",
      "size": 956432,
      "created_time": "2025-07-09T18:00:00Z",
      "checksum": "sha256:def456...",
      "app_version": "1.2.2",
      "description": "å†å²å¤‡ä»½",
      "location": "legacy"
    }
  ],
  "settings": {
    "auto_cleanup": true,
    "max_backups": 20,
    "warn_on_delete": true
  },
  "statistics": {
    "total_backups": 2,
    "current_location_backups": 1,
    "legacy_location_backups": 1,
    "total_size": 2005008,
    "last_backup_time": "2025-07-10T12:00:00Z"
  }
}
```

#### 2.2 é…ç½®æ–‡ä»¶ç‰¹ç‚¹

1. **å®Œæ•´è®°å½•**ï¼šåŒ…å«æ‰€æœ‰å¤‡ä»½çš„å®Œæ•´è·¯å¾„å’Œè¯¦ç»†ä¿¡æ¯
2. **ä½ç½®æ ‡è¯†**ï¼šåŒºåˆ†å½“å‰ä½ç½®å’Œå†å²ä½ç½®çš„å¤‡ä»½
3. **ç»Ÿä¸€ç®¡ç†**ï¼šæ‰€æœ‰å¤‡ä»½æ“ä½œéƒ½åŸºäºæ­¤é…ç½®æ–‡ä»¶
4. **æŒ‰éœ€åˆ é™¤**ï¼šå¯ä»¥åˆ é™¤ä»»æ„ä½ç½®çš„å¤‡ä»½æ–‡ä»¶

### 3. æŠ€æœ¯å®ç°

#### 3.1 å¤‡ä»½æ³¨å†Œç®¡ç†å™¨

```dart
class BackupRegistryManager {
  static const String _registryFileName = 'backup_registry.json';
  
  // è·å–å¤‡ä»½æ³¨å†Œè¡¨
  static Future<BackupRegistry> getRegistry() async {
    final prefs = await SharedPreferences.getInstance();
    final currentPath = prefs.getString('current_backup_path');
    
    if (currentPath == null) {
      throw Exception('æœªè®¾ç½®å¤‡ä»½è·¯å¾„');
    }
    
    final registryFile = File(path.join(currentPath, _registryFileName));
    
    if (!await registryFile.exists()) {
      // åˆ›å»ºæ–°çš„æ³¨å†Œè¡¨
      return await _createNewRegistry(currentPath);
    }
    
    final registryJson = await registryFile.readAsString();
    return BackupRegistry.fromJson(jsonDecode(registryJson));
  }
  
  // è®¾ç½®æ–°çš„å¤‡ä»½è·¯å¾„
  static Future<void> setBackupLocation(String newPath) async {
    final prefs = await SharedPreferences.getInstance();
    
    // 1. æ‰«æåŸæœ‰å¤‡ä»½
    final existingBackups = await _scanExistingBackups();
    
    // 2. åˆ›å»ºæ–°çš„æ³¨å†Œè¡¨
    final registry = BackupRegistry(
      location: BackupLocation(
        path: newPath,
        createdTime: DateTime.now(),
        description: 'ä¸»è¦å¤‡ä»½ä½ç½®',
      ),
      backups: existingBackups,
    );
    
    // 3. ä¿å­˜æ³¨å†Œè¡¨åˆ°æ–°ä½ç½®
    await _saveRegistry(newPath, registry);
    
    // 4. æ›´æ–°å½“å‰è·¯å¾„
    await prefs.setString('current_backup_path', newPath);
  }
  
  // æ‰«æç°æœ‰å¤‡ä»½
  static Future<List<BackupEntry>> _scanExistingBackups() async {
    final backups = <BackupEntry>[];
    
    // æ‰«æé»˜è®¤è·¯å¾„
    final defaultPath = path.join(
      await _getAppDataPath(), 
      'backups'
    );
    
    if (await Directory(defaultPath).exists()) {
      final files = await Directory(defaultPath)
          .list()
          .where((entity) => entity.path.endsWith('.zip'))
          .toList();
      
      for (final file in files) {
        final stat = await File(file.path).stat();
        backups.add(BackupEntry(
          id: _generateId(),
          filename: path.basename(file.path),
          fullPath: file.path,
          size: stat.size,
          createdTime: stat.modified,
          location: 'legacy',
          description: 'å†å²å¤‡ä»½',
        ));
      }
    }
    
    return backups;
  }
  
  // æ·»åŠ æ–°å¤‡ä»½åˆ°æ³¨å†Œè¡¨
  static Future<void> addBackup(BackupEntry backup) async {
    final registry = await getRegistry();
    registry.addBackup(backup);
    await _saveRegistry(registry.location.path, registry);
  }
  
  // åˆ é™¤å¤‡ä»½
  static Future<void> deleteBackup(String backupId) async {
    final registry = await getRegistry();
    final backup = registry.getBackup(backupId);
    
    if (backup != null) {
      // 1. åˆ é™¤ç‰©ç†æ–‡ä»¶
      final file = File(backup.fullPath);
      if (await file.exists()) {
        await file.delete();
      }
      
      // 2. ä»æ³¨å†Œè¡¨ä¸­ç§»é™¤
      registry.removeBackup(backupId);
      
      // 3. æ›´æ–°é…ç½®æ–‡ä»¶
      await _saveRegistry(registry.location.path, registry);
    }
  }
  
  // è·å–æ‰€æœ‰å¤‡ä»½
  static Future<List<BackupEntry>> getAllBackups() async {
    final registry = await getRegistry();
    return registry.backups;
  }
}
```

#### 3.2 å¤‡ä»½æœåŠ¡ä¿®æ”¹

```dart
class EnhancedBackupService {
  Future<void> createBackup() async {
    // 1. è·å–å½“å‰å¤‡ä»½è·¯å¾„
    final prefs = await SharedPreferences.getInstance();
    final backupPath = prefs.getString('current_backup_path');
    
    if (backupPath == null) {
      throw Exception('è¯·å…ˆè®¾ç½®å¤‡ä»½è·¯å¾„');
    }
    
    // 2. åˆ›å»ºå¤‡ä»½æ–‡ä»¶
    final backupFile = await _performBackup(backupPath);
    
    // 3. æ·»åŠ åˆ°æ³¨å†Œè¡¨
    final backupEntry = BackupEntry(
      id: _generateId(),
      filename: path.basename(backupFile.path),
      fullPath: backupFile.path,
      size: await backupFile.length(),
      createdTime: DateTime.now(),
      location: 'current',
      description: 'æ‰‹åŠ¨åˆ›å»ºçš„å¤‡ä»½',
      checksum: await _calculateChecksum(backupFile),
    );
    
    await BackupRegistryManager.addBackup(backupEntry);
  }
  
  // è·å–æ‰€æœ‰å¤‡ä»½
  Future<List<BackupEntry>> getBackups() async {
    return await BackupRegistryManager.getAllBackups();
  }
  
  // åˆ é™¤å¤‡ä»½
  Future<void> deleteBackup(String backupId) async {
    await BackupRegistryManager.deleteBackup(backupId);
  }
  
  // æ¢å¤å¤‡ä»½
  Future<void> restoreBackup(String backupId) async {
    final registry = await BackupRegistryManager.getRegistry();
    final backup = registry.getBackup(backupId);
    
    if (backup != null) {
      await _performRestore(backup.fullPath);
    }
  }
}
```

### 4. ç”¨æˆ·ç•Œé¢è®¾è®¡

#### 4.1 è®¾ç½®ç•Œé¢

```dart
class BackupLocationSettings extends StatefulWidget {
  @override
  _BackupLocationSettingsState createState() => _BackupLocationSettingsState();
}

class _BackupLocationSettingsState extends State<BackupLocationSettings> {
  String? _currentPath;
  BackupRegistry? _registry;
  
  @override
  void initState() {
    super.initState();
    _loadCurrentPath();
  }
  
  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        // å½“å‰å¤‡ä»½ä½ç½®
        Card(
          child: ListTile(
            title: Text('å¤‡ä»½å­˜å‚¨ä½ç½®'),
            subtitle: Text(_currentPath ?? 'æœªè®¾ç½®'),
            trailing: IconButton(
              icon: Icon(Icons.folder_open),
              onPressed: () => _selectNewBackupPath(),
            ),
          ),
        ),
        
        // å¤‡ä»½ç»Ÿè®¡
        if (_registry != null)
          Card(
            child: ListTile(
              title: Text('å¤‡ä»½ç»Ÿè®¡'),
              subtitle: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text('æ€»å¤‡ä»½æ•°ï¼š${_registry!.statistics.totalBackups}'),
                  Text('å½“å‰ä½ç½®ï¼š${_registry!.statistics.currentLocationBackups}'),
                  Text('å†å²ä½ç½®ï¼š${_registry!.statistics.legacyLocationBackups}'),
                  Text('æ€»å¤§å°ï¼š${_formatFileSize(_registry!.statistics.totalSize)}'),
                ],
              ),
            ),
          ),
      ],
    );
  }
  
  Future<void> _selectNewBackupPath() async {
    final newPath = await FilePicker.platform.getDirectoryPath(
      dialogTitle: 'é€‰æ‹©å¤‡ä»½å­˜å‚¨ä½ç½®',
    );
    
    if (newPath != null) {
      await BackupRegistryManager.setBackupLocation(newPath);
      await _loadCurrentPath();
      setState(() {});
    }
  }
}
```

#### 4.2 å¤‡ä»½ç®¡ç†ç•Œé¢

```dart
class BackupManagementPage extends StatefulWidget {
  @override
  _BackupManagementPageState createState() => _BackupManagementPageState();
}

class _BackupManagementPageState extends State<BackupManagementPage> {
  List<BackupEntry> _backups = [];
  
  @override
  void initState() {
    super.initState();
    _loadBackups();
  }
  
  @override
  Widget build(BuildContext context) {
    return ListView.builder(
      itemCount: _backups.length,
      itemBuilder: (context, index) {
        final backup = _backups[index];
        return Card(
          child: ListTile(
            title: Text(backup.filename),
            subtitle: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text('å¤§å°ï¼š${_formatFileSize(backup.size)}'),
                Text('åˆ›å»ºæ—¶é—´ï¼š${_formatDateTime(backup.createdTime)}'),
                Text('ä½ç½®ï¼š${backup.location == 'current' ? 'å½“å‰' : 'å†å²'}'),
                Text('è·¯å¾„ï¼š${backup.fullPath}'),
              ],
            ),
            trailing: PopupMenuButton<String>(
              onSelected: (value) => _handleAction(value, backup),
              itemBuilder: (context) => [
                PopupMenuItem(
                  value: 'restore',
                  child: Text('æ¢å¤'),
                ),
                PopupMenuItem(
                  value: 'delete',
                  child: Text('åˆ é™¤'),
                ),
                PopupMenuItem(
                  value: 'info',
                  child: Text('è¯¦æƒ…'),
                ),
              ],
            ),
          ),
        );
      },
    );
  }
  
  Future<void> _handleAction(String action, BackupEntry backup) async {
    switch (action) {
      case 'restore':
        await _restoreBackup(backup.id);
        break;
      case 'delete':
        await _deleteBackup(backup.id);
        break;
      case 'info':
        _showBackupInfo(backup);
        break;
    }
  }
  
  Future<void> _deleteBackup(String backupId) async {
    final confirmed = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        title: Text('ç¡®è®¤åˆ é™¤'),
        content: Text('ç¡®å®šè¦åˆ é™¤æ­¤å¤‡ä»½å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ¢å¤ã€‚'),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context, false),
            child: Text('å–æ¶ˆ'),
          ),
          TextButton(
            onPressed: () => Navigator.pop(context, true),
            child: Text('åˆ é™¤'),
          ),
        ],
      ),
    );
    
    if (confirmed == true) {
      await BackupRegistryManager.deleteBackup(backupId);
      await _loadBackups();
      setState(() {});
    }
  }
}
```

### 5. å®æ–½æ­¥éª¤

#### 5.1 æ ¸å¿ƒåŠŸèƒ½å®ç°

1. **å®ç°å¤‡ä»½æ³¨å†Œç®¡ç†å™¨**ï¼š`BackupRegistryManager` ç±»
2. **ä¿®æ”¹å¤‡ä»½æœåŠ¡**ï¼šæ”¯æŒåŸºäºé…ç½®æ–‡ä»¶çš„å¤‡ä»½ç®¡ç†
3. **åˆ›å»ºè®¾ç½®ç•Œé¢**ï¼šå¤‡ä»½è·¯å¾„é€‰æ‹©å’Œç»Ÿè®¡æ˜¾ç¤º
4. **å®ç°å¤‡ä»½ç®¡ç†ç•Œé¢**ï¼šåˆ—è¡¨æ˜¾ç¤ºã€åˆ é™¤åŠŸèƒ½

#### 5.2 å…³é”®ä¿®æ”¹ç‚¹

**1. ä¿®æ”¹ BackupService æ„é€ å‡½æ•°**

```dart
BackupService({
  required IStorage storage,
  required DatabaseInterface database,
})  : _storage = storage,
      _database = database {
  // ä¸å†ç›´æ¥è®¾ç½®å¤‡ä»½è·¯å¾„ï¼Œè€Œæ˜¯é€šè¿‡æ³¨å†Œç®¡ç†å™¨è·å–
  _initializeFromRegistry();
}

Future<void> _initializeFromRegistry() async {
  final prefs = await SharedPreferences.getInstance();
  final backupPath = prefs.getString('current_backup_path');
  
  if (backupPath != null) {
    _backupDir = backupPath;
  } else {
    // ä½¿ç”¨é»˜è®¤è·¯å¾„
    _backupDir = p.join(_storage.getAppDataPath(), 'backups');
  }
}
```

**2. ä¿®æ”¹ getBackups() æ–¹æ³•**

```dart
Future<List<BackupInfo>> getBackups() async {
  try {
    final backups = await BackupRegistryManager.getAllBackups();
    return backups.map((entry) => BackupInfo(
      filename: entry.filename,
      path: entry.fullPath,
      size: entry.size,
      createdTime: entry.createdTime,
      description: entry.description,
      isFromCurrentLocation: entry.location == 'current',
    )).toList();
  } catch (e) {
    // å¦‚æœé…ç½®æ–‡ä»¶ä¸å­˜åœ¨ï¼Œå›é€€åˆ°æ‰«ææ–‡ä»¶ç³»ç»Ÿ
    return await _scanFileSystem();
  }
}
```

## æ€»ç»“

### æ ¸å¿ƒä¼˜åŠ¿

1. **ç®€å•ç›´æ¥**ï¼šé€šè¿‡é…ç½®æ–‡ä»¶ç»Ÿä¸€ç®¡ç†ï¼Œæ— éœ€å¤æ‚çš„è¿ç§»é€»è¾‘
2. **é«˜æ•ˆå®ç”¨**ï¼šä¸ç§»åŠ¨æ–‡ä»¶ï¼Œåªç®¡ç†å¼•ç”¨ï¼Œæ“ä½œå¿«é€Ÿ
3. **ç»Ÿä¸€ç®¡ç†**ï¼šæ‰€æœ‰å¤‡ä»½ä¿¡æ¯é›†ä¸­åœ¨ä¸€ä¸ªé…ç½®æ–‡ä»¶ä¸­
4. **æŒ‰éœ€åˆ é™¤**ï¼šå¯ä»¥åˆ é™¤ä»»æ„ä½ç½®çš„å¤‡ä»½æ–‡ä»¶
5. **å®Œæ•´è®°å½•**ï¼šä¿ç•™æ‰€æœ‰å¤‡ä»½çš„è¯¦ç»†ä¿¡æ¯å’Œå†å²è½¨è¿¹

### ç”¨æˆ·ä»·å€¼

- **è§£å†³ç©ºé—´é—®é¢˜**ï¼šæ•°æ®ç£ç›˜ç©ºé—´ä¸è¶³æ—¶ä»å¯æ­£å¸¸å¤‡ä»½
- **ç»Ÿä¸€ç®¡ç†**ï¼šæ‰€æœ‰å¤‡ä»½ï¼ˆåŒ…æ‹¬å†å²å¤‡ä»½ï¼‰éƒ½åœ¨ä¸€ä¸ªç•Œé¢ä¸­ç®¡ç†
- **æŒ‰éœ€ä½¿ç”¨**ï¼šå¯ä»¥é€‰æ‹©æ€§åœ°ä¿ç•™æˆ–åˆ é™¤ç‰¹å®šå¤‡ä»½
- **ç®€å•æ“ä½œ**ï¼šåªéœ€ä¸€æ¬¡è®¾ç½®å¤‡ä»½è·¯å¾„ï¼Œåç»­è‡ªåŠ¨ç®¡ç†

### æŠ€æœ¯ç‰¹ç‚¹

- **é…ç½®æ–‡ä»¶é©±åŠ¨**ï¼šæ‰€æœ‰å¤‡ä»½ä¿¡æ¯åŸºäº JSON é…ç½®æ–‡ä»¶
- **æ— ç¼å…¼å®¹**ï¼šä¸ç°æœ‰å¤‡ä»½æµç¨‹å®Œå…¨å…¼å®¹
- **æ‰©å±•æ€§å¼º**ï¼šé…ç½®æ–‡ä»¶ç»“æ„æ˜“äºæ‰©å±•æ–°åŠŸèƒ½
- **å¯ç»´æŠ¤æ€§é«˜**ï¼šæ¸…æ™°çš„æ•°æ®ç»“æ„å’Œç®€å•çš„é€»è¾‘

### å®æ–½å»ºè®®

1. **ç¬¬ä¸€æ­¥**ï¼šå®ç°å¤‡ä»½æ³¨å†Œç®¡ç†å™¨å’ŒåŸºç¡€é…ç½®æ–‡ä»¶åŠŸèƒ½
2. **ç¬¬äºŒæ­¥**ï¼šä¿®æ”¹ç°æœ‰å¤‡ä»½æœåŠ¡ï¼Œæ”¯æŒé…ç½®æ–‡ä»¶ç®¡ç†
3. **ç¬¬ä¸‰æ­¥**ï¼šåˆ›å»ºç”¨æˆ·ç•Œé¢ï¼Œæ”¯æŒå¤‡ä»½è·¯å¾„è®¾ç½®å’Œå¤‡ä»½ç®¡ç†
4. **ç¬¬å››æ­¥**ï¼šæµ‹è¯•å’Œä¼˜åŒ–ï¼Œç¡®ä¿æ•°æ®å®‰å…¨å’Œç”¨æˆ·ä½“éªŒ

è¿™ä¸ªæ–¹æ¡ˆå®Œå…¨é¿å…äº†å¤æ‚çš„æ–‡ä»¶è¿ç§»æ“ä½œï¼Œé€šè¿‡é…ç½®æ–‡ä»¶å®ç°äº†ç®€å•è€Œå¼ºå¤§çš„å¤‡ä»½ç®¡ç†åŠŸèƒ½ã€‚ç”¨æˆ·å¯ä»¥è½»æ¾åœ°å°†å¤‡ä»½å­˜å‚¨åˆ°ä»»æ„ä½ç½®ï¼ŒåŒæ—¶ä¿æŒå¯¹æ‰€æœ‰å†å²å¤‡ä»½çš„å®Œæ•´ç®¡ç†èƒ½åŠ›ã€‚

### 6. æ•°æ®è·¯å¾„åˆ‡æ¢çš„å®Œæ•´è§£å†³æ–¹æ¡ˆ

å½“å­˜å‚¨ç©ºé—´ä¸è¶³æ—¶ï¼Œç”¨æˆ·å¯èƒ½è¿˜éœ€è¦è¿›è¡Œæ•°æ®è·¯å¾„åˆ‡æ¢ã€‚è¿™é‡Œæä¾›å®Œæ•´çš„æ•°æ®è·¯å¾„åˆ‡æ¢è§£å†³æ–¹æ¡ˆã€‚

#### 6.1 æ•°æ®è·¯å¾„åˆ‡æ¢å‰çš„å®‰å…¨ä¿éšœ

##### 6.1.1 å»ºè®®å¤‡ä»½æé†’

åœ¨ç”¨æˆ·å°è¯•åˆ‡æ¢æ•°æ®è·¯å¾„ä¹‹å‰ï¼Œå»ºè®®å…ˆè¿›è¡Œæ•°æ®å¤‡ä»½ï¼š

```dart
class DataPathSwitchManager {
  // æ£€æŸ¥æ•°æ®è·¯å¾„åˆ‡æ¢å‰çš„å‡†å¤‡å·¥ä½œ
  static Future<BackupRecommendation> checkPreSwitchRecommendations() async {
    final backupService = BackupService();
    
    // 1. æ£€æŸ¥æ˜¯å¦å·²è®¾ç½®å¤‡ä»½è·¯å¾„
    final prefs = await SharedPreferences.getInstance();
    final backupPath = prefs.getString('current_backup_path');
    
    if (backupPath == null) {
      return BackupRecommendation(
        needsBackupPath: true,
        recommendBackup: true,
        reason: 'æœªè®¾ç½®å¤‡ä»½è·¯å¾„ï¼Œå»ºè®®å…ˆè®¾ç½®å¤‡ä»½è·¯å¾„å¹¶åˆ›å»ºå¤‡ä»½',
      );
    }
    
    // 2. æ£€æŸ¥æœ€è¿‘å¤‡ä»½æ—¶é—´
    final lastBackupTime = await _getLastBackupTime();
    final now = DateTime.now();
    
    if (lastBackupTime == null) {
      return BackupRecommendation(
        needsBackupPath: false,
        recommendBackup: true,
        reason: 'å°šæœªåˆ›å»ºä»»ä½•å¤‡ä»½ï¼Œå»ºè®®å…ˆåˆ›å»ºå¤‡ä»½ä»¥ç¡®ä¿æ•°æ®å®‰å…¨',
      );
    }
    
    if (now.difference(lastBackupTime).inHours > 24) {
      return BackupRecommendation(
        needsBackupPath: false,
        recommendBackup: true,
        reason: 'æœ€è¿‘å¤‡ä»½æ—¶é—´è¶…è¿‡24å°æ—¶ï¼Œå»ºè®®åˆ›å»ºæ–°å¤‡ä»½',
      );
    }
    
    return BackupRecommendation(
      needsBackupPath: false,
      recommendBackup: false,
      reason: 'æœ€è¿‘å·²æœ‰å¤‡ä»½ï¼Œå¯ä»¥ç›´æ¥åˆ‡æ¢',
    );
  }
  
  // å»ºè®®å¤‡ä»½å¯¹è¯æ¡†
  static Future<BackupChoice> showBackupRecommendationDialog(
    BuildContext context, 
    BackupRecommendation recommendation
  ) async {
    return await showDialog<BackupChoice>(
      context: context,
      barrierDismissible: true, // å…è®¸ç‚¹å‡»å¤–éƒ¨å…³é—­
      builder: (context) => AlertDialog(
        title: Row(
          children: [
            Icon(Icons.info_outline, color: Colors.blue),
            SizedBox(width: 8),
            Text('æ•°æ®å®‰å…¨å»ºè®®'),
          ],
        ),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'ğŸ’¡ å®‰å…¨å»ºè®®ï¼š',
              style: TextStyle(
                fontWeight: FontWeight.bold,
                color: Colors.blue,
              ),
            ),
            SizedBox(height: 8),
            Text(recommendation.reason),
            SizedBox(height: 8),
            Text('â€¢ å¤‡ä»½å¯ä»¥ç¡®ä¿æ•°æ®å®‰å…¨'),
            Text('â€¢ åˆ‡æ¢è¿‡ç¨‹ä¸­å¦‚é‡é—®é¢˜å¯å¿«é€Ÿæ¢å¤'),
            Text('â€¢ æ‚¨ä¹Ÿå¯ä»¥é€‰æ‹©ç›´æ¥åˆ‡æ¢'),
          ],
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context, BackupChoice.cancel),
            child: Text('å–æ¶ˆ'),
          ),
          TextButton(
            onPressed: () => Navigator.pop(context, BackupChoice.skipBackup),
            child: Text('ç›´æ¥åˆ‡æ¢'),
          ),
          ElevatedButton(
            onPressed: () => Navigator.pop(context, BackupChoice.createBackup),
            child: Text('å…ˆå¤‡ä»½'),
          ),
        ],
      ),
    ) ?? BackupChoice.cancel;
  }
}
```

##### 6.1.2 æ•°æ®è·¯å¾„åˆ‡æ¢ç¡®è®¤æµç¨‹

```dart
// æ•°æ®è·¯å¾„åˆ‡æ¢çš„å®Œæ•´ç¡®è®¤æµç¨‹
Future<void> switchDataPath(BuildContext context) async {
  try {
    // ç¬¬1æ­¥ï¼šæ£€æŸ¥å’Œå»ºè®®å¤‡ä»½
    final recommendation = await DataPathSwitchManager.checkPreSwitchRecommendations();
    
    if (recommendation.recommendBackup) {
      // æ˜¾ç¤ºå»ºè®®æ€§å¤‡ä»½å¯¹è¯æ¡†
      final choice = await DataPathSwitchManager.showBackupRecommendationDialog(context, recommendation);
      
      switch (choice) {
        case BackupChoice.cancel:
          return; // ç”¨æˆ·å–æ¶ˆåˆ‡æ¢
        case BackupChoice.createBackup:
          await _performBackup(); // æ‰§è¡Œå¤‡ä»½
          break;
        case BackupChoice.skipBackup:
          // ç›´æ¥è¿›è¡Œä¸‹ä¸€æ­¥
          break;
      }
    }
    
    // ç¬¬2æ­¥ï¼šé€‰æ‹©æ–°çš„æ•°æ®è·¯å¾„
    final newDataPath = await FilePicker.platform.getDirectoryPath(
      dialogTitle: 'é€‰æ‹©æ–°çš„æ•°æ®å­˜å‚¨ä½ç½®',
    );
    
    if (newDataPath != null) {
      // ç¬¬3æ­¥ï¼šæ˜¾ç¤ºåˆ‡æ¢ç¡®è®¤å¯¹è¯æ¡†
      final confirmed = await _showDataPathSwitchConfirmDialog(context, newDataPath);
      
      if (confirmed) {
        // ç¬¬4æ­¥ï¼šæ‰§è¡Œæ•°æ®è·¯å¾„åˆ‡æ¢
        await _performDataPathSwitch(newDataPath);
      }
    }
  } catch (e) {
    _showErrorDialog(context, 'æ•°æ®è·¯å¾„åˆ‡æ¢å¤±è´¥ï¼š$e');
  }
}

// æ•°æ®è·¯å¾„åˆ‡æ¢ç¡®è®¤å¯¹è¯æ¡†
Future<bool> _showDataPathSwitchConfirmDialog(BuildContext context, String newPath) async {
  return await showDialog<bool>(
    context: context,
    builder: (context) => AlertDialog(
      title: Text('ç¡®è®¤æ•°æ®è·¯å¾„åˆ‡æ¢'),
      content: Column(
        mainAxisSize: MainAxisSize.min,
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text('æ–°çš„æ•°æ®è·¯å¾„ï¼š'),
          Text(
            newPath,
            style: TextStyle(fontWeight: FontWeight.bold),
          ),
          SizedBox(height: 16),
          Text('æ³¨æ„äº‹é¡¹ï¼š'),
          Text('â€¢ åˆ‡æ¢åï¼Œæ—§è·¯å¾„çš„æ•°æ®ä¸ä¼šè‡ªåŠ¨åˆ é™¤'),
          Text('â€¢ æ‚¨å¯ä»¥ç¨åæ‰‹åŠ¨æ¸…ç†æ—§è·¯å¾„çš„æ•°æ®'),
          Text('â€¢ å»ºè®®ç¡®è®¤æ•°æ®æ­£å¸¸åå†æ¸…ç†æ—§è·¯å¾„'),
        ],
      ),
      actions: [
        TextButton(
          onPressed: () => Navigator.pop(context, false),
          child: Text('å–æ¶ˆ'),
        ),
        ElevatedButton(
          onPressed: () => Navigator.pop(context, true),
          child: Text('ç¡®è®¤åˆ‡æ¢'),
        ),
      ],
    ),
  ) ?? false;
}
```

#### 6.2 æ—§æ•°æ®è·¯å¾„çš„å¤„ç†æ–¹æ¡ˆ

##### 6.2.1 æ—§è·¯å¾„è®°å½•æœºåˆ¶

åœ¨é…ç½®æ–‡ä»¶ä¸­è®°å½•æ—§çš„æ•°æ®è·¯å¾„ï¼Œä¾›ç”¨æˆ·åç»­ç®¡ç†ï¼š

```json
{
  "current_data_path": "D:\\CharasGemæ•°æ®",
  "data_path_history": [
    {
      "path": "C:\\Users\\wailik\\AppData\\Roaming\\charasgem\\data",
      "switched_time": "2025-07-10T12:00:00Z",
      "size_estimate": 524288000,
      "status": "pending_cleanup",
      "description": "åŸé»˜è®¤æ•°æ®è·¯å¾„"
    }
  ],
  "cleanup_settings": {
    "auto_cleanup_days": 30,
    "warn_before_cleanup": true,
    "verify_before_cleanup": true
  }
}
```

##### 6.2.2 æ—§è·¯å¾„ç®¡ç†å™¨

```dart
class LegacyDataPathManager {
  static const String _configKey = 'legacy_data_paths';
  
  // è®°å½•æ—§æ•°æ®è·¯å¾„
  static Future<void> recordLegacyPath(String oldPath) async {
    final prefs = await SharedPreferences.getInstance();
    final legacyPaths = await _getLegacyPaths();
    
    // ä¼°ç®—æ—§è·¯å¾„çš„æ•°æ®å¤§å°
    final sizeEstimate = await _calculateDirectorySize(oldPath);
    
    legacyPaths.add(LegacyDataPath(
      path: oldPath,
      switchedTime: DateTime.now(),
      sizeEstimate: sizeEstimate,
      status: 'pending_cleanup',
      description: 'éœ€è¦æ¸…ç†çš„æ—§æ•°æ®è·¯å¾„',
    ));
    
    await _saveLegacyPaths(legacyPaths);
  }
  
  // è·å–æ‰€æœ‰å¾…æ¸…ç†çš„æ—§è·¯å¾„
  static Future<List<LegacyDataPath>> getPendingCleanupPaths() async {
    final legacyPaths = await _getLegacyPaths();
    return legacyPaths.where((path) => path.status == 'pending_cleanup').toList();
  }
  
  // æ¸…ç†æ—§æ•°æ®è·¯å¾„
  static Future<void> cleanupLegacyPath(String pathId) async {
    final legacyPaths = await _getLegacyPaths();
    final targetPath = legacyPaths.firstWhere((p) => p.id == pathId);
    
    if (targetPath != null) {
      // åˆ é™¤æ—§è·¯å¾„çš„æ•°æ®
      final directory = Directory(targetPath.path);
      if (await directory.exists()) {
        await directory.delete(recursive: true);
      }
      
      // æ›´æ–°çŠ¶æ€
      targetPath.status = 'cleaned';
      targetPath.cleanedTime = DateTime.now();
      
      await _saveLegacyPaths(legacyPaths);
    }
  }
  
  // è®¡ç®—ç›®å½•å¤§å°
  static Future<int> _calculateDirectorySize(String path) async {
    try {
      final directory = Directory(path);
      if (!await directory.exists()) return 0;
      
      int totalSize = 0;
      await for (final entity in directory.list(recursive: true)) {
        if (entity is File) {
          totalSize += await entity.length();
        }
      }
      return totalSize;
    } catch (e) {
      return 0;
    }
  }
}
```

#### 6.3 ç”¨æˆ·ç•Œé¢è®¾è®¡

##### 6.3.1 æ•°æ®è·¯å¾„ç®¡ç†ç•Œé¢

```dart
class DataPathManagementPage extends StatefulWidget {
  @override
  _DataPathManagementPageState createState() => _DataPathManagementPageState();
}

class _DataPathManagementPageState extends State<DataPathManagementPage> {
  String? _currentDataPath;
  List<LegacyDataPath> _pendingCleanupPaths = [];
  
  @override
  void initState() {
    super.initState();
    _loadDataPaths();
  }
  
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('æ•°æ®è·¯å¾„ç®¡ç†')),
      body: Column(
        children: [
          // å½“å‰æ•°æ®è·¯å¾„
          Card(
            child: ListTile(
              title: Text('å½“å‰æ•°æ®è·¯å¾„'),
              subtitle: Text(_currentDataPath ?? 'æœªè®¾ç½®'),
              trailing: ElevatedButton(
                onPressed: () => _switchDataPath(),
                child: Text('åˆ‡æ¢è·¯å¾„'),
              ),
            ),
          ),
          
          // å¾…æ¸…ç†çš„æ—§è·¯å¾„
          if (_pendingCleanupPaths.isNotEmpty) ...[
            SizedBox(height: 16),
            Card(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Padding(
                    padding: EdgeInsets.all(16),
                    child: Row(
                      children: [
                        Icon(Icons.warning, color: Colors.orange),
                        SizedBox(width: 8),
                        Text(
                          'å¾…æ¸…ç†çš„æ—§æ•°æ®è·¯å¾„',
                          style: TextStyle(
                            fontSize: 16,
                            fontWeight: FontWeight.bold,
                          ),
                        ),
                      ],
                    ),
                  ),
                  for (final legacyPath in _pendingCleanupPaths)
                    ListTile(
                      title: Text(legacyPath.path),
                      subtitle: Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          Text('åˆ‡æ¢æ—¶é—´ï¼š${_formatDateTime(legacyPath.switchedTime)}'),
                          Text('æ•°æ®å¤§å°ï¼š${_formatFileSize(legacyPath.sizeEstimate)}'),
                        ],
                      ),
                      trailing: PopupMenuButton<String>(
                        onSelected: (value) => _handleLegacyPathAction(value, legacyPath),
                        itemBuilder: (context) => [
                          PopupMenuItem(
                            value: 'cleanup',
                            child: Text('æ¸…ç†æ•°æ®'),
                          ),
                          PopupMenuItem(
                            value: 'explore',
                            child: Text('æ‰“å¼€è·¯å¾„'),
                          ),
                          PopupMenuItem(
                            value: 'ignore',
                            child: Text('å¿½ç•¥'),
                          ),
                        ],
                      ),
                    ),
                ],
              ),
            ),
          ],
        ],
      ),
    );
  }
  
  // å¤„ç†æ—§è·¯å¾„æ“ä½œ
  Future<void> _handleLegacyPathAction(String action, LegacyDataPath legacyPath) async {
    switch (action) {
      case 'cleanup':
        await _cleanupLegacyPath(legacyPath);
        break;
      case 'explore':
        await _openPathInExplorer(legacyPath.path);
        break;
      case 'ignore':
        await _ignoreLegacyPath(legacyPath);
        break;
    }
  }
  
  // æ¸…ç†æ—§è·¯å¾„
  Future<void> _cleanupLegacyPath(LegacyDataPath legacyPath) async {
    final confirmed = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        title: Text('ç¡®è®¤æ¸…ç†æ—§æ•°æ®'),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text('å³å°†æ¸…ç†ä»¥ä¸‹è·¯å¾„çš„æ•°æ®ï¼š'),
            SizedBox(height: 8),
            Text(
              legacyPath.path,
              style: TextStyle(fontWeight: FontWeight.bold),
            ),
            SizedBox(height: 16),
            Text('âš ï¸ æ³¨æ„ï¼šæ­¤æ“ä½œä¸å¯æ¢å¤ï¼'),
            Text('è¯·ç¡®è®¤æ–°æ•°æ®è·¯å¾„å·¥ä½œæ­£å¸¸åå†è¿›è¡Œæ¸…ç†ã€‚'),
          ],
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context, false),
            child: Text('å–æ¶ˆ'),
          ),
          ElevatedButton(
            onPressed: () => Navigator.pop(context, true),
            style: ElevatedButton.styleFrom(backgroundColor: Colors.red),
            child: Text('ç¡®è®¤æ¸…ç†'),
          ),
        ],
      ),
    );
    
    if (confirmed == true) {
      try {
        await LegacyDataPathManager.cleanupLegacyPath(legacyPath.id);
        await _loadDataPaths();
        setState(() {});
        
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('æ—§æ•°æ®è·¯å¾„å·²æ¸…ç†å®Œæˆ')),
        );
      } catch (e) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('æ¸…ç†å¤±è´¥ï¼š$e')),
        );
      }
    }
  }
}
```

##### 6.3.2 æ•°æ®è·¯å¾„åˆ‡æ¢å‘å¯¼

```dart
class DataPathSwitchWizard extends StatefulWidget {
  @override
  _DataPathSwitchWizardState createState() => _DataPathSwitchWizardState();
}

class _DataPathSwitchWizardState extends State<DataPathSwitchWizard> {
  int _currentStep = 0;
  String? _selectedPath;
  bool _backupCompleted = false;
  
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: Text('æ•°æ®è·¯å¾„åˆ‡æ¢å‘å¯¼')),
      body: Stepper(
        currentStep: _currentStep,
        onStepTapped: (step) {
          if (step <= _currentStep) {
            setState(() => _currentStep = step);
          }
        },
        steps: [
          Step(
            title: Text('æ•°æ®å¤‡ä»½'),
            content: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text('ä¸ºäº†ç¡®ä¿æ•°æ®å®‰å…¨ï¼Œè¯·å…ˆåˆ›å»ºæ•°æ®å¤‡ä»½ï¼š'),
                SizedBox(height: 16),
                ElevatedButton(
                  onPressed: _backupCompleted ? null : _performBackup,
                  child: Text(_backupCompleted ? 'âœ“ å¤‡ä»½å·²å®Œæˆ' : 'å¼€å§‹å¤‡ä»½'),
                ),
              ],
            ),
            isActive: _currentStep >= 0,
          ),
          Step(
            title: Text('é€‰æ‹©æ–°è·¯å¾„'),
            content: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text('é€‰æ‹©æ–°çš„æ•°æ®å­˜å‚¨è·¯å¾„ï¼š'),
                SizedBox(height: 16),
                ElevatedButton(
                  onPressed: _selectNewPath,
                  child: Text('é€‰æ‹©è·¯å¾„'),
                ),
                if (_selectedPath != null) ...[
                  SizedBox(height: 8),
                  Text('å·²é€‰æ‹©ï¼š$_selectedPath'),
                ],
              ],
            ),
            isActive: _currentStep >= 1,
          ),
          Step(
            title: Text('ç¡®è®¤åˆ‡æ¢'),
            content: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text('ç¡®è®¤åˆ‡æ¢åˆ°æ–°çš„æ•°æ®è·¯å¾„ï¼š'),
                if (_selectedPath != null) ...[
                  SizedBox(height: 8),
                  Text('æ–°è·¯å¾„ï¼š$_selectedPath'),
                ],
                SizedBox(height: 16),
                ElevatedButton(
                  onPressed: _canConfirmSwitch() ? _confirmSwitch : null,
                  child: Text('ç¡®è®¤åˆ‡æ¢'),
                ),
              ],
            ),
            isActive: _currentStep >= 2,
          ),
        ],
      ),
    );
  }
  
  bool _canConfirmSwitch() {
    return _backupCompleted && _selectedPath != null;
  }
  
  Future<void> _performBackup() async {
    // æ‰§è¡Œå¤‡ä»½é€»è¾‘
    setState(() => _backupCompleted = true);
    setState(() => _currentStep = 1);
  }
  
  Future<void> _selectNewPath() async {
    final path = await FilePicker.platform.getDirectoryPath();
    if (path != null) {
      setState(() => _selectedPath = path);
      setState(() => _currentStep = 2);
    }
  }
  
  Future<void> _confirmSwitch() async {
    if (_selectedPath != null) {
      await _performDataPathSwitch(_selectedPath!);
      Navigator.pop(context, true);
    }
  }
}
```

#### 6.4 å®Œæ•´çš„æ•°æ®è·¯å¾„åˆ‡æ¢æµç¨‹

1. **åˆ‡æ¢å‰æ£€æŸ¥**ï¼š
   - éªŒè¯å¤‡ä»½è·¯å¾„æ˜¯å¦å·²è®¾ç½®
   - æ£€æŸ¥æœ€è¿‘å¤‡ä»½æ—¶é—´
   - å¼ºåˆ¶ç”¨æˆ·å…ˆè¿›è¡Œæ•°æ®å¤‡ä»½

2. **è·¯å¾„é€‰æ‹©**ï¼š
   - ç”¨æˆ·é€‰æ‹©æ–°çš„æ•°æ®è·¯å¾„
   - éªŒè¯è·¯å¾„å¯ç”¨æ€§å’Œæƒé™

3. **åˆ‡æ¢ç¡®è®¤**ï¼š
   - æ˜¾ç¤ºåˆ‡æ¢è¯¦æƒ…
   - å‘ŠçŸ¥ç”¨æˆ·æ—§è·¯å¾„å¤„ç†æ–¹å¼
   - ç”¨æˆ·ç¡®è®¤åæ‰§è¡Œåˆ‡æ¢

4. **åˆ‡æ¢åå¤„ç†**ï¼š
   - è®°å½•æ—§æ•°æ®è·¯å¾„åˆ°é…ç½®æ–‡ä»¶
   - æä¾›æ—§è·¯å¾„ç®¡ç†ç•Œé¢
   - ç”¨æˆ·å¯ä»¥é€‰æ‹©åˆé€‚æ—¶æœºæ¸…ç†æ—§è·¯å¾„

è¿™ä¸ªæ–¹æ¡ˆç¡®ä¿äº†æ•°æ®å®‰å…¨ï¼ŒåŒæ—¶ç»™ç”¨æˆ·å……åˆ†çš„æ§åˆ¶æƒæ¥ç®¡ç†æ—§æ•°æ®è·¯å¾„ã€‚

// æ”¯æŒçš„æ•°æ®ç±»å‹
enum BackupChoice {
  cancel,        // å–æ¶ˆåˆ‡æ¢
  skipBackup,    // è·³è¿‡å¤‡ä»½ï¼Œç›´æ¥åˆ‡æ¢
  createBackup,  // å…ˆåˆ›å»ºå¤‡ä»½å†åˆ‡æ¢
}

class BackupRecommendation {
  final bool needsBackupPath;
  final bool recommendBackup;
  final String reason;
  
  BackupRecommendation({
    required this.needsBackupPath,
    required this.recommendBackup,
    required this.reason,
  });
}

class DataPathSwitchException implements Exception {
  final String message;
  DataPathSwitchException(this.message);
  
  @override
  String toString() => 'DataPathSwitchException: $message';
}
