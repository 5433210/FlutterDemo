# 参考线自动对齐功能设计

## 1. 功能概述

参考线自动对齐功能为练习编辑页面提供智能对齐辅助，帮助用户精确定位和对齐元素。

### 1.1 核心特性

- **智能参考线检测**：自动检测元素的中线和边线
- **实时对齐提示**：拖拽过程中显示对齐参考线
- **自动吸附对齐**：释放时自动调整到最佳对齐位置
- **可配置开关**：通过工具栏控制功能开启/关闭

## 2. 参考线类型定义

### 2.1 参考线分类

```dart
enum GuideLineType {
  // 中线
  horizontalCenter,  // 横向中线
  verticalCenter,    // 纵向中线
  
  // 边线
  top,              // 上边线
  bottom,           // 下边线
  left,             // 左边线
  right,            // 右边线
}

enum GuideLineOrientation {
  horizontal,       // 横向参考线
  vertical,         // 纵向参考线
}
```

### 2.2 参考线数据结构

```dart
class GuideLine {
  final String elementId;              // 关联的元素ID
  final GuideLineType type;            // 参考线类型
  final GuideLineOrientation orientation; // 方向
  final double position;               // 位置坐标
  final Rect elementBounds;           // 元素边界
  
  // 计算属性
  bool get isCenter => type == GuideLineType.horizontalCenter || 
                      type == GuideLineType.verticalCenter;
  bool get isEdge => !isCenter;
}
```

## 3. 对齐检测算法

### 3.1 对齐检测范围

```dart
class AlignmentConfig {
  // 统一吸附距离：用于参考线检测和自动对齐的统一阈值
  static const double alignmentThreshold = 8.0;
  
  // 网格大小配置
  static const double gridSize = 20.0;
  
  // 对齐动画持续时间
  static const Duration animationDuration = Duration(milliseconds: 150);
}
```

#### 3.1.1 统一吸附距离设计

**设计优势：**

- **用户体验一致性**：看到参考线就意味着会自动对齐，心理预期统一
- **代码简洁性**：减少配置参数，简化算法逻辑
- **降低理解成本**：单一距离概念，易于理解和维护

**工作流程：**

1. **拖拽过程中**：使用`alignmentThreshold`(8px)检测并显示参考线
2. **鼠标释放时**：使用相同距离(8px)判断是否自动吸附
3. **触觉反馈**：当进入吸附距离范围时提供触觉反馈

**实际应用：**

- 当元素进入8像素感应范围时显示参考线
- 当鼠标释放时如果仍在8像素范围内就自动吸附
- 用户的心理预期完全一致：看到参考线就会对齐

### 3.2 对齐类型定义

```dart
enum AlignmentType {
  // 同类型对齐
  centerToCenter,    // 中线对中线
  edgeToEdge,        // 边线对边线
  
  // 混合对齐
  centerToEdge,      // 中线对边线
  edgeToCenter,      // 边线对中线
}

class AlignmentMatch {
  final GuideLine sourceLine;         // 被拖拽元素的参考线
  final GuideLine targetLine;         // 目标元素的参考线
  final AlignmentType alignmentType;  // 对齐类型
  final double distance;              // 距离
  final Offset adjustment;            // 需要调整的偏移量
  
  double get priority => 1.0 / (distance + 1.0); // 距离越近优先级越高
}
```

## 4. 核心算法设计

### 4.1 参考线生成算法

#### 4.1.1 算法原理

参考线生成算法是整个对齐系统的基础，负责为每个元素计算出所有可能的对齐参考线。算法的核心思想是：

**基本概念：**

- 每个矩形元素都有6条潜在的参考线：3条水平线（上边、中心、下边）和3条垂直线（左边、中心、右边）
- 这些参考线代表了其他元素可能与当前元素对齐的所有位置
- 参考线的位置由元素的边界矩形坐标计算得出

**计算逻辑：**

1. **水平参考线计算**：
   - 上边线 = 元素的y坐标
   - 水平中心线 = 元素的y坐标 + 元素高度的一半
   - 下边线 = 元素的y坐标 + 元素高度

2. **垂直参考线计算**：
   - 左边线 = 元素的x坐标
   - 垂直中心线 = 元素的x坐标 + 元素宽度的一半
   - 右边线 = 元素的x坐标 + 元素宽度

**数据结构设计**：
每条参考线包含完整的上下文信息，包括所属元素ID、参考线类型、方向、精确位置坐标以及元素边界，这些信息在后续的对齐检测中至关重要。

```dart
class GuideLineGenerator {
  /// 为元素生成所有参考线
  static List<GuideLine> generateGuideLines(Map<String, dynamic> element) {
    final id = element['id'] as String;
    final x = element['x'] as double;
    final y = element['y'] as double;
    final width = element['width'] as double;
    final height = element['height'] as double;
    
    final bounds = Rect.fromLTWH(x, y, width, height);
    
    return [
      // 横向参考线（水平线）
      GuideLine(
        elementId: id,
        type: GuideLineType.top,
        orientation: GuideLineOrientation.horizontal,
        position: y,
        elementBounds: bounds,
      ),
      GuideLine(
        elementId: id,
        type: GuideLineType.horizontalCenter,
        orientation: GuideLineOrientation.horizontal,
        position: y + height / 2,
        elementBounds: bounds,
      ),
      GuideLine(
        elementId: id,
        type: GuideLineType.bottom,
        orientation: GuideLineOrientation.horizontal,
        position: y + height,
        elementBounds: bounds,
      ),
      
      // 纵向参考线（垂直线）
      GuideLine(
        elementId: id,
        type: GuideLineType.left,
        orientation: GuideLineOrientation.vertical,
        position: x,
        elementBounds: bounds,
      ),
      GuideLine(
        elementId: id,
        type: GuideLineType.verticalCenter,
        orientation: GuideLineOrientation.vertical,
        position: x + width / 2,
        elementBounds: bounds,
      ),
      GuideLine(
        elementId: id,
        type: GuideLineType.right,
        orientation: GuideLineOrientation.vertical,
        position: x + width,
        elementBounds: bounds,
      ),
    ];
  }
}
```

### 4.2 对齐检测算法

#### 4.2.1 算法设计理念

对齐检测算法是参考线系统的核心，负责识别拖拽元素与其他元素之间的潜在对齐关系。算法采用**穷举搜索**的策略，确保不遗漏任何可能的对齐机会。

**算法步骤详解：**

1. **参考线生成阶段**：
   - 为被拖拽元素生成6条参考线（上、中、下、左、中、右）
   - 为画布上所有其他元素分别生成参考线
   - 总共可能产生的参考线数量 = 元素数量 × 6

2. **两两比较阶段**：
   - 对拖拽元素的每条参考线，与所有其他元素的参考线进行比较
   - 只比较相同方向的参考线（水平对水平，垂直对垂直）
   - 比较次数 = 拖拽元素参考线数 × 其他元素参考线数 ÷ 2（因为只比较同方向）

3. **距离筛选阶段**：
   - 计算两条参考线之间的绝对距离
   - 只保留距离小于等于`alignmentThreshold`（8像素）的匹配
   - 这个阈值确保只有足够接近的元素才会触发对齐

4. **匹配信息构建**：
   - 为每个有效匹配创建`AlignmentMatch`对象
   - 包含源参考线、目标参考线、对齐类型、距离和调整偏移量
   - 调整偏移量 = 目标位置 - 当前位置

**优化策略：**

- **早期退出**：如果距离超过阈值，立即跳过后续计算
- **方向过滤**：只比较相同方向的参考线，减少50%的比较次数
- **优先级排序**：按距离从近到远排序，确保最近的匹配优先级最高

```dart
class AlignmentDetector {
  /// 检测最佳对齐匹配
  static List<AlignmentMatch> detectAlignments(
    Map<String, dynamic> draggedElement,
    List<Map<String, dynamic>> otherElements,
  ) {
    final draggedLines = GuideLineGenerator.generateGuideLines(draggedElement);
    final allMatches = <AlignmentMatch>[];
    
    // 为所有其他元素生成参考线
    for (final element in otherElements) {
      if (element['id'] == draggedElement['id']) continue;
      
      final targetLines = GuideLineGenerator.generateGuideLines(element);
      
      // 检测每条拖拽元素参考线与目标参考线的匹配
      for (final sourceLine in draggedLines) {
        for (final targetLine in targetLines) {
          final match = _checkAlignment(sourceLine, targetLine);
          if (match != null) {
            allMatches.add(match);
          }
        }
      }
    }
      
    // 按优先级排序并过滤
    allMatches.sort((a, b) => b.priority.compareTo(a.priority));
    return _filterBestMatches(allMatches);
  }

#### 4.2.2 对齐类型判断算法

`_determineAlignmentType`方法负责识别两条参考线的对齐类型，这直接影响对齐的视觉效果和用户体验：

**对齐类型分类：**

- **中线对中线（centerToCenter）**：最常用的对齐方式，视觉效果最佳
- **边线对边线（edgeToEdge）**：适合元素边界对齐的场景
- **中线对边线（centerToEdge）**：一个元素的中心对齐到另一个元素的边界
- **边线对中线（edgeToCenter）**：一个元素的边界对齐到另一个元素的中心

**判断优先级：**
中线对中线 > 边线对边线 > 混合对齐，这个优先级反映了不同对齐方式的视觉美感和实用性。

#### 4.2.3 调整偏移量计算

`_calculateAdjustment`方法计算将拖拽元素移动到对齐位置所需的偏移量：

**计算公式：**
- 偏移量 = 目标位置 - 当前位置
- 水平参考线：返回(0, delta)，只调整Y坐标
- 垂直参考线：返回(delta, 0)，只调整X坐标

这确保了每次只在一个方向上进行对齐调整，避免了复杂的多维度调整。

  /// 检查两条参考线是否可以对齐
  static AlignmentMatch? _checkAlignment(GuideLine source, GuideLine target) {
    // 只检查相同方向的参考线
    if (source.orientation != target.orientation) return null;
    
    final distance = (source.position - target.position).abs();
    if (distance > AlignmentConfig.snapDistance) return null;
    
    // 确定对齐类型
    final alignmentType = _determineAlignmentType(source, target);
    
    // 计算调整偏移量
    final adjustment = _calculateAdjustment(source, target);
    
    return AlignmentMatch(
      sourceLine: source,
      targetLine: target,
      alignmentType: alignmentType,
      distance: distance,
      adjustment: adjustment,
    );
  }
  
  /// 确定对齐类型
  static AlignmentType _determineAlignmentType(GuideLine source, GuideLine target) {
    if (source.isCenter && target.isCenter) {
      return AlignmentType.centerToCenter;
    } else if (source.isEdge && target.isEdge) {
      return AlignmentType.edgeToEdge;
    } else if (source.isCenter && target.isEdge) {
      return AlignmentType.centerToEdge;
    } else {
      return AlignmentType.edgeToCenter;
    }
  }
  
  /// 计算调整偏移量
  static Offset _calculateAdjustment(GuideLine source, GuideLine target) {
    final delta = target.position - source.position;
    
    if (source.orientation == GuideLineOrientation.horizontal) {
      return Offset(0, delta);
    } else {
      return Offset(delta, 0);
    }
  }
    /// 过滤最佳匹配（每个方向只保留最优匹配）
  static List<AlignmentMatch> _filterBestMatches(List<AlignmentMatch> allMatches) {

#### 4.2.4 最佳匹配过滤算法

`_filterBestMatches`方法实现了智能过滤策略，解决了多重对齐冲突的问题：

**过滤策略：**

1. **方向独立性**：水平和垂直方向的对齐是独立的，用户可以同时在两个方向上对齐
2. **单方向唯一性**：每个方向只保留一个最佳匹配，避免同一方向的多重对齐冲突
3. **距离优先原则**：由于输入的匹配列表已按距离排序，取第一个即为最近距离的匹配

**算法效果：**
- 最多返回2个匹配：一个水平方向，一个垂直方向
- 确保对齐结果的确定性和可预测性
- 避免了复杂的多重对齐导致的位置混乱

    final bestHorizontal = allMatches
        .where((m) => m.sourceLine.orientation == GuideLineOrientation.horizontal)
        .take(1);
    
    final bestVertical = allMatches
        .where((m) => m.sourceLine.orientation == GuideLineOrientation.vertical)
        .take(1);
    
    return [...bestHorizontal, ...bestVertical];
  }
}
```

### 4.3 拖拽过程中的实时检测

#### 4.3.1 实时检测算法原理

实时检测算法的核心挑战是在保证响应性的同时提供准确的对齐反馈。算法采用了**增量计算**和**临时状态**的设计模式：

**算法工作流程：**

1. **临时状态创建**：
   - 每次拖拽更新时，创建元素的临时副本
   - 临时副本反映元素在当前鼠标位置的状态
   - 避免修改原始元素数据，确保状态的纯净性

2. **增量检测**：
   - 只对拖拽元素进行对齐检测，其他元素保持静态
   - 减少了计算复杂度：O(n) 而不是 O(n²)
   - 每次只需要处理一个元素的6条参考线

3. **状态管理**：
   - 使用`ValueNotifier<List<AlignmentMatch>>`实现响应式状态更新
   - UI层可以监听状态变化，自动更新参考线显示
   - 确保UI与数据层的同步

**性能优化考虑：**

- **避免频繁GC**：复用临时对象，减少内存分配
- **计算缓存**：相同位置的检测结果可以缓存
- **阈值过滤**：早期过滤掉距离过远的匹配，减少后续计算

```dart
class DragAlignmentHandler {
  final List<Map<String, dynamic>> _allElements;
  final ValueNotifier<List<AlignmentMatch>> _activeAlignments;
  bool _isAlignmentEnabled;
  
  /// 处理拖拽更新
  void onDragUpdate(String elementId, Offset delta) {
    if (!_isAlignmentEnabled) return;
    
    // 找到被拖拽的元素
    final draggedElement = _findElement(elementId);
    if (draggedElement == null) return;
    
    // 创建临时位置的元素副本
    final tempElement = Map<String, dynamic>.from(draggedElement);
    tempElement['x'] = (tempElement['x'] as double) + delta.dx;
    tempElement['y'] = (tempElement['y'] as double) + delta.dy;
    
    // 检测对齐
    final otherElements = _allElements.where((e) => e['id'] != elementId).toList();
    final alignments = AlignmentDetector.detectAlignments(tempElement, otherElements);
    
    // 更新活跃对齐
    _activeAlignments.value = alignments;
  }
    /// 处理拖拽结束
  Offset onDragEnd(String elementId, Offset finalDelta) {

#### 4.3.2 拖拽结束对齐算法

`onDragEnd`方法实现了智能的位置调整策略，确保用户释放鼠标时元素能够精确对齐：

**调整策略：**

1. **累积调整**：将所有活跃对齐的调整量进行矢量叠加
2. **精确定位**：确保最终位置精确对齐到参考线
3. **状态清理**：处理完成后清除所有临时对齐状态

**数学原理：**
- 最终位置 = 原始拖拽位置 + 所有对齐调整的矢量和
- 支持同时在X和Y方向进行调整
- 保证调整后的位置在吸附阈值范围内

    final adjustedDelta = finalDelta;
    
    if (_isAlignmentEnabled && _activeAlignments.value.isNotEmpty) {
      // 应用对齐调整
      for (final alignment in _activeAlignments.value) {
        adjustedDelta += alignment.adjustment;
      }
    }
    
    // 清除活跃对齐
    _activeAlignments.value = [];
    
    return adjustedDelta;
  }
}
```

### 4.4 元素平移时的参考线对齐

#### 4.4.1 平移对齐触发机制

平移对齐是拖拽对齐的扩展，专门处理元素移动过程中的对齐反馈。其算法特点包括：

**实时反馈机制：**

1. **连续检测**：每次平移更新都触发对齐检测
2. **触觉反馈**：检测到对齐时提供触觉震动，增强用户体验
3. **视觉预览**：实时显示参考线，让用户预知对齐效果

**性能优化：**

- **增量计算**：只计算发生变化的元素
- **距离预过滤**：在进行详细计算前先进行距离筛选
- **频率控制**：限制检测频率，避免过度计算

```dart
class ElementTranslationAlignmentHandler {
  final List<Map<String, dynamic>> _allElements;
  final ValueNotifier<List<AlignmentMatch>> _activeAlignments;
  bool _isAlignmentEnabled;
  
  /// 处理元素平移过程中的实时对齐检测
  void onElementTranslate(String elementId, Offset delta) {
    if (!_isAlignmentEnabled) return;
    
    final draggedElement = _findElement(elementId);
    if (draggedElement == null) return;
    
    // 创建临时位置的元素副本（平移后的位置）
    final tempElement = Map<String, dynamic>.from(draggedElement);
    tempElement['x'] = (tempElement['x'] as double) + delta.dx;
    tempElement['y'] = (tempElement['y'] as double) + delta.dy;
    
    // 检测与其他元素的对齐关系
    final otherElements = _allElements.where((e) => e['id'] != elementId).toList();
    final alignments = AlignmentDetector.detectAlignments(tempElement, otherElements);
    
    // 更新活跃的参考线
    _activeAlignments.value = alignments;
    
    // 如果检测到对齐，提供触觉反馈
    if (alignments.isNotEmpty) {
      _provideTactileFeedback();
    }
  }
  
  /// 处理元素平移结束时的自动吸附
  Offset onElementTranslateEnd(String elementId, Offset finalDelta) {
    var adjustedDelta = finalDelta;
    
    if (_isAlignmentEnabled && _activeAlignments.value.isNotEmpty) {
      // 选择最佳对齐目标（优先级最高的）
      final bestAlignment = _selectBestAlignment(_activeAlignments.value);
      
      if (bestAlignment != null) {
        // 应用对齐调整
        adjustedDelta += bestAlignment.adjustment;
        
        // 记录对齐操作
        _logAlignmentAction(elementId, bestAlignment);
      }
    }
    
    // 清除活跃对齐状态
    _activeAlignments.value = [];
    
    return adjustedDelta;
  }
    /// 选择最佳对齐目标
  AlignmentMatch? _selectBestAlignment(List<AlignmentMatch> alignments) {

#### 4.4.2 最佳对齐选择算法

`_selectBestAlignment`方法实现了智能的对齐目标选择策略，解决了多重对齐候选的优先级问题：

**选择策略层次：**

1. **距离优先**：距离最近的对齐具有绝对优先权
   - 计算公式：distance = |position1 - position2|
   - 确保用户的拖拽意图得到最准确的响应

2. **类型优先**：当距离相同时，按对齐类型的视觉美感排序
   - 中线对中线（优先级1）：视觉上最和谐，最常用
   - 边线对边线（优先级2）：结构化对齐，常用于布局
   - 混合对齐（优先级3）：特殊场景使用

3. **确定性原则**：算法保证在相同输入下始终返回相同结果

**算法复杂度：**
- 时间复杂度：O(n log n)，主要消耗在排序阶段
- 空间复杂度：O(1)，原地排序，不创建额外数据结构

    if (alignments.isEmpty) return null;
    
    // 优先级排序：
    // 1. 距离最近的对齐
    // 2. 中线对中线优于边线对边线
    // 3. 同类型对齐优于混合对齐
    alignments.sort((a, b) {
      // 首先按距离排序
      final distanceComparison = a.distance.compareTo(b.distance);
      if (distanceComparison != 0) return distanceComparison;
      
      // 距离相同时，按对齐类型优先级排序
      final aPriority = _getAlignmentTypePriority(a.alignmentType);
      final bPriority = _getAlignmentTypePriority(b.alignmentType);
      return aPriority.compareTo(bPriority);
    });
    
    return alignments.first;
  }

#### 4.4.3 对齐类型优先级算法

`_getAlignmentTypePriority`方法定义了不同对齐类型的优先级权重，这个设计基于用户界面设计的最佳实践：

**优先级设计原理：**

1. **中线对中线（权重1）**：
   - 视觉平衡感最强，符合人类对称美学
   - 在界面设计中使用频率最高
   - 提供最稳定的视觉锚点

2. **边线对边线（权重2）**：
   - 适合创建整齐的边界对齐
   - 常用于表格、列表等结构化布局
   - 提供清晰的视觉边界

3. **混合对齐（权重3）**：
   - 用于特殊设计需求
   - 相对较少使用，优先级最低
   - 避免过度复杂的对齐关系

  /// 获取对齐类型的优先级
  int _getAlignmentTypePriority(AlignmentType type) {
    switch (type) {
      case AlignmentType.centerToCenter:
        return 1; // 最高优先级
      case AlignmentType.edgeToEdge:
        return 2;
      case AlignmentType.centerToEdge:
      case AlignmentType.edgeToCenter:
        return 3; // 最低优先级
    }
  }
  
  /// 提供触觉反馈
  void _provideTactileFeedback() {
    // 在移动设备上提供轻微震动反馈
    HapticFeedback.lightImpact();
  }
  
  /// 记录对齐操作（用于分析和调试）
  void _logAlignmentAction(String elementId, AlignmentMatch alignment) {
    AppLogger.debug(
      '元素自动对齐',
      tag: 'ElementAlignment',
      data: {
        'elementId': elementId,
        'alignmentType': alignment.alignmentType.toString(),
        'distance': alignment.distance,
        'adjustment': '${alignment.adjustment.dx}, ${alignment.adjustment.dy}',
      },
    );
  }
}
```

#### 4.4.2 平移对齐的视觉反馈

平移对齐的视觉反馈系统采用了多层次的信息传达策略，确保用户能够清晰理解当前的对齐状态。

##### 4.4.2.1 参考线渲染算法

`paintTranslationGuideLines`方法实现了智能的参考线渲染，其设计考虑了以下要素：

**渲染层次设计：**

1. **参考线主体**：使用虚线绘制，减少视觉干扰
2. **吸附指示器**：在关键交点绘制圆点，明确对齐位置
3. **方向箭头**：显示调整方向，帮助用户理解移动意图
4. **距离标注**：调试模式下显示精确距离信息

**性能优化策略：**

- **空检查**：活跃对齐为空时立即返回，避免无效绘制
- **批量绘制**：使用相同Paint对象绘制同类型元素
- **条件渲染**：调试信息只在需要时绘制

##### 4.4.2.2 虚线绘制算法

`_drawDashedLine`方法实现了高效的虚线绘制，避免了使用系统API可能带来的性能问题：

**算法特点：**

1. **数学精确性**：使用矢量计算确保线段的精确方向
2. **均匀分布**：虚线段和间隔的长度严格控制
3. **边界处理**：确保线段在画布边界处正确截断

**绘制参数：**

- 虚线段长度：8像素（视觉上清晰可见）
- 间隔长度：4像素（保持适当的虚线感）
- 这个比例（2:1）在各种分辨率下都有良好的视觉效果

##### 4.4.2.3 吸附指示器算法

吸附指示器的设计目标是在不干扰用户操作的前提下，清晰地指示对齐点的位置：

**位置计算策略：**

- **水平参考线**：指示器位于元素左边界，Y坐标为参考线位置
- **垂直参考线**：指示器位于元素上边界，X坐标为参考线位置
- **交点原则**：指示器总是位于参考线与元素边界的交点

**视觉设计**：

- **圆形指示器**：半径4像素，视觉突出但不过度
- **方向箭头**：长度20像素，清晰指示调整方向
- **颜色一致性**：与参考线使用相同色彩，保持视觉统一

```dart
class TranslationAlignmentRenderer {
  /// 绘制平移过程中的参考线
  static void paintTranslationGuideLines(
    Canvas canvas,
    Size canvasSize,
    List<AlignmentMatch> activeAlignments,
    String draggedElementId,
  ) {
    if (activeAlignments.isEmpty) return;
    
    final guideLinePaint = Paint()
      ..color = Colors.blue.withOpacity(0.8)
      ..strokeWidth = 1.0
      ..style = PaintingStyle.stroke;
    
    final snapIndicatorPaint = Paint()
      ..color = Colors.blue
      ..style = PaintingStyle.fill;
    
    for (final alignment in activeAlignments) {
      // 绘制参考线
      _drawGuideLine(canvas, canvasSize, alignment.targetLine, guideLinePaint);
      
      // 绘制吸附指示器
      _drawSnapIndicator(canvas, alignment, snapIndicatorPaint);
      
      // 绘制距离标注（调试模式下）
      if (AlignmentConfig.showDebugInfo) {
        _drawDistanceLabel(canvas, alignment);
      }
    }
  }
  
  /// 绘制参考线
  static void _drawGuideLine(
    Canvas canvas,
    Size canvasSize,
    GuideLine guideLine,
    Paint paint,
  ) {
    final startPoint = guideLine.orientation == GuideLineOrientation.horizontal
        ? Offset(0, guideLine.position)
        : Offset(guideLine.position, 0);
    
    final endPoint = guideLine.orientation == GuideLineOrientation.horizontal
        ? Offset(canvasSize.width, guideLine.position)
        : Offset(guideLine.position, canvasSize.height);
    
    // 绘制虚线参考线
    _drawDashedLine(canvas, startPoint, endPoint, paint);
  }
  
  /// 绘制虚线
  static void _drawDashedLine(Canvas canvas, Offset start, Offset end, Paint paint) {
    const dashWidth = 8.0;
    const dashSpace = 4.0;
    
    final direction = (end - start);
    final totalDistance = direction.distance;
    final normalizedDirection = direction / totalDistance;
    
    double currentDistance = 0.0;
    bool drawDash = true;
    
    while (currentDistance < totalDistance) {
      final segmentLength = drawDash ? dashWidth : dashSpace;
      final segmentEnd = (currentDistance + segmentLength).clamp(0.0, totalDistance);
      
      if (drawDash) {
        final segmentStart = start + normalizedDirection * currentDistance;
        final segmentEndPoint = start + normalizedDirection * segmentEnd;
        canvas.drawLine(segmentStart, segmentEndPoint, paint);
      }
      
      currentDistance = segmentEnd;
      drawDash = !drawDash;
    }
  }
  
  /// 绘制吸附指示器
  static void _drawSnapIndicator(Canvas canvas, AlignmentMatch alignment, Paint paint) {
    // 在参考线与被拖拽元素的交点处绘制指示器
    final indicatorPosition = _calculateSnapPosition(alignment);
    
    // 绘制小圆圈指示器
    canvas.drawCircle(indicatorPosition, 4.0, paint);
    
    // 绘制箭头指示方向
    _drawSnapArrow(canvas, alignment, paint);
  }
  
  /// 计算吸附位置
  static Offset _calculateSnapPosition(AlignmentMatch alignment) {
    final sourceLine = alignment.sourceLine;
    final targetLine = alignment.targetLine;
    
    if (sourceLine.orientation == GuideLineOrientation.horizontal) {
      // 水平参考线，在元素的左边界或中心点显示指示器
      final x = sourceLine.elementBounds.left;
      return Offset(x, targetLine.position);
    } else {
      // 垂直参考线，在元素的上边界或中心点显示指示器
      final y = sourceLine.elementBounds.top;
      return Offset(targetLine.position, y);
    }
  }
  
  /// 绘制吸附箭头
  static void _drawSnapArrow(Canvas canvas, AlignmentMatch alignment, Paint paint) {
    final adjustment = alignment.adjustment;
    if (adjustment.distance < 2.0) return; // 距离太小不显示箭头
    
    final snapPosition = _calculateSnapPosition(alignment);
    final arrowEnd = snapPosition + adjustment.normalized * 20.0;
    
    // 绘制箭头线
    canvas.drawLine(snapPosition, arrowEnd, paint);
    
    // 绘制箭头头部
    final arrowPaint = Paint()
      ..color = paint.color
      ..style = PaintingStyle.fill;
    
    _drawArrowHead(canvas, snapPosition, arrowEnd, arrowPaint);
  }
  
  /// 绘制箭头头部
  static void _drawArrowHead(Canvas canvas, Offset start, Offset end, Paint paint) {
    const arrowSize = 6.0;
    final direction = (end - start).normalized;
    final perpendicular = Offset(-direction.dy, direction.dx);
    
    final arrowPoint1 = end - direction * arrowSize + perpendicular * (arrowSize / 2);
    final arrowPoint2 = end - direction * arrowSize - perpendicular * (arrowSize / 2);
    
    final path = Path()
      ..moveTo(end.dx, end.dy)
      ..lineTo(arrowPoint1.dx, arrowPoint1.dy)
      ..lineTo(arrowPoint2.dx, arrowPoint2.dy)
      ..close();
    
    canvas.drawPath(path, paint);
  }
  
  /// 绘制距离标注（调试用）
  static void _drawDistanceLabel(Canvas canvas, AlignmentMatch alignment) {
    final distance = alignment.distance;
    final snapPosition = _calculateSnapPosition(alignment);
    
    final textPainter = TextPainter(
      text: TextSpan(
        text: '${distance.toStringAsFixed(1)}px',
        style: const TextStyle(
          color: Colors.red,
          fontSize: 10,
          fontWeight: FontWeight.bold,
        ),
      ),
      textDirection: TextDirection.ltr,
    );
    
    textPainter.layout();
    
    // 绘制背景
    final bgRect = Rect.fromCenter(
      center: snapPosition,
      width: textPainter.width + 4,
      height: textPainter.height + 2,
    );
    
    canvas.drawRect(
      bgRect,
      Paint()..color = Colors.white.withOpacity(0.8),
    );
    
    // 绘制文字
    textPainter.paint(
      canvas,
      snapPosition - Offset(textPainter.width / 2, textPainter.height / 2),
    );
  }
}
```

#### 4.4.3 集成到现有拖拽系统

平移对齐需要集成到现有的`SmartCanvasGestureHandler`和`DragStateManager`中：

```dart
class SmartCanvasGestureHandler {
  // ...existing code...
  
  late ElementTranslationAlignmentHandler _translationAlignmentHandler;
  
  void handlePanUpdate(DragUpdateDetails details) {
    // ...existing drag logic...
    
    // 处理元素平移时的参考线对齐
    if (_draggedElementId != null && _isElementDrag) {
      _translationAlignmentHandler.onElementTranslate(
        _draggedElementId!,
        details.delta,
      );
    }
    
    // ...rest of the method...
  }
  
  void handlePanEnd(DragEndDetails details) {
    if (_draggedElementId != null && _isElementDrag) {
      // 应用平移对齐调整
      final finalDelta = _translationAlignmentHandler.onElementTranslateEnd(
        _draggedElementId!,
        _accumulatedDelta,
      );
      
      // 使用调整后的位置更新元素
      _updateElementPosition(_draggedElementId!, finalDelta);
    }
    
    // ...rest of the method...
  }
}
```

## 5. Resize对齐算法

### 5.1 Resize参考线计算

#### 5.1.1 Resize对齐的特殊性

Resize对齐算法与平移对齐的最大区别在于**选择性检测**——并非所有参考线都参与对齐，而是根据用户操作的Resize手柄来决定哪些参考线是相关的。

**算法设计原理：**

1. **手柄关联性**：不同的Resize手柄对应不同的参考线组合
   - 角落手柄（如topLeft）：同时影响两个方向的边线
   - 边缘手柄（如top）：只影响单一方向的边线
   - 中心不变原则：Resize时元素中心线可能发生变化，需要重新计算

2. **增量计算策略**：
   - 基于新的边界矩形重新计算参考线
   - 只比较与当前操作相关的参考线
   - 避免无意义的对齐检测

3. **约束保持**：
   - 确保Resize后的尺寸合理（避免负值）
   - 保持元素的最小尺寸限制
   - 维护纵横比（如果需要）

#### 5.1.2 手柄参考线映射算法

`_getRelevantLines`方法实现了智能的参考线过滤，确保只检测与当前操作相关的对齐：

**映射策略：**

- **角落手柄**：涉及两条边线（如topLeft涉及top和left）
- **边缘手柄**：只涉及一条边线（如top只涉及top边线）
- **中心线排除**：Resize时中心线位置不稳定，通常不用于对齐

**性能优化：**
通过精确的参考线过滤，算法复杂度从O(6n)降低到O(1-2n)，显著提升了Resize操作的响应性。

```dart
class ResizeAlignmentHandler {
  /// 处理Resize操作的对齐
  static List<AlignmentMatch> detectResizeAlignments(
    Map<String, dynamic> element,
    Rect newBounds,
    List<Map<String, dynamic>> otherElements,
    ResizeHandle handle,
  ) {
    // 创建临时元素用于检测
    final tempElement = Map<String, dynamic>.from(element);
    tempElement['x'] = newBounds.left;
    tempElement['y'] = newBounds.top;
    tempElement['width'] = newBounds.width;
    tempElement['height'] = newBounds.height;
    
    // 根据Resize手柄类型，只检测相关的参考线
    final relevantLines = _getRelevantLines(tempElement, handle);
    final allMatches = <AlignmentMatch>[];
    
    for (final otherElement in otherElements) {
      if (otherElement['id'] == element['id']) continue;
      
      final targetLines = GuideLineGenerator.generateGuideLines(otherElement);
      
      for (final sourceLine in relevantLines) {
        for (final targetLine in targetLines) {
          if (sourceLine.orientation != targetLine.orientation) continue;
          
          final distance = (sourceLine.position - targetLine.position).abs();
          if (distance <= AlignmentConfig.snapDistance) {
            // ... 创建AlignmentMatch
          }
        }
      }
    }
    
    return allMatches;
  }
  
  /// 根据Resize手柄获取相关参考线
  static List<GuideLine> _getRelevantLines(
    Map<String, dynamic> element,
    ResizeHandle handle,
  ) {
    final allLines = GuideLineGenerator.generateGuideLines(element);
    
    switch (handle) {
      case ResizeHandle.topLeft:
        return allLines.where((line) => 
          line.type == GuideLineType.top || line.type == GuideLineType.left
        ).toList();
      case ResizeHandle.topRight:
        return allLines.where((line) => 
          line.type == GuideLineType.top || line.type == GuideLineType.right
        ).toList();
      case ResizeHandle.bottomLeft:
        return allLines.where((line) => 
          line.type == GuideLineType.bottom || line.type == GuideLineType.left
        ).toList();
      case ResizeHandle.bottomRight:
        return allLines.where((line) => 
          line.type == GuideLineType.bottom || line.type == GuideLineType.right
        ).toList();
      case ResizeHandle.top:
        return allLines.where((line) => line.type == GuideLineType.top).toList();
      case ResizeHandle.bottom:
        return allLines.where((line) => line.type == GuideLineType.bottom).toList();
      case ResizeHandle.left:
        return allLines.where((line) => line.type == GuideLineType.left).toList();
      case ResizeHandle.right:
        return allLines.where((line) => line.type == GuideLineType.right).toList();
      default:
        return [];
    }
  }
}
```

## 6. 渲染系统设计

### 6.1 Canvas渲染层级架构

根据项目中实际的`M3PracticeEditCanvas`和`LayerRenderManager`实现，参考线渲染在Canvas的分层架构中有明确的层级位置：

```text
┌─────────────────────────────────────┐
│        UI控件层 (最顶层)              │  ← 工具栏、属性面板等UI控件
├─────────────────────────────────────┤
│      uiOverlay (UI覆盖层)            │  ← 状态栏、缩放指示器等
├─────────────────────────────────────┤
│      interaction (交互层)            │  ← 选择框、控制点、参考线
├─────────────────────────────────────┤
│      dragPreview (拖拽预览层)         │  ← 元素拖拽时的预览效果
├─────────────────────────────────────┤
│      content (内容层)                │  ← 所有练习元素(文本、图片等)
├─────────────────────────────────────┤
│      staticBackground (静态背景层)   │  ← 网格、页面边框
└─────────────────────────────────────┘
```

**参考线在interaction层的特点：**

- 与选择框、控制点同级，确保交互一致性
- 位于内容层之上，确保参考线不被元素遮挡
- 位于拖拽预览层之下，不干扰拖拽操作的视觉反馈
- 使用`LayerConfig`进行性能优化和缓存管理
- 支持`LayerVisibility`控制显示状态

### 6.2 吸附距离机制详解

系统使用两种不同的吸附距离机制：

#### 6.2.1 基础吸附距离 (8像素)

**用途：** 参考线检测和显示的触发距离

```dart
class AlignmentConfig {
  static const double snapDistance = 8.0;  // 基础吸附距离
}

// 检测逻辑示例
bool isWithinSnapDistance(double elementPos, double guideLinePos) {
  return (elementPos - guideLinePos).abs() <= AlignmentConfig.snapDistance;
}
```

**工作原理：**

- 当拖拽元素的边界距离参考线8像素以内时，显示参考线
- 这是一个"感应区域"，用于提前提示用户可能的对齐位置
- 不会立即吸附，只是视觉提示

**示例场景：**

```text
元素边界: x = 100
参考线位置: x = 105
距离: 5像素 < 8像素 → 显示参考线提示
```

#### 6.2.2 精确对齐距离 (网格大小的一半)

**用途：** 鼠标释放时的自动吸附调整

```dart
class AlignmentConfig {
  static const double gridSize = 20.0;
  static const double preciseAlignDistance = gridSize / 2; // 10像素
}

// 自动对齐逻辑示例
void performAutoAlignment(DragEndEvent event) {
  final nearestGuideLine = findNearestGuideLine(event.position);
  final distance = calculateDistance(event.position, nearestGuideLine.position);
  
  if (distance <= AlignmentConfig.preciseAlignDistance) {
    // 执行自动对齐
    snapToGuideLine(nearestGuideLine);
  }
}
```

**工作原理：**

- 当鼠标释放时，检测元素是否在参考线10像素范围内
- 如果是，则自动调整元素位置使其精确对齐到参考线
- 这个距离基于网格大小，确保对齐后的位置符合网格规范

**两种距离的协同工作：**

```text
拖拽过程：
├─ 距离8像素内 → 显示参考线（视觉提示）
├─ 继续拖拽...
└─ 释放鼠标时距离10像素内 → 自动吸附对齐

时间线：
8px感应 ──→ 显示参考线 ──→ 10px吸附 ──→ 自动对齐
   ↑              ↑              ↑
提前提示        持续显示        精确定位
```

### 6.3 参考线渲染实现

```dart
class GuideLineRenderer {
  void renderGuideLine(Canvas canvas, GuideLine guideLine) {
    final paint = Paint()
      ..color = Colors.blue.withOpacity(0.6)  // 半透明蓝色
      ..strokeWidth = 1.0
      ..style = PaintingStyle.stroke;
    
    if (guideLine.orientation == GuideLineOrientation.horizontal) {
      // 绘制横向参考线
      canvas.drawLine(
        Offset(0, guideLine.position),
        Offset(canvasWidth, guideLine.position),
        paint,
      );
    } else {
      // 绘制纵向参考线
      canvas.drawLine(
        Offset(guideLine.position, 0),
        Offset(guideLine.position, canvasHeight),
        paint,
      );
    }
    
    // 绘制吸附点指示器
    _renderSnapIndicator(canvas, guideLine);
  }
  
  void _renderSnapIndicator(Canvas canvas, GuideLine guideLine) {
    final indicatorPaint = Paint()
      ..color = Colors.blue
      ..style = PaintingStyle.fill;
    
    // 在参考线与元素边界交点绘制小圆点
    canvas.drawCircle(
      _calculateIntersectionPoint(guideLine),
      3.0,
      indicatorPaint,
    );
  }
}
```

## 7. 工具栏集成

### 7.1 对齐开关控件

```dart
class AlignmentToggle extends StatelessWidget {
  final bool isEnabled;
  final ValueChanged<bool> onChanged;
  
  @override
  Widget build(BuildContext context) {
    return IconButton(
      icon: Icon(
        Icons.align_horizontal_center,
        color: isEnabled ? Colors.blue : Colors.grey,
      ),
      tooltip: isEnabled ? '关闭自动对齐' : '开启自动对齐',
      onPressed: () => onChanged(!isEnabled),
    );
  }
}
```

## 8. 性能优化策略

### 8.1 计算优化

#### 8.1.1 算法复杂度分析

**核心算法复杂度：**

1. **参考线生成**：O(1)
   - 每个元素固定生成6条参考线
   - 时间复杂度与元素数量无关
   - 空间复杂度：O(6) = O(1)

2. **对齐检测**：O(n)
   - n为画布上的元素数量
   - 拖拽元素的6条参考线 × 其他元素的6n条参考线
   - 实际复杂度：O(36n) = O(n)

3. **最佳匹配过滤**：O(m log m)
   - m为检测到的匹配数量，通常 m << n
   - 排序操作是主要开销
   - 实际影响较小，因为m值通常很小

**优化策略：**

- **距离计算缓存**：缓存元素间距离计算结果，避免重复计算
- **空间索引**：使用四叉树等空间索引结构加速查找，将复杂度降低到O(log n)
- **增量更新**：只对发生变化的元素重新计算参考线

### 8.2 渲染优化

#### 8.2.1 渲染性能优化策略

**渲染复杂度分析：**

1. **参考线渲染**：O(k)
   - k为活跃参考线数量，通常k ≤ 2（水平+垂直）
   - 虚线绘制复杂度：O(线段长度/虚线段长度)
   - 总体影响：几乎可忽略

2. **指示器渲染**：O(1)
   - 固定数量的圆形和箭头绘制
   - 与画布大小和元素数量无关

**优化技术：**

- **按需渲染**：只在拖拽过程中渲染参考线，避免静态状态下的无效绘制
- **LOD机制**：根据缩放级别调整参考线密度，远距离时减少绘制细节
- **缓存绘制**：缓存参考线的绘制路径，避免重复计算几何形状

### 8.3 内存优化

#### 8.3.1 内存使用策略

**内存消耗分析：**

1. **参考线对象**：每条参考线约100字节（估算）
2. **对齐匹配对象**：每个匹配约200字节（估算）
3. **临时对象**：拖拽过程中的临时元素副本

**优化措施：**

- **对象池**：复用AlignmentMatch和GuideLine对象
- **及时清理**：拖拽结束后立即清理临时状态
- **懒加载**：按需生成参考线，避免预计算

- **距离计算缓存**：缓存元素间距离计算结果
- **空间索引**：使用四叉树等空间索引结构加速查找
- **增量更新**：只对发生变化的元素重新计算参考线

### 8.2 渲染优化

- **按需渲染**：只在拖拽过程中渲染参考线
- **LOD机制**：根据缩放级别调整参考线密度
- **缓存绘制**：缓存参考线的绘制路径

## 9. 配置参数

```dart
class AlignmentSettings {
  static const double alignmentThreshold = 8.0;     // 统一对齐阈值
  static const double gridSize = 20.0;              // 网格大小
  static const int maxGuideLines = 10;             // 最大同时显示参考线数
  static const Duration animationDuration = Duration(milliseconds: 150);
  static const Color guideLineColor = Color(0xFF2196F3);
  static const double guideLineOpacity = 0.8;
  static const double guideLineWidth = 1.0;
}
```

## 10. 测试用例

### 10.1 基础对齐测试

#### 10.1.1 功能正确性测试

**测试目标：** 验证各种对齐场景下算法的正确性和精确度

**测试用例设计：**

1. **中线对中线对齐**：
   - 测试场景：两个矩形元素，拖拽其中一个使其中心线对齐
   - 验证指标：对齐后的中心坐标差值 < 1像素
   - 边界条件：不同尺寸的元素、重叠元素、边界元素

2. **边线对边线对齐**：
   - 测试场景：多个元素的左边线、右边线、上边线、下边线对齐
   - 验证指标：对齐后的边界坐标完全一致
   - 特殊情况：元素部分重叠时的对齐行为

3. **中线对边线对齐**：
   - 测试场景：一个元素的中心线对齐到另一个元素的边界
   - 验证指标：中心线坐标与目标边界坐标的差值 < 1像素
   - 复杂场景：多个候选对齐目标时的优先级选择

4. **多元素复杂对齐场景**：
   - 测试场景：3个以上元素的复杂对齐组合
   - 验证指标：选择最优对齐目标，避免冲突
   - 性能指标：复杂场景下的响应时间 < 16ms（60FPS）

**自动化测试框架：**

```dart
class AlignmentTestSuite {
  void testCenterToCenterAlignment() {
    // 设置测试环境
    final element1 = createElement(x: 100, y: 100, width: 50, height: 50);
    final element2 = createElement(x: 200, y: 150, width: 60, height: 40);
    
    // 执行对齐算法
    final matches = AlignmentDetector.detectAlignments(element1, [element2]);
    
    // 验证结果
    expect(matches.length, equals(1));
    expect(matches.first.alignmentType, equals(AlignmentType.centerToCenter));
    expect(matches.first.distance, lessThan(8.0));
  }
}
```

- 中线对中线对齐
- 边线对边线对齐
- 中线对边线对齐
- 多元素复杂对齐场景

### 10.2 性能测试

#### 10.2.1 性能基准测试

**测试目标：** 确保在各种负载条件下系统保持良好的响应性

**测试维度：**

1. **大量元素场景下的性能表现**：
   - 测试规模：10个、50个、100个、500个元素
   - 性能指标：对齐检测时间 < 16ms（保证60FPS）
   - 内存指标：内存增长呈线性关系，无内存泄漏

2. **实时拖拽的响应性测试**：
   - 测试场景：连续快速拖拽操作
   - 响应时间：从鼠标移动到参考线显示 < 8ms
   - 帧率稳定性：维持稳定的60FPS，无明显掉帧

3. **复杂几何计算性能**：
   - 测试场景：大尺寸画布、高精度坐标
   - 计算精度：浮点数计算误差 < 0.1像素
   - 数值稳定性：避免浮点溢出和精度丢失

**性能监控工具：**

```dart
class PerformanceProfiler {
  static void profileAlignmentDetection() {
    final stopwatch = Stopwatch()..start();
    
    // 执行对齐检测
    final result = AlignmentDetector.detectAlignments(element, elements);
    
    stopwatch.stop();
    final duration = stopwatch.elapsedMicroseconds;
    
    // 记录性能数据
    PerformanceLogger.log('AlignmentDetection', duration);
    
    // 验证性能阈值
    assert(duration < 16000, '对齐检测超时: ${duration}μs');
  }
}
```

- 大量元素场景下的性能表现
- 实时拖拽的响应性测试
- 内存使用情况监控

### 10.3 用户体验测试

#### 10.3.1 交互体验评估

**测试目标：** 验证功能的易用性和用户满意度

**测试方法：**

1. **对齐精度验证**：
   - 测试指标：用户完成对齐任务的成功率 > 95%
   - 精度要求：最终对齐误差 < 2像素（用户可接受范围）
   - 一致性验证：相同操作产生相同结果

2. **视觉反馈效果**：
   - 参考线可见性：在各种背景下都能清晰识别
   - 动画流畅度：参考线出现/消失动画自然流畅
   - 颜色对比度：符合WCAG无障碍标准

3. **操作流畅性评估**：
   - 学习曲线：新用户5分钟内掌握基本操作
   - 操作效率：相比手动对齐提升80%以上的效率
   - 错误恢复：误操作后能够快速恢复

**A/B测试设计：**

- 对照组：无自动对齐功能
- 实验组：启用参考线自动对齐
- 评估指标：任务完成时间、精确度、用户满意度

- 对齐精度验证
- 视觉反馈效果
- 操作流畅性评估

## 11. 实现阶段规划

### 阶段1：核心算法实现

1. 参考线生成算法
2. 对齐检测算法
3. 基础拖拽集成

### 阶段2：视觉反馈系统

1. 参考线渲染
2. 对齐指示器
3. 动画效果

### 阶段3：性能优化

1. 计算优化
2. 渲染优化
3. 内存管理

### 阶段4：工具栏集成

1. 开关控件
2. 设置面板
3. 用户偏好保存

这个设计提供了完整的参考线自动对齐功能架构，包括算法设计、性能优化和用户体验考虑。

## 算法设计总结

### 核心算法创新点

1. **统一吸附距离设计**：
   - 简化了用户理解成本，提升了体验一致性
   - 减少了配置复杂度，降低了实现难度

2. **增量检测策略**：
   - 只对拖拽元素进行实时检测，避免了O(n²)的复杂度
   - 临时状态管理确保了数据的纯净性

3. **智能优先级算法**：
   - 距离优先+类型优先的双重排序
   - 确保了对齐结果的确定性和美观性

4. **互斥模式管理**：
   - 彻底解决了网格对齐与参考线对齐的冲突
   - 状态机模式确保了系统的稳定性

### 算法性能特征

| 算法组件 | 时间复杂度 | 空间复杂度 | 实际性能 |
|----------|------------|------------|----------|
| 参考线生成 | O(1) | O(1) | < 1ms |
| 对齐检测 | O(n) | O(n) | < 8ms |
| 最佳匹配过滤 | O(m log m) | O(1) | < 2ms |
| 视觉渲染 | O(k) | O(1) | < 4ms |

*注：n=元素数量，m=匹配数量，k=活跃参考线数量*

### 设计原则体现

1. **用户体验优先**：算法设计始终以用户的直觉和预期为准
2. **性能与功能平衡**：在保证功能完整性的前提下优化性能
3. **可扩展性**：模块化设计便于未来功能扩展
4. **稳定性保障**：完整的错误处理和边界条件考虑

请审阅并提供反馈意见。

## 12. 网格对齐与参考线对齐的关系设计

### 12.1 冲突分析

网格对齐和参考线对齐存在以下潜在冲突：

**功能冲突：**

- **网格对齐**：将元素对齐到预定义的规则网格点
- **参考线对齐**：将元素对齐到其他元素的边界或中心线
- **冲突场景**：当两种对齐同时触发时，元素的最终位置不确定

**用户体验冲突：**

- 同时显示网格线和参考线造成视觉混乱
- 用户难以预测元素的最终对齐位置
- 不同对齐方式代表不同的设计意图

### 12.2 设计决策：互斥模式

#### 12.2.1 互斥模式算法设计

采用**互斥设计**是解决网格对齐和参考线对齐冲突的最优策略。该算法基于**状态机模式**，确保系统在任意时刻只处于一种对齐模式。

**状态转换算法：**

1. **状态清理阶段**：
   - 在切换到新模式前，必须完全清理前一模式的所有状态
   - 包括渲染缓存、事件监听器、临时数据等
   - 确保没有状态泄漏影响新模式的工作

2. **状态初始化阶段**：
   - 根据新模式类型进行相应的初始化
   - 网格模式：显示背景网格，初始化网格吸附计算器
   - 参考线模式：准备参考线检测器，清空之前的参考线缓存
   - 无对齐模式：停用所有对齐相关的计算和渲染

3. **原子性保证**：
   - 整个状态转换过程是原子的，不会出现中间状态
   - 使用锁机制防止并发状态修改
   - 确保用户界面的一致性

**算法优势：**

- **确定性**：任何时刻系统状态都是明确的
- **性能优化**：避免了多种对齐算法的并行计算
- **用户体验**：消除了模糊的对齐行为

采用**互斥设计**，用户只能选择一种对齐方式：

```dart
enum AlignmentMode {
  none,           // 无自动对齐
  grid,          // 网格对齐模式
  guideLine,     // 参考线对齐模式
}

class AlignmentModeManager {
  static AlignmentMode _currentMode = AlignmentMode.none;
  static final ValueNotifier<AlignmentMode> modeNotifier = 
      ValueNotifier(AlignmentMode.none);
  
  static AlignmentMode get currentMode => _currentMode;
  
  static void setMode(AlignmentMode mode) {
    if (_currentMode == mode) return;
    
    // 清理前一模式的状态
    _cleanupPreviousMode(_currentMode);
    
    // 设置新模式
    _currentMode = mode;
    modeNotifier.value = mode;
    
    // 初始化新模式
    _initializeMode(mode);
  }
  
  static void _cleanupPreviousMode(AlignmentMode mode) {
    switch (mode) {
      case AlignmentMode.grid:
        GridAlignmentRenderer.clearGridLines();
        break;
      case AlignmentMode.guideLine:
        GuideLineRenderer.clearGuideLines();
        break;
      case AlignmentMode.none:
        break;
    }
  }
  
  static void _initializeMode(AlignmentMode mode) {
    switch (mode) {
      case AlignmentMode.grid:
        GridAlignmentRenderer.showGridLines();
        break;
      case AlignmentMode.guideLine:
        // 参考线按需显示，不需要预初始化
        break;
      case AlignmentMode.none:
        break;
    }
  }
}
```

### 12.3 工具栏设计

```dart
class AlignmentModeSelector extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return ValueListenableBuilder<AlignmentMode>(
      valueListenable: AlignmentModeManager.modeNotifier,
      builder: (context, currentMode, child) {
        return SegmentedButton<AlignmentMode>(
          segments: [
            ButtonSegment(
              value: AlignmentMode.none,
              icon: Icon(Icons.grid_off),
              label: Text('自由'),
              tooltip: '无自动对齐，完全手动定位',
            ),
            ButtonSegment(
              value: AlignmentMode.grid,
              icon: Icon(Icons.grid_on),
              label: Text('网格'),
              tooltip: '对齐到网格点，适合规整布局',
            ),
            ButtonSegment(
              value: AlignmentMode.guideLine,
              icon: Icon(Icons.align_horizontal_center),
              label: Text('参考线'),
              tooltip: '对齐到其他元素，适合相对定位',
            ),
          ],
          selected: {currentMode},
          onSelectionChanged: (Set<AlignmentMode> selection) {
            AlignmentModeManager.setMode(selection.first);
          },
        );
      },
    );
  }
}
```

### 12.4 模式特性对比

| 特性 | 网格对齐 | 参考线对齐 | 无对齐 |
|------|----------|------------|--------|
| **适用场景** | 规整布局、表格式排列 | 自由布局、相对定位 | 完全自由设计 |
| **对齐目标** | 固定网格点 | 其他元素边界/中心 | 无 |
| **视觉反馈** | 背景网格线 | 临时参考线 | 无 |
| **精确度** | 网格间距精度 | 像素级精度 | 完全手动 |
| **性能影响** | 较低 | 中等 | 无 |

### 12.5 智能模式建议

#### 12.5.1 智能推荐算法

智能模式建议系统采用**启发式分析算法**，通过分析当前编辑上下文来推荐最适合的对齐模式。

**分析维度：**

1. **元素数量分析**：
   - 少量元素（<3个）：建议自由模式，避免过度约束
   - 中等数量（3-10个）：根据分布模式进一步分析
   - 大量元素（>10个）：倾向于推荐网格模式，便于管理

2. **分布模式识别**：
   - **规则网格检测**：使用统计算法检测元素是否呈网格分布
   - **对齐线检测**：分析是否存在明显的水平或垂直对齐模式
   - **随机分布检测**：检测元素分布的随机性程度

3. **用户行为分析**：
   - 历史操作模式：用户偏好的对齐方式
   - 编辑频率：频繁调整时建议更灵活的模式
   - 精确度需求：基于操作精细程度推荐合适模式

**算法实现策略：**

```text
决策树结构：
├─ 元素数量 < 3 → 自由模式
├─ 检测到规则网格分布 → 网格模式
├─ 检测到明显对齐线 → 参考线模式
└─ 其他情况 → 根据用户历史偏好决定
```

**机器学习集成**：

- 收集用户的模式选择数据
- 逐步学习用户的偏好模式
- 提高推荐准确度

系统可以根据当前编辑场景智能建议对齐模式：

```dart
class AlignmentModeSuggester {
  static AlignmentMode suggestMode(EditingContext context) {
    final elements = context.elements;
    final elementCount = elements.length;
    
    // 元素数量少时建议自由模式
    if (elementCount < 3) {
      return AlignmentMode.none;
    }
    
    // 分析元素分布模式
    final distribution = analyzeElementDistribution(elements);
    
    if (distribution.isRegularGrid) {
      // 规则网格分布，建议网格对齐
      return AlignmentMode.grid;
    } else if (distribution.hasAlignmentPatterns) {
      // 存在对齐模式，建议参考线对齐
      return AlignmentMode.guideLine;
    } else {
      // 分布较为自由，建议自由模式
      return AlignmentMode.none;
    }
  }
  
  static ElementDistribution analyzeElementDistribution(
    List<Map<String, dynamic>> elements,
  ) {
    // 分析元素分布特征
    // 检测是否存在规则网格、对齐线等模式
    // 具体实现...
  }
}
```

### 12.6 配置更新

更新配置类以支持模式切换：

```dart
class AlignmentConfig {
  // 基础配置
  static const double alignmentThreshold = 8.0;  // 统一对齐阈值
  static const Duration animationDuration = Duration(milliseconds: 150);
  
  // 网格对齐配置
  static const double gridSize = 20.0;
  
  // 参考线对齐配置  
  static const int maxSimultaneousGuideLines = 2; // 最多同时显示2条参考线
  
  // 根据当前模式获取相应的吸附距离
  static double get activeSnapDistance {
    switch (AlignmentModeManager.currentMode) {
      case AlignmentMode.grid:
        return alignmentThreshold; // 网格和参考线使用相同距离
      case AlignmentMode.guideLine:
        return alignmentThreshold;
      case AlignmentMode.none:
        return 0.0; // 无对齐
    }
  }
}
```

### 12.7 实现优势

**用户体验优势：**

- 清晰的模式选择，避免功能冲突
- 每种模式都有明确的使用场景和视觉反馈
- 智能建议帮助用户选择合适的模式

**技术优势：**

- 简化实现逻辑，避免复杂的优先级判断
- 更好的性能，每次只需计算一种对齐
- 代码结构清晰，易于维护和扩展

**设计优势：**

- 符合单一职责原则
- 减少用户的认知负担
- 为未来扩展其他对齐模式留出空间
