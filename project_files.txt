C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\main.dart
-----------------------------------
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:window_manager/window_manager.dart';

import 'infrastructure/logging/log_level.dart';
import 'infrastructure/logging/logger.dart';
import 'infrastructure/providers/shared_preferences_provider.dart';
import 'presentation/app.dart';
import 'utils/keyboard/keyboard_monitor.dart';
import 'utils/keyboard/keyboard_utils.dart';

void main() async {
  WidgetsFlutterBinding.ensureInitialized();

  // 鍒濆鍖栭敭鐩樺伐鍏?
  KeyboardUtils.initialize();

  // 鍒濆鍖栫獥鍙ｇ鐞嗗櫒
  await windowManager.ensureInitialized();

  WindowOptions windowOptions = const WindowOptions(
    size: Size(1280, 800),
    minimumSize: Size(800, 600),
    center: true,
    backgroundColor: Colors.transparent,
    skipTaskbar: false,
    titleBarStyle: TitleBarStyle.hidden,
  );

  // 璁剧疆绐楀彛
  await windowManager.waitUntilReadyToShow(windowOptions, () async {
    await windowManager.show();
    await windowManager.focus();
  });

  // 鍒濆鍖栨棩蹇楃郴缁燂紝鍚敤鎺у埗鍙拌緭鍑哄拰璋冭瘯绾у埆
  await AppLogger.init(enableConsole: true, minLevel: LogLevel.debug);
  try {
    // 鍒濆鍖?SharedPreferences
    final prefs = await SharedPreferences.getInstance();

    // 鍒涘缓ProviderContainer鐢ㄤ簬鍒濆鍖栭樁娈?
    final container = ProviderContainer(
      observers: [ProviderLogger()],
      overrides: [
        sharedPreferencesProvider.overrideWithValue(prefs),
      ],
    );

    // 鍚姩搴旂敤
    runApp(
      ProviderScope(
        parent: container,
        observers: kDebugMode ? [FilteredProviderObserver()] : null,
        child: KeyboardMonitor.wrapApp(const MyApp()),
      ),
    );
  } catch (e, stack) {
    // 纭繚鍦ㄥ垵濮嬪寲杩囩▼涓殑閿欒涔熻兘琚褰?
    if (AppLogger.hasHandlers) {
      AppLogger.fatal('搴旂敤鍚姩澶辫触', error: e, stackTrace: stack, tag: 'App');
    } else {
      // 濡傛灉鏃ュ織绯荤粺鏈垵濮嬪寲锛屼娇鐢ㄨ皟璇曟墦鍗?
      debugPrint('涓ラ噸閿欒锛氬簲鐢ㄥ惎鍔ㄥけ璐? $e');
      debugPrint('$stack');
    }

    // 鏄剧ず鍩烘湰鐨勯敊璇晫闈?
    runApp(
      MaterialApp(
        home: Scaffold(
          body: Center(
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                const Icon(Icons.error_outline, size: 48, color: Colors.red),
                const SizedBox(height: 16),
                Text(
                  '搴旂敤鍚姩澶辫触: $e',
                  style: const TextStyle(color: Colors.red),
                  textAlign: TextAlign.center,
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}

/// Custom provider observer that filters log messages
class FilteredProviderObserver extends ProviderObserver {
  // List of providers to ignore in logs
  static final _ignoredProviders = ['cursor', 'position', 'render', 'path'];

  @override
  void didUpdateProvider(
    ProviderBase provider,
    Object? previousValue,
    Object? newValue,
    ProviderContainer container,
  ) {
    // Skip logging for certain providers that update frequently
    final name = provider.name ?? '';
    if (_ignoredProviders.any((term) => name.contains(term))) {
      return; // Skip logging entirely
    }

    // For other providers, only log significant updates
    if (previousValue != newValue) {
      debugPrint('[Provider] ${provider.name}: updated');
    }
  }
}

/// Riverpod 鏃ュ織璁板綍鍣?
class ProviderLogger extends ProviderObserver {
  @override
  void didAddProvider(
    ProviderBase<dynamic> provider,
    Object? value,
    ProviderContainer container,
  ) {
    AppLogger.debug(
      'Provider $provider was initialized with $value',
      tag: 'Riverpod',
    );
  }

  @override
  void didDisposeProvider(
    ProviderBase<dynamic> provider,
    ProviderContainer container,
  ) {
    AppLogger.debug('Provider $provider was disposed', tag: 'Riverpod');
  }

  @override
  void didUpdateProvider(
    ProviderBase<dynamic> provider,
    Object? previousValue,
    Object? newValue,
    ProviderContainer container,
  ) {
    if (previousValue != newValue) {
      AppLogger.debug(
        'Provider $provider updated from $previousValue to $newValue',
        tag: 'Riverpod',
      );
    }
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\providers.dart
-----------------------------------
// Re-export providers
export 'application/providers/providers.dart';
export 'domain/repositories/repositories.dart';



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\application\commands\migration_commands.dart
-----------------------------------
import 'dart:convert';

import '../../domain/repositories/settings_repository.dart';
import '../../infrastructure/logging/logger.dart';

/// 杩佺Щ鍛戒护
class MigrationCommands {
  final SettingsRepository _settingsRepository;

  MigrationCommands(this._settingsRepository);

  /// 妫€鏌4杩佺Щ鐘舵€?
  Future<void> checkV4MigrationStatus() async {
    try {
      // 鑾峰彇杩佺Щ缁熻
      final stats = await _settingsRepository.getValue('migration_v4_stats');
      if (stats != null) {
        final data = json.decode(stats);
        AppLogger.info('杩佺ЩV4缁熻淇℃伅', tag: 'Migration', data: {
          '鎬诲浘鐗囨暟': data['total_images'],
          '鏇存柊鏁伴噺': data['updated_images'],
          '鏈夊師濮嬭矾寰?: data['with_original_path'],
          '鏃犲師濮嬭矾寰?: data['without_original_path'],
          '鎵ц鏃堕棿': data['timestamp'],
        });
      }

      // 鑾峰彇杩佺Щ瀹屾垚鐘舵€?
      final completion =
          await _settingsRepository.getValue('migration_v4_completion');
      if (completion != null) {
        final data = json.decode(completion);
        AppLogger.info('杩佺ЩV4瀹屾垚鐘舵€?, tag: 'Migration', data: {
          '杩佺Щ鍥剧墖鏁?: data['migrated_images'],
          '瀹屾垚鏃堕棿': data['timestamp'],
        });
      }

      if (stats == null && completion == null) {
        AppLogger.warning('鏈壘鍒癡4杩佺Щ璁板綍', tag: 'Migration');
      }
    } catch (e, stack) {
      AppLogger.error('妫€鏌ヨ縼绉荤姸鎬佸け璐?,
          tag: 'Migration', error: e, stackTrace: stack);
    }
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\application\config\app_config.dart
-----------------------------------
class AppConfig {
  // 搴旂敤鍚嶇О
  static String get appName => '涔︽硶闆嗗瓧';

  // 缂撳瓨鐩綍鍚?
  static String get cacheFolder => 'cache';

  // 鏁版嵁瀛樺偍璺緞
  static String get dataPath => 'data';

  // 鏁版嵁搴撴枃浠跺悕
  static String get dbFilename => 'works.db';

  // 鏈€澶ф枃浠跺ぇ灏忛檺鍒?(20MB)
  static int get maxImageSize => 20 * 1024 * 1024;

  static int get optimizedImageHeight => 1080;

  static int get optimizedImageQuality => 85;

  // 鍥剧墖浼樺寲璁剧疆
  static int get optimizedImageWidth => 1920;

  // 瀛樺偍鐩綍鍚?
  static String get storageFolder => 'storage';
  // 涓存椂鏂囦欢鐩綍鍚?
  static String get tempFolder => 'temp';
  static int get thumbnailQuality => 85;

  // 缂╃暐鍥剧洰褰曞悕
  static String get thumbnailsFolder => 'thumbnails';
  // 缂╃暐鍥捐缃?
  static int get thumbnailSize => 256;

  // 浣滃搧瀛樺偍鐩綍鍚?
  static String get worksFolder => 'works';
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\application\providers\image_providers.dart
-----------------------------------
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../infrastructure/image/default_image_processor.dart';
import '../services/character/character_service.dart';
import '../services/image/character_image_processor.dart';
import '../services/storage/cache_manager.dart';

/// 搴曞眰鍥惧儚澶勭悊鍣≒rovider
final baseImageProcessorProvider = Provider<DefaultImageProcessor>((ref) {
  return DefaultImageProcessor();
});

/// 缂撳瓨绠＄悊鍣≒rovider
final cacheManagerProvider = Provider<CacheManager>((ref) {
  return CacheManager();
});

/// 瀛楃鍥惧儚澶勭悊鍣≒rovider
final characterImageProcessorProvider =
    Provider<CharacterImageProcessor>((ref) {
  final processor = ref.watch(baseImageProcessorProvider);
  final cacheManager = ref.watch(cacheManagerProvider);
  return CharacterImageProcessor(processor, cacheManager);
});

/// 瀛楃鏈嶅姟Provider
final characterProvider = Provider<CharacterService>((ref) {
  return ref.watch(characterServiceProvider);
});



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\application\providers\initialization_providers.dart
-----------------------------------
import 'package:demo/infrastructure/providers/database_providers.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../infrastructure/providers/storage_providers.dart';

/// 搴旂敤鍒濆鍖朠rovider
final appInitializationProvider = FutureProvider<void>((ref) async {
  // 绛夊緟瀛樺偍鏈嶅姟鍒濆鍖栧畬鎴?
  await ref.watch(storageProvider.future);
  await ref.watch(databaseProvider.future);
});



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\application\providers\providers.dart
-----------------------------------
export 'initialization_providers.dart';
export 'repository_providers.dart';
export 'service_providers.dart';
export 'settings_providers.dart';



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\application\providers\repository_providers.dart
-----------------------------------
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../domain/repositories/character_repository.dart';
import '../../domain/repositories/practice_repository.dart';
import '../../domain/repositories/work_image_repository.dart';
import '../../domain/repositories/work_repository.dart';
import '../../infrastructure/persistence/database_interface.dart';
import '../../infrastructure/providers/database_providers.dart';
import '../repositories/character_repository_impl.dart';
import '../repositories/practice_repository_impl.dart';
import '../repositories/work_image_repository_impl.dart';
import '../repositories/work_repository_impl.dart';

/// Character Repository Provider
final characterRepositoryProvider = Provider<CharacterRepository>((ref) {
  return CharacterRepositoryImpl(_getInitializedDatabase(ref));
});

/// Practice Repository Provider
final practiceRepositoryProvider = Provider<PracticeRepository>((ref) {
  return PracticeRepositoryImpl(_getInitializedDatabase(ref));
});

/// WorkImageRepository Provider
final workImageRepositoryProvider = Provider<WorkImageRepository>((ref) {
  return WorkImageRepositoryImpl(_getInitializedDatabase(ref));
});

/// Work Repository Provider
final workRepositoryProvider = Provider<WorkRepository>((ref) {
  return WorkRepositoryImpl(_getInitializedDatabase(ref));
});

/// 鎻愪緵鍒濆鍖栧畬鎴愮殑鏁版嵁搴撳疄渚?
DatabaseInterface _getInitializedDatabase(Ref ref) {
  return ref.watch(initializedDatabaseProvider);
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\application\providers\service_providers.dart
-----------------------------------
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:path/path.dart' as path;

import '../../infrastructure/image/image_processor.dart';
import '../../infrastructure/image/image_processor_impl.dart';
import '../../infrastructure/providers/shared_preferences_provider.dart';
import '../../infrastructure/providers/storage_providers.dart';
import '../services/restoration/state_restoration_service.dart';
import '../services/storage/work_storage_service.dart';
import '../services/work/work_image_service.dart';
import '../services/work/work_service.dart';
import 'repository_providers.dart';

/// Image Processor Provider
final imageProcessorProvider = Provider<ImageProcessor>((ref) {
  final storage = ref.watch(initializedStorageProvider);
  return ImageProcessorImpl(
      cachePath: path.join(storage.getAppDataPath(), 'cache'));
});

final stateRestorationServiceProvider = Provider<StateRestorationService>(
  (ref) => StateRestorationService(ref.watch(sharedPreferencesProvider)),
);

/// Work Image Service Provider
final workImageServiceProvider = Provider<WorkImageService>((ref) {
  return WorkImageService(
    storage: ref.watch(workStorageProvider),
    processor: ref.watch(imageProcessorProvider),
    repository: ref.watch(workImageRepositoryProvider),
  );
});

/// Work Service Provider
final workServiceProvider = Provider<WorkService>((ref) {
  return WorkService(
    repository: ref.watch(workRepositoryProvider),
    imageService: ref.watch(workImageServiceProvider),
    storage: ref.watch(initializedStorageProvider),
    workImageRepository: ref.watch(workImageRepositoryProvider),
  );
});

/// Work Storage Service Provider
final workStorageProvider = Provider<WorkStorageService>((ref) {
  final storage = ref.watch(initializedStorageProvider);
  return WorkStorageService(storage: storage);
});



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\application\providers\settings_providers.dart
-----------------------------------
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:shared_preferences/shared_preferences.dart';

import '../../domain/repositories/settings_repository.dart';
import '../../infrastructure/providers/database_providers.dart';
import '../commands/migration_commands.dart';
import '../repositories/settings_repository_impl.dart';

final languageProvider =
    StateNotifierProvider<LanguageNotifier, Locale?>((ref) {
  return LanguageNotifier();
});

/// Migration Commands Provider
final migrationCommandsProvider =
    Provider.autoDispose<AsyncValue<MigrationCommands>>((ref) {
  final settingsRepoAsync = ref.watch(settingsRepositoryProvider);
  return settingsRepoAsync.when(
    loading: () => const AsyncLoading(),
    error: (err, stack) => AsyncError(err, stack),
    data: (repo) => AsyncData(MigrationCommands(repo)),
  );
});

/// Settings Repository Provider
final settingsRepositoryProvider =
    Provider.autoDispose<AsyncValue<SettingsRepository>>((ref) {
  final dbAsync = ref.watch(databaseProvider);
  return dbAsync.when(
    loading: () => const AsyncLoading(),
    error: (err, stack) => AsyncError(err, stack),
    data: (db) => AsyncData(SettingsRepositoryImpl(db)),
  );
});

class LanguageNotifier extends StateNotifier<Locale?> {
  LanguageNotifier() : super(null) {
    _loadSavedLanguage();
  }

  Future<void> setLanguage(String? languageCode) async {
    final prefs = await SharedPreferences.getInstance();
    if (languageCode == null) {
      await prefs.remove('languageCode');
      state = null;
    } else {
      await prefs.setString('languageCode', languageCode);
      state = Locale(languageCode);
    }
  }

  Future<void> _loadSavedLanguage() async {
    final prefs = await SharedPreferences.getInstance();
    final languageCode = prefs.getString('languageCode');
    if (languageCode != null) {
      state = Locale(languageCode);
    }
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\application\repositories\character_repository_impl.dart
-----------------------------------
import 'dart:convert';

import '../../domain/models/character/character_entity.dart';
import '../../domain/models/character/character_region.dart';
import '../../domain/repositories/character_repository.dart';
import '../../infrastructure/logging/logger.dart';
import '../../infrastructure/persistence/database_interface.dart';
import '../../infrastructure/persistence/models/database_query.dart';

/// 瀛楃浠撳簱瀹炵幇
class CharacterRepositoryImpl implements CharacterRepository {
  static const String _table = 'characters';
  final DatabaseInterface _db;

  CharacterRepositoryImpl(this._db);

  @override
  Future<int> count(CharacterFilter? filter) async {
    try {
      final query = _buildFilterQuery(filter).toJson();
      final result = await _db.count(_table, query);
      return result;
    } catch (e) {
      AppLogger.error('Failed to count characters',
          tag: 'CharacterRepository', error: e);
      rethrow;
    }
  }

  @override
  Future<CharacterEntity> create(CharacterEntity character) async {
    await _db.set(_table, character.id, _toDbMap(character));
    return character;
  }

  @override
  Future<void> delete(String id) async {
    await _db.delete(_table, id);
  }

  @override
  Future<void> deleteBatch(List<String> ids) => deleteMany(ids);

  @override
  Future<void> deleteMany(List<String> ids) async {
    await _db.deleteMany(_table, ids);
  }

  @override
  Future<CharacterEntity?> findById(String id) => get(id);

  @override
  Future<List<CharacterEntity>> findByWorkId(String workId) =>
      getByWorkId(workId);

  @override
  Future<CharacterEntity?> get(String id) async {
    final data = await _db.get(_table, id);
    if (data == null) return null;
    return _fromDbMap(data);
  }

  @override
  Future<List<CharacterEntity>> getAll() async {
    final data = await _db.getAll(_table);
    return data.map((e) => _fromDbMap(e)).toList();
  }

  @override
  Future<List<CharacterEntity>> getByWorkId(String workId) async {
    final query = DatabaseQuery(conditions: [
      DatabaseQueryCondition(field: 'workId', operator: '=', value: workId)
    ]);
    final results = await _db.query(_table, query.toJson());
    return results.map((map) => _fromDbMap(map)).toList();
  }

  @override
  Future<List<CharacterRegion>> getRegionsByPageId(String pageId) async {
    try {
      final query = DatabaseQuery(conditions: [
        DatabaseQueryCondition(field: 'pageId', operator: '=', value: pageId)
      ]);
      final results = await _db.query(_table, query.toJson());

      return results.map((map) => _fromDbMap(map).region).toList();
    } catch (e) {
      AppLogger.error('Failed to get regions by page id',
          tag: 'CharacterRepository', error: e, data: {'pageId': pageId});
      rethrow;
    }
  }

  @override
  Future<List<CharacterRegion>> getRegionsByWorkId(String workId) async {
    try {
      final query = DatabaseQuery(conditions: [
        DatabaseQueryCondition(field: 'workId', operator: '=', value: workId)
      ]);
      final results = await _db.query(_table, query.toJson());

      return results.map((map) => _fromDbMap(map).region).toList();
    } catch (e) {
      AppLogger.error('Failed to get regions by work id',
          tag: 'CharacterRepository', error: e, data: {'workId': workId});
      rethrow;
    }
  }

  @override
  Future<List<CharacterEntity>> query(CharacterFilter filter) async {
    try {
      final query = _buildFilterQuery(filter);

      final results = await _db.query(_table, query.toJson());
      return results.map((map) => _fromDbMap(map)).toList();
    } catch (e) {
      AppLogger.error('Failed to query characters',
          tag: 'CharacterRepository', error: e);
      rethrow;
    }
  }

  @override
  Future<CharacterEntity> save(CharacterEntity character) async {
    final now = DateTime.now();
    final updated = character.copyWith(updateTime: now);
    await _db.save(_table, updated.id, _toDbMap(updated));
    return updated;
  }

  @override
  Future<List<CharacterEntity>> saveMany(
      List<CharacterEntity> characters) async {
    final now = DateTime.now();
    final updates = {
      for (final character in characters)
        character.id: _toDbMap(character.copyWith(updateTime: now))
    };

    await _db.saveMany(_table, updates);
    return characters.map((c) => c.copyWith(updateTime: now)).toList();
  }

  @override
  Future<List<CharacterEntity>> search(String query, {int? limit}) async {
    // 鍙傛暟楠岃瘉
    if (query.trim().isEmpty) return [];
    if (limit != null && limit <= 0) {
      throw ArgumentError('Limit must be a positive number');
    }

    try {
      // 鏋勫缓鎼滅储鏌ヨ
      final searchQuery = DatabaseQuery(conditions: [
        DatabaseQueryCondition(
            field: 'character', operator: 'LIKE', value: '%${query.trim()}%')
      ], limit: limit, orderBy: 'character ASC');

      // 鎵ц浼樺寲鍚庣殑鏌ヨ
      final results = await _db.query(_table, searchQuery.toJson());

      // 杞崲缁撴灉
      return results.map((map) => _fromDbMap(map)).toList();
    } catch (e) {
      AppLogger.error('Failed to search characters',
          tag: 'CharacterRepository',
          error: e,
          data: {
            'query': query,
            'limit': limit,
          });
      rethrow;
    }
  }

  @override
  Future<void> updateRegion(CharacterRegion region) async {
    try {
      final character = await findById(region.id);
      if (character == null) {
        throw Exception('Character not found: ${region.id}');
      }

      final updated = character.copyWith(
        region: region,
        updateTime: DateTime.now(),
      );

      await save(updated);
    } catch (e) {
      AppLogger.error('Failed to update region',
          tag: 'CharacterRepository', error: e, data: {'id': region.id});
      rethrow;
    }
  }

  // Helper methods
  DatabaseQuery _buildFilterQuery(CharacterFilter? filter) {
    final conditions = <DatabaseQueryCondition>[];

    if (filter == null) {
      return const DatabaseQuery();
    }

    // 宸ヤ綔ID杩囨护
    if (filter.workId != null) {
      conditions.add(DatabaseQueryCondition(
        field: 'workId',
        operator: '=',
        value: filter.workId,
      ));
    }

    // 椤甸潰ID杩囨护
    if (filter.pageId != null) {
      conditions.add(DatabaseQueryCondition(
        field: 'pageId',
        operator: '=',
        value: filter.pageId,
      ));
    }

    // 鏂囨湰鎼滅储杩囨护
    if (filter.searchText != null && filter.searchText!.isNotEmpty) {
      conditions.add(DatabaseQueryCondition(
        field: 'character',
        operator: 'LIKE',
        value: '%${filter.searchText}%',
      ));
    }

    // 鏀惰棌鐘舵€佽繃婊?
    if (filter.isFavorite != null) {
      conditions.add(DatabaseQueryCondition(
        field: 'isFavorite',
        operator: '=',
        value: filter.isFavorite! ? 1 : 0,
      ));
    }

    // 鏍囩杩囨护
    if (filter.tags != null && filter.tags!.isNotEmpty) {
      final tagConditions = filter.tags!.map((tag) {
        return DatabaseQueryCondition(
          field: 'tags',
          operator: 'LIKE',
          value: '%$tag%',
        );
      }).toList();

      if (tagConditions.length == 1) {
        conditions.add(tagConditions.first);
      } else if (tagConditions.isNotEmpty) {
        conditions.add(DatabaseQueryCondition(
          field: 'tags',
          operator: 'ALL',
          value: filter.tags,
        ));
      }
    }

    // 鏃堕棿鑼冨洿杩囨护
    if (filter.fromDate != null) {
      conditions.add(DatabaseQueryCondition(
        field: 'createTime',
        operator: '>=',
        value: filter.fromDate!.toIso8601String(),
      ));
    }

    if (filter.toDate != null) {
      conditions.add(DatabaseQueryCondition(
        field: 'createTime',
        operator: '<=',
        value: filter.toDate!.toIso8601String(),
      ));
    }

    // 鏋勫缓鎺掑簭瀛愬彞
    String? orderBy;
    if (filter.sortBy != null) {
      final field = _getSortField(filter.sortBy!);
      final direction =
          filter.sortDirection == SortDirection.descending ? 'DESC' : 'ASC';
      orderBy = '$field $direction';
    }

    // 鏋勫缓鏈€缁堟煡璇?
    return DatabaseQuery(
      conditions: conditions,
      orderBy: orderBy,
      limit: filter.limit,
      offset: filter.offset,
    );
  }

  CharacterEntity _fromDbMap(Map<String, dynamic> map) {
    // Parse region field
    final regionJson = jsonDecode(map['region'] as String);
    final region = CharacterRegion.fromJson(regionJson).copyWith(
      characterId: map['id'] as String,
    );

    // Parse tags field
    final tagsJson = map['tags'] as String?;
    final tags = tagsJson != null && tagsJson.isNotEmpty
        ? (jsonDecode(tagsJson) as List<dynamic>).cast<String>()
        : <String>[];

    return CharacterEntity(
      id: map['id'] as String,
      workId: map['workId'] as String,
      pageId: map['pageId'] as String,
      character: map['character'] as String,
      region: region,
      createTime: DateTime.parse(map['createTime'] as String),
      updateTime: DateTime.parse(map['updateTime'] as String),
      isFavorite: (map['isFavorite'] as int) == 1,
      tags: tags,
      note: map['note'] as String?,
    );
  }

  String _getSortField(SortField field) {
    switch (field) {
      case SortField.character:
        return 'character';
      case SortField.createTime:
        return 'createTime';
      case SortField.updateTime:
        return 'updateTime';
    }
  }

  Map<String, dynamic> _toDbMap(CharacterEntity entity) {
    return {
      'id': entity.id,
      'workId': entity.workId,
      'pageId': entity.pageId,
      'character': entity.character,
      'region': jsonEncode(entity.region.toJson()),
      'createTime': entity.createTime.toIso8601String(),
      'updateTime': entity.updateTime.toIso8601String(),
      'isFavorite': entity.isFavorite ? 1 : 0,
      'tags': entity.tags.join(','),
      'note': entity.note,
    };
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\application\repositories\practice_repository_impl.dart
-----------------------------------
import '../../domain/models/practice/practice_entity.dart';
import '../../domain/models/practice/practice_filter.dart';
import '../../domain/repositories/practice_repository.dart';
import '../../infrastructure/persistence/database_interface.dart';
import '../../utils/date_time_helper.dart';

/// 瀛楀笘缁冧範浠撳簱瀹炵幇
class PracticeRepositoryImpl implements PracticeRepository {
  static const _table = 'practices';
  final DatabaseInterface _db;

  PracticeRepositoryImpl(this._db);

  @override
  Future<void> close() => _db.close();

  @override
  Future<int> count(PracticeFilter? filter) async {
    if (filter == null) {
      return _db.count(_table);
    }
    final query = _buildQuery(filter);
    return _db.count(_table, query);
  }

  @override
  Future<PracticeEntity> create(PracticeEntity practice) async {
    await _db.save(_table, practice.id, practice.toJson());
    return practice;
  }

  @override
  Future<void> delete(String id) => _db.delete(_table, id);

  @override
  Future<void> deleteMany(List<String> ids) => _db.deleteMany(_table, ids);

  @override
  Future<PracticeEntity> duplicate(String id, {String? newId}) async {
    final practice = await get(id);
    if (practice == null) {
      throw ArgumentError('缁冧範涓嶅瓨鍦?);
    }

    final now = DateTime.now();
    final copy = practice.copyWith(
      id: newId ?? DateTime.now().millisecondsSinceEpoch.toString(),
      title: '${practice.title} (鍓湰)',
      createTime: now,
      updateTime: now,
    );

    await create(copy);
    return copy;
  }

  @override
  Future<PracticeEntity?> get(String id) async {
    final data = await _db.get(_table, id);
    if (data == null) return null;
    return PracticeEntity.fromJson(data);
  }

  @override
  Future<List<PracticeEntity>> getAll() async {
    final list = await _db.getAll(_table);
    return list.map((e) => PracticeEntity.fromJson(e)).toList();
  }

  @override
  Future<Set<String>> getAllTags() async {
    final list = await _db.getAll(_table);
    final tags = <String>{};
    for (final item in list) {
      final practice = PracticeEntity.fromJson(item);
      tags.addAll(practice.tags);
    }
    return tags;
  }

  @override
  Future<List<PracticeEntity>> getByTags(Set<String> tags) async {
    if (tags.isEmpty) return [];

    final filter = PracticeFilter(tags: tags.toList());
    return query(filter);
  }

  @override
  Future<List<PracticeEntity>> query(PracticeFilter filter) async {
    final query = _buildQuery(filter);
    final list = await _db.query(_table, query);
    return list.map((e) => PracticeEntity.fromJson(e)).toList();
  }

  @override
  Future<PracticeEntity> save(PracticeEntity practice) async {
    await _db.save(_table, practice.id, practice.toJson());
    return practice;
  }

  @override
  Future<List<PracticeEntity>> saveMany(List<PracticeEntity> practices) async {
    final map = {
      for (var p in practices) p.id: p.toJson(),
    };
    await _db.saveMany(_table, map);
    return practices;
  }

  @override
  Future<List<PracticeEntity>> search(String query, {int? limit}) async {
    final filter = PracticeFilter(
      keyword: query,
      limit: limit ?? 20,
    );
    return this.query(filter);
  }

  @override
  Future<List<String>> suggestTags(String prefix, {int limit = 10}) async {
    final allTags = await getAllTags();
    return allTags
        .where((tag) => tag.toLowerCase().startsWith(prefix.toLowerCase()))
        .take(limit)
        .toList();
  }

  /// 鏋勫缓鏌ヨ鏉′欢
  Map<String, dynamic> _buildQuery(PracticeFilter filter) {
    final query = <String, dynamic>{};

    if (filter.keyword?.isNotEmpty == true) {
      query['title'] = {'contains': filter.keyword};
    }

    if (filter.tags.isNotEmpty) {
      query['tags'] = {'contains': filter.tags};
    }

    if (filter.status?.isNotEmpty == true) {
      query['status'] = filter.status;
    }

    if (filter.startTime != null) {
      query['create_time'] = {
        'gte': DateTimeHelper.toStorageFormat(filter.startTime!),
      };
    }

    if (filter.endTime != null) {
      query['create_time'] ??= {};
      query['create_time']['lte'] =
          DateTimeHelper.toStorageFormat(filter.endTime!);
    }

    query['sort'] = {
      filter.sortField: filter.sortOrder,
    };

    query['limit'] = filter.limit;
    query['offset'] = filter.offset;

    return query;
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\application\repositories\repositories.dart
-----------------------------------
export 'character_repository_impl.dart';
export 'practice_repository_impl.dart';
export 'settings_repository_impl.dart';
export 'work_image_repository_impl.dart';
export 'work_repository_impl.dart';



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\application\repositories\settings_repository_impl.dart
-----------------------------------
import '../../domain/repositories/settings_repository.dart';
import '../../infrastructure/persistence/database_interface.dart';
import '../../utils/date_time_helper.dart';

class SettingsRepositoryImpl implements SettingsRepository {
  final DatabaseInterface _db;
  final String _table = 'settings';

  SettingsRepositoryImpl(this._db);

  @override
  Future<void> deleteValue(String key) async {
    await _db.rawDelete(
      'DELETE FROM $_table WHERE key = ?',
      [key],
    );
  }

  @override
  Future<String?> getValue(String key) async {
    final results = await _db.rawQuery(
      'SELECT value FROM $_table WHERE key = ? LIMIT 1',
      [key],
    );
    return results.isEmpty ? null : results.first['value'] as String?;
  }

  @override
  Future<Map<String, String>> getValues(List<String> keys) async {
    final results = <String, String>{};
    final placeholders = List.filled(keys.length, '?').join(',');

    final rows = await _db.rawQuery(
      'SELECT key, value FROM $_table WHERE key IN ($placeholders)',
      keys,
    );

    for (final row in rows) {
      results[row['key'] as String] = row['value'] as String;
    }

    return results;
  }

  @override
  Future<void> setValue(String key, String value) async {
    final updateTime = DateTimeHelper.toStorageFormat(DateTime.now());
    await _db.rawUpdate(
      'INSERT OR REPLACE INTO $_table (key, value, updateTime) VALUES (?, ?, ?)',
      [key, value, updateTime],
    );
  }

  @override
  Future<void> setValues(Map<String, String> values) async {
    final now = DateTimeHelper.toStorageFormat(DateTime.now());
    final batch = values.entries.map((entry) => _db.rawUpdate(
          'INSERT OR REPLACE INTO $_table (key, value, updateTime) VALUES (?, ?, ?)',
          [entry.key, entry.value, now],
        ));
    await Future.wait(batch);
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\application\repositories\work_image_repository_impl.dart
-----------------------------------
import 'package:demo/domain/models/work/work_image.dart';
import 'package:demo/domain/repositories/work_image_repository.dart';
import 'package:demo/infrastructure/logging/logger.dart';
import 'package:demo/infrastructure/persistence/database_interface.dart';
import 'package:demo/utils/date_time_helper.dart';

class WorkImageRepositoryImpl implements WorkImageRepository {
  final DatabaseInterface _db;

  WorkImageRepositoryImpl(this._db);

  @override
  Future<WorkImage> create(String workId, WorkImage image) async {
    // 妫€鏌ユ槸鍚﹀凡瀛樺湪鐩稿悓璺緞鐨勫浘鐗?
    final existing = await _db.query('work_images', {
      'where': [
        {'field': 'workId', 'op': '=', 'val': workId},
        {'field': 'original_path', 'op': '=', 'val': image.originalPath},
      ],
      'limit': 1,
    });

    AppLogger.info('妫€鏌ュ浘鐗囨槸鍚﹀凡瀛樺湪', tag: 'WorkImageRepository', data: {
      'workId': workId,
      'originalPath': image.originalPath,
      'exists': existing.isNotEmpty,
      'createTime': DateTimeHelper.toStorageFormat(image.createTime),
      'updateTime': DateTimeHelper.toStorageFormat(image.updateTime),
    });

    if (existing.isNotEmpty) {
      AppLogger.info('宸插瓨鍦ㄥ浘鐗囩殑鏃堕棿淇℃伅', tag: 'WorkImageRepository', data: {
        'existingCreateTime': existing.first['createTime'],
        'existingUpdateTime': existing.first['updateTime'],
      });
      return _mapToWorkImage(existing.first);
    }

    // 鍒涘缓鏂拌褰?
    final row = _mapToRow(image, workId);
    AppLogger.debug('鍑嗗淇濆瓨鏂板浘鐗?, tag: 'WorkImageRepository', data: {
      'row': row,
    });

    await _db.set('work_images', image.id, row);
    return image;
  }

  @override
  Future<List<WorkImage>> createMany(
      String workId, List<WorkImage> images) async {
    AppLogger.debug('鎵归噺鍒涘缓鍥剧墖', tag: 'WorkImageRepository', data: {
      'workId': workId,
      'count': images.length,
      'createTimes': images
          .map((img) => DateTimeHelper.toStorageFormat(img.createTime))
          .toList(),
    });

    // 妫€鏌ュ苟杩囨护閲嶅鍥剧墖
    final uniqueImages = <WorkImage>[];
    final existingPaths = <String>{};

    // 鑾峰彇宸插瓨鍦ㄧ殑鍥剧墖璺緞
    final existing = await _db.query('work_images', {
      'where': [
        {'field': 'workId', 'op': '=', 'val': workId},
      ],
    });
    existingPaths.addAll(existing.map((e) => e['original_path'] as String));

    AppLogger.debug('宸插瓨鍦ㄥ浘鐗囪矾寰?, tag: 'WorkImageRepository', data: {
      'paths': existingPaths.toList(),
    });

    // 杩囨护鍑轰笉閲嶅鐨勫浘鐗?
    for (final image in images) {
      if (!existingPaths.contains(image.originalPath)) {
        uniqueImages.add(image);
      } else {
        AppLogger.debug('璺宠繃閲嶅鍥剧墖', tag: 'WorkImageRepository', data: {
          'originalPath': image.originalPath,
          'createTime': DateTimeHelper.toStorageFormat(image.createTime),
        });
      }
    }

    AppLogger.debug('杩囨护閲嶅鍥剧墖瀹屾垚', tag: 'WorkImageRepository', data: {
      'originalCount': images.length,
      'uniqueCount': uniqueImages.length,
    });

    if (uniqueImages.isNotEmpty) {
      final data = Map.fromEntries(
        uniqueImages.map((img) => MapEntry(img.id, _mapToRow(img, workId))),
      );
      await _db.setMany('work_images', data);
    }

    // 杩斿洖鎵€鏈夊浘鐗囷紝鍖呮嫭宸插瓨鍦ㄧ殑
    return getAllByWorkId(workId);
  }

  @override
  Future<void> delete(String workId, String imageId) async {
    AppLogger.debug('鍒犻櫎鍥剧墖', tag: 'WorkImageRepository', data: {
      'workId': workId,
      'imageId': imageId,
    });
    await _db.delete('work_images', imageId);
  }

  @override
  Future<void> deleteMany(String workId, List<String> imageIds) async {
    AppLogger.debug('鎵归噺鍒犻櫎鍥剧墖', tag: 'WorkImageRepository', data: {
      'workId': workId,
      'count': imageIds.length,
    });
    await _db.deleteMany('work_images', imageIds);
  }

  @override
  Future<WorkImage?> get(String imageId) async {
    final result = await _db.get('work_images', imageId);
    if (result != null) {
      AppLogger.debug('鑾峰彇鍗曚釜鍥剧墖', tag: 'WorkImageRepository', data: {
        'imageId': imageId,
        'createTime': result['createTime'],
        'updateTime': result['updateTime'],
      });
    }
    return result != null ? _mapToWorkImage(result) : null;
  }

  @override
  Future<List<WorkImage>> getAllByWorkId(String workId) async {
    final results = await _db.query('work_images', {
      'where': [
        {'field': 'workId', 'op': '=', 'val': workId}
      ],
      'orderBy': 'indexInWork ASC',
    });

    AppLogger.debug('鑾峰彇浣滃搧鎵€鏈夊浘鐗?, tag: 'WorkImageRepository', data: {
      'workId': workId,
      'count': results.length,
      'records': results
          .map((row) => {
                'id': row['id'],
                'originalPath': row['original_path'],
                'createTime': row['createTime'],
                'updateTime': row['updateTime'],
              })
          .toList(),
    });

    return results.map((row) => _mapToWorkImage(row)).toList();
  }

  @override
  Future<WorkImage?> getFirstByWorkId(String workId) async {
    final results = await _db.query('work_images', {
      'where': [
        {'field': 'workId', 'op': '=', 'val': workId}
      ],
      'orderBy': 'indexInWork ASC',
      'limit': 1,
    });
    return results.isNotEmpty ? _mapToWorkImage(results.first) : null;
  }

  @override
  Future<int> getNextIndex(String workId) async {
    final results = await _db.query('work_images', {
      'where': [
        {'field': 'workId', 'op': '=', 'val': workId}
      ],
      'orderBy': 'indexInWork DESC',
      'limit': 1,
    });
    return (results.isNotEmpty
        ? (_mapToWorkImage(results.first).index + 1)
        : 0);
  }

  @override
  Future<List<WorkImage>> saveMany(List<WorkImage> images) async {
    AppLogger.debug('鎵归噺淇濆瓨鍥剧墖', tag: 'WorkImageRepository', data: {
      'count': images.length,
      'times': images
          .map((img) => {
                'id': img.id,
                'createTime': DateTimeHelper.toStorageFormat(img.createTime),
                'updateTime': DateTimeHelper.toStorageFormat(img.updateTime),
              })
          .toList(),
    });

    if (images.isEmpty) return [];

    final data = Map.fromEntries(
      images.map((img) => MapEntry(img.id, _mapToRow(img, img.workId))),
    );
    await _db.setMany('work_images', data);
    return images;
  }

  @override
  Future<void> updateIndex(String workId, String imageId, int index) async {
    AppLogger.debug('鏇存柊鍥剧墖绱㈠紩', tag: 'WorkImageRepository', data: {
      'workId': workId,
      'imageId': imageId,
      'newIndex': index,
      'updateTime': DateTimeHelper.getCurrentUtc(),
    });

    await _db.save('work_images', imageId, {
      'indexInWork': index,
      'updateTime': DateTimeHelper.getCurrentUtc(),
    });
  }

  Map<String, dynamic> _mapToRow(WorkImage image, String workId) {
    final row = {
      'workId': workId,
      'path': image.path,
      'original_path': image.originalPath,
      'thumbnail_path': image.thumbnailPath,
      'format': image.format,
      'size': image.size,
      'width': image.width,
      'height': image.height,
      'indexInWork': image.index,
      'createTime': DateTimeHelper.toStorageFormat(image.createTime),
      'updateTime': DateTimeHelper.toStorageFormat(image.updateTime),
    };

    AppLogger.debug('杞崲涓烘暟鎹簱琛?, tag: 'WorkImageRepository', data: {
      'imageId': image.id,
      'row': row,
    });

    return row;
  }

  WorkImage _mapToWorkImage(Map<String, dynamic> row) {
    AppLogger.debug('鏄犲皠鏁版嵁搴撹褰?, tag: 'WorkImageRepository', data: {
      'record': row,
    });

    return WorkImage(
      id: row['id'] as String,
      workId: row['workId'] as String,
      path: row['path'] as String,
      originalPath: row['original_path'] as String,
      thumbnailPath: row['thumbnail_path'] as String,
      format: row['format'] as String,
      size: row['size'] as int,
      width: row['width'] as int,
      height: row['height'] as int,
      index: row['indexInWork'] as int,
      createTime:
          DateTimeHelper.fromStorageFormat(_safeGetTime(row, 'createTime')) ??
              DateTime.now(),
      updateTime:
          DateTimeHelper.fromStorageFormat(_safeGetTime(row, 'updateTime')) ??
              DateTime.now(),
    );
  }

  String? _safeGetTime(Map<String, dynamic> row, String key) {
    final value = row[key];
    AppLogger.debug('璇诲彇鏃堕棿瀛楁', tag: 'WorkImageRepository', data: {
      'field': key,
      'value': value,
      'type': value?.runtimeType.toString(),
    });
    return value as String?;
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\application\repositories\work_repository_impl.dart
-----------------------------------
import '../../domain/models/work/work_entity.dart';
import '../../domain/models/work/work_filter.dart';
import '../../domain/repositories/work_repository.dart';
import '../../infrastructure/logging/logger.dart';
import '../../infrastructure/persistence/database_interface.dart';
import '../../infrastructure/persistence/models/database_query.dart';
import '../../utils/date_time_helper.dart';

/// 浣滃搧浠撳簱瀹炵幇
class WorkRepositoryImpl implements WorkRepository {
  final DatabaseInterface _db;
  final String _table = 'works';

  WorkRepositoryImpl(this._db);

  @override
  Future<void> close() async {
    await _db.close();
  }

  @override
  Future<int> count(WorkFilter? filter) async {
    final query = _buildQuery(filter);
    return _db.count(_table, query);
  }

  @override
  Future<WorkEntity> create(WorkEntity work) async {
    await _db.set(_table, work.id, _toTableJson(work));
    return work;
  }

  @override
  Future<void> delete(String id) async {
    await _db.delete(_table, id);
  }

  @override
  Future<void> deleteMany(List<String> ids) async {
    await _db.deleteMany(_table, ids);
  }

  @override
  Future<WorkEntity> duplicate(String id, {String? newId}) async {
    final work = await get(id);
    if (work == null) {
      throw Exception('Work not found: $id');
    }

    final now = DateTime.now();
    final duplicated = work.copyWith(
      id: newId ?? '${work.id}_copy',
      createTime: now,
      updateTime: now,
    );

    await _db.set(_table, duplicated.id, _toTableJson(duplicated));
    return duplicated;
  }

  @override
  Future<WorkEntity?> get(String id) async {
    final data = await _db.get(_table, id);
    if (data == null) return null;
    return WorkEntity.fromJson(_convertDates(data));
  }

  @override
  Future<List<WorkEntity>> getAll() async {
    final data = await _db.getAll(_table);
    return data.map((e) => WorkEntity.fromJson(_convertDates(e))).toList();
  }

  @override
  Future<Set<String>> getAllTags() async {
    final works = await getAll();
    return works.expand((work) => work.tags).toSet();
  }

  @override
  Future<List<WorkEntity>> getByTags(Set<String> tags) async {
    if (tags.isEmpty) return [];

    final query = DatabaseQuery(conditions: [
      DatabaseQueryCondition(
        field: 'tags',
        operator: 'contains',
        value: tags.toList(),
      ),
    ]);

    final data = await _db.query(_table, query.toJson());
    return data.map((e) => WorkEntity.fromJson(_convertDates(e))).toList();
  }

  @override
  Future<List<WorkEntity>> query(WorkFilter filter) async {
    final query = _buildQuery(filter);
    final data = await _db.query(_table, query);
    return data.map((e) => WorkEntity.fromJson(_convertDates(e))).toList();
  }

  @override
  Future<WorkEntity> save(WorkEntity work) async {
    final now = DateTime.now();
    final updated = work.copyWith(updateTime: now);
    await _db.save(_table, work.id, _toTableJson(updated));
    return updated;
  }

  @override
  Future<List<WorkEntity>> saveMany(List<WorkEntity> works) async {
    final now = DateTime.now();
    final updates = {
      for (final work in works)
        work.id: _toTableJson(work.copyWith(updateTime: now))
    };

    await _db.saveMany(_table, updates);
    return works.map((w) => w.copyWith(updateTime: now)).toList();
  }

  @override
  Future<List<WorkEntity>> search(String query, {int? limit}) async {
    // 鍒涘缓涓€涓彧鍖呭惈鎼滅储鏉′欢鐨勮繃婊ゅ櫒
    final filter = WorkFilter(keyword: query);
    final results = await this.query(filter);

    if (limit != null && results.length > limit) {
      return results.take(limit).toList();
    }
    return results;
  }

  @override
  Future<List<String>> suggestTags(String prefix, {int limit = 10}) async {
    final allTags = await getAllTags();
    return allTags
        .where((tag) => tag.toLowerCase().startsWith(prefix.toLowerCase()))
        .take(limit)
        .toList();
  }

  /// 鏋勫缓鏁版嵁搴撴煡璇?
  Map<String, dynamic> _buildQuery(WorkFilter? filter) {
    AppLogger.debug(
      '寮€濮嬫瀯寤烘煡璇㈡潯浠?,
      tag: 'WorkRepositoryImpl',
      data: {
        'hasFilter': filter != null,
        'style': filter?.style?.name,
        'tool': filter?.tool?.name,
        'tagsCount': filter?.tags.length ?? 0,
        'hasKeyword': filter?.keyword?.isNotEmpty ?? false,
      },
    );

    if (filter == null) return {};

    final conditions = <DatabaseQueryCondition>[];
    final groups = <DatabaseQueryGroup>[];

    // 鍩烘湰杩囨护
    if (filter.style != null) {
      conditions.add(DatabaseQueryCondition(
        field: 'style',
        operator: '=',
        value: filter.style?.name,
      ));
    }

    if (filter.tool != null) {
      conditions.add(DatabaseQueryCondition(
        field: 'tool',
        operator: '=',
        value: filter.tool?.name,
      ));
    }

    if (filter.tags.isNotEmpty) {
      conditions.add(DatabaseQueryCondition(
        field: 'tags',
        operator: 'contains',
        value: filter.tags,
      ));
    }

    // 鎼滅储鍏抽敭瀛?
    if (filter.keyword?.isNotEmpty == true) {
      groups.add(
        DatabaseQueryGroup.or([
          DatabaseQueryCondition(
            field: 'title',
            operator: 'like',
            value: '%${filter.keyword}%',
          ),
          DatabaseQueryCondition(
            field: 'author',
            operator: 'like',
            value: '%${filter.keyword}%',
          ),
          DatabaseQueryCondition(
            field: 'remark',
            operator: 'like',
            value: '%${filter.keyword}%',
          ),
        ]),
      );
    }

    // 鏃ユ湡鑼冨洿杩囨护
    if (filter.dateRange != null) {
      final start = filter.dateRange?.start;
      final end = filter.dateRange?.end;
      if (start != null && end != null) {
        conditions.add(DatabaseQueryCondition(
          field: 'creationDate',
          operator: '>=',
          value: DateTimeHelper.toStorageFormat(start),
        ));

        conditions.add(DatabaseQueryCondition(
          field: 'creationDate',
          operator: '<=',
          value: DateTimeHelper.toStorageFormat(end),
        ));
      }
    }

    // 鍒涘缓鏃堕棿杩囨护
    if (filter.createTimeRange != null) {
      final start = filter.createTimeRange?.start;
      final end = filter.createTimeRange?.end;
      if (start != null && end != null) {
        conditions.add(DatabaseQueryCondition(
          field: 'createTime',
          operator: '>=',
          value: DateTimeHelper.toStorageFormat(start),
        ));

        conditions.add(DatabaseQueryCondition(
          field: 'createTime',
          operator: '<=',
          value: DateTimeHelper.toStorageFormat(end),
        ));
      }
    }

    // 鏇存柊鏃堕棿杩囨护
    if (filter.updateTimeRange != null) {
      final start = filter.updateTimeRange?.start;
      final end = filter.updateTimeRange?.end;
      if (start != null && end != null) {
        conditions.add(DatabaseQueryCondition(
          field: 'updateTime',
          operator: '>=',
          value: DateTimeHelper.toStorageFormat(start),
        ));

        conditions.add(DatabaseQueryCondition(
          field: 'updateTime',
          operator: '<=',
          value: DateTimeHelper.toStorageFormat(end),
        ));
      }
    }

    final query = DatabaseQuery(
      conditions: conditions,
      groups: groups.isEmpty ? null : groups,
      orderBy: filter.sortOption.field != null
          ? '${filter.sortOption.field.name} ${filter.sortOption.descending ? 'DESC' : 'ASC'}'
          : null,
    );
    AppLogger.debug(
      '鏌ヨ鏉′欢鏋勫缓瀹屾垚',
      tag: 'WorkRepositoryImpl',
      data: {
        'conditions': conditions.length,
        'groups': groups.length,
        'hasOrderBy': filter.sortOption.field != null,
        'orderBy': filter.sortOption.field.name,
        'isDescending': filter.sortOption.descending,
      },
    );

    return query.toJson();
  }

  /// 灏嗘暟鎹簱涓殑鏃堕棿鎴宠浆鎹负ISO8601瀛楃涓?
  Map<String, dynamic> _convertDates(Map<String, dynamic> data) {
    return {
      ...data,
      'tags': data['tags']
              ?.toString()
              .split(',')
              .where((tag) => tag.isNotEmpty)
              .toList() ??
          const [],
      'creationDate': data['creationDate'],
      'createTime': data['createTime'],
      'updateTime': data['updateTime'],
      'lastImageUpdateTime': data['lastImageUpdateTime'],
    };
  }

  /// 灏嗘椂闂村瓧娈佃浆鎹负ISO8601瀛楃涓?
  String? _convertToIso8601String(dynamic value) {
    if (value == null) {
      return null;
    }

    // 濡傛灉宸茬粡鏄瓧绗︿覆鏍煎紡锛屾鏌ユ槸鍚︿负ISO8601鏍煎紡
    if (value is String && value.contains('T')) {
      return value;
    }

    // 鍚﹀垯浣滀负鏃堕棿鎴冲鐞?
    return DateTime.fromMillisecondsSinceEpoch(value as int).toIso8601String();
  }

  /// 灏哤orkEntity杞崲涓烘暟鎹簱琛ㄥ瓧娈?
  Map<String, dynamic> _toTableJson(WorkEntity work) {
    return {
      'id': work.id,
      'title': work.title,
      'author': work.author,
      'style': work.style.value,
      'tool': work.tool.value,
      'remark': work.remark,
      'creationDate': DateTimeHelper.toStorageFormat(work.creationDate),
      'createTime': DateTimeHelper.toStorageFormat(work.createTime),
      'updateTime': DateTimeHelper.toStorageFormat(work.updateTime),
      'lastImageUpdateTime':
          DateTimeHelper.toStorageFormat(work.lastImageUpdateTime),
      'status': work.status.name,
      'firstImageId': work.firstImageId,
      'tags': work.tags.join(','),
      'imageCount': work.imageCount
    };
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\application\services\services.dart
-----------------------------------
export 'character/character_service.dart';
export 'practice/practice_service.dart';
export 'storage/work_storage_service.dart';
export 'work/work_image_service.dart';
export 'work/work_service.dart';



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\application\services\character\character_persistence_service.dart
-----------------------------------
import 'dart:io';
import 'dart:typed_data';

import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../domain/models/character/character_entity.dart';
import '../../../domain/models/character/character_image_type.dart';
import '../../../domain/models/character/character_region.dart';
import '../../../domain/models/character/processing_result.dart';
import '../../../domain/repositories/character_repository.dart';
import '../../../infrastructure/logging/logger.dart';
import '../../providers/repository_providers.dart';
import '../storage/cache_manager.dart';
import '../storage/character_storage_service.dart';

final characterPersistenceServiceProvider =
    Provider<CharacterPersistenceService>((ref) {
  final repository = ref.watch(characterRepositoryProvider);
  final storageService = ref.watch(characterStorageServiceProvider);
  final cacheManager = ref.watch(cacheManagerProvider);

  return CharacterPersistenceService(
    repository: repository,
    storageService: storageService,
    cacheManager: cacheManager,
  );
});

class CharacterPersistenceService {
  final CharacterRepository _repository;
  final CharacterStorageService _storageService;
  final CacheManager _cacheManager;

  CharacterPersistenceService({
    required CharacterRepository repository,
    required CharacterStorageService storageService,
    required CacheManager cacheManager,
  })  : _repository = repository,
        _storageService = storageService,
        _cacheManager = cacheManager;

  /// 浠庡瓧绗﹀尯鍩熷垱寤哄瓧绗﹀疄浣?
  Future<CharacterEntity> createFromRegion(
    CharacterRegion region,
    Uint8List originalImage,
    Uint8List binaryImage,
    Uint8List thumbnail,
    String? svgOutline,
  ) async {
    try {
      // 淇濆瓨鍥剧墖鏂囦欢
      await _storageService.saveOriginalImage(region.id, originalImage);
      await _storageService.saveBinaryImage(region.id, binaryImage);
      await _storageService.saveThumbnail(region.id, thumbnail);

      if (svgOutline != null) {
        await _storageService.saveSvgOutline(region.id, svgOutline);
      }

      // 鍒涘缓瀹炰綋骞朵繚瀛樺埌鏁版嵁搴?
      final entity = CharacterEntity.create(
        workId: 'temp', // TODO: 鏇挎崲涓哄疄闄呯殑workId锛屾殏鏃朵娇鐢ㄤ复鏃禝D浠ユ弧瓒冲閿害鏉?
        pageId: region.pageId,
        region: region,
        character: region.character,
      );

      return await _repository.create(entity);
    } catch (e) {
      print('浠庡尯鍩熷垱寤哄瓧绗﹀疄浣撳け璐? $e');
      rethrow;
    }
  }

  // 鍒犻櫎瀛楃鏁版嵁
  Future<void> deleteCharacter(String id) async {
    try {
      await _repository.delete(id);
      _cacheManager.invalidate(id);
    } catch (e) {
      print('鍒犻櫎瀛楃澶辫触: $e');
      rethrow;
    }
  }

  /// 澶嶅埗瀛楀舰
  Future<CharacterEntity> duplicateCharacter(String id, {String? newId}) async {
    try {
      // 鑾峰彇鍘熷瀛楃
      final original = await _repository.findById(id);
      if (original == null) {
        throw Exception('Character not found: $id');
      }

      final generatedId =
          newId ?? DateTime.now().millisecondsSinceEpoch.toString();

      // 澶嶅埗鏂囦欢
      final originalImageData =
          await getCharacterImage(id, CharacterImageType.original);
      final binaryImageData =
          await getCharacterImage(id, CharacterImageType.binary);
      final thumbnailData =
          await getCharacterImage(id, CharacterImageType.thumbnail);

      if (originalImageData == null ||
          binaryImageData == null ||
          thumbnailData == null) {
        throw Exception('Failed to load character images');
      }

      await _storageService.saveOriginalImage(generatedId, originalImageData);
      await _storageService.saveBinaryImage(generatedId, binaryImageData);
      await _storageService.saveThumbnail(generatedId, thumbnailData);

      // 鍒涘缓鏂板疄浣?
      final now = DateTime.now();
      final duplicated = original.copyWith(
        id: generatedId,
        createTime: now,
        updateTime: now,
        isFavorite: false,
        region: original.region.copyWith(
          id: generatedId,
          createTime: now,
          updateTime: now,
        ),
      );

      // 淇濆瓨鍒版暟鎹簱
      await _repository.create(duplicated);
      return duplicated;
    } catch (e) {
      print('澶嶅埗瀛楃澶辫触: $e');
      rethrow;
    }
  }

  /// 鑾峰彇瀛楃鍥惧儚鏁版嵁
  Future<Uint8List?> getCharacterImage(
      String id, CharacterImageType type) async {
    try {
      String? filePath;
      switch (type) {
        case CharacterImageType.original:
          filePath = await _storageService.getOriginalImagePath(id);
          break;
        case CharacterImageType.binary:
          filePath = await _storageService.getBinaryImagePath(id);
          break;
        case CharacterImageType.thumbnail:
          filePath = await _storageService.getThumbnailPath(id);
          break;
      }

      final file = File(filePath);
      if (await file.exists()) {
        return await file.readAsBytes();
      }

      return null;
    } catch (e) {
      print('鑾峰彇瀛楃鍥惧儚澶辫触: $e');
      rethrow;
    }
  }

  /// 鑾峰彇瀛楃缂╃暐鍥捐矾寰?
  Future<String> getThumbnailPath(String id) async {
    try {
      final path = await _storageService.getThumbnailPath(id);

      // 娣诲姞鏃ュ織妫€鏌ョ敓鎴愮殑璺緞
      print('瀛楃缂╃暐鍥捐矾寰勭敓鎴? $path锛孖D: $id');

      // 妫€鏌ユ枃浠舵槸鍚﹀瓨鍦?
      final file = File(path);
      final exists = await file.exists();
      print('缂╃暐鍥捐矾寰勬鏌? ${exists ? '瀛樺湪' : '涓嶅瓨鍦?} $path');

      if (!exists) {
        print('缂╃暐鍥炬枃浠朵笉瀛樺湪: $path');
      } else {
        final fileSize = await file.length();
        print('缂╃暐鍥炬枃浠跺ぇ灏? $fileSize 瀛楄妭');
      }

      return path;
    } catch (e, stack) {
      print('鑾峰彇缂╃暐鍥捐矾寰勫紓甯? $e');
      AppLogger.error('鑾峰彇缂╃暐鍥捐矾寰勫紓甯?,
          error: e, stackTrace: stack, data: {'id': id});
      rethrow;
    }
  }

  // 淇濆瓨瀛楃鏁版嵁
  Future<CharacterEntity> saveCharacter(
      CharacterRegion region, ProcessingResult result, String workId) async {
    try {
      await _storageService.saveOriginalImage(region.id, result.originalCrop);
      await _storageService.saveBinaryImage(region.id, result.binaryImage);
      await _storageService.saveThumbnail(region.id, result.thumbnail);

      if (result.svgOutline != null) {
        await _storageService.saveSvgOutline(region.id, result.svgOutline!);
      }

      // 鍒涘缓瀹炰綋骞朵繚瀛樺埌鏁版嵁搴?
      final entity = CharacterEntity.create(
        workId: workId,
        pageId: region.pageId,
        region: region,
        character: region.character,
      );

      return await _repository.create(entity);
    } catch (e) {
      print('淇濆瓨瀛楃澶辫触: $e');
      rethrow;
    }
  }

  // 鏇存柊瀛楃鏁版嵁
  Future<void> updateCharacter(String id, CharacterRegion region,
      ProcessingResult? newResult, String character) async {
    try {
      // 浣跨敤鏇存柊鍚庣殑瀛楃鍐呭鍜屾椂闂存埑
      final now = DateTime.now();
      final updatedRegion = region.copyWith(
        character: character,
        updateTime: now,
      );

      // 濡傛灉鏈夋柊鐨勫鐞嗙粨鏋滐紝鍒欐洿鏂板浘鍍忔枃浠?
      if (newResult != null && newResult.isValid) {
        await _storageService.saveOriginalImage(id, newResult.originalCrop);
        await _storageService.saveBinaryImage(id, newResult.binaryImage);
        await _storageService.saveThumbnail(id, newResult.thumbnail);

        if (newResult.svgOutline != null) {
          await _storageService.saveSvgOutline(id, newResult.svgOutline!);
        }
      }

      // 鏇存柊鍖哄煙鏁版嵁
      await _repository.updateRegion(updatedRegion);

      // 娓呴櫎缂撳瓨
      _cacheManager.invalidate(id);
    } catch (e) {
      print('鏇存柊瀛楃澶辫触: $e');
      rethrow;
    }
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\application\services\character\character_service.dart
-----------------------------------
import 'dart:typed_data';
import 'dart:io';

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:image/image.dart' as img;

import '../../../domain/models/character/character_entity.dart';
import '../../../domain/models/character/character_image_type.dart';
import '../../../domain/models/character/character_region.dart';
import '../../../domain/models/character/processing_options.dart';
import '../../../domain/models/character/processing_result.dart';
import '../../../domain/repositories/character_repository.dart';
import '../../../infrastructure/logging/logger.dart';
import '../../../presentation/viewmodels/character_collection_viewmodel.dart';
import '../../providers/repository_providers.dart';
import '../image/character_image_processor.dart';
import '../storage/cache_manager.dart';
import 'character_persistence_service.dart';

final characterServiceProvider = Provider<CharacterService>((ref) {
  final repository = ref.watch(characterRepositoryProvider);
  final imageProcessor = ref.watch(characterImageProcessorProvider);
  final persistenceService = ref.watch(characterPersistenceServiceProvider);
  final cacheManager = ref.watch(cacheManagerProvider);

  return CharacterService(
    repository: repository,
    imageProcessor: imageProcessor,
    persistenceService: persistenceService,
    cacheManager: cacheManager,
  );
});

class CharacterService {
  final CharacterRepository _repository;
  final CharacterImageProcessor _imageProcessor;
  final CharacterPersistenceService _persistenceService;
  final CacheManager _cacheManager;

  CharacterService({
    required CharacterRepository repository,
    required CharacterImageProcessor imageProcessor,
    required CharacterPersistenceService persistenceService,
    required CacheManager cacheManager,
  })  : _repository = repository,
        _imageProcessor = imageProcessor,
        _persistenceService = persistenceService,
        _cacheManager = cacheManager;

  /// 搴旂敤鎿﹂櫎鎿嶄綔
  Future<ProcessingResult> applyErase(
    String characterId,
    CharacterRegion region,
    List<Offset> erasePoints,
    Uint8List originalImage,
  ) async {
    // 灏嗘摝闄ょ偣杞崲涓烘纭殑鏍煎紡
    final allErasePoints = <Map<String, dynamic>>[
      if (region.erasePoints != null)
        {'points': region.erasePoints!, 'brushSize': region.options.brushSize},
      {
        'points': erasePoints,
        'brushSize': region.options.brushSize,
      }
    ];

    // 閲嶆柊澶勭悊鍥惧儚
    final result = await _imageProcessor.processCharacterRegion(
      originalImage,
      region.rect,
      region.options,
      allErasePoints,
    );

    return result;
  }

  /// 娓呯悊缂撳瓨
  Future<void> clearCache() async {
    try {
      await _cacheManager.clear();
    } catch (e) {
      print('娓呯悊缂撳瓨澶辫触: $e');
    }
  }

  /// 鎵归噺鍒犻櫎瀛楃
  Future<void> deleteBatchCharacters(List<String> ids) async {
    try {
      // 鎵归噺鍒犻櫎鏁版嵁搴撹褰?
      await _repository.deleteBatch(ids);

      // 鎵归噺鍒犻櫎鏂囦欢
      for (final id in ids) {
        await _persistenceService.deleteCharacter(id);
        _cacheManager.invalidate(id);
      }
    } catch (e) {
      print('鎵归噺鍒犻櫎瀛楃澶辫触: $e');
      rethrow;
    }
  }

  /// 鍒犻櫎瀛楃
  Future<void> deleteCharacter(String id) async {
    try {
      // 鍒犻櫎鏁版嵁搴撹褰?
      await _repository.delete(id);

      // 鍒犻櫎鐩稿叧鏂囦欢
      await _persistenceService.deleteCharacter(id);

      // 娓呴櫎缂撳瓨
      _cacheManager.invalidate(id);
    } catch (e) {
      print('鍒犻櫎瀛楃澶辫触: $e');
      rethrow;
    }
  }

  /// 鎻愬彇瀛楃鍖哄煙骞跺鐞?
  Future<CharacterEntity> extractCharacter(String workId, String pageId,
      Rect region, ProcessingOptions options, Uint8List imageData,
      {bool isSaved = false}) async {
    try {
      AppLogger.debug('寮€濮嬫彁鍙栧瓧绗﹀尯鍩?, data: {
        'workId': workId,
        'pageId': pageId,
        'region':
            '${region.left},${region.top},${region.width},${region.height}',
        'imageDataLength': imageData.length,
        'isSaved': isSaved,
      });
      // 澶勭悊瀛楃鍖哄煙
      final result = await _imageProcessor.processCharacterRegion(
        imageData,
        region,
        options,
        null, // 鏂板垱寤虹殑瀛楃娌℃湁鎿﹂櫎鐐?
      );
      AppLogger.debug('瀛楃鍖哄煙澶勭悊瀹屾垚', data: {
        'originalCropLength': result.originalCrop.length,
        'binaryImageLength': result.binaryImage.length,
        'thumbnailLength': result.thumbnail.length
      });

      // 鍒涘缓瀛楃鍖哄煙锛岃缃繚瀛樼姸鎬?
      final characterRegion = CharacterRegion.create(
        pageId: pageId,
        rect: region,
        options: options,
      ).copyWith(isSaved: isSaved);

      AppLogger.debug('瀛楃鍖哄煙鍒涘缓瀹屾垚', data: {
        'regionId': characterRegion.id,
        'isSaved': characterRegion.isSaved,
      });

      // 淇濆瓨瀛楃鍜屽浘鍍?
      final character = await _persistenceService.saveCharacter(
        characterRegion,
        result,
        workId,
      );
      AppLogger.debug('瀛楃鍜屽浘鍍忎繚瀛樺畬鎴?, data: {'characterId': character.id});

      // 缂撳瓨鍥惧儚鏁版嵁
      final id = character.id;
      try {
        await Future.wait([
          _cacheManager.put('${id}_original', result.originalCrop),
          _cacheManager.put('${id}_binary', result.binaryImage),
          _cacheManager.put('${id}_thumbnail', result.thumbnail),
        ]);

        AppLogger.debug('鍥惧儚鏁版嵁缂撳瓨瀹屾垚', data: {'characterId': id});
      } catch (e) {
        AppLogger.error('缂撳瓨鍥惧儚鏁版嵁澶辫触', error: e, data: {'characterId': id});
      }

      return character.copyWith(workId: workId);
    } catch (e) {
      AppLogger.error('鎻愬彇瀛楃澶辫触', error: e);
      rethrow;
    }
  }

  /// 鑾峰彇瀛楃璇︽儏
  Future<CharacterEntity?> getCharacterDetails(String id) async {
    try {
      final character = await _repository.findById(id);
      if (character == null) {
        throw Exception('Character not found: $id');
      }
      return character;
    } catch (e) {
      print('鑾峰彇瀛楃璇︽儏澶辫触: $e');
      rethrow;
    }
  }

  /// 鑾峰彇瀛楃鍘熷鍥惧儚
  Future<Uint8List?> getCharacterImage(
      String id, CharacterImageType type) async {
    try {
      // 灏濊瘯浠庣紦瀛樿幏鍙?
      final cacheKey = '${id}_${type.toString()}';
      final cached = await _cacheManager.get(cacheKey);
      if (cached != null) {
        return cached;
      }

      // 浠庝粨搴撹幏鍙?
      final imageData = await _persistenceService.getCharacterImage(id, type);

      // 缂撳瓨缁撴灉
      if (imageData != null) {
        await _cacheManager.put(cacheKey, imageData);
      }

      return imageData;
    } catch (e) {
      print('鑾峰彇瀛楃鍥惧儚澶辫触: $e');
      rethrow;
    }
  }

  /// 鑾峰彇瀛楃缂╃暐鍥捐矾寰?
  Future<String?> getCharacterThumbnailPath(String characterId) async {
    try {
      print('CharacterService - 鑾峰彇缂╃暐鍥捐矾寰? $characterId');
      // 浠庢寔涔呭寲鏈嶅姟鑾峰彇缂╃暐鍥捐矾寰?
      final path = await _persistenceService.getThumbnailPath(characterId);

      // 妫€鏌ョ缉鐣ュ浘鏂囦欢鏄惁瀛樺湪
      final file = File(path);
      final exists = await file.exists();

      // 濡傛灉缂╃暐鍥句笉瀛樺湪锛屽皾璇曚粠鍘熷鍥惧儚鐢熸垚
      if (!exists) {
        print('CharacterService - 缂╃暐鍥句笉瀛樺湪锛屽皾璇曢噸鏂扮敓鎴? $path');
        try {
          // 鑾峰彇瀛楃璇︽儏
          final character = await _repository.findById(characterId);
          if (character == null) {
            print('CharacterService - 瀛楃涓嶅瓨鍦紝鏃犳硶閲嶆柊鐢熸垚缂╃暐鍥? $characterId');
            return path; // 鍗充娇鏂囦欢涓嶅瓨鍦紝涔熻繑鍥炶矾寰勪緵涓婂眰澶勭悊
          }

          // 鑾峰彇鍘熷鍥惧儚鏁版嵁
          final originalData =
              await getCharacterImage(characterId, CharacterImageType.original);
          if (originalData == null) {
            print('CharacterService - 鍘熷鍥惧儚鏁版嵁涓虹┖锛屾棤娉曢噸鏂扮敓鎴愮缉鐣ュ浘');
            return path;
          }

          // 鐢熸垚鏂扮殑缂╃暐鍥?
          // 灏嗗師濮嬪浘鍍忚В鐮佷负img.Image
          final image = img.decodeImage(originalData);
          if (image == null) {
            print('CharacterService - 鏃犳硶瑙ｇ爜鍘熷鍥惧儚');
            return path;
          }

          // 鐢熸垚缂╃暐鍥?
          final thumbnail = img.copyResize(image,
              width: 100,
              height: 100,
              interpolation: img.Interpolation.average);

          // 缂栫爜涓篔PEG鏁版嵁
          final thumbnailData =
              Uint8List.fromList(img.encodeJpg(thumbnail, quality: 80));

          // 淇濆瓨鍒版枃浠剁郴缁?- 鐩存帴鍐欏叆鏂囦欢鑰屼笉鏄皟鐢ㄥ彲鑳戒笉瀛樺湪鐨勬湇鍔℃柟娉?
          await file.create(recursive: true);
          await file.writeAsBytes(thumbnailData);

          print('CharacterService - 缂╃暐鍥鹃噸鏂扮敓鎴愭垚鍔? $path');
          return path;
        } catch (regenerateError) {
          print('CharacterService - 閲嶆柊鐢熸垚缂╃暐鍥惧け璐? $regenerateError');
          AppLogger.error('閲嶆柊鐢熸垚缂╃暐鍥惧け璐?,
              error: regenerateError, data: {'characterId': characterId});
          return path; // 鍗充娇閲嶆柊鐢熸垚澶辫触锛屼篃杩斿洖璺緞渚涗笂灞傚鐞?
        }
      }

      return path;
    } catch (e) {
      AppLogger.error('鑾峰彇缂╃暐鍥捐矾寰勫け璐?,
          error: e, data: {'characterId': characterId});
      return null;
    }
  }

  /// 鑾峰彇椤甸潰涓婄殑鎵€鏈夊尯鍩?
  Future<List<CharacterRegion>> getPageRegions(String pageId) async {
    try {
      return await _repository.getRegionsByPageId(pageId);
    } catch (e) {
      print('鑾峰彇椤甸潰鍖哄煙澶辫触: $e');
      return [];
    }
  }

  /// 鑾峰彇浣滃搧涓殑瀛楃鍒楄〃
  Future<List<CharacterViewModel>> listCharacters(String workId) async {
    try {
      final characters = await _repository.findByWorkId(workId);

      // 灏嗗瓧绗﹀疄浣撹浆鎹负瑙嗗浘妯″瀷
      final futures = characters.map((entity) async {
        // 鏋勫缓缂╃暐鍥捐矾寰?
        final thumbnailPath =
            await _persistenceService.getThumbnailPath(entity.id);

        return CharacterViewModel(
          id: entity.id,
          pageId: entity.pageId,
          character: entity.character,
          rect: entity.region.rect,
          thumbnailPath: thumbnailPath,
          createdAt: entity.createTime,
          updatedAt: entity.updateTime,
          isFavorite: false,
        );
      }).toList();

      return await Future.wait(futures);
    } catch (e) {
      print('鑾峰彇瀛楃鍒楄〃澶辫触: $e');
      rethrow;
    }
  }

  /// 鎼滅储瀛楃
  Future<List<CharacterViewModel>> searchCharacters(String query) async {
    try {
      final characters = await _repository.search(query);

      // 灏嗙粨鏋滆浆鎹负瑙嗗浘妯″瀷
      final futures = characters.map((entity) async {
        final thumbnailPath =
            await _persistenceService.getThumbnailPath(entity.id);

        return CharacterViewModel(
          id: entity.id,
          pageId: entity.pageId,
          character: entity.character,
          rect: entity.region.rect,
          thumbnailPath: thumbnailPath,
          createdAt: entity.createTime,
          updatedAt: entity.updateTime,
          isFavorite: false,
        );
      }).toList();

      return await Future.wait(futures);
    } catch (e) {
      print('鎼滅储瀛楃澶辫触: $e');
      return [];
    }
  }

  /// 鏇存柊瀛楃
  Future<void> updateCharacter(
      String id, CharacterRegion region, String character,
      {ProcessingResult? newResult}) async {
    try {
      // 鏇存柊瀛楃鍜屽鐞嗙粨鏋?
      await _persistenceService.updateCharacter(
        id,
        region.copyWith(character: character),
        newResult,
        character,
      );
    } catch (e) {
      print('鏇存柊瀛楃澶辫触: $e');
      rethrow;
    }
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\application\services\image\character_image_processor.dart
-----------------------------------
import 'dart:math' as math;
import 'dart:typed_data';

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:image/image.dart' as img;

import '../../../domain/models/character/detected_outline.dart';
import '../../../domain/models/character/processing_options.dart';
import '../../../domain/models/character/processing_result.dart';
import '../../../infrastructure/image/image_processor.dart';
import '../../../infrastructure/logging/logger.dart';
import '../../providers/service_providers.dart';
import '../storage/cache_manager.dart';

/// Character Image Processor Provider
final characterImageProcessorProvider =
    Provider<CharacterImageProcessor>((ref) {
  final imageProcessor = ref.watch(imageProcessorProvider);
  final cacheManager = ref.watch(cacheManagerProvider);
  return CharacterImageProcessor(imageProcessor, cacheManager);
});

/// 瀛楃鍥惧儚澶勭悊鍣?
class CharacterImageProcessor {
  static const int maxPreviewSize = 800;
  final ImageProcessor _processor;
  final CacheManager _cacheManager;

  CharacterImageProcessor(this._processor, this._cacheManager);

  String generateSvgOutline(DetectedOutline outline, bool isInverted) {
    final width = outline.boundingRect.width;
    final height = outline.boundingRect.height;

    if (outline.contourPoints.isEmpty) {
      return '';
    }

    final strokeColor = isInverted ? 'white' : 'black';

    final svg = StringBuffer()
      ..write(
          '<svg viewBox="0 0 $width $height" xmlns="http://www.w3.org/2000/svg">');

    for (final contour in outline.contourPoints) {
      if (contour.length < 3) continue;

      svg.write('<path d="');
      svg.write(
          'M${contour[0].dx.toStringAsFixed(1)},${contour[0].dy.toStringAsFixed(1)} ');

      for (int i = 1; i < contour.length - 1; i++) {
        final p0 = contour[i - 1];
        final p1 = contour[i];
        final p2 = contour[i + 1];

        final control =
            Offset(p1.dx + (p2.dx - p0.dx) / 4, p1.dy + (p2.dy - p0.dy) / 4);

        svg.write(
            'Q${control.dx.toStringAsFixed(1)},${control.dy.toStringAsFixed(1)} '
            '${p1.dx.toStringAsFixed(1)},${p1.dy.toStringAsFixed(1)} ');
      }

      svg.write('Z" fill="none" stroke="$strokeColor" '
          'stroke-width="1.0" stroke-linecap="round" '
          'stroke-linejoin="round"/>');
    }

    svg.write('</svg>');
    return svg.toString();
  }

  /// 棰勮澶勭悊
  Future<PreviewResult> previewProcessing(
    Uint8List imageData,
    Rect region,
    ProcessingOptions options,
    List<Map<String, dynamic>>? erasePaths, {
    double rotation = 0.0,
  }) async {
    final params = ProcessingParams(
      imageData: imageData,
      region: region,
      rotation: rotation,
      options: options,
      erasePaths: erasePaths,
    );

    if (!params.isRegionValid) {
      throw ImageProcessingException('棰勮鍖哄煙鏃犳晥');
    }

    try {
      final sourceImage = img.decodeImage(params.imageData);
      if (sourceImage == null) {
        throw ImageProcessingException('鍥惧儚瑙ｇ爜澶辫触');
      }

      final croppedImage =
          _rotateAndCropImage(sourceImage, params.region, params.rotation);

      // 搴旂敤瀵规瘮搴﹀拰浜害璋冩暣
      img.Image finalImage = croppedImage;
      if (params.options.contrast != 1.0 || params.options.brightness != 0.0) {
        final adjustedImage =
            img.Image(width: croppedImage.width, height: croppedImage.height);
        for (var y = 0; y < croppedImage.height; y++) {
          for (var x = 0; x < croppedImage.width; x++) {
            final pixel = croppedImage.getPixel(x, y);
            final r = ((pixel.r - 128) * params.options.contrast +
                    128 +
                    params.options.brightness)
                .clamp(0, 255)
                .round();
            final g = ((pixel.g - 128) * params.options.contrast +
                    128 +
                    params.options.brightness)
                .clamp(0, 255)
                .round();
            final b = ((pixel.b - 128) * params.options.contrast +
                    128 +
                    params.options.brightness)
                .clamp(0, 255)
                .round();
            adjustedImage.setPixelRgba(x, y, r, g, b, pixel.a);
          }
        }
        finalImage = adjustedImage;
      }

      // 搴旂敤鍏朵粬澶勭悊閫夐」
      if (params.options.noiseReduction > 0.3) {
        finalImage = _denoise(finalImage, params.options.noiseReduction);
      }

      final processedBytes = Uint8List.fromList(img.encodeJpg(finalImage));
      final thumbnailBytes = _generateThumbnail(finalImage);
      final outline = options.showContour
          ? _detectOutline(finalImage, options.inverted)
          : null;

      final result = ProcessingResult(
        originalCrop: processedBytes,
        binaryImage: processedBytes,
        thumbnail: thumbnailBytes,
        svgOutline: outline != null
            ? generateSvgOutline(outline, options.inverted)
            : null,
        boundingBox: outline?.boundingRect ?? params.region,
      );

      return PreviewResult(
        processedImage: finalImage,
        outline: outline,
      );
    } catch (e) {
      AppLogger.error('棰勮澶勭悊澶辫触', error: e);
      rethrow;
    }
  }

  /// 瀹屾暣澶勭悊
  Future<ProcessingResult> processCharacterRegion(
    Uint8List imageData,
    Rect region,
    ProcessingOptions options,
    List<Map<String, dynamic>>? erasePaths,
  ) async {
    final params = ProcessingParams(
      imageData: imageData,
      region: region,
      options: options,
      erasePaths: erasePaths,
    );

    if (!params.isRegionValid) {
      throw ImageProcessingException('澶勭悊鍖哄煙鏃犳晥');
    }

    final cacheKey = _generateCacheKey(params);

    try {
      final sourceImage = img.decodeImage(params.imageData);
      if (sourceImage == null) {
        throw ImageProcessingException('鍥惧儚瑙ｇ爜澶辫触');
      }

      final croppedImage =
          _rotateAndCropImage(sourceImage, params.region, params.rotation);

      // 搴旂敤瀵规瘮搴﹀拰浜害璋冩暣
      img.Image finalImage = croppedImage;
      if (params.options.contrast != 1.0 || params.options.brightness != 0.0) {
        final adjustedImage =
            img.Image(width: croppedImage.width, height: croppedImage.height);
        for (var y = 0; y < croppedImage.height; y++) {
          for (var x = 0; x < croppedImage.width; x++) {
            final pixel = croppedImage.getPixel(x, y);
            final r = ((pixel.r - 128) * params.options.contrast +
                    128 +
                    params.options.brightness)
                .clamp(0, 255)
                .round();
            final g = ((pixel.g - 128) * params.options.contrast +
                    128 +
                    params.options.brightness)
                .clamp(0, 255)
                .round();
            final b = ((pixel.b - 128) * params.options.contrast +
                    128 +
                    params.options.brightness)
                .clamp(0, 255)
                .round();
            adjustedImage.setPixelRgba(x, y, r, g, b, pixel.a);
          }
        }
        finalImage = adjustedImage;
      }

      // 搴旂敤鍏朵粬澶勭悊閫夐」
      if (params.options.noiseReduction > 0.3) {
        finalImage = _denoise(finalImage, params.options.noiseReduction);
      }

      final processedBytes = Uint8List.fromList(img.encodeJpg(finalImage));
      final thumbnailBytes = _generateThumbnail(finalImage);
      final outline = options.showContour
          ? _detectOutline(finalImage, options.inverted)
          : null;

      final result = ProcessingResult(
        originalCrop: processedBytes,
        binaryImage: processedBytes,
        thumbnail: thumbnailBytes,
        svgOutline: outline != null
            ? generateSvgOutline(outline, options.inverted)
            : null,
        boundingBox: outline?.boundingRect ?? params.region,
      );

      await _cacheManager.put(cacheKey, result.toArchiveBytes());
      return result;
    } catch (e) {
      AppLogger.error('鍥惧儚澶勭悊澶辫触', error: e);
      rethrow;
    }
  }

  /// 搴旂敤鎿﹂櫎
  img.Image _applyErase(
    img.Image source,
    List<Map<String, dynamic>> erasePaths,
    ProcessingOptions options,
  ) {
    final result =
        img.copyResize(source, width: source.width, height: source.height);

    for (final pathData in erasePaths) {
      final points = pathData['points'] as List<dynamic>;
      final brushSize = (pathData['brushSize'] as num?)?.toDouble() ?? 10.0;
      final brushRadius = brushSize / 2;

      // 鑾峰彇璺緞鐨勯鑹诧紝榛樿涓虹櫧鑹?
      final brushColorValue = pathData['brushColor'] as int?;
      final brushColor = brushColorValue != null
          ? img.ColorRgb8((brushColorValue >> 16) & 0xFF,
              (brushColorValue >> 8) & 0xFF, brushColorValue & 0xFF)
          : options.inverted
              ? img.ColorRgb8(0, 0, 0) // 鍙嶈浆鏃朵娇鐢ㄩ粦鑹?
              : img.ColorRgb8(255, 255, 255); // 鏈弽杞椂浣跨敤鐧借壊

      for (final point in points) {
        double x, y;
        if (point is Offset) {
          x = point.dx;
          y = point.dy;
        } else if (point is Map) {
          x = (point['x'] as num).toDouble();
          y = (point['y'] as num).toDouble();
        } else {
          continue;
        }

        x = x.clamp(0, source.width - 1);
        y = y.clamp(0, source.height - 1);

        for (var dy = -brushRadius; dy <= brushRadius; dy++) {
          for (var dx = -brushRadius; dx <= brushRadius; dx++) {
            if (dx * dx + dy * dy <= brushRadius * brushRadius) {
              final px = (x + dx).round();
              final py = (y + dy).round();
              if (px >= 0 &&
                  px < result.width &&
                  py >= 0 &&
                  py < result.height) {
                result.setPixel(px, py, brushColor); // 浣跨敤璺緞鐨勯鑹?
              }
            }
          }
        }
      }
    }

    return result;
  }

  /// 浜屽€煎寲澶勭悊
  img.Image _binarize(img.Image source, ProcessingOptions options) {
    final gray = img.grayscale(source);
    final threshold = options.threshold.toInt().clamp(0, 255);

    for (int y = 0; y < gray.height; y++) {
      for (int x = 0; x < gray.width; x++) {
        final pixel = gray.getPixel(x, y);
        final luminance = img.getLuminanceRgb(pixel.r, pixel.g, pixel.b);
        gray.setPixel(
          x,
          y,
          luminance > threshold
              ? img.ColorRgb8(255, 255, 255)
              : img.ColorRgb8(0, 0, 0),
        );
      }
    }

    return options.inverted ? img.invert(gray) : gray;
  }

  /// 璁＄畻鏃嬭浆鍚庣殑鐭╁舰鍖哄煙
  Rect _calculateRotatedRect(Rect rect, double rotation) {
    if (rotation == 0) return rect;

    final center = Offset(rect.center.dx, rect.center.dy);
    final width = rect.width;
    final height = rect.height;

    // 璁＄畻鏃嬭浆鍚庣殑鍥涗釜瑙掔偣
    final points = [
      _rotatePoint(Offset(rect.left, rect.top), center, rotation),
      _rotatePoint(Offset(rect.right, rect.top), center, rotation),
      _rotatePoint(Offset(rect.right, rect.bottom), center, rotation),
      _rotatePoint(Offset(rect.left, rect.bottom), center, rotation),
    ];

    // 璁＄畻鏂扮殑杈圭晫
    double minX = double.infinity;
    double minY = double.infinity;
    double maxX = -double.infinity;
    double maxY = -double.infinity;

    for (final point in points) {
      minX = math.min(minX, point.dx);
      minY = math.min(minY, point.dy);
      maxX = math.max(maxX, point.dx);
      maxY = math.max(maxY, point.dy);
    }

    return Rect.fromLTWH(minX, minY, maxX - minX, maxY - minY);
  }

  /// 瑁佸壀骞惰皟鏁村ぇ灏?
  img.Image _cropAndResize(img.Image source, Rect region) {
    final cropped = img.copyCrop(
      source,
      x: region.left.toInt().clamp(0, source.width - 1),
      y: region.top.toInt().clamp(0, source.height - 1),
      width: region.width.toInt().clamp(1, source.width),
      height: region.height.toInt().clamp(1, source.height),
    );

    if (cropped.width > maxPreviewSize || cropped.height > maxPreviewSize) {
      final ratio = maxPreviewSize / math.max(cropped.width, cropped.height);
      return img.copyResize(
        cropped,
        width: (cropped.width * ratio).toInt(),
        height: (cropped.height * ratio).toInt(),
        interpolation: img.Interpolation.cubic,
      );
    }

    return cropped;
  }

  /// 闄嶅櫔澶勭悊
  img.Image _denoise(img.Image source, double strength) {
    final radius = (strength * 5).clamp(1.0, 3.0);
    final blurred = img.gaussianBlur(source, radius: radius.toInt());

    for (int y = 0; y < blurred.height; y++) {
      for (int x = 0; x < blurred.width; x++) {
        final pixel = blurred.getPixel(x, y);
        final luminance = img.getLuminanceRgb(pixel.r, pixel.g, pixel.b);
        blurred.setPixel(
          x,
          y,
          luminance > 128
              ? img.ColorRgb8(255, 255, 255)
              : img.ColorRgb8(0, 0, 0),
        );
      }
    }

    return blurred;
  }

  /// 鐢熸垚缂撳瓨閿?
  String _generateCacheKey(ProcessingParams params) {
    final regionKey =
        'rect_${params.region.left.toInt()}_${params.region.top.toInt()}_'
        '${params.region.width.toInt()}_${params.region.height.toInt()}';
    final optionsKey = 'opt_${params.options.inverted ? 1 : 0}_'
        '${params.options.threshold.toInt()}_'
        '${(params.options.noiseReduction * 10).toInt()}';
    final eraseKey = params.erasePaths?.isNotEmpty == true
        ? 'erase_${params.erasePaths!.length}'
        : 'noerase';
    return '${params.imageData.hashCode}:$regionKey:$optionsKey:$eraseKey';
  }

  /// 鐢熸垚缂╃暐鍥?
  Uint8List _generateThumbnail(img.Image source) {
    final thumbnail = img.copyResize(
      source,
      width:
          (source.width * 100 / math.max(source.width, source.height)).toInt(),
      height:
          (source.height * 100 / math.max(source.width, source.height)).toInt(),
      interpolation: img.Interpolation.cubic,
    );
    return Uint8List.fromList(img.encodeJpg(thumbnail, quality: 85));
  }

  /// 瀵瑰浘鍍忚繘琛屽熀浜庨€夊尯涓績鐨勬棆杞拰瑁佸壀澶勭悊
  ///
  /// [sourceImage] 婧愬浘鍍?
  /// [region] 閫夊尯鐭╁舰
  /// [rotation] 鏃嬭浆瑙掑害
  /// 杩斿洖澶勭悊鍚庣殑鍥惧儚
  img.Image _rotateAndCropImage(
    img.Image sourceImage,
    Rect region,
    double rotation,
  ) {
    final center =
        Offset(region.left + region.width / 2, region.top + region.height / 2);

    if (rotation == 0) {
      return img.copyCrop(
        sourceImage,
        x: region.left.round(),
        y: region.top.round(),
        width: region.width.round(),
        height: region.height.round(),
      );
    }

    // 鍒涘缓鐩爣鍥惧儚
    final result =
        img.Image(width: region.width.round(), height: region.height.round());

    // 鍒涘缓鍙樻崲鐭╅樀
    final cos = math.cos(rotation);
    final sin = math.sin(rotation);

    // 浣跨敤浠垮皠鍙樻崲杩涜鏃嬭浆瑁佸壀
    for (int y = 0; y < result.height; y++) {
      for (int x = 0; x < result.width; x++) {
        // 灏嗙洰鏍囧潗鏍囨槧灏勫洖婧愬浘鍍忓潗鏍?
        final srcX = cos * (x - region.width / 2) -
            sin * (y - region.height / 2) +
            center.dx;
        final srcY = sin * (x - region.width / 2) +
            cos * (y - region.height / 2) +
            center.dy;

        // 鍙岀嚎鎬ф彃鍊艰幏鍙栧儚绱犲€?
        if (srcX >= 0 &&
            srcX < sourceImage.width - 1 &&
            srcY >= 0 &&
            srcY < sourceImage.height - 1) {
          // 鑾峰彇鍛ㄥ洿鍥涗釜鍍忕礌鐐?
          final x0 = srcX.floor();
          final y0 = srcY.floor();
          final x1 = x0 + 1;
          final y1 = y0 + 1;

          // 璁＄畻鎻掑€兼潈閲?
          final wx = srcX - x0;
          final wy = srcY - y0;

          // 鑾峰彇鍥涗釜瑙掔殑鍍忕礌鍊?
          final p00 = sourceImage.getPixel(x0, y0);
          final p01 = sourceImage.getPixel(x0, y1);
          final p10 = sourceImage.getPixel(x1, y0);
          final p11 = sourceImage.getPixel(x1, y1);

          // 杩涜鍙岀嚎鎬ф彃鍊?
          final r = ((1 - wx) * (1 - wy) * p00.r +
                  wx * (1 - wy) * p10.r +
                  (1 - wx) * wy * p01.r +
                  wx * wy * p11.r)
              .round();
          final g = ((1 - wx) * (1 - wy) * p00.g +
                  wx * (1 - wy) * p10.g +
                  (1 - wx) * wy * p01.g +
                  wx * wy * p11.g)
              .round();
          final b = ((1 - wx) * (1 - wy) * p00.b +
                  wx * (1 - wy) * p10.b +
                  (1 - wx) * wy * p01.b +
                  wx * wy * p11.b)
              .round();
          final a = ((1 - wx) * (1 - wy) * p00.a +
                  wx * (1 - wy) * p10.a +
                  (1 - wx) * wy * p01.a +
                  wx * wy * p11.a)
              .round();

          result.setPixelRgba(x, y, r, g, b, a);
        }
      }
    }

    return result;
  }

  Offset _rotatePoint(Offset point, Offset center, double rotation) {
    final dx = point.dx - center.dx;
    final dy = point.dy - center.dy;
    final cos = math.cos(rotation);
    final sin = math.sin(rotation);
    return Offset(
      center.dx + dx * cos - dy * sin,
      center.dy + dx * sin + dy * cos,
    );
  }

  static img.Image _addBorderToImage(img.Image source, bool isInverted) {
    const borderWidth = 1;
    final width = source.width + borderWidth * 2;
    final height = source.height + borderWidth * 2;
    final result = img.Image(width: width, height: height);

    isInverted
        ? img.fill(result, color: img.ColorRgb8(0, 0, 0))
        : img.fill(result, color: img.ColorRgb8(255, 255, 255));

    for (int y = 0; y < source.height; y++) {
      for (int x = 0; x < source.width; x++) {
        result.setPixel(
            x + borderWidth, y + borderWidth, source.getPixel(x, y));
      }
    }

    return result;
  }

  /// 妫€娴嬭疆寤?
  static DetectedOutline _detectOutline(
      img.Image binaryImage, bool isInverted) {
    final paddedImage = _addBorderToImage(binaryImage, isInverted);

    final width = paddedImage.width;
    final height = paddedImage.height;
    final visited = List.generate(
        height, (y) => List.generate(width, (x) => false, growable: false),
        growable: false);

    final allContours = <List<Offset>>[];

    var startPoint = _findFirstContourPoint(paddedImage, isInverted);
    if (startPoint != null) {
      final outerContour =
          _traceContour(paddedImage, visited, startPoint, isInverted);
      if (outerContour.length >= 4) {
        allContours.add(outerContour);
      }
    }

    for (int y = 1; y < height - 1; y++) {
      for (int x = 1; x < width - 1; x++) {
        if (visited[y][x] ||
            _isForegroundPixel(paddedImage.getPixel(x, y), isInverted)) {
          continue;
        }

        if (_isInnerContourPoint(paddedImage, x, y, isInverted)) {
          final innerStart = Offset(x.toDouble(), y.toDouble());
          final innerContour =
              _traceContour(paddedImage, visited, innerStart, isInverted);

          if (innerContour.length >= 4) {
            allContours.add(innerContour);
          }
        }
      }
    }

    const borderWidth = 1;
    final adjustedContours = allContours.map((contour) {
      return contour
          .map(
              (point) => Offset(point.dx - borderWidth, point.dy - borderWidth))
          .toList();
    }).toList();

    return DetectedOutline(
      boundingRect: Rect.fromLTWH(
          0, 0, binaryImage.width.toDouble(), binaryImage.height.toDouble()),
      contourPoints: adjustedContours,
    );
  }

  static Offset? _findFirstContourPoint(img.Image image, bool isInverted) {
    for (int y = 0; y < image.height; y++) {
      for (int x = 0; x < image.width; x++) {
        if (_isForegroundPixel(image.getPixel(x, y), isInverted) &&
            _isContourPoint(image, x, y, isInverted)) {
          return Offset(x.toDouble(), y.toDouble());
        }
      }
    }
    return null;
  }

  /// 鏌ユ壘涓嬩竴涓竟鐣屾柟鍚?
  static List<int>? _findNextBoundaryDirection(int x, int y, int width,
      int height, List<List<int>> allDirections, List<int> currentDir) {
    // 纭畾褰撳墠鏄摢涓竟鐣?
    bool isLeftBoundary = x == 0;
    bool isRightBoundary = x == width - 1;
    bool isTopBoundary = y == 0;
    bool isBottomBoundary = y == height - 1;

    // 寰幆灏濊瘯鍚勪釜鏂瑰悜锛屾壘鍒颁竴涓湁鏁堢殑杈圭晫鐐?
    int startIdx = allDirections.indexOf(currentDir);
    for (int i = 0; i < allDirections.length; i++) {
      int idx = (startIdx + i) % allDirections.length;
      List<int> dir = allDirections[idx];

      int nx = x + dir[0];
      int ny = y + dir[1];

      // 妫€鏌ユ槸鍚︿粛鍦ㄨ竟鐣屼笂涓旀槸鏈夋晥鍧愭爣
      if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
        // 纭繚鏂扮偣鑷冲皯鏈変竴杈瑰湪杈圭晫涓?
        if ((isLeftBoundary && nx == 0) ||
            (isRightBoundary && nx == width - 1) ||
            (isTopBoundary && ny == 0) ||
            (isBottomBoundary && ny == height - 1)) {
          return dir;
        }
      }
    }

    return null; // 娌℃壘鍒板悎閫傜殑杈圭晫鏂瑰悜
  }

  static bool _isContourPoint(img.Image image, int x, int y, bool isInverted) {
    if (!_isForegroundPixel(image.getPixel(x, y), isInverted)) {
      return false;
    }

    if (x == 0 || x == image.width - 1 || y == 0 || y == image.height - 1) {
      return true;
    }

    final neighbors = [
      [-1, 0],
      [1, 0],
      [0, -1],
      [0, 1]
    ];

    for (final dir in neighbors) {
      final nx = x + dir[0];
      final ny = y + dir[1];

      if (nx < 0 || nx >= image.width || ny < 0 || ny >= image.height) {
        continue;
      }

      if (!_isForegroundPixel(image.getPixel(nx, ny), isInverted)) {
        return true;
      }
    }

    return false;
  }

  static bool _isForegroundPixel(img.Pixel pixel, bool isInverted) {
    final luminance = img.getLuminanceRgb(pixel.r, pixel.g, pixel.b);
    return isInverted ? luminance >= 128 : luminance < 128;
  }

  static bool _isInnerContourPoint(
      img.Image image, int x, int y, bool isInverted) {
    if (_isForegroundPixel(image.getPixel(x, y), isInverted)) {
      return false;
    }

    final neighbors = [
      [-1, 0],
      [1, 0],
      [0, -1],
      [0, 1],
      [-1, -1],
      [-1, 1],
      [1, -1],
      [1, 1],
    ];

    for (final dir in neighbors) {
      final nx = x + dir[0];
      final ny = y + dir[1];

      if (nx < 0 || nx >= image.width || ny < 0 || ny >= image.height) {
        continue;
      }

      if (_isForegroundPixel(image.getPixel(nx, ny), isInverted)) {
        return true;
      }
    }

    return false;
  }

  static List<Offset> _traceContour(img.Image image, List<List<bool>> visited,
      Offset start, bool isInverted) {
    final contour = <Offset>[];
    var x = start.dx.toInt();
    var y = start.dy.toInt();
    final startX = x;
    final startY = y;

    const directions = [
      [1, 0],
      [1, 1],
      [0, 1],
      [-1, 1],
      [-1, 0],
      [-1, -1],
      [0, -1],
      [1, -1],
    ];

    do {
      contour.add(Offset(x.toDouble(), y.toDouble()));
      visited[y][x] = true;

      var found = false;
      for (final dir in directions) {
        // 濡傛灉褰撳墠鐐规槸杈圭晫鐐癸紝鏍囪涓哄凡鎵惧埌锛岀户缁部鐫€杈圭晫绉诲姩

        final nx = x + dir[0];
        final ny = y + dir[1];

        if (nx < 0 || nx >= image.width || ny < 0 || ny >= image.height) {
// 濡傛灉褰撳墠鐐规槸杈圭晫鐐癸紝鏍囪涓哄凡鎵惧埌锛岀户缁部鐫€杈圭晫绉诲姩
          if (x == 0 ||
              x == image.width - 1 ||
              y == 0 ||
              y == image.height - 1) {
            // 灏濊瘯绉诲姩鍒颁笅涓€涓竟鐣岀偣 - 娌跨潃杈圭晫绉诲姩
            final nextBoundaryDir = _findNextBoundaryDirection(
                x, y, image.width, image.height, directions, dir);
            if (nextBoundaryDir != null) {
              x += nextBoundaryDir[0];
              y += nextBoundaryDir[1];
              found = true;
              break;
            }
          }
          continue;
        }

        if (visited[ny][nx]) {
          if (nx == startX && ny == startY && contour.length > 3) {
            contour.add(start);
            return contour;
          }
          continue;
        }

        if (_isForegroundPixel(image.getPixel(nx, ny), isInverted) &&
            _isContourPoint(image, nx, ny, isInverted)) {
          x = nx;
          y = ny;
          found = true;
          break;
        }
      }

      if (!found || contour.length > 400000) {
        break;
      }
    } while (true);

    return contour;
  }
}

/// 鍥惧儚澶勭悊寮傚父
class ImageProcessingException implements Exception {
  final String message;
  ImageProcessingException(this.message);
  @override
  String toString() => 'ImageProcessingException: $message';
}

/// 棰勮缁撴灉
class PreviewResult {
  final img.Image processedImage;
  final DetectedOutline? outline;

  PreviewResult({
    required this.processedImage,
    this.outline,
  });
}

/// 鍥惧儚澶勭悊鍙傛暟
class ProcessingParams {
  final Uint8List imageData;
  final Rect region;
  final double rotation;
  final ProcessingOptions options;
  final List<Map<String, dynamic>>? erasePaths;

  const ProcessingParams({
    required this.imageData,
    required this.region,
    this.rotation = 0.0,
    required this.options,
    this.erasePaths,
  });

  bool get isRegionValid =>
      region.left >= 0 &&
      region.top >= 0 &&
      region.width > 0 &&
      region.height > 0;
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\application\services\image\erase_manager.dart
-----------------------------------
import 'dart:typed_data';

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../domain/models/character/undo_action.dart';

final eraseManagerProvider = Provider<EraseManager>((ref) {
  return EraseManager();
});

class EraseManager {
  // 瀛樺偍鎵€鏈夋摝闄よ矾寰?
  final List<List<Offset>> _erasePaths = [];

  // 褰撳墠姝ｅ湪缁樺埗鐨勮矾寰?
  List<Offset>? _currentPath;

  // 鎾ら攢鏍?
  final List<UndoAction> _undoStack = [];

  // 閲嶅仛鏍?
  final List<UndoAction> _redoStack = [];

  // 绗斿埛澶у皬锛堢洿寰勶級
  double _brushSize = 10.0;

  // 鑾峰彇绗斿埛澶у皬
  double get brushSize => _brushSize;

  // 鏄惁鏈夊彲閲嶅仛鐨勬搷浣?
  bool get canRedo => _redoStack.isNotEmpty;

  // 鏄惁鏈夊彲鎾ら攢鐨勬搷浣?
  bool get canUndo => _undoStack.isNotEmpty;

  // 鑾峰彇鎵€鏈夋摝闄よ矾寰?
  List<List<Offset>> get erasePaths => List.unmodifiable(_erasePaths);

  // 娓呴櫎鎵€鏈夋摝闄?
  void clearErase() {
    if (_erasePaths.isNotEmpty) {
      // 淇濆瓨褰撳墠鐘舵€佺敤浜庢挙閿€
      _undoStack.add(UndoAction(
        type: UndoActionType.batch,
        data: List.from(_erasePaths),
      ));

      // 娓呯┖璺緞
      _erasePaths.clear();

      // 娓呯┖閲嶅仛鏍?
      _redoStack.clear();
    }
  }

  // 缁х画鎿﹂櫎鎿嶄綔
  void continueErase(Offset position) {
    if (_currentPath != null) {
      _currentPath!.add(position);
    }
  }

  // 缁撴潫鎿﹂櫎鎿嶄綔
  void endErase() {
    if (_currentPath != null && _currentPath!.isNotEmpty) {
      // 淇濆瓨褰撳墠璺緞
      _erasePaths.add(List.from(_currentPath!));

      // 鍒涘缓鎾ら攢鎿嶄綔
      _undoStack.add(UndoAction(
        type: UndoActionType.erase,
        data: {
          'pathIndex': _erasePaths.length - 1,
          'path': List.from(_currentPath!),
        },
      ));

      // 娓呯┖閲嶅仛鏍?
      _redoStack.clear();

      // 閲嶇疆褰撳墠璺緞
      _currentPath = null;
    }
  }

  // 鐢熸垚鎿﹂櫎閬僵鍥惧儚
  Uint8List? generateEraseMask(Size imageSize) {
    if (_erasePaths.isEmpty) return null;

    // 杩欓噷闇€瑕侀泦鎴愬浘鍍忓鐞嗗簱鏉ョ敓鎴愬疄闄呯殑鎿﹂櫎閬僵
    // 渚嬪浣跨敤Flutter鐨凜anvas缁樺埗鍒颁竴涓嚜瀹氫箟鐨勫浘鍍忎笂

    // 姝ゅ涓虹ず渚嬶紝瀹為檯瀹炵幇闇€瑕佷笌鍥惧儚澶勭悊閫昏緫闆嗘垚
    return Uint8List(0);
  }

  // 鍒ゆ柇鐐规槸鍚﹀湪鎿﹂櫎鍖哄煙鍐?
  bool isPointErased(Offset point) {
    for (final path in _erasePaths) {
      for (final erasePoint in path) {
        final distance = (point - erasePoint).distance;
        if (distance <= _brushSize / 2) {
          return true;
        }
      }
    }
    return false;
  }

  // 浠庡凡鏈夎矾寰勫姞杞?
  void loadFromPaths(List<List<Offset>> paths) {
    // 娓呯┖褰撳墠鐘舵€?
    _erasePaths.clear();
    _undoStack.clear();
    _redoStack.clear();

    // 娣诲姞鎵€鏈夎矾寰?
    if (paths.isNotEmpty) {
      _erasePaths.addAll(paths.map((path) => List<Offset>.from(path)));
    }
  }

  // 閲嶅仛鎿嶄綔
  bool redo() {
    if (!canRedo) return false;

    final action = _redoStack.removeLast();
    _undoStack.add(action);

    if (action.type == UndoActionType.erase) {
      final path = action.data['path'] as List<Offset>;
      _erasePaths.add(path);
    }

    return true;
  }

  // 閲嶇疆鎵€鏈夌姸鎬?
  void reset() {
    _erasePaths.clear();
    _currentPath = null;
    _undoStack.clear();
    _redoStack.clear();
  }

  // 璁剧疆绗斿埛澶у皬
  void setBrushSize(double size) {
    // 闄愬埗绗斿埛澶у皬鑼冨洿
    _brushSize = size.clamp(1.0, 50.0);
  }

  // 寮€濮嬫摝闄ゆ搷浣?
  void startErase(Offset position) {
    _currentPath = [position];
  }

  // 鎾ら攢鎿嶄綔
  bool undo() {
    if (!canUndo) return false;

    final action = _undoStack.removeLast();
    _redoStack.add(action);

    if (action.type == UndoActionType.erase) {
      final pathIndex = action.data['pathIndex'] as int;
      if (pathIndex >= 0 && pathIndex < _erasePaths.length) {
        _erasePaths.removeAt(pathIndex);
      }
    }

    return true;
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\application\services\image\erase_processor.dart
-----------------------------------
import 'dart:typed_data';
import 'dart:ui' as ui;

import 'package:flutter/foundation.dart';
import 'package:flutter/painting.dart';

/// 鎿﹂櫎澶勭悊鍣?
/// 璐熻矗澶勭悊鍥惧儚鎿﹂櫎鐨勫簳灞傞€昏緫
class EraseProcessor {
  /// 浠嶱NG鍥惧儚瀛楄妭鏁版嵁涓垱寤哄浘鍍?
  Future<ui.Image> createImageFromBytes(Uint8List bytes) async {
    final codec = await ui.instantiateImageCodec(bytes);
    final frameInfo = await codec.getNextFrame();
    return frameInfo.image;
  }

  /// 瀵瑰浘鍍忓簲鐢ㄦ摝闄ゆ搷浣?
  /// [sourceImage] 婧愬浘鍍?
  /// [points] 鎿﹂櫎鐐?
  /// [brushSize] 绗斿埛澶у皬
  /// 杩斿洖鎿﹂櫎鍚庣殑鍥惧儚
  Future<EraseResult> eraseImage({
    required ui.Image sourceImage,
    required List<Offset> points,
    required double brushSize,
  }) async {
    if (points.isEmpty) {
      return EraseResult(
        processedImage: sourceImage,
        success: true,
      );
    }

    try {
      // 鍒涘缓鍥剧墖璁板綍鍣?
      final recorder = ui.PictureRecorder();
      final canvas = Canvas(recorder);

      // 缁樺埗鍘熷鍥惧儚
      canvas.drawImage(sourceImage, Offset.zero, Paint());

      // 璁剧疆鎿﹂櫎鐢荤瑪
      final paint = Paint()
        ..color = const Color(0x00000000) // 閫忔槑鑹?
        ..strokeWidth = brushSize
        ..strokeCap = StrokeCap.round
        ..strokeJoin = StrokeJoin.round
        ..style = PaintingStyle.stroke
        ..blendMode = BlendMode.clear; // 浣跨敤娓呴櫎娣峰悎妯″紡瀹炵幇鎿﹂櫎鏁堟灉

      // 鍒涘缓璺緞骞剁粯鍒?
      final path = Path();
      path.moveTo(points.first.dx, points.first.dy);

      for (int i = 1; i < points.length; i++) {
        path.lineTo(points[i].dx, points[i].dy);
      }

      canvas.drawPath(path, paint);

      // 瀹屾垚缁樺埗骞惰幏鍙栧浘鍍?
      final picture = recorder.endRecording();
      final image = await picture.toImage(
        sourceImage.width,
        sourceImage.height,
      );

      return EraseResult(
        processedImage: image,
        success: true,
      );
    } catch (e) {
      return EraseResult(
        processedImage: sourceImage,
        success: false,
        errorMessage: 'Error processing erase operation: $e',
      );
    }
  }

  /// 灏嗗浘鍍忚浆鎹负瀛楄妭鏁版嵁
  Future<Uint8List> imageToBytes(ui.Image image) async {
    final byteData = await image.toByteData(format: ui.ImageByteFormat.png);
    return byteData!.buffer.asUint8List();
  }

  /// 寮傛澶勭悊鎿﹂櫎鎿嶄綔
  /// 杩欎釜鏂规硶鍙互鍦ㄩ殧绂诲尯(Isolate)涓繍琛屼互閬垮厤闃诲UI绾跨▼
  static Future<Uint8List> processEraseInIsolate(
      Map<String, dynamic> params) async {
    final processor = EraseProcessor();

    // 浠庡弬鏁颁腑鑾峰彇鍥惧儚鍜屾摝闄や俊鎭?
    final sourceImageBytes = params['sourceImageBytes'] as Uint8List;
    final points = (params['points'] as List)
        .map((e) => Offset((e as Map)['dx'] as double, e['dy'] as double))
        .toList();
    final brushSize = params['brushSize'] as double;

    // 鍒涘缓鍥惧儚
    final sourceImage = await processor.createImageFromBytes(sourceImageBytes);

    // 澶勭悊鎿﹂櫎
    final result = await processor.eraseImage(
      sourceImage: sourceImage,
      points: points,
      brushSize: brushSize,
    );

    // 杞崲鍥炲瓧鑺傛暟鎹?
    return await processor.imageToBytes(result.processedImage);
  }
}

/// 鎿﹂櫎澶勭悊缁撴灉
class EraseResult {
  /// 澶勭悊鍚庣殑鍥惧儚
  final ui.Image processedImage;

  /// 澶勭悊鏄惁鎴愬姛
  final bool success;

  /// 閿欒淇℃伅锛屽鏋滃鐞嗗け璐?
  final String? errorMessage;

  EraseResult({
    required this.processedImage,
    this.success = true,
    this.errorMessage,
  });
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\application\services\practice\practice_service.dart
-----------------------------------
import '../../../domain/models/practice/practice_entity.dart';
import '../../../domain/models/practice/practice_filter.dart';
import '../../../domain/repositories/practice_repository.dart';

/// 瀛楀笘缁冧範鏈嶅姟
class PracticeService {
  final PracticeRepository _repository;

  const PracticeService({
    required PracticeRepository repository,
  }) : _repository = repository;

  /// 鍒涘缓瀛楀笘缁冧範
  Future<PracticeEntity> createPractice({
    required String title,
    List<String> tags = const [],
    String status = 'active',
  }) async {
    final practice = PracticeEntity.create(
      title: title,
      tags: tags,
      status: status,
    );
    return _repository.save(practice);
  }

  /// 鍒犻櫎瀛楀笘缁冧範
  Future<void> deletePractice(String id) {
    return _repository.delete(id);
  }

  /// 鎵归噺鍒犻櫎瀛楀笘缁冧範
  Future<void> deletePractices(List<String> ids) {
    return _repository.deleteMany(ids);
  }

  /// 澶嶅埗瀛楀笘缁冧範
  Future<PracticeEntity> duplicatePractice(String id) {
    return _repository.duplicate(id);
  }

  /// 鑾峰彇鎵€鏈夊瓧甯栫粌涔?
  Future<List<PracticeEntity>> getAllPractices() {
    return _repository.getAll();
  }

  /// 鑾峰彇鎵€鏈夋爣绛?
  Future<Set<String>> getAllTags() {
    return _repository.getAllTags();
  }

  /// 鑾峰彇瀛楀笘缁冧範
  Future<PracticeEntity?> getPractice(String id) {
    return _repository.get(id);
  }

  /// 鏌ヨ瀛楀笘缁冧範
  Future<List<PracticeEntity>> queryPractices(PracticeFilter filter) {
    return _repository.query(filter);
  }

  /// 鎼滅储瀛楀笘缁冧範
  Future<List<PracticeEntity>> searchPractices(String query, {int? limit}) {
    return _repository.search(query, limit: limit);
  }

  /// 鑾峰彇鏍囩寤鸿
  Future<List<String>> suggestTags(String prefix, {int limit = 10}) {
    return _repository.suggestTags(prefix, limit: limit);
  }

  /// 鏇存柊瀛楀笘缁冧範
  Future<PracticeEntity> updatePractice(PracticeEntity practice) {
    return _repository.save(practice);
  }

  /// 鎵归噺鏇存柊瀛楀笘缁冧範
  Future<List<PracticeEntity>> updatePractices(List<PracticeEntity> practices) {
    return _repository.saveMany(practices);
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\application\services\restoration\state_restoration_service.dart
-----------------------------------
import 'dart:convert';
import 'dart:io';

import 'package:path_provider/path_provider.dart';
import 'package:shared_preferences/shared_preferences.dart';

import '../../../domain/models/work/work_entity.dart';
import '../../../infrastructure/logging/logger.dart';
import '../../../presentation/providers/work_detail_provider.dart';
import '../../../presentation/viewmodels/states/work_browse_state.dart';

/// 璐熻矗淇濆瓨鍜屾仮澶嶅簲鐢ㄧ姸鎬?
class StateRestorationService {
  // 閿墠缂€甯搁噺
  static const _workEditStatePrefix = 'work_edit_state_';
  static const _workEditTimestampPrefix = 'work_edit_timestamp_';

  // 娴忚椤电浉鍏抽敭
  static const String _workBrowseStateKey = 'work_browse_state';
  static const String _workBrowseTimestampKey = 'work_browse_timestamp';

  // 鐘舵€佹湁鏁堟湡锛堟绉掞級锛岄粯璁?4灏忔椂
  static const _stateValidityPeriod = 24 * 60 * 60 * 1000;

  final SharedPreferences _prefs;

  StateRestorationService(this._prefs) {
    _checkFirstRun();
  }

  /// 妫€鏌ョ紪杈戜細璇濈姸鎬?
  Future<String> checkEditSessions() async {
    try {
      final keys = _prefs.getKeys();
      final editStateKeys =
          keys.where((key) => key.startsWith('work_edit_state_'));
      return '${editStateKeys.length}涓椿鍔ㄧ紪杈戜細璇?;
    } catch (e) {
      AppLogger.error('妫€鏌ョ紪杈戜細璇濆け璐?, tag: 'StateRestorationService', error: e);
      return '鏈煡';
    }
  }

  /// 娓呴櫎浜у搧娴忚椤电姸鎬?
  Future<void> clearWorkBrowseState() async {
    try {
      await _prefs.remove(_workBrowseStateKey);
      await _prefs.remove(_workBrowseTimestampKey);

      AppLogger.debug('宸叉竻闄ゆ祻瑙堥〉鐘舵€?, tag: 'StateRestorationService');
    } catch (e, stack) {
      AppLogger.error(
        '娓呴櫎娴忚椤电姸鎬佸け璐?,
        tag: 'StateRestorationService',
        error: e,
        stackTrace: stack,
      );
    }
  }

  /// 娓呴櫎鐗瑰畾浣滃搧鐨勭紪杈戠姸鎬?
  Future<void> clearWorkEditState(String workId) async {
    try {
      final stateKey = '$_workEditStatePrefix$workId';
      final timestampKey = '$_workEditTimestampPrefix$workId';

      await _prefs.remove(stateKey);
      await _prefs.remove(timestampKey);

      AppLogger.debug('宸叉竻闄ょ紪杈戠姸鎬?,
          tag: 'StateRestorationService', data: {'workId': workId});
    } catch (e, stack) {
      AppLogger.error(
        '娓呴櫎缂栬緫鐘舵€佸け璐?,
        tag: 'StateRestorationService',
        error: e,
        stackTrace: stack,
        data: {'workId': workId},
      );
    }
  }

  /// 鑾峰彇SharedPreferences涓殑鏉＄洰鏁?
  Future<String> getPreferencesEntryCount() async {
    try {
      final keys = _prefs.getKeys();
      return keys.length.toString();
    } catch (e) {
      AppLogger.error(
        '鑾峰彇Preferences鏉＄洰鏁板け璐?,
        tag: 'StateRestorationService',
        error: e,
      );
    }
    return '鏈煡';
  }

  /// 鑾峰彇SharedPreferences鏂囦欢鐨勫ぇ灏?
  Future<String> getPreferencesFileSize() async {
    try {
      final path = await getPreferencesPath();
      final file = File(path);
      if (await file.exists()) {
        final size = await file.length();
        return '${(size / 1024).toStringAsFixed(2)} KB';
      }
    } catch (e) {
      AppLogger.error(
        '鑾峰彇Preferences鏂囦欢澶у皬澶辫触',
        tag: 'StateRestorationService',
        error: e,
      );
    }
    return '鏈煡';
  }

  /// 鑾峰彇SharedPreferences鏂囦欢鐨勮矾寰?
  Future<String> getPreferencesPath() async {
    final appDataDir = Platform.isWindows
        ? Platform.environment['LOCALAPPDATA']
        : Platform.environment['HOME'];

    if (appDataDir == null) {
      return '鏈煡';
    }

    return '$appDataDir/SharedPreferences.json';
  }

  /// 鑾峰彇鐘舵€佸瓨鍌ㄤ綅缃?
  Future<String> getStorageLocation() async {
    try {
      final appDir = await getApplicationDocumentsDirectory();
      return appDir.path;
    } catch (e) {
      AppLogger.error('鑾峰彇瀛樺偍浣嶇疆澶辫触', tag: 'StateRestorationService', error: e);
      return '鏈煡';
    }
  }

  /// 妫€鏌ユ槸鍚︽湁鏈畬鎴愮殑缂栬緫浼氳瘽
  Future<bool> hasUnfinishedEditSession(String workId) async {
    try {
      final stateKey = '$_workEditStatePrefix$workId';
      final timestampKey = '$_workEditTimestampPrefix$workId';

      // 妫€鏌ョ姸鎬佹槸鍚﹀瓨鍦?
      final hasState = _prefs.containsKey(stateKey);
      if (!hasState) return false;

      // 妫€鏌ョ姸鎬佹槸鍚﹁繃鏈?
      final timestamp = _prefs.getInt(timestampKey) ?? 0;
      final currentTime = DateTime.now().millisecondsSinceEpoch;

      if (currentTime - timestamp > _stateValidityPeriod) {
        // 鐘舵€佸凡杩囨湡锛岃嚜鍔ㄦ竻鐞?
        await clearWorkEditState(workId);
        return false;
      }

      return true;
    } catch (e) {
      AppLogger.error(
        '妫€鏌ユ湭瀹屾垚缂栬緫浼氳瘽澶辫触',
        tag: 'StateRestorationService',
        error: e,
        data: {'workId': workId},
      );
      return false;
    }
  }

  /// 妫€鏌ユ槸鍚︽湁淇濆瓨鐨勬祻瑙堥〉鐘舵€?
  Future<bool> hasWorkBrowseState() async {
    try {
      // 妫€鏌ョ姸鎬佹槸鍚﹀瓨鍦?
      final hasState = _prefs.containsKey(_workBrowseStateKey);
      if (!hasState) return false;

      // 妫€鏌ョ姸鎬佹槸鍚﹁繃鏈?
      final timestamp = _prefs.getInt(_workBrowseTimestampKey) ?? 0;
      final currentTime = DateTime.now().millisecondsSinceEpoch;

      if (currentTime - timestamp > _stateValidityPeriod) {
        // 鐘舵€佸凡杩囨湡锛岃嚜鍔ㄦ竻鐞?
        await clearWorkBrowseState();
        return false;
      }

      return true;
    } catch (e) {
      AppLogger.error(
        '妫€鏌ユ祻瑙堥〉鐘舵€佸け璐?,
        tag: 'StateRestorationService',
        error: e,
      );
      return false;
    }
  }

  /// 鎭㈠浜у搧娴忚椤电姸鎬?
  Future<WorkBrowseState?> restoreWorkBrowseState() async {
    try {
      // 鑾峰彇淇濆瓨鐨勭姸鎬?
      AppLogger.debug(
        '灏濊瘯鎭㈠WorkBrowseState',
        tag: 'StateRestorationService',
      );

      final stateJson = _prefs.getString(_workBrowseStateKey);
      if (stateJson == null) {
        AppLogger.debug(
          '娌℃湁鎵惧埌宸蹭繚瀛樼殑鐘舵€侊紝杩斿洖null',
          tag: 'StateRestorationService',
        );
        return null;
      }

      // 瑙ｆ瀽鐘舵€?
      AppLogger.debug(
        '寮€濮嬭В鏋愮姸鎬丣SON',
        tag: 'StateRestorationService',
        data: {'stateJson': stateJson},
      );

      try {
        final stateMap = jsonDecode(stateJson) as Map<String, dynamic>;

        // 鍒涘缓鐘舵€佸璞?
        final restoredState = WorkBrowseState.fromJson(stateMap);

        AppLogger.debug(
          '鐘舵€佹仮澶嶆垚鍔?,
          tag: 'StateRestorationService',
          data: {
            'filter': {
              'style': restoredState.filter.style?.name,
              'tool': restoredState.filter.tool?.name,
            }
          },
        );

        return restoredState;
      } catch (parseError) {
        AppLogger.error(
          'JSON瑙ｆ瀽澶辫触',
          tag: 'StateRestorationService',
          error: parseError,
          data: {'stateJson': stateJson},
        );
        // 濡傛灉JSON瑙ｆ瀽澶辫触锛屾竻闄ゅ瓨鍌ㄧ殑鐘舵€佸苟杩斿洖null
        await clearWorkBrowseState();
        return null;
      }
    } catch (e, stack) {
      AppLogger.error(
        '鎭㈠娴忚椤电姸鎬佸け璐?,
        tag: 'StateRestorationService',
        error: e,
        stackTrace: stack,
      );
      return null;
    }
  }

  /// 鎭㈠浣滃搧鐨勭紪杈戠姸鎬?
  Future<WorkDetailState?> restoreWorkEditState(String workId) async {
    try {
      final stateKey = '$_workEditStatePrefix$workId';

      // 鑾峰彇淇濆瓨鐨勭姸鎬?
      final stateJson = _prefs.getString(stateKey);
      if (stateJson == null) return null;

      // 瑙ｆ瀽鐘舵€?
      final stateMap = jsonDecode(stateJson) as Map<String, dynamic>;

      // 鎭㈠ WorkEntity 瀵硅薄
      WorkEntity? editingWork;
      if (stateMap.containsKey('editingWork')) {
        try {
          final workMap = stateMap['editingWork'] as Map<String, dynamic>;
          editingWork = WorkEntity.fromJson(workMap);
        } catch (e) {
          AppLogger.error(
            '鎭㈠浣滃搧瀹炰綋澶辫触',
            tag: 'StateRestorationService',
            error: e,
            data: {'workId': workId},
          );
        }
      }

      // 鎭㈠鍩烘湰鐘舵€佸睘鎬?
      final isEditing = stateMap['isEditing'] as bool? ?? false;
      final hasChanges = stateMap['hasChanges'] as bool? ?? false;
      final historyIndex = stateMap['historyIndex'] as int? ?? -1;

      // 杩斿洖鎭㈠鐨勭姸鎬侊紙娉ㄦ剰: 鍛戒护鍘嗗彶鏃犳硶浠?JSON 鎭㈠锛屽洜涓哄畠鍖呭惈鏈嶅姟渚濊禆锛?
      return WorkDetailState(
        isEditing: isEditing,
        editingWork: editingWork,
        hasChanges: hasChanges,
        historyIndex: historyIndex,
      );
    } catch (e, stack) {
      AppLogger.error(
        '鎭㈠缂栬緫鐘舵€佸け璐?,
        tag: 'StateRestorationService',
        error: e,
        stackTrace: stack,
        data: {'workId': workId},
      );
      return null;
    }
  }

  /// 淇濆瓨浜у搧娴忚椤电姸鎬?
  Future<void> saveWorkBrowseState(WorkBrowseState state) async {
    try {
      // 杞崲鐘舵€佷负 JSON
      final stateMap = state.toJson();
      AppLogger.debug(
        '鍑嗗淇濆瓨鐘舵€?,
        tag: 'StateRestorationService',
        data: {
          'filter': {
            'style': state.filter.style?.name,
            'tool': state.filter.tool?.name,
          }
        },
      );

      final stateJson = jsonEncode(stateMap);

      // 淇濆瓨鐘舵€佸拰鏃堕棿鎴?
      await _prefs.setString(_workBrowseStateKey, stateJson);
      await _prefs.setInt(
          _workBrowseTimestampKey, DateTime.now().millisecondsSinceEpoch);

      AppLogger.debug(
        '鐘舵€佷繚瀛樻垚鍔?,
        tag: 'StateRestorationService',
      );
    } catch (e, stack) {
      AppLogger.error(
        '淇濆瓨娴忚椤电姸鎬佸け璐?,
        tag: 'StateRestorationService',
        error: e,
        stackTrace: stack,
      );
    }
  }

  /// 淇濆瓨浣滃搧鐨勭紪杈戠姸鎬?
  Future<void> saveWorkEditState(String workId, WorkDetailState state) async {
    try {
      if (state.editingWork == null) return;

      final stateKey = '$_workEditStatePrefix$workId';
      final timestampKey = '$_workEditTimestampPrefix$workId';

      // 鍑嗗瑕佷繚瀛樼殑鏁版嵁
      final stateMap = {
        'isEditing': state.isEditing,
        'hasChanges': state.hasChanges,
        'historyIndex': state.historyIndex,
      };

      // 淇濆瓨 WorkEntity
      try {
        stateMap['editingWork'] = state.editingWork!.toJson();
      } catch (e) {
        AppLogger.error(
          '搴忓垪鍖栦綔鍝佸疄浣撳け璐?,
          tag: 'StateRestorationService',
          error: e,
          data: {'workId': workId},
        );
      }

      // 淇濆瓨鐘舵€佸拰鏃堕棿鎴?
      final stateJson = jsonEncode(stateMap);
      await _prefs.setString(stateKey, stateJson);
      await _prefs.setInt(timestampKey, DateTime.now().millisecondsSinceEpoch);

      AppLogger.debug('宸蹭繚瀛樼紪杈戠姸鎬?,
          tag: 'StateRestorationService', data: {'workId': workId});
    } catch (e, stack) {
      AppLogger.error(
        '淇濆瓨缂栬緫鐘舵€佸け璐?,
        tag: 'StateRestorationService',
        error: e,
        stackTrace: stack,
        data: {'workId': workId},
      );
    }
  }

  /// 妫€鏌ユ槸鍚﹂娆¤繍琛岋紝濡傛灉鏄垯娓呴櫎鎵€鏈夌姸鎬?
  void _checkFirstRun() {
    final firstRun = _prefs.getBool('first_run') ?? true;
    if (firstRun) {
      _prefs.remove(_workBrowseStateKey);
      _prefs.remove(_workBrowseTimestampKey);
      _prefs.setBool('first_run', false);
      AppLogger.info(
        '棣栨杩愯锛屽凡娓呴櫎鎵€鏈夊凡淇濆瓨鐘舵€?,
        tag: 'StateRestorationService',
      );
    }
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\application\services\storage\cache_manager.dart
-----------------------------------
import 'dart:convert';
import 'dart:io';
import 'dart:typed_data';

import 'package:crypto/crypto.dart' as crypto;
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:path/path.dart' as path;
import 'package:path_provider/path_provider.dart';

final cacheManagerProvider = Provider<CacheManager>((ref) {
  return CacheManager();
});

class CacheManager {
  // 鍐呭瓨缂撳瓨锛岀敤浜庡揩閫熻闂?
  late final LruCache<String, Uint8List> _memoryCache;

  // 缂撳瓨鐩綍
  late String _cachePath;

  // 鏄惁宸插垵濮嬪寲
  bool _initialized = false;

  // 缂撳瓨澶у皬涓婇檺锛堝瓧鑺傦級
  final int _maxCacheSize = 100 * 1024 * 1024; // 100MB

  // 褰撳墠缂撳瓨澶у皬
  int _currentCacheSize = 0;

  CacheManager() {
    _memoryCache = LruCache<String, Uint8List>(capacity: 20); // 鏈€澶?0涓」鐩?
    _init();
  }

  // 娓呯┖鎵€鏈夌紦瀛?
  Future<void> clear() async {
    await _ensureInitialized();

    // 娓呯┖鍐呭瓨缂撳瓨
    _memoryCache.clear();

    // 娓呯┖鏂囦欢缂撳瓨
    try {
      final dir = Directory(_cachePath);
      if (await dir.exists()) {
        await dir.delete(recursive: true);
        await dir.create();
      }

      // 閲嶇疆缂撳瓨澶у皬
      _currentCacheSize = 0;
    } catch (e) {
      print('娓呯┖缂撳瓨澶辫触: $e');
    }
  }

  // 鑾峰彇缂撳瓨椤?
  Future<Uint8List?> get(String key) async {
    await _ensureInitialized();

    // 鍏堝皾璇曚粠鍐呭瓨缂撳瓨鑾峰彇
    final memCached = _memoryCache.get(key);
    if (memCached != null) {
      return memCached;
    }

    // 浠庢枃浠剁紦瀛樿幏鍙?
    try {
      final hashedKey = _hashKey(key);
      final cacheFile = File(path.join(_cachePath, hashedKey));

      if (await cacheFile.exists()) {
        final data = await cacheFile.readAsBytes();

        // 鏇存柊鍐呭瓨缂撳瓨
        _memoryCache.put(key, data);

        return data;
      }
    } catch (e) {
      print('浠庣紦瀛樿幏鍙栨暟鎹け璐? $e');
    }

    return null;
  }

  // 鑾峰彇褰撳墠缂撳瓨澶у皬锛圡B锛?
  Future<double> getCacheSizeMB() async {
    await _ensureInitialized();
    return _currentCacheSize / (1024 * 1024);
  }

  // 绉婚櫎缂撳瓨椤?
  Future<void> invalidate(String key) async {
    await _ensureInitialized();

    // 浠庡唴瀛樼紦瀛樼Щ闄?
    _memoryCache.remove(key);

    // 浠庢枃浠剁紦瀛樼Щ闄?
    try {
      final hashedKey = _hashKey(key);
      final cacheFile = File(path.join(_cachePath, hashedKey));

      if (await cacheFile.exists()) {
        final stat = await cacheFile.stat();
        await cacheFile.delete();

        // 鏇存柊缂撳瓨澶у皬
        _currentCacheSize -= stat.size;
      }
    } catch (e) {
      print('浠庣紦瀛樼Щ闄ゆ暟鎹け璐? $e');
    }
  }

  // 瀛樺偍缂撳瓨椤?
  Future<void> put(String key, Uint8List data) async {
    await _ensureInitialized();

    // 鏇存柊鍐呭瓨缂撳瓨
    _memoryCache.put(key, data);

    // 鏇存柊鏂囦欢缂撳瓨
    try {
      final hashedKey = _hashKey(key);
      final cacheFile = File(path.join(_cachePath, hashedKey));

      await cacheFile.writeAsBytes(data);

      // 鏇存柊缂撳瓨澶у皬
      _currentCacheSize += data.length;

      // 妫€鏌ユ槸鍚﹂渶瑕佹竻鐞嗙紦瀛?
      if (_currentCacheSize > _maxCacheSize) {
        await _trimCache();
      }
    } catch (e) {
      print('缂撳瓨鏁版嵁澶辫触: $e');
    }
  }

  // 璁＄畻褰撳墠缂撳瓨澶у皬
  Future<void> _calculateCacheSize() async {
    _currentCacheSize = 0;
    final dir = Directory(_cachePath);
    if (await dir.exists()) {
      await for (final file in dir.list(recursive: true, followLinks: false)) {
        if (file is File) {
          final stat = await file.stat();
          _currentCacheSize += stat.size;
        }
      }
    }
  }

  // 纭繚鍒濆鍖栧畬鎴?
  Future<void> _ensureInitialized() async {
    if (!_initialized) {
      await _init();
    }
  }

  // 瀵圭紦瀛橀敭杩涜鍝堝笇澶勭悊锛岄伩鍏嶆棤鏁堢殑鏂囦欢鍚?
  String _hashKey(String key) {
    final bytes = utf8.encode(key);
    final digest = crypto.md5.convert(bytes);
    return digest.toString();
  }

  // 寮傛鍒濆鍖?
  Future<void> _init() async {
    if (_initialized) return;

    try {
      final cacheDir = await getTemporaryDirectory();
      _cachePath = path.join(cacheDir.path, 'character_cache');

      // 纭繚缂撳瓨鐩綍瀛樺湪
      final dir = Directory(_cachePath);
      if (!await dir.exists()) {
        await dir.create(recursive: true);
      }

      // 璁＄畻褰撳墠缂撳瓨澶у皬
      await _calculateCacheSize();

      _initialized = true;
    } catch (e) {
      print('鍒濆鍖栫紦瀛樼鐞嗗櫒澶辫触: $e');
    }
  }

  // 瑁佸壀缂撳瓨锛屽垹闄ゆ渶鏃х殑鏂囦欢鐩村埌澶у皬鍚堥€?
  Future<void> _trimCache() async {
    try {
      final dir = Directory(_cachePath);
      if (!await dir.exists()) return;

      // 鑾峰彇鎵€鏈夌紦瀛樻枃浠跺苟鎸変慨鏀规椂闂存帓搴?
      final files = await dir.list().where((entity) => entity is File).toList();

      // 鍏堟敹闆嗘枃浠朵俊鎭啀鎺掑簭
      final fileInfos = <MapEntry<File, FileStat>>[];
      for (final entity in files) {
        if (entity is File) {
          final stat = await entity.stat();
          fileInfos.add(MapEntry(entity, stat));
        }
      }

      // 鎸変慨鏀规椂闂存帓搴?
      fileInfos.sort((a, b) => a.value.modified.compareTo(b.value.modified));

      // 鍒犻櫎鏂囦欢鐩村埌缂撳瓨澶у皬鍦ㄩ檺鍒惰寖鍥村唴
      for (final entity in files) {
        if (_currentCacheSize <= _maxCacheSize * 0.8) {
          // 濡傛灉缂撳瓨澶у皬宸插噺灏戝埌涓婇檺鐨?0%锛屽垯鍋滄鍒犻櫎
          break;
        }

        if (entity is File) {
          final stat = await entity.stat();
          await entity.delete();
          _currentCacheSize -= stat.size;
        }
      }
    } catch (e) {
      print('瑁佸壀缂撳瓨澶辫触: $e');
    }
  }
}

// LRU缂撳瓨杈呭姪绫?
class LruCache<K, V> {
  final int capacity;
  final Map<K, V> _cache = {};
  final List<K> _keys = [];

  LruCache({required this.capacity});

  // 鑾峰彇鎵€鏈夐敭
  Set<K> get keys => _cache.keys.toSet();

  // 鑾峰彇缂撳瓨澶у皬
  int get size => _cache.length;

  // 娓呯┖缂撳瓨
  void clear() {
    _cache.clear();
    _keys.clear();
  }

  // 鑾峰彇缂撳瓨椤?
  V? get(K key) {
    if (!_cache.containsKey(key)) return null;

    // 鏇存柊璁块棶椤哄簭
    _keys.remove(key);
    _keys.add(key);

    return _cache[key];
  }

  // 瀛樺偍缂撳瓨椤?
  void put(K key, V value) {
    if (_cache.containsKey(key)) {
      _keys.remove(key);
    } else if (_keys.length >= capacity) {
      // 绉婚櫎鏈€杩戞渶灏戜娇鐢ㄧ殑椤?
      final oldestKey = _keys.removeAt(0);
      _cache.remove(oldestKey);
    }

    _cache[key] = value;
    _keys.add(key);
  }

  // 绉婚櫎缂撳瓨椤?
  void remove(K key) {
    if (_cache.containsKey(key)) {
      _cache.remove(key);
      _keys.remove(key);
    }
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\application\services\storage\character_storage_service.dart
-----------------------------------
import 'dart:io';
import 'dart:typed_data';

import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:path/path.dart' as path;
import 'package:path_provider/path_provider.dart';
import 'package:image/image.dart' as img;

final characterStorageServiceProvider =
    Provider<CharacterStorageService>((ref) {
  return CharacterStorageService();
});

// 杈呭姪鍑芥暟锛氳В鏋怞SON
Map<String, dynamic> jsonDecode(String jsonString) {
  // 绠€鍗曞疄鐜帮紝瀹為檯搴斾娇鐢╠art:convert搴?
  return {};
}

// 杈呭姪鍑芥暟锛氬瓧绗︿覆鍖朖SON
String jsonEncode(Map<String, dynamic> json) {
  // 绠€鍗曞疄鐜帮紝瀹為檯搴斾娇鐢╠art:convert搴?
  return json.toString();
}

class CharacterStorageService {
  // 瀛樺偍鏍圭洰褰?
  late String _baseStoragePath;

  // 瀛楃瀛樺偍瀛愮洰褰?
  late String _charactersPath;

  // 缂撳瓨鐩綍
  late String _cachePath;

  // 鏄惁宸插垵濮嬪寲
  bool _initialized = false;

  // 娓呯悊涓存椂鏂囦欢
  Future<void> cleanupTemporaryFiles() async {
    await _ensureInitialized();

    try {
      final cacheDir = Directory(_cachePath);
      if (await cacheDir.exists()) {
        // 鍒犻櫎7澶╁墠鍒涘缓鐨勬枃浠?
        final now = DateTime.now();
        await for (final entity in cacheDir.list()) {
          if (entity is File) {
            final stat = await entity.stat();
            final fileAge = now.difference(stat.modified).inDays;

            if (fileAge > 7) {
              await entity.delete();
            }
          }
        }
      }
    } catch (e) {
      print('娓呯悊涓存椂鏂囦欢澶辫触: $e');
    }
  }

  // 鍒犻櫎瀛楃鏁版嵁
  Future<void> deleteCharacter(String characterId) async {
    await _ensureInitialized();

    final characterDir = path.join(_charactersPath, characterId);
    final dir = Directory(characterDir);

    if (await dir.exists()) {
      await dir.delete(recursive: true);
    }
  }

  // 鑾峰彇浜屽€煎寲鍥惧儚璺緞
  Future<String> getBinaryImagePath(String characterId) async {
    final characterDir = await getCharacterDirectory(characterId);
    return path.join(characterDir, 'binary.png');
  }

  // 鑾峰彇瀛楃瀛樺偍鐩綍
  Future<String> getCharacterDirectory(String characterId) async {
    await _ensureInitialized();

    final characterDir = path.join(_charactersPath, characterId);
    await Directory(characterDir).create(recursive: true);

    return characterDir;
  }

  // 鑾峰彇鍏冩暟鎹?
  Future<Map<String, dynamic>?> getMetadata(String characterId) async {
    final characterDir = await getCharacterDirectory(characterId);
    final filePath = path.join(characterDir, 'metadata.json');

    final file = File(filePath);
    if (await file.exists()) {
      final jsonString = await file.readAsString();
      return jsonDecode(jsonString);
    }

    return null;
  }

  // 鑾峰彇鍘熷鍥惧儚璺緞
  Future<String> getOriginalImagePath(String characterId) async {
    final characterDir = await getCharacterDirectory(characterId);
    return path.join(characterDir, 'original.png');
  }

  // 鑾峰彇瀛樺偍淇℃伅
  Future<StorageInfo> getStorageInfo() async {
    await _ensureInitialized();

    try {
      // 鑾峰彇瀛楃鏁伴噺
      final charactersDir = Directory(_charactersPath);
      int characterCount = 0;
      if (await charactersDir.exists()) {
        final items = await charactersDir.list().toList();
        characterCount = items.whereType<Directory>().length;
      }

      // 鑾峰彇瀛樺偍澶у皬
      int totalSize = 0;
      await for (final entity in charactersDir.list(recursive: true)) {
        if (entity is File) {
          final stat = await entity.stat();
          totalSize += stat.size;
        }
      }

      return StorageInfo(
        characterCount: characterCount,
        totalSizeBytes: totalSize,
      );
    } catch (e) {
      print('鑾峰彇瀛樺偍淇℃伅澶辫触: $e');
      return StorageInfo(
        characterCount: 0,
        totalSizeBytes: 0,
      );
    }
  }

  // 鑾峰彇SVG杞粨璺緞
  Future<String?> getSvgOutlinePath(String characterId) async {
    final characterDir = await getCharacterDirectory(characterId);
    final filePath = path.join(characterDir, 'outline.svg');

    if (await File(filePath).exists()) {
      return filePath;
    }

    return null;
  }

  // 鑾峰彇缂╃暐鍥捐矾寰?
  Future<String> getThumbnailPath(String characterId) async {
    try {
      await _ensureInitialized();

      print('CharacterStorageService - 鑾峰彇缂╃暐鍥捐矾寰?- ID: $characterId');
      print('CharacterStorageService - 瀛樺偍鏍圭洰褰? $_baseStoragePath');
      print('CharacterStorageService - 瀛楃瀛樺偍鐩綍: $_charactersPath');

      final characterDir = await getCharacterDirectory(characterId);
      print('CharacterStorageService - 瀛楃鐩綍: $characterDir');

      final thumbnailPath = path.join(characterDir, 'thumbnail.jpg');
      print('CharacterStorageService - 瀹屾暣缂╃暐鍥捐矾寰? $thumbnailPath');

      // 妫€鏌ユ枃浠舵槸鍚﹀瓨鍦?
      final file = File(thumbnailPath);
      final exists = await file.exists();
      print(
          'CharacterStorageService - 缂╃暐鍥炬枃浠?{exists ? "瀛樺湪" : "涓嶅瓨鍦?}: $thumbnailPath');

      if (!exists) {
        print('CharacterStorageService - 缂╃暐鍥炬枃浠朵笉瀛樺湪锛屽皾璇曚粠鍘熷鍥惧儚鐢熸垚');
        try {
          // 鑾峰彇鍘熷鍥惧儚璺緞
          final originalPath = path.join(characterDir, 'original.png');
          final originalFile = File(originalPath);

          if (!await originalFile.exists()) {
            print('CharacterStorageService - 鍘熷鍥惧儚鏂囦欢涓嶅瓨鍦紝鏃犳硶鐢熸垚缂╃暐鍥?);
            return thumbnailPath;
          }

          // 璇诲彇鍘熷鍥惧儚
          final originalBytes = await originalFile.readAsBytes();
          if (originalBytes.isEmpty) {
            print('CharacterStorageService - 鍘熷鍥惧儚鏂囦欢涓虹┖');
            return thumbnailPath;
          }

          // 瑙ｇ爜鍥惧儚
          final image = img.decodeImage(originalBytes);
          if (image == null) {
            print('CharacterStorageService - 鏃犳硶瑙ｇ爜鍘熷鍥惧儚');
            return thumbnailPath;
          }

          // 鐢熸垚缂╃暐鍥?
          final thumbnail = img.copyResize(
            image,
            width: 100,
            height: 100,
            interpolation: img.Interpolation.average,
          );

          // 缂栫爜涓篔PEG
          final thumbnailBytes = Uint8List.fromList(
            img.encodeJpg(thumbnail, quality: 80),
          );

          // 淇濆瓨缂╃暐鍥?
          await file.writeAsBytes(thumbnailBytes);
          print('CharacterStorageService - 缂╃暐鍥剧敓鎴愭垚鍔?);

          // 楠岃瘉鐢熸垚鐨勬枃浠?
          final newExists = await file.exists();
          final fileSize = await file.length();
          print(
              'CharacterStorageService - 鏂扮敓鎴愮殑缂╃暐鍥炬枃浠?{newExists ? "瀛樺湪" : "涓嶅瓨鍦?}锛屽ぇ灏? $fileSize 瀛楄妭');
        } catch (e) {
          print('CharacterStorageService - 鐢熸垚缂╃暐鍥惧け璐? $e');
        }
      } else {
        // 楠岃瘉鐜版湁鏂囦欢
        try {
          final fileSize = await file.length();
          print('CharacterStorageService - 鐜版湁缂╃暐鍥炬枃浠跺ぇ灏? $fileSize 瀛楄妭');

          if (fileSize == 0) {
            print('CharacterStorageService - 鐜版湁缂╃暐鍥炬枃浠跺ぇ灏忎负0');
          } else {
            // 灏濊瘯璇诲彇鏂囦欢鍐呭
            final bytes = await file.readAsBytes();
            print('CharacterStorageService - 鎴愬姛璇诲彇缂╃暐鍥炬枃浠讹紝澶у皬: ${bytes.length} 瀛楄妭');
          }
        } catch (e) {
          print('CharacterStorageService - 楠岃瘉鐜版湁缂╃暐鍥炬枃浠跺け璐? $e');
        }
      }

      return thumbnailPath;
    } catch (e, stack) {
      print('CharacterStorageService - 鑾峰彇缂╃暐鍥捐矾寰勫紓甯? $e');
      print('$stack');
      rethrow;
    }
  }

  // 妫€鏌ュ瓨鍌ㄧ┖闂存槸鍚﹁冻澶?
  Future<bool> hasEnoughStorage(int requiredBytes) async {
    try {
      final appDir = await getApplicationDocumentsDirectory();
      final stat = await FileStat.stat(appDir.path);

      // 杩欐槸涓€涓矖鐣ョ殑瀹炵幇锛屽疄闄呭簲璇ヨ幏鍙栧彲鐢ㄧ┖闂?
      // 鐢变簬Flutter娌℃湁鐩存帴API鑾峰彇鍙敤绌洪棿锛岃繖閲岀畝鍖栧鐞?
      return true;
    } catch (e) {
      print('妫€鏌ュ瓨鍌ㄧ┖闂村け璐? $e');
      return false;
    }
  }

  // 淇濆瓨浜屽€煎寲鍥惧儚
  Future<String> saveBinaryImage(
      String characterId, Uint8List imageData) async {
    final characterDir = await getCharacterDirectory(characterId);

    final filePath = path.join(characterDir, 'binary.png');
    await File(filePath).writeAsBytes(imageData);

    return filePath;
  }

  // 淇濆瓨鍏冩暟鎹?
  Future<void> saveMetadata(
      String characterId, Map<String, dynamic> metadata) async {
    final characterDir = await getCharacterDirectory(characterId);

    final filePath = path.join(characterDir, 'metadata.json');
    await File(filePath).writeAsString(jsonEncode(metadata));
  }

  // 淇濆瓨鍘熷瑁佸壀鍥惧儚
  Future<String> saveOriginalImage(
      String characterId, Uint8List imageData) async {
    final characterDir = await getCharacterDirectory(characterId);

    final filePath = path.join(characterDir, 'original.png');
    await File(filePath).writeAsBytes(imageData);

    return filePath;
  }

  // 淇濆瓨SVG杞粨
  Future<String?> saveSvgOutline(String characterId, String? svgData) async {
    if (svgData == null) return null;

    final characterDir = await getCharacterDirectory(characterId);

    final filePath = path.join(characterDir, 'outline.svg');
    await File(filePath).writeAsString(svgData);

    return filePath;
  }

  // 淇濆瓨缂╃暐鍥?
  Future<String> saveThumbnail(String characterId, Uint8List imageData) async {
    final characterDir = await getCharacterDirectory(characterId);

    final filePath = path.join(characterDir, 'thumbnail.jpg');
    await File(filePath).writeAsBytes(imageData);

    return filePath;
  }

  // 纭繚鍒濆鍖栧畬鎴?
  Future<void> _ensureInitialized() async {
    if (!_initialized) {
      await _init();
    }
  }

  // 鍒濆鍖栧瓨鍌ㄨ矾寰?
  Future<void> _init() async {
    if (_initialized) return;

    try {
      // 鑾峰彇搴旂敤鏂囨。鐩綍
      final appDir = await getApplicationDocumentsDirectory();

      // 璁剧疆鍩虹瀛樺偍璺緞
      _baseStoragePath = path.join(appDir.path, 'storage');

      // 璁剧疆瀛楃瀛樺偍璺緞
      _charactersPath = path.join(_baseStoragePath, 'characters');

      // 璁剧疆缂撳瓨璺緞
      final tempDir = await getTemporaryDirectory();
      _cachePath = path.join(tempDir.path, 'character_cache');

      // 纭繚鐩綍瀛樺湪
      await Directory(_baseStoragePath).create(recursive: true);
      await Directory(_charactersPath).create(recursive: true);
      await Directory(_cachePath).create(recursive: true);

      _initialized = true;
    } catch (e) {
      print('鍒濆鍖栧瓧绗﹀瓨鍌ㄦ湇鍔″け璐? $e');
      rethrow;
    }
  }
}

// 瀛樺偍淇℃伅妯″瀷
class StorageInfo {
  final int characterCount;
  final int totalSizeBytes;

  StorageInfo({
    required this.characterCount,
    required this.totalSizeBytes,
  });

  // 鏍煎紡鍖栫殑鎬诲ぇ灏?
  String get formattedSize {
    if (totalSizeBytes < 1024) {
      return '$totalSizeBytes B';
    } else if (totalSizeBytes < 1024 * 1024) {
      final kb = totalSizeBytes / 1024;
      return '${kb.toStringAsFixed(2)} KB';
    } else if (totalSizeBytes < 1024 * 1024 * 1024) {
      final mb = totalSizeBytes / (1024 * 1024);
      return '${mb.toStringAsFixed(2)} MB';
    } else {
      final gb = totalSizeBytes / (1024 * 1024 * 1024);
      return '${gb.toStringAsFixed(2)} GB';
    }
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\application\services\storage\work_storage_service.dart
-----------------------------------
import 'dart:io';

import 'package:demo/infrastructure/storage/storage_interface.dart';
import 'package:path/path.dart' as path;

import '../../../infrastructure/logging/logger.dart';

/// 浣滃搧瀛樺偍鏈嶅姟
///
/// 鑱岃矗:
/// 1. 浣滃搧鏂囦欢鐩綍绠＄悊
/// 2. 浣滃搧鏂囦欢鍛藉悕瑙勫垯
/// 3. 鏂囦欢鐗堟湰绠＄悊
/// 4. 鍥剧墖鏍煎紡澶勭悊
class WorkStorageService {
  final IStorage _storage;

  WorkStorageService({
    required IStorage storage,
  }) : _storage = storage;

  /// 鍒涘缓浣滃搧鐩綍缁撴瀯
  Future<void> createWorkDirectories(String workId) async {
    try {
      await _storage.createDirectory(getWorkPath(workId));
      await _storage.createDirectory(getWorkImagesPath(workId));
      await _storage.createDirectory(getWorkCoverPath(workId));
    } catch (e, stack) {
      _handleError(
        '鍒涘缓浣滃搧鐩綍澶辫触',
        e,
        stack,
        data: {'workId': workId},
      );
    }
  }

  /// 鍒犻櫎浣滃搧鐩綍
  Future<void> deleteWorkDirectory(String workId) async {
    try {
      final workPath = getWorkPath(workId);
      await _storage.deleteDirectory(workPath);
    } catch (e, stack) {
      _handleError(
        '鍒犻櫎浣滃搧鐩綍澶辫触',
        e,
        stack,
        data: {'workId': workId},
      );
    }
  }

  /// 鍒犻櫎浣滃搧鍥剧墖
  Future<void> deleteWorkImage(String workId, String imageId) async {
    try {
      final imagePath = getWorkImagePath(workId, imageId);
      await _storage.deleteDirectory(imagePath);
    } catch (e, stack) {
      _handleError(
        '鍒犻櫎浣滃搧鍥剧墖澶辫触',
        e,
        stack,
        data: {
          'workId': workId,
          'imageId': imageId,
        },
      );
    }
  }

  Future<void> ensureWorkDirectoryExists(String workId) async {
    try {
      await _storage.ensureDirectoryExists(getWorkPath(workId));
      await _storage.ensureDirectoryExists(getWorkImagesPath(workId));
      await _storage.ensureDirectoryExists(getWorkCoverPath(workId));
    } catch (e, stack) {
      _handleError(
        '鍒涘缓浣滃搧鐩綍澶辫触',
        e,
        stack,
        data: {'workId': workId},
      );
    }
  }

  /// 鑾峰彇浣滃搧瀵煎叆鍥剧墖璺緞
  String getImportedPath(String workId, String imageId) =>
      path.join(getWorkImagePath(workId, imageId), 'imported.png');

  /// 鑾峰彇浣滃搧鍏冩暟鎹枃浠惰矾寰?
  String getMetadataPath(String workId) =>
      path.join(getWorkPath(workId), 'metadata.json');

  /// 鑾峰彇浣滃搧鍘熷鍥剧墖璺緞
  String getOriginalPath(String workId, String imageId) => path.join(
      getWorkImagePath(workId, imageId), 'original.${_getExtension(imageId)}');

  /// 鑾峰彇浣滃搧缂╃暐鍥捐矾寰?
  String getThumbnailPath(String workId, String imageId) =>
      path.join(getWorkImagePath(workId, imageId), 'thumbnail.jpg');

  /// 鑾峰彇浣滃搧灏侀潰瀵煎叆鍥捐矾寰?
  String getWorkCoverImportedPath(String workId) =>
      path.join(getWorkCoverPath(workId), 'imported.png');

  /// 鑾峰彇浣滃搧灏侀潰鐩綍璺緞
  String getWorkCoverPath(String workId) =>
      path.join(getWorkPath(workId), 'cover');

  /// 鑾峰彇浣滃搧灏侀潰缂╃暐鍥捐矾寰?
  String getWorkCoverThumbnailPath(String workId) =>
      path.join(getWorkCoverPath(workId), 'thumbnail.jpg');

  /// 鑾峰彇浣滃搧鍥剧墖
  Future<File> getWorkImage(String path) async {
    if (!await _storage.fileExists(path)) {
      throw FileSystemException('鏂囦欢涓嶅瓨鍦?, path);
    }
    return File(path);
  }

  /// 鑾峰彇鍥剧墖淇℃伅
  Future<Map<String, int>> getWorkImageInfo(String path) async {
    final file = File(path);
    if (!await file.exists()) {
      throw FileSystemException('鏂囦欢涓嶅瓨鍦?, path);
    }

    return {
      'size': await file.length(),
      'width': 0, // TODO: 瀹炵幇鍥剧墖灏哄鑾峰彇
      'height': 0,
    };
  }

  /// 鑾峰彇浣滃搧鍥剧墖璺緞
  String getWorkImagePath(String workId, String imageId) =>
      path.join(getWorkImagesPath(workId), imageId);

  /// 鑾峰彇鍥剧墖澶у皬
  Future<int> getWorkImageSize(String path) => _storage.getFileSize(path);

  /// 鑾峰彇浣滃搧鍥剧墖鐩綍璺緞
  String getWorkImagesPath(String workId) =>
      path.join(getWorkPath(workId), 'images');

  /// 鑾峰彇浣滃搧鐩綍璺緞
  String getWorkPath(String workId) =>
      (path.join(_storage.getAppDataPath(), 'works', workId));

  /// 妫€鏌ヤ綔鍝佸浘鐗囨槸鍚﹀瓨鍦?
  Future<bool> hasWorkImage(String path) => _storage.fileExists(path);

  /// 鍒楀嚭浣滃搧鎵€鏈夋枃浠惰矾寰勶紙閫掑綊锛?
  Future<List<String>> listWorkFiles(String workId) async {
    try {
      final workPath = getWorkPath(workId);
      return await _storage.listDirectoryFiles(workPath);
    } catch (e, stack) {
      _handleError(
        '鑾峰彇浣滃搧鏂囦欢鍒楄〃澶辫触',
        e,
        stack,
        data: {'workId': workId},
      );
      return [];
    }
  }

  /// 淇濆瓨浣滃搧灏侀潰瀵煎叆鍥?
  Future<String> saveCoverImported(String workId, File file) async {
    final targetPath = getWorkCoverImportedPath(workId);
    try {
      await ensureWorkDirectoryExists(workId);

      // 纭繚鐩爣鐩綍瀛樺湪
      final targetDir = Directory(path.dirname(targetPath));
      if (!await targetDir.exists()) {
        await targetDir.create(recursive: true);
      }

      // 濡傛灉鐩爣鏂囦欢瀛樺湪鍒欏厛鍒犻櫎
      if (await _storage.fileExists(targetPath)) {
        await _storage.deleteFile(targetPath);
      }
      await _storage.copyFile(file.path, targetPath);

      // 楠岃瘉鏂囦欢鏄惁鎴愬姛淇濆瓨
      if (!await _storage.fileExists(targetPath)) {
        AppLogger.error('灏侀潰瀵煎叆鍥句繚瀛樺け璐?, tag: 'WorkStorageService', data: {
          'workId': workId,
          'sourcePath': file.path,
          'targetPath': targetPath
        });
        throw FileSystemException('灏侀潰瀵煎叆鍥句繚瀛樺け璐?, targetPath);
      }

      return targetPath;
    } catch (e, stack) {
      _handleError(
        '淇濆瓨灏侀潰瀵煎叆鍥惧け璐?,
        e,
        stack,
        data: {
          'workId': workId,
          'sourcePath': file.path,
          'targetPath': targetPath
        },
      );
      rethrow;
    }
  }

  /// 淇濆瓨浣滃搧灏侀潰缂╃暐鍥?
  Future<String> saveCoverThumbnail(String workId, File file) async {
    final targetPath = getWorkCoverThumbnailPath(workId);
    try {
      await ensureWorkDirectoryExists(workId);

      // 纭繚鐩爣鐩綍瀛樺湪
      final targetDir = Directory(path.dirname(targetPath));
      if (!await targetDir.exists()) {
        await targetDir.create(recursive: true);
      }

      // 濡傛灉鐩爣鏂囦欢瀛樺湪鍒欏厛鍒犻櫎
      if (await _storage.fileExists(targetPath)) {
        await _storage.deleteFile(targetPath);
      }
      await _storage.copyFile(file.path, targetPath);

      // 楠岃瘉鏂囦欢鏄惁鎴愬姛淇濆瓨
      if (!await _storage.fileExists(targetPath)) {
        AppLogger.error('灏侀潰缂╃暐鍥句繚瀛樺け璐?, tag: 'WorkStorageService', data: {
          'workId': workId,
          'sourcePath': file.path,
          'targetPath': targetPath
        });
        throw FileSystemException('灏侀潰缂╃暐鍥句繚瀛樺け璐?, targetPath);
      }

      return targetPath;
    } catch (e, stack) {
      _handleError(
        '淇濆瓨灏侀潰缂╃暐鍥惧け璐?,
        e,
        stack,
        data: {
          'workId': workId,
          'sourcePath': file.path,
          'targetPath': targetPath
        },
      );
      rethrow;
    }
  }

  /// 淇濆瓨浣滃搧瀵煎叆鍥剧墖
  Future<String> saveImportedImage(
    String workId,
    String imageId,
    File file,
  ) async {
    final targetPath = getImportedPath(workId, imageId);
    await _storage.copyFile(file.path, targetPath);
    return targetPath;
  }

  /// 淇濆瓨浣滃搧鍏冩暟鎹?
  Future<void> saveMetadata(String workId, String content) async {
    final targetPath = getMetadataPath(workId);
    await _storage.writeFile(targetPath, content.codeUnits);
  }

  /// 淇濆瓨浣滃搧鍘熷鍥剧墖
  Future<String> saveOriginalImage(
    String workId,
    String imageId,
    File file,
  ) async {
    final targetPath = getOriginalPath(workId, imageId);
    await _storage.copyFile(file.path, targetPath);
    return targetPath;
  }

  /// 淇濆瓨浣滃搧缂╃暐鍥?
  Future<String> saveThumbnail(
    String workId,
    String imageId,
    File file,
  ) async {
    final targetPath = getThumbnailPath(workId, imageId);
    await _storage.copyFile(file.path, targetPath);
    return targetPath;
  }

  /// 妫€鏌ヤ綔鍝佸浘鐗囨槸鍚﹀瓨鍦紙甯﹂噸璇曟満鍒讹級
  Future<bool> verifyWorkImageExists(String path, {int retries = 3}) async {
    bool exists = await _storage.fileExists(path);

    // If file doesn't exist, retry a few times with delays
    int attempt = 0;
    while (!exists && attempt < retries) {
      await Future.delayed(Duration(milliseconds: 200 * (attempt + 1)));
      exists = await _storage.fileExists(path);
      attempt++;

      AppLogger.debug(
        'Retry checking file existence',
        tag: 'WorkStorageService',
        data: {
          'path': path,
          'attempt': attempt,
          'exists': exists,
        },
      );
    }

    // 濡傛灉鏂囦欢瀛樺湪锛屽皾璇曡鍙栦互纭繚瀹冨畬鍏ㄥ啓鍏?
    if (exists) {
      try {
        final file = File(path);
        final randomAccessFile = await file.open(mode: FileMode.read);
        try {
          // 灏濊瘯璇诲彇鍑犱釜瀛楄妭浠ラ獙璇佹枃浠跺彲璁块棶
          await randomAccessFile.read(8);
        } finally {
          await randomAccessFile.close();
        }
      } catch (e) {
        AppLogger.warning(
          '鏂囦欢瀛樺湪浣嗘棤娉曞畬鍏ㄨ闂?,
          tag: 'WorkStorageService',
          error: e,
          data: {'path': path},
        );
        exists = false; // 鏂囦欢瀛樺湪浣嗕笉鍙闂紝鏍囪涓轰笉瀛樺湪
      }
    }

    if (!exists) {
      AppLogger.warning(
        '鏂囦欢涓嶅瓨鍦ㄦ垨涓嶅彲璁块棶',
        tag: 'WorkStorageService',
        data: {'path': path, 'afterRetries': retries},
      );
    }

    return exists;
  }

  /// 纭浣滃搧鎵€鏈夊浘鐗囬兘瀛樺湪
  Future<Map<String, bool>> verifyWorkImages(String workId) async {
    Map<String, bool> results = {};
    try {
      final workPath = getWorkPath(workId);
      final files = await _storage.listDirectoryFiles(workPath);

      for (final file in files) {
        results[file] = await _storage.fileExists(file);
      }

      // Check cover files specifically
      final coverPath = getWorkCoverImportedPath(workId);
      final coverThumbPath = getWorkCoverThumbnailPath(workId);

      results[coverPath] = await verifyWorkImageExists(coverPath);
      results[coverThumbPath] = await verifyWorkImageExists(coverThumbPath);

      // Log any missing files
      final missingFiles =
          results.entries.where((e) => !e.value).map((e) => e.key).toList();

      if (missingFiles.isNotEmpty) {
        AppLogger.warning(
          '浣滃搧瀛樺湪涓㈠け鐨勬枃浠?,
          tag: 'WorkStorageService',
          data: {
            'workId': workId,
            'missingFiles': missingFiles,
          },
        );
      }
    } catch (e, stack) {
      _handleError(
        '楠岃瘉浣滃搧鍥剧墖澶辫触',
        e,
        stack,
        data: {'workId': workId},
      );
    }

    return results;
  }

  /// 鑾峰彇鏂囦欢鎵╁睍鍚?
  String _getExtension(String imageId) {
    // 浠庡浘鐗嘔D鎴栧叾浠栧厓鏁版嵁鑾峰彇鎵╁睍鍚?
    return 'png';
  }

  /// 缁熶竴閿欒澶勭悊
  void _handleError(
    String message,
    Object error,
    StackTrace stack, {
    Map<String, dynamic>? data,
  }) {
    AppLogger.error(
      message,
      error: error,
      stackTrace: stack,
      tag: 'WorkStorageService',
      data: data,
    );
    throw error;
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\application\services\work\service_errors.dart
-----------------------------------
import '../../../infrastructure/logging/logger.dart';

/// 浣滃搧鏈嶅姟寮傚父鍩虹被
abstract class ServiceException implements Exception {
  final String operation;
  final String message;
  final Map<String, dynamic>? data;

  ServiceException(this.operation, this.message, [this.data]);

  @override
  String toString() => '$runtimeType: $operation - $message';
}

/// 鍥剧墖鏈嶅姟閿欒澶勭悊Mixin
mixin WorkImageErrorHandler {
  /// 澶勭悊鍥剧墖鎿嶄綔
  Future<T> handleImageOperation<T>(
    String operation,
    Future<T> Function() action, {
    Map<String, dynamic>? data,
    bool rethrowError = true,
  }) async {
    try {
      return await action();
    } catch (e, stack) {
      // 璁板綍閿欒
      AppLogger.error(
        'Image operation failed: $operation',
        tag: runtimeType.toString(),
        error: e,
        stackTrace: stack,
        data: data,
      );

      if (rethrowError) {
        if (e is ArgumentError) {
          rethrow;
        }
        throw WorkImageException(
          operation,
          e.toString(),
          data,
        );
      }

      return Future.value(); // 濡傛灉涓嶉噸鏂版姏鍑猴紝杩斿洖null
    }
  }

  /// 澶勭悊鍚屾鍥剧墖鎿嶄綔
  T handleImageSync<T>(
    String operation,
    T Function() action, {
    Map<String, dynamic>? data,
    bool rethrowError = true,
  }) {
    try {
      return action();
    } catch (e, stack) {
      // 璁板綍閿欒
      AppLogger.error(
        'Image operation failed: $operation',
        tag: runtimeType.toString(),
        error: e,
        stackTrace: stack,
        data: data,
      );

      if (rethrowError) {
        if (e is ArgumentError) {
          rethrow;
        }
        throw WorkImageException(
          operation,
          e.toString(),
          data,
        );
      }

      return null as T; // 濡傛灉涓嶉噸鏂版姏鍑猴紝杩斿洖null
    }
  }
}

/// 鍥剧墖鏈嶅姟寮傚父
class WorkImageException extends ServiceException {
  WorkImageException(String operation, String message,
      [Map<String, dynamic>? data])
      : super(operation, message, data);
}

/// Utility mixin for handling service operations with error logging
mixin WorkServiceErrorHandler {
  /// Execute a service operation with proper error handling and logging
  Future<T> handleOperation<T>(
    String operation,
    Future<T> Function() action, {
    Map<String, dynamic>? data,
  }) async {
    try {
      return await action();
    } catch (e, stack) {
      AppLogger.error(
        'Operation "$operation" failed',
        tag: runtimeType.toString(),
        error: e,
        stackTrace: stack,
        data: data,
      );
      rethrow;
    }
  }
}

/// 浣滃搧鏈嶅姟涓氬姟寮傚父
class WorkServiceException extends ServiceException {
  WorkServiceException(String operation, String message,
      [Map<String, dynamic>? data])
      : super(operation, message, data);
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\application\services\work\work_image_service.dart
-----------------------------------
import 'dart:collection';
import 'dart:io';
import 'dart:math' as math;
import 'dart:typed_data';

import 'package:image/image.dart' as img;

import '../../../domain/models/work/work_image.dart';
import '../../../domain/repositories/work_image_repository.dart';
import '../../../infrastructure/image/image_processor.dart';
import '../../../infrastructure/logging/logger.dart';
import '../storage/work_storage_service.dart';
import './service_errors.dart';

typedef ProgressCallback = void Function(double progress, String message);

/// 浣滃搧鍥剧墖鏈嶅姟
class WorkImageService with WorkServiceErrorHandler {
  final WorkStorageService _storage;
  final ImageProcessor _processor;
  final WorkImageRepository _repository;

  WorkImageService({
    required WorkStorageService storage,
    required ImageProcessor processor,
    required WorkImageRepository repository,
  })  : _storage = storage,
        _processor = processor,
        _repository = repository;

  /// 娓呯悊鏈娇鐢ㄧ殑鍥剧墖鏂囦欢
  Future<void> cleanupUnusedFiles(String workId, List<String> usedPaths) async {
    return handleOperation(
      'cleanupUnusedFiles',
      () async {
        AppLogger.debug('寮€濮嬫竻鐞嗘湭浣跨敤鐨勫浘鐗囨枃浠?, tag: 'WorkImageService', data: {
          'workId': workId,
          'usedPathsCount': usedPaths.length,
        });

        final allFiles = await _storage.listWorkFiles(workId);
        final unusedFiles =
            allFiles.where((f) => !usedPaths.contains(f)).toList();

        if (unusedFiles.isNotEmpty) {
          AppLogger.debug('鍙戠幇鏈娇鐢ㄧ殑鏂囦欢', tag: 'WorkImageService', data: {
            'count': unusedFiles.length,
            'files': unusedFiles,
          });

          for (final file in unusedFiles) {
            try {
              await File(file).delete();
            } catch (e) {
              AppLogger.warning('鍒犻櫎鏈娇鐢ㄦ枃浠跺け璐?,
                  tag: 'WorkImageService', error: e, data: {'file': file});
            }
          }
        }
      },
      data: {'workId': workId},
    );
  }

  /// 娓呯悊浣滃搧鍥剧墖
  Future<void> cleanupWorkImages(String workId) async {
    return handleOperation(
      'cleanupWorkImages',
      () async {
        AppLogger.info('寮€濮嬫竻鐞嗕綔鍝佸浘鐗?, tag: 'WorkImageService', data: {
          'workId': workId,
        });

        // 鍒犻櫎鍥剧墖鏂囦欢
        await _storage.deleteWorkDirectory(workId);

        // 鍒犻櫎鏁版嵁搴撹褰?
        await _repository.getAllByWorkId(workId).then((images) {
          if (images.isNotEmpty) {
            final imageIds = images.map((e) => e.id).toList();
            return _repository.deleteMany(workId, imageIds);
          }
        });

        AppLogger.info('鍥剧墖娓呯悊瀹屾垚', tag: 'WorkImageService');
      },
      data: {'workId': workId},
    );
  }

  /// 鍒犻櫎鍥剧墖锛堜笉绔嬪嵆鏇存柊鏁版嵁搴擄級
  Future<void> deleteImage(String workId, String imageId) async {
    return handleOperation(
      'deleteImage',
      () async {
        AppLogger.info('寮€濮嬪垹闄ゅ浘鐗?, tag: 'WorkImageService', data: {
          'workId': workId,
          'imageId': imageId,
        });

        // 鍒犻櫎鏂囦欢
        await _storage.deleteWorkImage(workId, imageId);

        // 鍒犻櫎鏁版嵁搴撹褰?
        await _repository.delete(workId, imageId);

        AppLogger.info('鍥剧墖鏂囦欢鍒犻櫎瀹屾垚', tag: 'WorkImageService');
      },
      data: {'workId': workId, 'imageId': imageId},
    );
  }

  /// 鑾峰彇椤甸潰缂╃暐鍥捐矾寰?
  Future<String?> getPageThumbnailPath(String pageId) async {
    return handleOperation(
      'getPageThumbnailPath',
      () async {
        try {
          final workImage = await _repository.get(pageId);
          if (workImage == null) {
            AppLogger.warning('鍥剧墖璁板綍涓嶅瓨鍦?, tag: 'WorkImageService', data: {
              'pageId': pageId,
            });
            return null;
          }

          final workId = workImage.workId;
          final thumbnailPath = _storage.getThumbnailPath(workId, pageId);

          // 楠岃瘉鏂囦欢鏄惁瀛樺湪
          final exists = await _storage.verifyWorkImageExists(thumbnailPath);
          if (!exists) {
            AppLogger.warning('缂╃暐鍥炬枃浠朵笉瀛樺湪', tag: 'WorkImageService', data: {
              'pageId': pageId,
              'path': thumbnailPath,
            });
            return null;
          }

          return thumbnailPath;
        } catch (e, stack) {
          AppLogger.error('鑾峰彇缂╃暐鍥捐矾寰勫け璐?,
              tag: 'WorkImageService',
              error: e,
              stackTrace: stack,
              data: {'pageId': pageId});
          return null;
        }
      },
      data: {'pageId': pageId},
    );
  }

  /// 鑾峰彇浣滃搧鐨勬墍鏈夊浘鐗?
  Future<List<WorkImage>> getWorkImages(String workId) async {
    return handleOperation(
      'getWorkImages',
      () => _repository.getAllByWorkId(workId),
      data: {'workId': workId},
    );
  }

  /// Gets the all image ids for a work
  Future<List<String>?> getWorkPageIds(String workId) async {
    return handleOperation(
      'getWorkPageIds',
      () async {
        AppLogger.debug('鑾峰彇浣滃搧椤甸潰ID鍒楄〃', tag: 'WorkImageService', data: {
          'workId': workId,
        });

        final images = await _repository.getAllByWorkId(workId);
        if (images.isEmpty) {
          return null;
        }

        // 鎸夌収绱㈠紩鎺掑簭骞舵彁鍙朓D
        final sortedImages = [...images]
          ..sort((a, b) => a.index.compareTo(b.index));
        final ids = sortedImages.map((img) => img.id).toList();

        return ids;
      },
      data: {'workId': workId},
    );
  }

  /// Gets the image data for a specific page of a work
  Future<Uint8List?> getWorkPageImage(String workId, String pageId) async {
    return handleOperation(
      'getWorkPageImage',
      () async {
        AppLogger.debug('鑾峰彇浣滃搧椤甸潰鍥剧墖', tag: 'WorkImageService', data: {
          'workId': workId,
          'pageId': pageId,
        });

        // 鑾峰彇瀵煎叆鍚庣殑鍥剧墖璺緞
        final imagePath = _storage.getImportedPath(workId, pageId);
        final file = File(imagePath);

        if (!await file.exists()) {
          AppLogger.warning('鍥剧墖鏂囦欢涓嶅瓨鍦?,
              tag: 'WorkImageService', data: {'path': imagePath});
          return null;
        }

        // 璇诲彇鍥剧墖鏁版嵁
        final imageBytes = await file.readAsBytes();

        AppLogger.debug('璇诲彇椤甸潰鍥剧墖鏁版嵁', tag: 'WorkImageService', data: {
          'workId': workId,
          'pageId': pageId,
          'imageSize': imageBytes.length,
        });

        // 楠岃瘉鍥剧墖鏁版嵁
        try {
          final image = img.decodeImage(imageBytes);
          if (image != null) {
            AppLogger.debug('鍥剧墖鏁版嵁楠岃瘉鎴愬姛', tag: 'WorkImageService', data: {
              'width': image.width,
              'height': image.height,
            });
          }
        } catch (e, stack) {
          AppLogger.error('鍥剧墖鏁版嵁瑙ｇ爜澶辫触',
              tag: 'WorkImageService', error: e, stackTrace: stack);
        }

        return imageBytes;
      },
      data: {
        'workId': workId,
        'pageId': pageId,
      },
    );
  }

  /// 瀵煎叆鏂板浘鐗囷紙杩斿洖涓存椂鐘舵€侊紝涓嶇珛鍗充繚瀛橈級
  Future<WorkImage> importImage(String workId, File file) async {
    return handleOperation(
      'importImage',
      () async {
        final imageId = DateTime.now().millisecondsSinceEpoch.toString();

        AppLogger.debug('鍑嗗瀵煎叆鏂板浘鐗?, tag: 'WorkImageService', data: {
          'workId': workId,
          'imageId': imageId,
          'filePath': file.path,
        });

        if (!await file.exists()) {
          throw FileSystemException('婧愭枃浠朵笉瀛樺湪', file.path);
        }

        // 鍏堝垱寤轰复鏃跺浘鐗囧璞?
        final nextIndex = await _getNextImageIndex(workId);
        final tempImage = WorkImage(
          id: imageId,
          workId: workId,
          path: file.path,
          originalPath: file.path,
          thumbnailPath: file.path,
          format: _getImageFormat(file),
          size: await file.length(),
          width: 0,
          height: 0,
          index: nextIndex,
          createTime: DateTime.now(),
          updateTime: DateTime.now(),
        );

        AppLogger.debug('鍒涘缓涓存椂鍥剧墖瀵硅薄', tag: 'WorkImageService', data: {
          'imageId': imageId,
          'index': nextIndex,
        });

        return tempImage;
      },
      data: {'workId': workId, 'file': file.path},
    );
  }

  /// 鎵归噺瀵煎叆鍥剧墖锛堜笉绔嬪嵆淇濆瓨锛?
  Future<List<WorkImage>> importImages(String workId, List<File> files) async {
    return handleOperation(
      'importImages',
      () async {
        AppLogger.info('寮€濮嬫壒閲忓鍏ュ浘鐗?, tag: 'WorkImageService', data: {
          'workId': workId,
          'fileCount': files.length,
        });

        final images = <WorkImage>[];
        final uniqueFiles = LinkedHashSet<File>(
          equals: (a, b) => a.path == b.path,
          hashCode: (file) => file.absolute.path.hashCode,
        )..addAll(files);

        AppLogger.debug('鏂囦欢鍘婚噸瀹屾垚', tag: 'WorkImageService', data: {
          'originalCount': files.length,
          'uniqueCount': uniqueFiles.length,
        });

        for (final file in uniqueFiles) {
          final image = await importImage(workId, file);
          images.add(image);
        }

        return images;
      },
      data: {'workId': workId, 'fileCount': files.length},
    );
  }

  /// 澶勭悊瀹屾暣鐨勫浘鐗囧鍏ユ祦绋?
  Future<List<WorkImage>> processImport(String workId, List<File> files) async {
    return handleOperation(
      'processImport',
      () async {
        AppLogger.info('寮€濮嬪鐞嗗浘鐗囧鍏?, tag: 'WorkImageService', data: {
          'workId': workId,
          'fileCount': files.length,
        });

        // 1. 纭繚浣滃搧鐩綍缁撴瀯
        await _storage.ensureWorkDirectoryExists(workId);

        // 2. 瀵煎叆鎵€鏈夊浘鐗?
        final tempImages = await importImages(workId, files);

        // 3. 澶勭悊骞朵繚瀛樺浘鐗?
        final savedImages = await saveChanges(workId, tempImages);

        // 4. 寮哄埗楠岃瘉灏侀潰鏄惁宸叉纭敓鎴?
        if (savedImages.isNotEmpty) {
          AppLogger.info('瀵煎叆瀹屾垚鍚庨獙璇佸皝闈?, tag: 'WorkImageService');

          final coverPath = _storage.getWorkCoverImportedPath(workId);
          final coverThumbnailPath = _storage.getWorkCoverThumbnailPath(workId);

          // 妫€鏌ュ皝闈㈠拰缂╃暐鍥?
          final coverExists = await _storage.verifyWorkImageExists(coverPath);
          final thumbnailExists =
              await _storage.verifyWorkImageExists(coverThumbnailPath);

          AppLogger.debug('瀵煎叆鍚庡皝闈㈢姸鎬?, tag: 'WorkImageService', data: {
            'coverExists': coverExists,
            'thumbnailExists': thumbnailExists,
            'coverPath': coverPath,
            'thumbnailPath': coverThumbnailPath,
          });

          // 濡傛灉灏侀潰鎴栫缉鐣ュ浘涓嶅瓨鍦紝閲嶆柊鐢熸垚
          if (!coverExists || !thumbnailExists) {
            AppLogger.warning('瀵煎叆鍚庡皝闈㈤獙璇佸け璐ワ紝閲嶆柊鐢熸垚', tag: 'WorkImageService', data: {
              'workId': workId,
              'firstImageId': savedImages[0].id,
              'coverMissing': !coverExists,
              'thumbnailMissing': !thumbnailExists,
            });

            await updateCover(workId, savedImages[0].id);

            // 鍐嶆楠岃瘉灏侀潰鏄惁鐢熸垚鎴愬姛
            final coverRegenerated =
                await _storage.verifyWorkImageExists(coverPath);
            final thumbnailRegenerated =
                await _storage.verifyWorkImageExists(coverThumbnailPath);

            if (!coverRegenerated || !thumbnailRegenerated) {
              AppLogger.error('灏侀潰閲嶆柊鐢熸垚鍚庝粛鐒剁己澶?, tag: 'WorkImageService', data: {
                'workId': workId,
                'coverMissing': !coverRegenerated,
                'thumbnailMissing': !thumbnailRegenerated,
              });
            }
          }
        }

        AppLogger.info('鍥剧墖瀵煎叆澶勭悊瀹屾垚', tag: 'WorkImageService', data: {
          'workId': workId,
          'totalSaved': savedImages.length,
        });

        return savedImages;
      },
      data: {'workId': workId, 'fileCount': files.length},
    );
  }

  /// 淇濆瓨鍥剧墖鏇存敼
  Future<List<WorkImage>> saveChanges(
    String workId,
    List<WorkImage> images, {
    ProgressCallback? onProgress,
  }) async {
    return handleOperation(
      'saveChanges',
      () async {
        AppLogger.info('寮€濮嬩繚瀛樺浘鐗囨洿鏀?, tag: 'WorkImageService', data: {
          'workId': workId,
          'imageCount': images.length,
          'firstImageId': images.isNotEmpty ? images[0].id : null,
        });

        // 棣栧厛鑾峰彇褰撳墠鎵€鏈夊浘鐗囷紝鐢ㄤ簬娓呯悊鏈娇鐢ㄧ殑鍥剧墖
        final existingImages = await _repository.getAllByWorkId(workId);
        final existingIds = existingImages.map((img) => img.id).toSet();
        final newIds = images.map((img) => img.id).toSet();

        // 鑾峰彇褰撳墠鐨勯寮犲浘鐗嘔D
        final existingFirstImageId =
            existingImages.isNotEmpty ? existingImages[0].id : null;
        final newFirstImageId = images.isNotEmpty ? images[0].id : null;

        // 妫€娴嬪浘鐗囬『搴忔槸鍚﹀彉鍖?
        final imagesReordered =
            _haveImagesBeenReordered(existingImages, images);

        AppLogger.debug('灏侀潰鍥剧墖妫€鏌?, tag: 'WorkImageService', data: {
          'currentFirstImageId': existingFirstImageId,
          'newFirstImageId': newFirstImageId,
          'currentFirstImageIndex':
              existingImages.isNotEmpty ? existingImages[0].index : null,
          'newFirstImageIndex': images.isNotEmpty ? images[0].index : null,
          'imagesReordered': imagesReordered,
        });

        // 纭畾鏄惁闇€瑕佹洿鏂板皝闈?
        // 濡傛灉棣栧浘ID鍙樹簡锛屾垨鑰呭浘鐗囬『搴忓彂鐢熷彉鍖栵紝閮介渶瑕佹洿鏂板皝闈?
        final shouldUpdateCover = newFirstImageId != null &&
            (existingFirstImageId != newFirstImageId ||
                imagesReordered ||
                existingFirstImageId == null);

        // 娓呯悊宸插垹闄ょ殑鍥剧墖璁板綍
        final deletedIds = existingIds.difference(newIds).toList();
        if (deletedIds.isNotEmpty) {
          await _repository.deleteMany(workId, deletedIds);
        }

        final processedImages = <WorkImage>[];
        final tempFiles = <String>[];
        var index = 0;
        final total = images.length;

        try {
          // 澶勭悊姣忎釜鍥剧墖
          for (final image in images) {
            onProgress?.call(
              index / total,
              '澶勭悊鍥剧墖 ${index + 1}/$total',
            );

            AppLogger.debug('澶勭悊鍥剧墖', tag: 'WorkImageService', data: {
              'imageId': image.id,
              'isNew': image.path == image.originalPath,
              'index': index,
            });

            if (image.path == image.originalPath) {
              // 鏂板浘鐗? 闇€瑕佸畬鏁寸殑澶勭悊娴佺▼
              try {
                final file = File(image.path);
                if (!await file.exists()) {
                  throw FileSystemException('婧愭枃浠朵笉瀛樺湪', image.path);
                }

                // 1. 淇濆瓨鍘熷鏂囦欢
                final originalPath = await _storage.saveOriginalImage(
                  workId,
                  image.id,
                  file,
                );
                tempFiles.add(originalPath);

                // 2. 澶勭悊骞朵繚瀛樺鍏ュ浘鐗?
                final processedFile = await _processor.processImage(
                  file,
                  maxWidth: 2400,
                  maxHeight: 2400,
                  quality: 90,
                );
                final importedPath = await _storage.saveImportedImage(
                  workId,
                  image.id,
                  processedFile,
                );
                tempFiles.add(importedPath);

                // 3. 鐢熸垚骞朵繚瀛樼缉鐣ュ浘
                final thumbnail = await _processor.processImage(
                  file,
                  maxWidth: 200,
                  maxHeight: 200,
                  quality: 80,
                );
                final thumbnailPath = await _storage.saveThumbnail(
                  workId,
                  image.id,
                  thumbnail,
                );
                tempFiles.add(thumbnailPath);

                // 4. 鑾峰彇鍥剧墖淇℃伅
                final info = await _storage.getWorkImageInfo(importedPath);

                processedImages.add(image.copyWith(
                  path: importedPath,
                  originalPath: originalPath,
                  thumbnailPath: thumbnailPath,
                  width: info['width'] ?? 0,
                  height: info['height'] ?? 0,
                  size: info['size'] ?? 0,
                  index: index++,
                  updateTime: DateTime.now(),
                ));

                AppLogger.debug('鏂板浘鐗囧鐞嗗畬鎴?, tag: 'WorkImageService', data: {
                  'imageId': image.id,
                  'size': info['size'],
                });
              } catch (e, stack) {
                AppLogger.error('澶勭悊鏂板浘鐗囧け璐?,
                    tag: 'WorkImageService',
                    error: e,
                    stackTrace: stack,
                    data: {
                      'imageId': image.id,
                      'path': image.path,
                    });
                rethrow;
              }
            } else {
              // 宸插瓨鍦ㄧ殑鍥剧墖: 鍙洿鏂扮储寮?
              processedImages.add(image.copyWith(
                index: index++,
                updateTime: DateTime.now(),
              ));
            }
          }

          onProgress?.call(0.9, '淇濆瓨鍒版暟鎹簱...');

          AppLogger.debug('鎵€鏈夊浘鐗囧鐞嗗畬鎴?, tag: 'WorkImageService', data: {
            'totalProcessed': processedImages.length,
          });

          try {
            // 鎵归噺淇濆瓨鍒版暟鎹簱
            final savedImages = await _repository.saveMany(processedImages);

            // 妫€鏌ユ槸鍚﹂渶瑕佹洿鏂板皝闈紙棣栧浘鍙樺寲鏃讹級
            if (shouldUpdateCover && savedImages.isNotEmpty) {
              AppLogger.info('闇€瑕佹洿鏂板皝闈?, tag: 'WorkImageService', data: {
                'oldFirstImageId': existingFirstImageId,
                'newFirstImageId': newFirstImageId,
                'reason': existingFirstImageId != newFirstImageId
                    ? '棣栧浘ID鍙樺寲'
                    : imagesReordered
                        ? '鍥剧墖椤哄簭鍙樺寲'
                        : '鍏朵粬鍘熷洜'
              });

              try {
                // 浣跨敤褰撳墠棣栧浘鏇存柊灏侀潰
                await updateCover(workId, savedImages[0].id);

                AppLogger.debug('灏侀潰宸叉洿鏂?, tag: 'WorkImageService', data: {
                  'usedImageId': savedImages[0].id,
                  'usedImageIndex': savedImages[0].index,
                });

                // 楠岃瘉灏侀潰鏂囦欢纭疄瀛樺湪
                await _verifyCoverExists(workId);
              } catch (e, stack) {
                AppLogger.error('鐢熸垚灏侀潰澶辫触',
                    tag: 'WorkImageService',
                    error: e,
                    stackTrace: stack,
                    data: {
                      'workId': workId,
                      'firstImageId': savedImages[0].id,
                    });
                // 缁х画鎵ц锛屼笉涓柇淇濆瓨娴佺▼
              }
            } else {
              // 璁板綍涓嶉渶瑕佹洿鏂板皝闈㈢殑鍘熷洜
              AppLogger.debug('涓嶉渶瑕佹洿鏂板皝闈?, tag: 'WorkImageService', data: {
                'existingFirstImageId': existingFirstImageId,
                'newFirstImageId': newFirstImageId,
                'imagesReordered': imagesReordered,
                'shouldUpdateCover': shouldUpdateCover,
              });

              // 鍗充娇涓嶉渶瑕佹洿鏂板皝闈紝涔熼獙璇佸皝闈㈠瓨鍦?
              if (savedImages.isNotEmpty) {
                await _verifyCoverExists(workId);
              }
            }

            // 娓呯悊鏈娇鐢ㄧ殑鏂囦欢
            final usedPaths = savedImages
                .expand(
                    (img) => [img.path, img.originalPath, img.thumbnailPath])
                .toList();
            await cleanupUnusedFiles(workId, usedPaths);

            // Verify all processed files
            await _verifyAllProcessedFiles(tempFiles);

            onProgress?.call(1.0, '瀹屾垚');

            AppLogger.info('鍥剧墖淇濆瓨瀹屾垚', tag: 'WorkImageService', data: {
              'savedCount': savedImages.length,
            });

            return savedImages;
          } catch (e, stack) {
            AppLogger.error('淇濆瓨鍒版暟鎹簱澶辫触',
                tag: 'WorkImageService', error: e, stackTrace: stack);
            // 娓呯悊涓存椂鏂囦欢
            for (final path in tempFiles) {
              try {
                await File(path).delete();
              } catch (e) {
                AppLogger.warning('娓呯悊涓存椂鏂囦欢澶辫触',
                    tag: 'WorkImageService', error: e, data: {'path': path});
              }
            }
            rethrow;
          }
        } catch (e) {
          // 纭繚杩涘害鍥炶皟鏄剧ず閿欒鐘舵€?
          onProgress?.call(0, '淇濆瓨澶辫触: ${e.toString()}');
          rethrow;
        }
      },
      data: {'workId': workId, 'imageCount': images.length},
    );
  }

  /// 鏇存柊灏侀潰
  Future<void> updateCover(String workId, String imageId) async {
    return handleOperation(
      'updateCover',
      () async {
        AppLogger.debug('寮€濮嬫洿鏂颁綔鍝佸皝闈?, tag: 'WorkImageService', data: {
          'workId': workId,
          'imageId': imageId,
          'timestamp': DateTime.now().millisecondsSinceEpoch,
        });

        // 纭繚灏侀潰鐩綍瀛樺湪
        await _storage.ensureWorkDirectoryExists(workId);

        // 鑾峰彇婧愬浘鐗囪矾寰勫苟楠岃瘉
        final importedPath = _storage.getImportedPath(workId, imageId);
        final sourceFile = File(importedPath);
        if (!await sourceFile.exists()) {
          AppLogger.error('婧愬浘鐗囦笉瀛樺湪', tag: 'WorkImageService', data: {
            'workId': workId,
            'imageId': imageId,
            'importedPath': importedPath
          });
          throw FileSystemException('婧愬浘鐗囦笉瀛樺湪', importedPath);
        }

        try {
          // 璁板綍婧愬浘鐗囦俊鎭紝鏈夊姪浜庤皟璇?
          final sourceSize = await sourceFile.length();
          AppLogger.debug('婧愬浘鐗囨枃浠朵俊鎭?, tag: 'WorkImageService', data: {
            'sourceSize': sourceSize,
            'sourcePath': importedPath,
          });

          // 鐢熸垚骞朵繚瀛樺皝闈㈠鍏ュ浘
          final coverImportedPath =
              await _storage.saveCoverImported(workId, sourceFile);

          // 鐢熸垚骞朵繚瀛樺皝闈㈢缉鐣ュ浘
          final thumbnail = await _processor.processImage(
            sourceFile,
            maxWidth: 200,
            maxHeight: 200,
            quality: 80,
          );
          final coverThumbnailPath =
              await _storage.saveCoverThumbnail(workId, thumbnail);

          // 楠岃瘉灏侀潰鏂囦欢鏄惁鎴愬姛鐢熸垚
          final coverFiles = [
            File(coverImportedPath),
            File(coverThumbnailPath),
          ];

          bool allFilesExist = true;
          for (final file in coverFiles) {
            final exists = await file.exists();
            if (!exists) {
              allFilesExist = false;
              AppLogger.error('灏侀潰鏂囦欢鐢熸垚鍚庝笉瀛樺湪',
                  tag: 'WorkImageService', data: {'path': file.path});
            } else {
              // 璁板綍鏂囦欢澶у皬鐢ㄤ簬璋冭瘯
              final size = await file.length();
              AppLogger.debug('鐢熸垚鐨勫皝闈㈡枃浠朵俊鎭?, tag: 'WorkImageService', data: {
                'path': file.path,
                'size': size,
              });
            }
          }

          if (!allFilesExist) {
            throw const FileSystemException('灏侀潰鏂囦欢鐢熸垚澶辫触');
          }

          AppLogger.info('浣滃搧灏侀潰鏇存柊瀹屾垚', tag: 'WorkImageService', data: {
            'workId': workId,
            'imageId': imageId,
            'coverImported': coverImportedPath,
            'coverThumbnail': coverThumbnailPath,
            'timestamp': DateTime.now().millisecondsSinceEpoch,
          });
        } catch (e, stack) {
          AppLogger.error('鐢熸垚灏侀潰澶辫触',
              tag: 'WorkImageService',
              error: e,
              stackTrace: stack,
              data: {
                'workId': workId,
                'imageId': imageId,
                'sourcePath': importedPath,
              });
          rethrow;
        }
      },
      data: {'workId': workId, 'imageId': imageId},
    );
  }

  /// 纭繚灏侀潰鏂囦欢瀛樺湪
  Future<bool> _ensureCoverFilesExist(String workId) async {
    final coverPath = _storage.getWorkCoverImportedPath(workId);
    final thumbnailPath = _storage.getWorkCoverThumbnailPath(workId);

    // 灏濊瘯澶氭妫€鏌ユ枃浠舵槸鍚﹀瓨鍦紝鍏佽鏂囦欢绯荤粺鎿嶄綔瀹屾垚
    for (int i = 0; i < 3; i++) {
      final coverExists = await File(coverPath).exists();
      final thumbnailExists = await File(thumbnailPath).exists();

      if (coverExists && thumbnailExists) {
        return true;
      }

      AppLogger.debug('绛夊緟灏侀潰鏂囦欢鍐欏叆瀹屾垚', tag: 'WorkImageService', data: {
        'attempt': i + 1,
        'coverExists': coverExists,
        'thumbnailExists': thumbnailExists
      });

      // 绛夊緟鏂囦欢绯荤粺鎿嶄綔瀹屾垚
      await Future.delayed(Duration(milliseconds: 100 * (i + 1)));
    }

    return false;
  }

  /// 纭繚鏂囦欢鍐欏叆瀹屾垚
  Future<void> _ensureFileWritten(String filePath) async {
    try {
      final file = File(filePath);
      if (await file.exists()) {
        // 灏濊瘯鎵撳紑鏂囦欢骞惰鍙栦竴閮ㄥ垎鏉ョ‘淇濆畠宸插畬鍏ㄥ啓鍏?
        final raf = await file.open(mode: FileMode.read);
        try {
          await raf.read(4); // 璇诲彇鍑犱釜瀛楄妭浠ョ‘璁ゆ枃浠跺彲璁块棶
        } finally {
          await raf.close();
        }
      } else {
        AppLogger.warning(
          '鏂囦欢涓嶅瓨鍦紝鏃犳硶纭鍐欏叆鐘舵€?,
          tag: 'WorkImageService',
          data: {'path': filePath},
        );
      }
    } catch (e) {
      AppLogger.warning(
        '纭鏂囦欢鍐欏叆鐘舵€佸け璐?,
        tag: 'WorkImageService',
        error: e,
        data: {'path': filePath},
      );
    }
  }

  /// 鑾峰彇鍥剧墖鏍煎紡
  String _getImageFormat(File file) {
    return file.path.split('.').last.toLowerCase();
  }

  /// 鑾峰彇涓嬩竴涓浘鐗囩储寮?
  Future<int> _getNextImageIndex(String workId) async {
    return await _repository.getNextIndex(workId);
  }

  /// 妫€鏌ュ浘鐗囨槸鍚﹁閲嶆柊鎺掑簭
  bool _haveImagesBeenReordered(
      List<WorkImage> oldImages, List<WorkImage> newImages) {
    // 娌℃湁瓒冲鐨勫浘鐗囷紝涓嶇畻閲嶆帓
    if (oldImages.isEmpty || newImages.isEmpty) {
      return false;
    }

    // 鍒涘缓鏄犲皠浠ュ揩閫熸煡鎵炬棫鍥剧墖鐨勭储寮?
    final oldImageMap = {for (var img in oldImages) img.id: img.index};

    // 鐗瑰埆妫€鏌ョ涓€寮犲浘鏄惁鍙樹簡浣嶇疆
    if (oldImages.isNotEmpty && newImages.isNotEmpty) {
      if (oldImages[0].id != newImages[0].id) {
        return true; // 棣栧浘鍙樹簡
      }
    }

    // 妫€鏌ュ墠鍑犲紶鍥剧殑椤哄簭鏄惁鍙樺寲
    final checkCount = math.min(oldImages.length, newImages.length);

    // 妫€鏌ュ叾浠栧浘鐗囩殑椤哄簭
    for (int i = 0; i < checkCount; i++) {
      final newImg = newImages[i];
      // 濡傛灉鏂伴『搴忎腑鐨勫浘鐗囧湪鏃ф暟鎹腑鏈変笉鍚岀殑绱㈠紩锛岃鏄庡彂鐢熶簡閲嶆帓
      if (oldImageMap.containsKey(newImg.id) && oldImageMap[newImg.id] != i) {
        return true;
      }
    }

    return false;
  }

  /// 鍦ㄦ枃浠朵繚瀛樺悗楠岃瘉鎵€鏈夊凡澶勭悊鏂囦欢
  Future<void> _verifyAllProcessedFiles(List<String> paths) async {
    for (final path in paths) {
      try {
        await _ensureFileWritten(path);
      } catch (e) {
        AppLogger.warning(
          '楠岃瘉鏂囦欢澶辫触',
          tag: 'WorkImageService',
          error: e,
          data: {'path': path},
        );
      }
    }
  }

  /// 楠岃瘉灏侀潰鏂囦欢鏄惁瀛樺湪锛屽鏋滀笉瀛樺湪鍒欓噸鏂扮敓鎴?
  Future<bool> _verifyCoverExists(String workId) async {
    final coverPath = _storage.getWorkCoverImportedPath(workId);
    final coverExists = await _storage.verifyWorkImageExists(coverPath);

    AppLogger.debug('楠岃瘉灏侀潰鏂囦欢', tag: 'WorkImageService', data: {
      'workId': workId,
      'coverPath': coverPath,
      'exists': coverExists
    });

    // 濡傛灉灏侀潰涓嶅瓨鍦紝鎵惧嚭褰撳墠鐨勭涓€寮犲浘骞堕噸鏂扮敓鎴愬皝闈?
    if (!coverExists) {
      try {
        final images = await _repository.getAllByWorkId(workId);
        if (images.isNotEmpty) {
          AppLogger.warning('灏侀潰鏂囦欢涓㈠け锛岄噸鏂扮敓鎴?,
              tag: 'WorkImageService',
              data: {'workId': workId, 'firstImageId': images[0].id});
          await updateCover(workId, images[0].id);
          return true;
        }
      } catch (e, stack) {
        AppLogger.error('楠岃瘉骞堕噸鏂扮敓鎴愬皝闈㈠け璐?,
            tag: 'WorkImageService',
            error: e,
            stackTrace: stack,
            data: {'workId': workId});
      }
      return false;
    }

    return true;
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\application\services\work\work_service.dart
-----------------------------------
import 'dart:io';

import '../../../domain/models/work/work_entity.dart';
import '../../../domain/models/work/work_filter.dart';
import '../../../domain/repositories/work_image_repository.dart';
import '../../../domain/repositories/work_repository.dart';
import '../../../infrastructure/logging/logger.dart';
import '../../../infrastructure/storage/storage_interface.dart';
import './service_errors.dart';
import './work_image_service.dart';

/// 浣滃搧鏈嶅姟
class WorkService with WorkServiceErrorHandler {
  final WorkRepository _repository;
  final WorkImageService _imageService;
  final IStorage _storage;
  final WorkImageRepository _workImageRepository;

  WorkService({
    required WorkRepository repository,
    required WorkImageService imageService,
    required IStorage storage,
    required WorkImageRepository workImageRepository,
  })  : _repository = repository,
        _imageService = imageService,
        _storage = storage,
        _workImageRepository = workImageRepository;

  /// 缁熻浣滃搧鏁伴噺
  Future<int> count(WorkFilter? filter) async {
    return handleOperation(
      'count',
      () => _repository.count(filter),
      data: {'filter': filter?.toString()},
    );
  }

  /// 鍒犻櫎浣滃搧
  Future<void> deleteWork(String workId) async {
    return handleOperation(
      'deleteWork',
      () async {
        // 鍒犻櫎浣滃搧鍙婂浘鐗?
        await _repository.delete(workId);
        await _imageService.cleanupWorkImages(workId);
      },
      data: {'workId': workId},
    );
  }

  /// 鑾峰彇鎵€鏈変綔鍝?
  Future<List<WorkEntity>> getAllWorks() async {
    return handleOperation(
      'getAllWorks',
      () => _repository.getAll(),
    );
  }

  /// 鑾峰彇浣滃搧瀹炰綋
  Future<WorkEntity?> getWork(String workId) async {
    return handleOperation(
      'getWorkEntity',
      () async {
        final work = await _repository.get(workId);
        if (work != null) {
          // Load work images
          final images = await _workImageRepository.getAllByWorkId(workId);
          AppLogger.debug(
            'Loading work with images',
            tag: 'WorkService',
            data: {
              'workId': workId,
              'imageCount': images.length,
              'imagePaths': images.map((img) => img.path).toList(),
            },
          );
          return work.copyWith(images: images);
        }
        return work;
      },
      data: {'workId': workId},
    );
  }

  /// 鎸夋爣绛捐幏鍙栦綔鍝?
  Future<List<WorkEntity>> getWorksByTags(Set<String> tags) async {
    return handleOperation(
      'getWorksByTags',
      () => _repository.getByTags(tags),
      data: {'tags': tags.toList()},
    );
  }

  /// 瀵煎叆浣滃搧
  Future<WorkEntity> importWork(List<File> files, WorkEntity work) async {
    return handleOperation(
      'importWork',
      () async {
        AppLogger.debug(
          '瀵煎叆浣滃搧',
          tag: 'WorkService',
          data: {'fileCount': files.length, 'work': work.toJson()},
        );

        // 楠岃瘉杈撳叆
        if (files.isEmpty) throw ArgumentError('鍥剧墖鏂囦欢涓嶈兘涓虹┖');

        // 鏇存柊浣滃搧淇℃伅
        final updatedWork = work.copyWith(
          imageCount: files.length,
          updateTime: DateTime.now(),
          createTime: DateTime.now(),
        );

        // 淇濆瓨鍒版暟鎹簱
        final savedWork = await _repository.create(updatedWork);

        // 澶勭悊鍥剧墖瀵煎叆锛堝寘鎷敓鎴愬皝闈級
        final imagesImported =
            await _imageService.processImport(work.id, files);

        // 娉ㄦ剰锛氫笉闇€瑕佸湪杩欓噷鏄惧紡璋冪敤updateCover锛?
        // processImport鍐呴儴鐨剆aveChanges宸茬粡澶勭悊浜嗗皝闈㈢敓鎴?

        return savedWork.copyWith(images: imagesImported);
      },
      data: {'workId': work.id, 'fileCount': files.length},
    );
  }

  /// 鏌ヨ浣滃搧
  Future<List<WorkEntity>> queryWorks(WorkFilter filter) async {
    return handleOperation(
      'queryWorks',
      () async {
        AppLogger.debug(
          '寮€濮嬫煡璇綔鍝?,
          tag: 'WorkService',
          data: {
            'filter': {
              'style': filter.style?.name,
              'tool': filter.tool?.name,
              'keyword': filter.keyword,
              'tags': filter.tags.toList(),
              'sortOption': {
                'field': filter.sortOption.field.name,
                'descending': filter.sortOption.descending,
              },
            },
          },
        );

        final results = await _repository.query(filter);

        AppLogger.debug(
          '鏌ヨ浣滃搧瀹屾垚',
          tag: 'WorkService',
          data: {'resultCount': results.length},
        );

        return results;
      },
      data: {'filter': filter.toString()},
    );
  }

  /// 鏇存柊浣滃搧瀹炰綋
  Future<WorkEntity> updateWorkEntity(WorkEntity work) async {
    return handleOperation(
      'updateWorkEntity',
      () async {
        AppLogger.debug('寮€濮嬫洿鏂颁綔鍝佷俊鎭?, tag: 'WorkService', data: {
          'workId': work.id,
          'imageCount': work.images.length,
          'hasImages': work.images.isNotEmpty,
        });

        // 鏇存柊鍩烘湰淇℃伅
        final updatedWork = work.copyWith(
          updateTime: DateTime.now(),
          imageCount: work.images.length,
        );

        // 淇濆瓨浣滃搧淇℃伅
        return await _repository.save(updatedWork);
      },
      data: {'workId': work.id},
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\application\services\work\work_service_error_handler.dart
-----------------------------------
import '../../../infrastructure/logging/logger.dart';

/// 閿欒澶勭悊Mixin
mixin WorkServiceErrorHandler {
  /// 缁熶竴澶勭悊鏈嶅姟鎿嶄綔
  Future<T> handleOperation<T>(
    String operation,
    Future<T> Function() action, {
    Map<String, dynamic>? data,
    bool rethrowError = true,
    String? tag,
  }) async {
    try {
      return await action();
    } catch (e, stack) {
      AppLogger.error(
        'Operation failed: $operation',
        tag: tag ?? runtimeType.toString(),
        error: e,
        stackTrace: stack,
        data: data,
      );

      if (rethrowError) {
        if (e is ArgumentError) {
          rethrow; // 鍙傛暟閿欒鐩存帴鎶涘嚭
        }
        throw WorkServiceException(operation, e.toString());
      }

      return Future.value(); // 濡傛灉涓嶉噸鏂版姏鍑猴紝杩斿洖榛樿鍊?
    }
  }

  /// 缁熶竴澶勭悊鍚屾鎿嶄綔
  T handleSync<T>(
    String operation,
    T Function() action, {
    Map<String, dynamic>? data,
    bool rethrowError = true,
    String? tag,
  }) {
    try {
      return action();
    } catch (e, stack) {
      AppLogger.error(
        'Operation failed: $operation',
        tag: tag ?? runtimeType.toString(),
        error: e,
        stackTrace: stack,
        data: data,
      );

      if (rethrowError) {
        if (e is ArgumentError) {
          rethrow;
        }
        throw WorkServiceException(operation, e.toString());
      }

      return null as T; // 濡傛灉涓嶉噸鏂版姏鍑猴紝杩斿洖null
    }
  }
}

/// 浣滃搧鏈嶅姟寮傚父绫?
class WorkServiceException implements Exception {
  final String operation;
  final String message;

  WorkServiceException(this.operation, this.message);

  @override
  String toString() => 'WorkServiceException: $operation - $message';
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\domain\enums\app_theme_mode.dart
-----------------------------------
import 'package:flutter/material.dart';

/// The theme mode options supported by the application
enum AppThemeMode {
  /// System theme mode (follows device settings)
  system,

  /// Light theme mode
  light,

  /// Dark theme mode
  dark;

  /// Get a friendly display name for the theme mode
  String get displayName {
    return switch (this) {
      AppThemeMode.system => '璺熼殢绯荤粺',
      AppThemeMode.light => '娴呰壊妯″紡',
      AppThemeMode.dark => '娣辫壊妯″紡',
    };
  }

  /// Get the icon for the theme mode
  IconData get icon {
    return switch (this) {
      AppThemeMode.system => Icons.settings_system_daydream_outlined,
      AppThemeMode.light => Icons.light_mode_outlined,
      AppThemeMode.dark => Icons.dark_mode_outlined,
    };
  }

  /// Convert to Flutter's ThemeMode
  ThemeMode toFlutterThemeMode() {
    return switch (this) {
      AppThemeMode.system => ThemeMode.system,
      AppThemeMode.light => ThemeMode.light,
      AppThemeMode.dark => ThemeMode.dark,
    };
  }

  /// Convert to string value (for storage)
  String toStorageValue() {
    return name;
  }

  /// Parse from string value (for storage)
  static AppThemeMode fromString(String? value) {
    return switch (value?.toLowerCase()) {
      'system' => AppThemeMode.system,
      'light' => AppThemeMode.light,
      'dark' => AppThemeMode.dark,
      _ => AppThemeMode.system, // Default to system if unknown
    };
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\domain\enums\sort_field.dart
-----------------------------------
/// 鎺掑簭瀛楁绫诲瀷
enum SortField {
  title('title', '鏍囬'),
  author('author', '浣滆€?),
  creationDate('creation_date', '鍒涗綔鏃ユ湡'),
  createTime('create_time', '鍒涘缓鏃堕棿'),
  updateTime('update_time', '鏇存柊鏃堕棿'),
  tool('tool', '宸ュ叿'),
  style('style', '椋庢牸'),
  none('none', '鏃?);

  final String value;
  final String label;

  const SortField(this.value, this.label);
}

extension SortFieldParsing on SortField {
  static SortField fromString(String value) {
    return SortField.values.firstWhere(
      (e) => e.value == value,
      orElse: () => SortField.createTime,
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\domain\enums\work_status.dart
-----------------------------------
/// 浣滃搧鐘舵€?
enum WorkStatus {
  draft('draft', '鑽夌'),
  published('published', '宸插彂甯?),
  archived('archived', '宸插綊妗?);

  final String value;
  final String label;

  const WorkStatus(this.value, this.label);

  /// 鏄惁宸插綊妗?
  bool get isArchived => this == WorkStatus.archived;

  /// 鏄惁涓鸿崏绋?
  bool get isDraft => this == WorkStatus.draft;

  /// 鏄惁涓洪潪鑽夌鐘舵€?
  bool get isNotDraft => !isDraft;

  /// 鏄惁宸插彂甯?
  bool get isPublished => this == WorkStatus.published;

  /// 浠庡瓧绗︿覆瑙ｆ瀽鐘舵€?
  static WorkStatus fromString(String value) {
    return WorkStatus.values.firstWhere(
      (e) => e.value == value,
      orElse: () => WorkStatus.draft,
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\domain\enums\work_style.dart
-----------------------------------
/// 浣滃搧椋庢牸
enum WorkStyle {
  regular('regular', '妤蜂功'),
  running('running', '琛屼功'),
  cursive('cursive', '鑽変功'),
  clerical('clerical', '闅朵功'),
  seal('seal', '绡嗕功'),
  other('other', '鍏朵粬');

  final String value;
  final String label;

  const WorkStyle(this.value, this.label);

  String toJson() => value;

  // 鐢ㄤ簬freezed鍙嶅簭鍒楀寲鐨勯潤鎬佹柟娉?
  static WorkStyle? deserializeNullable(dynamic value) =>
      value == null ? null : fromValue(value);

  static WorkStyle fromString(String value) {
    return WorkStyle.values.firstWhere(
      (e) => e.value == value || e.name == value,
      orElse: () => WorkStyle.other,
    );
  }

  static WorkStyle fromValue(dynamic v) {
    if (v is WorkStyle) return v;
    final value = v?.toString() ?? '';
    return fromString(value);
  }

  // 鐢ㄤ簬freezed搴忓垪鍖栫殑闈欐€佹柟娉?
  static String? serializeNullable(WorkStyle? style) => style?.value;
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\domain\enums\work_tool.dart
-----------------------------------
/// 鍒涗綔宸ュ叿
enum WorkTool {
  brush('brush', '姣涚瑪'),
  hardPen('hardPen', '纭瑪'),
  other('other', '鍏朵粬');

  final String value;
  final String label;

  const WorkTool(this.value, this.label);

  String toJson() => value;

  static WorkTool? fromJson(dynamic value) =>
      value == null ? null : fromValue(value);

  static WorkTool fromString(String value) {
    return WorkTool.values.firstWhere(
      (e) => e.value == value || e.name == value,
      orElse: () => WorkTool.other,
    );
  }

  static WorkTool fromValue(dynamic v) {
    if (v is WorkTool) return v;
    final value = v?.toString() ?? '';
    return fromString(value);
  }

  // 鐢ㄤ簬JSON搴忓垪鍖栫殑闈欐€佹柟娉?
  static String? serializeNullable(WorkTool? tool) => tool?.value;
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\domain\models\character\character_entity.dart
-----------------------------------
import 'package:equatable/equatable.dart';
import 'package:freezed_annotation/freezed_annotation.dart';

import 'character_region.dart';

part 'character_entity.freezed.dart';
part 'character_entity.g.dart';

@freezed
class CharacterEntity with _$CharacterEntity {
  const factory CharacterEntity({
    required String id,
    required String workId,
    required String pageId,
    required String character,
    required CharacterRegion region,
    required DateTime createTime,
    required DateTime updateTime,
    @Default(false) bool isFavorite,
    @Default([]) List<String> tags,
    String? note,
  }) = _CharacterEntity;

  factory CharacterEntity.create({
    required String workId,
    required String pageId,
    required CharacterRegion region,
    String character = '',
    List<String> tags = const [],
    String? note,
  }) {
    final now = DateTime.now();
    return CharacterEntity(
      id: region.id,
      workId: workId,
      pageId: pageId,
      character: character,
      region: region,
      createTime: now,
      updateTime: now,
      tags: tags,
      note: note,
    );
  }

  factory CharacterEntity.fromJson(Map<String, dynamic> json) =>
      _$CharacterEntityFromJson(json);
}

// 瀛楃杩囨护鍣ㄧ被
class CharacterFilter extends Equatable {
  final String? workId;
  final String? pageId;
  final String? searchText;
  final List<String>? tags;
  final bool? isFavorite;
  final DateTime? fromDate;
  final DateTime? toDate;
  final SortField? sortBy;
  final SortDirection? sortDirection;
  final int? limit;
  final int? offset;

  const CharacterFilter({
    this.workId,
    this.pageId,
    this.searchText,
    this.tags,
    this.isFavorite,
    this.fromDate,
    this.toDate,
    this.sortBy,
    this.sortDirection,
    this.limit,
    this.offset,
  });

  @override
  List<Object?> get props => [
        workId,
        pageId,
        searchText,
        tags,
        isFavorite,
        fromDate,
        toDate,
        sortBy,
        sortDirection,
        limit,
        offset,
      ];

  // 鍒涘缓鍓湰骞舵洿鏂伴儴鍒嗗睘鎬?
  CharacterFilter copyWith({
    String? workId,
    String? pageId,
    String? searchText,
    List<String>? tags,
    bool? isFavorite,
    DateTime? fromDate,
    DateTime? toDate,
    SortField? sortBy,
    SortDirection? sortDirection,
    int? limit,
    int? offset,
    bool clearWorkId = false,
    bool clearPageId = false,
    bool clearSearchText = false,
    bool clearTags = false,
    bool clearIsFavorite = false,
    bool clearFromDate = false,
    bool clearToDate = false,
    bool clearSortBy = false,
    bool clearSortDirection = false,
    bool clearLimit = false,
    bool clearOffset = false,
  }) {
    return CharacterFilter(
      workId: clearWorkId ? null : workId ?? this.workId,
      pageId: clearPageId ? null : pageId ?? this.pageId,
      searchText: clearSearchText ? null : searchText ?? this.searchText,
      tags: clearTags ? null : tags ?? this.tags,
      isFavorite: clearIsFavorite ? null : isFavorite ?? this.isFavorite,
      fromDate: clearFromDate ? null : fromDate ?? this.fromDate,
      toDate: clearToDate ? null : toDate ?? this.toDate,
      sortBy: clearSortBy ? null : sortBy ?? this.sortBy,
      sortDirection:
          clearSortDirection ? null : sortDirection ?? this.sortDirection,
      limit: clearLimit ? null : limit ?? this.limit,
      offset: clearOffset ? null : offset ?? this.offset,
    );
  }
}

// 鎺掑簭鏂瑰悜
enum SortDirection {
  ascending,
  descending,
}

// 鎺掑簭瀛楁
enum SortField {
  character,
  createTime,
  updateTime,
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\domain\models\character\character_entity.freezed.dart
-----------------------------------
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'character_entity.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

CharacterEntity _$CharacterEntityFromJson(Map<String, dynamic> json) {
  return _CharacterEntity.fromJson(json);
}

/// @nodoc
mixin _$CharacterEntity {
  String get id => throw _privateConstructorUsedError;
  String get workId => throw _privateConstructorUsedError;
  String get pageId => throw _privateConstructorUsedError;
  String get character => throw _privateConstructorUsedError;
  CharacterRegion get region => throw _privateConstructorUsedError;
  DateTime get createTime => throw _privateConstructorUsedError;
  DateTime get updateTime => throw _privateConstructorUsedError;
  bool get isFavorite => throw _privateConstructorUsedError;
  List<String> get tags => throw _privateConstructorUsedError;
  String? get note => throw _privateConstructorUsedError;

  /// Serializes this CharacterEntity to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of CharacterEntity
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $CharacterEntityCopyWith<CharacterEntity> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CharacterEntityCopyWith<$Res> {
  factory $CharacterEntityCopyWith(
          CharacterEntity value, $Res Function(CharacterEntity) then) =
      _$CharacterEntityCopyWithImpl<$Res, CharacterEntity>;
  @useResult
  $Res call(
      {String id,
      String workId,
      String pageId,
      String character,
      CharacterRegion region,
      DateTime createTime,
      DateTime updateTime,
      bool isFavorite,
      List<String> tags,
      String? note});

  $CharacterRegionCopyWith<$Res> get region;
}

/// @nodoc
class _$CharacterEntityCopyWithImpl<$Res, $Val extends CharacterEntity>
    implements $CharacterEntityCopyWith<$Res> {
  _$CharacterEntityCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of CharacterEntity
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? workId = null,
    Object? pageId = null,
    Object? character = null,
    Object? region = null,
    Object? createTime = null,
    Object? updateTime = null,
    Object? isFavorite = null,
    Object? tags = null,
    Object? note = freezed,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      workId: null == workId
          ? _value.workId
          : workId // ignore: cast_nullable_to_non_nullable
              as String,
      pageId: null == pageId
          ? _value.pageId
          : pageId // ignore: cast_nullable_to_non_nullable
              as String,
      character: null == character
          ? _value.character
          : character // ignore: cast_nullable_to_non_nullable
              as String,
      region: null == region
          ? _value.region
          : region // ignore: cast_nullable_to_non_nullable
              as CharacterRegion,
      createTime: null == createTime
          ? _value.createTime
          : createTime // ignore: cast_nullable_to_non_nullable
              as DateTime,
      updateTime: null == updateTime
          ? _value.updateTime
          : updateTime // ignore: cast_nullable_to_non_nullable
              as DateTime,
      isFavorite: null == isFavorite
          ? _value.isFavorite
          : isFavorite // ignore: cast_nullable_to_non_nullable
              as bool,
      tags: null == tags
          ? _value.tags
          : tags // ignore: cast_nullable_to_non_nullable
              as List<String>,
      note: freezed == note
          ? _value.note
          : note // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }

  /// Create a copy of CharacterEntity
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $CharacterRegionCopyWith<$Res> get region {
    return $CharacterRegionCopyWith<$Res>(_value.region, (value) {
      return _then(_value.copyWith(region: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$CharacterEntityImplCopyWith<$Res>
    implements $CharacterEntityCopyWith<$Res> {
  factory _$$CharacterEntityImplCopyWith(_$CharacterEntityImpl value,
          $Res Function(_$CharacterEntityImpl) then) =
      __$$CharacterEntityImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      String workId,
      String pageId,
      String character,
      CharacterRegion region,
      DateTime createTime,
      DateTime updateTime,
      bool isFavorite,
      List<String> tags,
      String? note});

  @override
  $CharacterRegionCopyWith<$Res> get region;
}

/// @nodoc
class __$$CharacterEntityImplCopyWithImpl<$Res>
    extends _$CharacterEntityCopyWithImpl<$Res, _$CharacterEntityImpl>
    implements _$$CharacterEntityImplCopyWith<$Res> {
  __$$CharacterEntityImplCopyWithImpl(
      _$CharacterEntityImpl _value, $Res Function(_$CharacterEntityImpl) _then)
      : super(_value, _then);

  /// Create a copy of CharacterEntity
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? workId = null,
    Object? pageId = null,
    Object? character = null,
    Object? region = null,
    Object? createTime = null,
    Object? updateTime = null,
    Object? isFavorite = null,
    Object? tags = null,
    Object? note = freezed,
  }) {
    return _then(_$CharacterEntityImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      workId: null == workId
          ? _value.workId
          : workId // ignore: cast_nullable_to_non_nullable
              as String,
      pageId: null == pageId
          ? _value.pageId
          : pageId // ignore: cast_nullable_to_non_nullable
              as String,
      character: null == character
          ? _value.character
          : character // ignore: cast_nullable_to_non_nullable
              as String,
      region: null == region
          ? _value.region
          : region // ignore: cast_nullable_to_non_nullable
              as CharacterRegion,
      createTime: null == createTime
          ? _value.createTime
          : createTime // ignore: cast_nullable_to_non_nullable
              as DateTime,
      updateTime: null == updateTime
          ? _value.updateTime
          : updateTime // ignore: cast_nullable_to_non_nullable
              as DateTime,
      isFavorite: null == isFavorite
          ? _value.isFavorite
          : isFavorite // ignore: cast_nullable_to_non_nullable
              as bool,
      tags: null == tags
          ? _value._tags
          : tags // ignore: cast_nullable_to_non_nullable
              as List<String>,
      note: freezed == note
          ? _value.note
          : note // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CharacterEntityImpl implements _CharacterEntity {
  const _$CharacterEntityImpl(
      {required this.id,
      required this.workId,
      required this.pageId,
      required this.character,
      required this.region,
      required this.createTime,
      required this.updateTime,
      this.isFavorite = false,
      final List<String> tags = const [],
      this.note})
      : _tags = tags;

  factory _$CharacterEntityImpl.fromJson(Map<String, dynamic> json) =>
      _$$CharacterEntityImplFromJson(json);

  @override
  final String id;
  @override
  final String workId;
  @override
  final String pageId;
  @override
  final String character;
  @override
  final CharacterRegion region;
  @override
  final DateTime createTime;
  @override
  final DateTime updateTime;
  @override
  @JsonKey()
  final bool isFavorite;
  final List<String> _tags;
  @override
  @JsonKey()
  List<String> get tags {
    if (_tags is EqualUnmodifiableListView) return _tags;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_tags);
  }

  @override
  final String? note;

  @override
  String toString() {
    return 'CharacterEntity(id: $id, workId: $workId, pageId: $pageId, character: $character, region: $region, createTime: $createTime, updateTime: $updateTime, isFavorite: $isFavorite, tags: $tags, note: $note)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CharacterEntityImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.workId, workId) || other.workId == workId) &&
            (identical(other.pageId, pageId) || other.pageId == pageId) &&
            (identical(other.character, character) ||
                other.character == character) &&
            (identical(other.region, region) || other.region == region) &&
            (identical(other.createTime, createTime) ||
                other.createTime == createTime) &&
            (identical(other.updateTime, updateTime) ||
                other.updateTime == updateTime) &&
            (identical(other.isFavorite, isFavorite) ||
                other.isFavorite == isFavorite) &&
            const DeepCollectionEquality().equals(other._tags, _tags) &&
            (identical(other.note, note) || other.note == note));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      workId,
      pageId,
      character,
      region,
      createTime,
      updateTime,
      isFavorite,
      const DeepCollectionEquality().hash(_tags),
      note);

  /// Create a copy of CharacterEntity
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$CharacterEntityImplCopyWith<_$CharacterEntityImpl> get copyWith =>
      __$$CharacterEntityImplCopyWithImpl<_$CharacterEntityImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$CharacterEntityImplToJson(
      this,
    );
  }
}

abstract class _CharacterEntity implements CharacterEntity {
  const factory _CharacterEntity(
      {required final String id,
      required final String workId,
      required final String pageId,
      required final String character,
      required final CharacterRegion region,
      required final DateTime createTime,
      required final DateTime updateTime,
      final bool isFavorite,
      final List<String> tags,
      final String? note}) = _$CharacterEntityImpl;

  factory _CharacterEntity.fromJson(Map<String, dynamic> json) =
      _$CharacterEntityImpl.fromJson;

  @override
  String get id;
  @override
  String get workId;
  @override
  String get pageId;
  @override
  String get character;
  @override
  CharacterRegion get region;
  @override
  DateTime get createTime;
  @override
  DateTime get updateTime;
  @override
  bool get isFavorite;
  @override
  List<String> get tags;
  @override
  String? get note;

  /// Create a copy of CharacterEntity
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$CharacterEntityImplCopyWith<_$CharacterEntityImpl> get copyWith =>
      throw _privateConstructorUsedError;
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\domain\models\character\character_entity.g.dart
-----------------------------------
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'character_entity.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_$CharacterEntityImpl _$$CharacterEntityImplFromJson(
        Map<String, dynamic> json) =>
    _$CharacterEntityImpl(
      id: json['id'] as String,
      workId: json['workId'] as String,
      pageId: json['pageId'] as String,
      character: json['character'] as String,
      region: CharacterRegion.fromJson(json['region'] as Map<String, dynamic>),
      createTime: DateTime.parse(json['createTime'] as String),
      updateTime: DateTime.parse(json['updateTime'] as String),
      isFavorite: json['isFavorite'] as bool? ?? false,
      tags:
          (json['tags'] as List<dynamic>?)?.map((e) => e as String).toList() ??
              const [],
      note: json['note'] as String?,
    );

Map<String, dynamic> _$$CharacterEntityImplToJson(
        _$CharacterEntityImpl instance) =>
    <String, dynamic>{
      'id': instance.id,
      'workId': instance.workId,
      'pageId': instance.pageId,
      'character': instance.character,
      'region': instance.region,
      'createTime': instance.createTime.toIso8601String(),
      'updateTime': instance.updateTime.toIso8601String(),
      'isFavorite': instance.isFavorite,
      'tags': instance.tags,
      'note': instance.note,
    };



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\domain\models\character\character_image.dart
-----------------------------------
import 'package:flutter/material.dart';
import 'package:freezed_annotation/freezed_annotation.dart';

import '../../../infrastructure/utils/json_converters.dart';
import 'character_region.dart';
import 'processing_options.dart';

part 'character_image.freezed.dart';
part 'character_image.g.dart';

@freezed
class CharacterImage with _$CharacterImage {
  const factory CharacterImage({
    required String id,
    required String originalPath,
    required String binaryPath,
    required String thumbnailPath,
    String? svgPath, // 鏂板锛歋VG杞粨璺緞
    @SizeConverter() required Size originalSize,
    required ProcessingOptions options,
  }) = _CharacterImage;

  factory CharacterImage.fromJson(Map<String, dynamic> json) =>
      _$CharacterImageFromJson(json);

  factory CharacterImage.fromRegion(CharacterRegion region, String originalPath,
      String binaryPath, String thumbnailPath, String? svgPath) {
    return CharacterImage(
      id: region.id,
      originalPath: originalPath,
      binaryPath: binaryPath,
      thumbnailPath: thumbnailPath,
      svgPath: svgPath,
      originalSize: Size(region.rect.width, region.rect.height),
      options: region.options,
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\domain\models\character\character_image.freezed.dart
-----------------------------------
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'character_image.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

CharacterImage _$CharacterImageFromJson(Map<String, dynamic> json) {
  return _CharacterImage.fromJson(json);
}

/// @nodoc
mixin _$CharacterImage {
  String get id => throw _privateConstructorUsedError;
  String get originalPath => throw _privateConstructorUsedError;
  String get binaryPath => throw _privateConstructorUsedError;
  String get thumbnailPath => throw _privateConstructorUsedError;
  String? get svgPath => throw _privateConstructorUsedError; // 鏂板锛歋VG杞粨璺緞
  @SizeConverter()
  Size get originalSize => throw _privateConstructorUsedError;
  ProcessingOptions get options => throw _privateConstructorUsedError;

  /// Serializes this CharacterImage to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of CharacterImage
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $CharacterImageCopyWith<CharacterImage> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CharacterImageCopyWith<$Res> {
  factory $CharacterImageCopyWith(
          CharacterImage value, $Res Function(CharacterImage) then) =
      _$CharacterImageCopyWithImpl<$Res, CharacterImage>;
  @useResult
  $Res call(
      {String id,
      String originalPath,
      String binaryPath,
      String thumbnailPath,
      String? svgPath,
      @SizeConverter() Size originalSize,
      ProcessingOptions options});

  $ProcessingOptionsCopyWith<$Res> get options;
}

/// @nodoc
class _$CharacterImageCopyWithImpl<$Res, $Val extends CharacterImage>
    implements $CharacterImageCopyWith<$Res> {
  _$CharacterImageCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of CharacterImage
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? originalPath = null,
    Object? binaryPath = null,
    Object? thumbnailPath = null,
    Object? svgPath = freezed,
    Object? originalSize = null,
    Object? options = null,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      originalPath: null == originalPath
          ? _value.originalPath
          : originalPath // ignore: cast_nullable_to_non_nullable
              as String,
      binaryPath: null == binaryPath
          ? _value.binaryPath
          : binaryPath // ignore: cast_nullable_to_non_nullable
              as String,
      thumbnailPath: null == thumbnailPath
          ? _value.thumbnailPath
          : thumbnailPath // ignore: cast_nullable_to_non_nullable
              as String,
      svgPath: freezed == svgPath
          ? _value.svgPath
          : svgPath // ignore: cast_nullable_to_non_nullable
              as String?,
      originalSize: null == originalSize
          ? _value.originalSize
          : originalSize // ignore: cast_nullable_to_non_nullable
              as Size,
      options: null == options
          ? _value.options
          : options // ignore: cast_nullable_to_non_nullable
              as ProcessingOptions,
    ) as $Val);
  }

  /// Create a copy of CharacterImage
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ProcessingOptionsCopyWith<$Res> get options {
    return $ProcessingOptionsCopyWith<$Res>(_value.options, (value) {
      return _then(_value.copyWith(options: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$CharacterImageImplCopyWith<$Res>
    implements $CharacterImageCopyWith<$Res> {
  factory _$$CharacterImageImplCopyWith(_$CharacterImageImpl value,
          $Res Function(_$CharacterImageImpl) then) =
      __$$CharacterImageImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      String originalPath,
      String binaryPath,
      String thumbnailPath,
      String? svgPath,
      @SizeConverter() Size originalSize,
      ProcessingOptions options});

  @override
  $ProcessingOptionsCopyWith<$Res> get options;
}

/// @nodoc
class __$$CharacterImageImplCopyWithImpl<$Res>
    extends _$CharacterImageCopyWithImpl<$Res, _$CharacterImageImpl>
    implements _$$CharacterImageImplCopyWith<$Res> {
  __$$CharacterImageImplCopyWithImpl(
      _$CharacterImageImpl _value, $Res Function(_$CharacterImageImpl) _then)
      : super(_value, _then);

  /// Create a copy of CharacterImage
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? originalPath = null,
    Object? binaryPath = null,
    Object? thumbnailPath = null,
    Object? svgPath = freezed,
    Object? originalSize = null,
    Object? options = null,
  }) {
    return _then(_$CharacterImageImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      originalPath: null == originalPath
          ? _value.originalPath
          : originalPath // ignore: cast_nullable_to_non_nullable
              as String,
      binaryPath: null == binaryPath
          ? _value.binaryPath
          : binaryPath // ignore: cast_nullable_to_non_nullable
              as String,
      thumbnailPath: null == thumbnailPath
          ? _value.thumbnailPath
          : thumbnailPath // ignore: cast_nullable_to_non_nullable
              as String,
      svgPath: freezed == svgPath
          ? _value.svgPath
          : svgPath // ignore: cast_nullable_to_non_nullable
              as String?,
      originalSize: null == originalSize
          ? _value.originalSize
          : originalSize // ignore: cast_nullable_to_non_nullable
              as Size,
      options: null == options
          ? _value.options
          : options // ignore: cast_nullable_to_non_nullable
              as ProcessingOptions,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CharacterImageImpl implements _CharacterImage {
  const _$CharacterImageImpl(
      {required this.id,
      required this.originalPath,
      required this.binaryPath,
      required this.thumbnailPath,
      this.svgPath,
      @SizeConverter() required this.originalSize,
      required this.options});

  factory _$CharacterImageImpl.fromJson(Map<String, dynamic> json) =>
      _$$CharacterImageImplFromJson(json);

  @override
  final String id;
  @override
  final String originalPath;
  @override
  final String binaryPath;
  @override
  final String thumbnailPath;
  @override
  final String? svgPath;
// 鏂板锛歋VG杞粨璺緞
  @override
  @SizeConverter()
  final Size originalSize;
  @override
  final ProcessingOptions options;

  @override
  String toString() {
    return 'CharacterImage(id: $id, originalPath: $originalPath, binaryPath: $binaryPath, thumbnailPath: $thumbnailPath, svgPath: $svgPath, originalSize: $originalSize, options: $options)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CharacterImageImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.originalPath, originalPath) ||
                other.originalPath == originalPath) &&
            (identical(other.binaryPath, binaryPath) ||
                other.binaryPath == binaryPath) &&
            (identical(other.thumbnailPath, thumbnailPath) ||
                other.thumbnailPath == thumbnailPath) &&
            (identical(other.svgPath, svgPath) || other.svgPath == svgPath) &&
            (identical(other.originalSize, originalSize) ||
                other.originalSize == originalSize) &&
            (identical(other.options, options) || other.options == options));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, id, originalPath, binaryPath,
      thumbnailPath, svgPath, originalSize, options);

  /// Create a copy of CharacterImage
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$CharacterImageImplCopyWith<_$CharacterImageImpl> get copyWith =>
      __$$CharacterImageImplCopyWithImpl<_$CharacterImageImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$CharacterImageImplToJson(
      this,
    );
  }
}

abstract class _CharacterImage implements CharacterImage {
  const factory _CharacterImage(
      {required final String id,
      required final String originalPath,
      required final String binaryPath,
      required final String thumbnailPath,
      final String? svgPath,
      @SizeConverter() required final Size originalSize,
      required final ProcessingOptions options}) = _$CharacterImageImpl;

  factory _CharacterImage.fromJson(Map<String, dynamic> json) =
      _$CharacterImageImpl.fromJson;

  @override
  String get id;
  @override
  String get originalPath;
  @override
  String get binaryPath;
  @override
  String get thumbnailPath;
  @override
  String? get svgPath; // 鏂板锛歋VG杞粨璺緞
  @override
  @SizeConverter()
  Size get originalSize;
  @override
  ProcessingOptions get options;

  /// Create a copy of CharacterImage
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$CharacterImageImplCopyWith<_$CharacterImageImpl> get copyWith =>
      throw _privateConstructorUsedError;
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\domain\models\character\character_image.g.dart
-----------------------------------
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'character_image.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_$CharacterImageImpl _$$CharacterImageImplFromJson(Map<String, dynamic> json) =>
    _$CharacterImageImpl(
      id: json['id'] as String,
      originalPath: json['originalPath'] as String,
      binaryPath: json['binaryPath'] as String,
      thumbnailPath: json['thumbnailPath'] as String,
      svgPath: json['svgPath'] as String?,
      originalSize: const SizeConverter()
          .fromJson(json['originalSize'] as Map<String, dynamic>),
      options:
          ProcessingOptions.fromJson(json['options'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$$CharacterImageImplToJson(
        _$CharacterImageImpl instance) =>
    <String, dynamic>{
      'id': instance.id,
      'originalPath': instance.originalPath,
      'binaryPath': instance.binaryPath,
      'thumbnailPath': instance.thumbnailPath,
      'svgPath': instance.svgPath,
      'originalSize': const SizeConverter().toJson(instance.originalSize),
      'options': instance.options,
    };



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\domain\models\character\character_image_type.dart
-----------------------------------
/// 瀛楃鍥惧儚绫诲瀷
enum CharacterImageType {
  /// 鍘熷鍥惧儚
  original,

  /// 浜屽€煎寲鍥惧儚
  binary,

  /// 缂╃暐鍥?
  thumbnail,
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\domain\models\character\character_region.dart
-----------------------------------
import 'dart:convert';

import 'package:flutter/material.dart';
import 'package:freezed_annotation/freezed_annotation.dart';
import 'package:uuid/uuid.dart';

import '../../../infrastructure/utils/json_converters.dart';
import 'processing_options.dart';

part 'character_region.freezed.dart';
part 'character_region.g.dart';

@freezed
class CharacterRegion with _$CharacterRegion {
  const factory CharacterRegion({
    required String id,
    required String pageId,
    @RectConverter() required Rect rect,
    @Default(0.0) double rotation,
    @Default('') String character,
    required DateTime createTime,
    required DateTime updateTime,
    @Default(ProcessingOptions()) ProcessingOptions options,
    @OffsetListConverter() List<Offset>? erasePoints,
    @Default(false) bool isSaved,
    String? characterId,
  }) = _CharacterRegion;

  factory CharacterRegion.create({
    required String pageId,
    required Rect rect,
    double rotation = 0.0,
    String character = '',
    ProcessingOptions? options,
    String? characterId,
  }) {
    final now = DateTime.now();
    return CharacterRegion(
      id: DateTime.now().millisecondsSinceEpoch.toString(),
      pageId: pageId,
      rect: rect,
      rotation: rotation,
      character: character,
      createTime: now,
      updateTime: now,
      options: options ?? const ProcessingOptions(),
      isSaved: false,
      characterId: characterId,
    );
  }

  factory CharacterRegion.fromJson(Map<String, dynamic> json) =>
      _$CharacterRegionFromJson(json);
}

// Extension for serialization helpers
extension CharacterRegionExt on CharacterRegion {
  Map<String, dynamic> toDbJson() {
    return {
      'id': id,
      'pageId': pageId,
      'rect_x': rect.left,
      'rect_y': rect.top,
      'rect_width': rect.width,
      'rect_height': rect.height,
      'rotation': rotation,
      'character': character,
      'createTime': createTime.toIso8601String(),
      'updateTime': updateTime.toIso8601String(),
      'options': jsonEncode(options.toJson()),
      'erasePoints': erasePoints != null
          ? jsonEncode(erasePoints!.map((p) => {'x': p.dx, 'y': p.dy}).toList())
          : null,
      'characterId': characterId,
    };
  }

  // 浠庢暟鎹簱璁板綍鍒涘缓
  static CharacterRegion fromDbJson(Map<String, dynamic> json) {
    return CharacterRegion(
      id: json['id'] as String,
      pageId: json['pageId'] as String,
      rect: Rect.fromLTWH(
        json['rect_x'] as double,
        json['rect_y'] as double,
        json['rect_width'] as double,
        json['rect_height'] as double,
      ),
      rotation: json['rotation'] as double,
      character: json['character'] as String,
      createTime: DateTime.parse(json['createTime'] as String),
      updateTime: DateTime.parse(json['updateTime'] as String),
      options:
          ProcessingOptions.fromJson(jsonDecode(json['options'] as String)),
      erasePoints: json['erasePoints'] != null
          ? (jsonDecode(json['erasePoints'] as String) as List)
              .map(
                  (point) => Offset(point['x'] as double, point['y'] as double))
              .toList()
          : [],
      isSaved: json['isSaved'] as bool,
      characterId: json['characterId'] as String?,
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\domain\models\character\character_region.freezed.dart
-----------------------------------
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'character_region.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

CharacterRegion _$CharacterRegionFromJson(Map<String, dynamic> json) {
  return _CharacterRegion.fromJson(json);
}

/// @nodoc
mixin _$CharacterRegion {
  String get id => throw _privateConstructorUsedError;
  String get pageId => throw _privateConstructorUsedError;
  @RectConverter()
  Rect get rect => throw _privateConstructorUsedError;
  double get rotation => throw _privateConstructorUsedError;
  String get character => throw _privateConstructorUsedError;
  DateTime get createTime => throw _privateConstructorUsedError;
  DateTime get updateTime => throw _privateConstructorUsedError;
  ProcessingOptions get options => throw _privateConstructorUsedError;
  @OffsetListConverter()
  List<Offset>? get erasePoints => throw _privateConstructorUsedError;
  bool get isSaved => throw _privateConstructorUsedError;
  String? get characterId => throw _privateConstructorUsedError;

  /// Serializes this CharacterRegion to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of CharacterRegion
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $CharacterRegionCopyWith<CharacterRegion> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CharacterRegionCopyWith<$Res> {
  factory $CharacterRegionCopyWith(
          CharacterRegion value, $Res Function(CharacterRegion) then) =
      _$CharacterRegionCopyWithImpl<$Res, CharacterRegion>;
  @useResult
  $Res call(
      {String id,
      String pageId,
      @RectConverter() Rect rect,
      double rotation,
      String character,
      DateTime createTime,
      DateTime updateTime,
      ProcessingOptions options,
      @OffsetListConverter() List<Offset>? erasePoints,
      bool isSaved,
      String? characterId});

  $ProcessingOptionsCopyWith<$Res> get options;
}

/// @nodoc
class _$CharacterRegionCopyWithImpl<$Res, $Val extends CharacterRegion>
    implements $CharacterRegionCopyWith<$Res> {
  _$CharacterRegionCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of CharacterRegion
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? pageId = null,
    Object? rect = null,
    Object? rotation = null,
    Object? character = null,
    Object? createTime = null,
    Object? updateTime = null,
    Object? options = null,
    Object? erasePoints = freezed,
    Object? isSaved = null,
    Object? characterId = freezed,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      pageId: null == pageId
          ? _value.pageId
          : pageId // ignore: cast_nullable_to_non_nullable
              as String,
      rect: null == rect
          ? _value.rect
          : rect // ignore: cast_nullable_to_non_nullable
              as Rect,
      rotation: null == rotation
          ? _value.rotation
          : rotation // ignore: cast_nullable_to_non_nullable
              as double,
      character: null == character
          ? _value.character
          : character // ignore: cast_nullable_to_non_nullable
              as String,
      createTime: null == createTime
          ? _value.createTime
          : createTime // ignore: cast_nullable_to_non_nullable
              as DateTime,
      updateTime: null == updateTime
          ? _value.updateTime
          : updateTime // ignore: cast_nullable_to_non_nullable
              as DateTime,
      options: null == options
          ? _value.options
          : options // ignore: cast_nullable_to_non_nullable
              as ProcessingOptions,
      erasePoints: freezed == erasePoints
          ? _value.erasePoints
          : erasePoints // ignore: cast_nullable_to_non_nullable
              as List<Offset>?,
      isSaved: null == isSaved
          ? _value.isSaved
          : isSaved // ignore: cast_nullable_to_non_nullable
              as bool,
      characterId: freezed == characterId
          ? _value.characterId
          : characterId // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }

  /// Create a copy of CharacterRegion
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ProcessingOptionsCopyWith<$Res> get options {
    return $ProcessingOptionsCopyWith<$Res>(_value.options, (value) {
      return _then(_value.copyWith(options: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$CharacterRegionImplCopyWith<$Res>
    implements $CharacterRegionCopyWith<$Res> {
  factory _$$CharacterRegionImplCopyWith(_$CharacterRegionImpl value,
          $Res Function(_$CharacterRegionImpl) then) =
      __$$CharacterRegionImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      String pageId,
      @RectConverter() Rect rect,
      double rotation,
      String character,
      DateTime createTime,
      DateTime updateTime,
      ProcessingOptions options,
      @OffsetListConverter() List<Offset>? erasePoints,
      bool isSaved,
      String? characterId});

  @override
  $ProcessingOptionsCopyWith<$Res> get options;
}

/// @nodoc
class __$$CharacterRegionImplCopyWithImpl<$Res>
    extends _$CharacterRegionCopyWithImpl<$Res, _$CharacterRegionImpl>
    implements _$$CharacterRegionImplCopyWith<$Res> {
  __$$CharacterRegionImplCopyWithImpl(
      _$CharacterRegionImpl _value, $Res Function(_$CharacterRegionImpl) _then)
      : super(_value, _then);

  /// Create a copy of CharacterRegion
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? pageId = null,
    Object? rect = null,
    Object? rotation = null,
    Object? character = null,
    Object? createTime = null,
    Object? updateTime = null,
    Object? options = null,
    Object? erasePoints = freezed,
    Object? isSaved = null,
    Object? characterId = freezed,
  }) {
    return _then(_$CharacterRegionImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      pageId: null == pageId
          ? _value.pageId
          : pageId // ignore: cast_nullable_to_non_nullable
              as String,
      rect: null == rect
          ? _value.rect
          : rect // ignore: cast_nullable_to_non_nullable
              as Rect,
      rotation: null == rotation
          ? _value.rotation
          : rotation // ignore: cast_nullable_to_non_nullable
              as double,
      character: null == character
          ? _value.character
          : character // ignore: cast_nullable_to_non_nullable
              as String,
      createTime: null == createTime
          ? _value.createTime
          : createTime // ignore: cast_nullable_to_non_nullable
              as DateTime,
      updateTime: null == updateTime
          ? _value.updateTime
          : updateTime // ignore: cast_nullable_to_non_nullable
              as DateTime,
      options: null == options
          ? _value.options
          : options // ignore: cast_nullable_to_non_nullable
              as ProcessingOptions,
      erasePoints: freezed == erasePoints
          ? _value._erasePoints
          : erasePoints // ignore: cast_nullable_to_non_nullable
              as List<Offset>?,
      isSaved: null == isSaved
          ? _value.isSaved
          : isSaved // ignore: cast_nullable_to_non_nullable
              as bool,
      characterId: freezed == characterId
          ? _value.characterId
          : characterId // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CharacterRegionImpl implements _CharacterRegion {
  const _$CharacterRegionImpl(
      {required this.id,
      required this.pageId,
      @RectConverter() required this.rect,
      this.rotation = 0.0,
      this.character = '',
      required this.createTime,
      required this.updateTime,
      this.options = const ProcessingOptions(),
      @OffsetListConverter() final List<Offset>? erasePoints,
      this.isSaved = false,
      this.characterId})
      : _erasePoints = erasePoints;

  factory _$CharacterRegionImpl.fromJson(Map<String, dynamic> json) =>
      _$$CharacterRegionImplFromJson(json);

  @override
  final String id;
  @override
  final String pageId;
  @override
  @RectConverter()
  final Rect rect;
  @override
  @JsonKey()
  final double rotation;
  @override
  @JsonKey()
  final String character;
  @override
  final DateTime createTime;
  @override
  final DateTime updateTime;
  @override
  @JsonKey()
  final ProcessingOptions options;
  final List<Offset>? _erasePoints;
  @override
  @OffsetListConverter()
  List<Offset>? get erasePoints {
    final value = _erasePoints;
    if (value == null) return null;
    if (_erasePoints is EqualUnmodifiableListView) return _erasePoints;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  @JsonKey()
  final bool isSaved;
  @override
  final String? characterId;

  @override
  String toString() {
    return 'CharacterRegion(id: $id, pageId: $pageId, rect: $rect, rotation: $rotation, character: $character, createTime: $createTime, updateTime: $updateTime, options: $options, erasePoints: $erasePoints, isSaved: $isSaved, characterId: $characterId)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CharacterRegionImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.pageId, pageId) || other.pageId == pageId) &&
            (identical(other.rect, rect) || other.rect == rect) &&
            (identical(other.rotation, rotation) ||
                other.rotation == rotation) &&
            (identical(other.character, character) ||
                other.character == character) &&
            (identical(other.createTime, createTime) ||
                other.createTime == createTime) &&
            (identical(other.updateTime, updateTime) ||
                other.updateTime == updateTime) &&
            (identical(other.options, options) || other.options == options) &&
            const DeepCollectionEquality()
                .equals(other._erasePoints, _erasePoints) &&
            (identical(other.isSaved, isSaved) || other.isSaved == isSaved) &&
            (identical(other.characterId, characterId) ||
                other.characterId == characterId));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      pageId,
      rect,
      rotation,
      character,
      createTime,
      updateTime,
      options,
      const DeepCollectionEquality().hash(_erasePoints),
      isSaved,
      characterId);

  /// Create a copy of CharacterRegion
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$CharacterRegionImplCopyWith<_$CharacterRegionImpl> get copyWith =>
      __$$CharacterRegionImplCopyWithImpl<_$CharacterRegionImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$CharacterRegionImplToJson(
      this,
    );
  }
}

abstract class _CharacterRegion implements CharacterRegion {
  const factory _CharacterRegion(
      {required final String id,
      required final String pageId,
      @RectConverter() required final Rect rect,
      final double rotation,
      final String character,
      required final DateTime createTime,
      required final DateTime updateTime,
      final ProcessingOptions options,
      @OffsetListConverter() final List<Offset>? erasePoints,
      final bool isSaved,
      final String? characterId}) = _$CharacterRegionImpl;

  factory _CharacterRegion.fromJson(Map<String, dynamic> json) =
      _$CharacterRegionImpl.fromJson;

  @override
  String get id;
  @override
  String get pageId;
  @override
  @RectConverter()
  Rect get rect;
  @override
  double get rotation;
  @override
  String get character;
  @override
  DateTime get createTime;
  @override
  DateTime get updateTime;
  @override
  ProcessingOptions get options;
  @override
  @OffsetListConverter()
  List<Offset>? get erasePoints;
  @override
  bool get isSaved;
  @override
  String? get characterId;

  /// Create a copy of CharacterRegion
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$CharacterRegionImplCopyWith<_$CharacterRegionImpl> get copyWith =>
      throw _privateConstructorUsedError;
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\domain\models\character\character_region.g.dart
-----------------------------------
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'character_region.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_$CharacterRegionImpl _$$CharacterRegionImplFromJson(
        Map<String, dynamic> json) =>
    _$CharacterRegionImpl(
      id: json['id'] as String,
      pageId: json['pageId'] as String,
      rect:
          const RectConverter().fromJson(json['rect'] as Map<String, dynamic>),
      rotation: (json['rotation'] as num?)?.toDouble() ?? 0.0,
      character: json['character'] as String? ?? '',
      createTime: DateTime.parse(json['createTime'] as String),
      updateTime: DateTime.parse(json['updateTime'] as String),
      options: json['options'] == null
          ? const ProcessingOptions()
          : ProcessingOptions.fromJson(json['options'] as Map<String, dynamic>),
      erasePoints:
          const OffsetListConverter().fromJson(json['erasePoints'] as List?),
      isSaved: json['isSaved'] as bool? ?? false,
      characterId: json['characterId'] as String?,
    );

Map<String, dynamic> _$$CharacterRegionImplToJson(
        _$CharacterRegionImpl instance) =>
    <String, dynamic>{
      'id': instance.id,
      'pageId': instance.pageId,
      'rect': const RectConverter().toJson(instance.rect),
      'rotation': instance.rotation,
      'character': instance.character,
      'createTime': instance.createTime.toIso8601String(),
      'updateTime': instance.updateTime.toIso8601String(),
      'options': instance.options,
      'erasePoints': const OffsetListConverter().toJson(instance.erasePoints),
      'isSaved': instance.isSaved,
      'characterId': instance.characterId,
    };



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\domain\models\character\character_region_state.dart
-----------------------------------
/// 琛ㄧず瀛楃鍖哄煙鐨勭姸鎬?
enum CharacterRegionState {
  /// 鏅€氱姸鎬侊紝鍒濆鐘舵€?
  normal,

  /// 閫変腑鐘舵€侊紙Pan妯″紡涓嬶級
  selected,

  /// 璋冩暣鐘舵€侊紙Select妯″紡涓嬶級
  adjusting
}

/// 瀛楃鍖哄煙棰滆壊鏂规
class CharacterRegionColorScheme {
  /// 宸蹭繚瀛樼殑鏅€氱姸鎬侀鑹?
  static const normalSaved = 0xFF00C853; // 缁胯壊

  /// 鏈繚瀛樼殑鏅€氱姸鎬侀鑹?
  static const normalUnsaved = 0xFFFFD700; // 榛勮壊

  /// 閫変腑鐘舵€侀鑹?
  static const selected = 0xFFFF5252; // 绾㈣壊

  /// 璋冩暣鐘舵€侀鑹?
  static const adjusting = 0xFF2196F3; // 钃濊壊

  /// 宸蹭繚瀛樼殑鏅€氱姸鎬侀€忔槑搴?
  static const normalSavedOpacity = 0.05;

  /// 鏈繚瀛樼殑鏅€氱姸鎬侀€忔槑搴?
  static const normalUnsavedOpacity = 0.1;

  /// 閫変腑鐘舵€侀€忔槑搴?
  static const selectedOpacity = 0.2;

  /// 璋冩暣鐘舵€侀€忔槑搴?
  static const adjustingOpacity = 0.2;
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\domain\models\character\character_usage.dart
-----------------------------------
import 'package:equatable/equatable.dart';

class CharacterUsage extends Equatable {
  final String practiceId;

  const CharacterUsage({
    required this.practiceId,
  });

  factory CharacterUsage.fromJson(Map<String, dynamic> json) {
    return CharacterUsage(
      practiceId: json['practiceId'] as String,
    );
  }

  @override
  List<Object?> get props => [practiceId];

  CharacterUsage copyWith({
    String? practiceId,
  }) {
    return CharacterUsage(
      practiceId: practiceId ?? this.practiceId,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'practiceId': practiceId,
    };
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\domain\models\character\detected_outline.dart
-----------------------------------
import 'package:flutter/material.dart';
import 'package:freezed_annotation/freezed_annotation.dart';

import '../../../infrastructure/utils/json_converters.dart';

part 'detected_outline.freezed.dart';
part 'detected_outline.g.dart';

class ContourPointsConverter
    implements JsonConverter<List<List<Offset>>, List<dynamic>> {
  const ContourPointsConverter();

  @override
  List<List<Offset>> fromJson(List<dynamic> json) {
    return json.map((contour) {
      return (contour as List).map((point) {
        final Map<String, dynamic> pointMap = point as Map<String, dynamic>;
        return Offset(pointMap['x'] as double, pointMap['y'] as double);
      }).toList();
    }).toList();
  }

  @override
  List<dynamic> toJson(List<List<Offset>> contours) {
    return contours.map((contour) {
      return contour.map((point) => {'x': point.dx, 'y': point.dy}).toList();
    }).toList();
  }
}

@freezed
class DetectedOutline with _$DetectedOutline {
  const factory DetectedOutline({
    @RectConverter() required Rect boundingRect,
    @ContourPointsConverter() required List<List<Offset>> contourPoints,
  }) = _DetectedOutline;

  factory DetectedOutline.fromJson(Map<String, dynamic> json) =>
      _$DetectedOutlineFromJson(json);
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\domain\models\character\detected_outline.freezed.dart
-----------------------------------
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'detected_outline.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

DetectedOutline _$DetectedOutlineFromJson(Map<String, dynamic> json) {
  return _DetectedOutline.fromJson(json);
}

/// @nodoc
mixin _$DetectedOutline {
  @RectConverter()
  Rect get boundingRect => throw _privateConstructorUsedError;
  @ContourPointsConverter()
  List<List<Offset>> get contourPoints => throw _privateConstructorUsedError;

  /// Serializes this DetectedOutline to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of DetectedOutline
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $DetectedOutlineCopyWith<DetectedOutline> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DetectedOutlineCopyWith<$Res> {
  factory $DetectedOutlineCopyWith(
          DetectedOutline value, $Res Function(DetectedOutline) then) =
      _$DetectedOutlineCopyWithImpl<$Res, DetectedOutline>;
  @useResult
  $Res call(
      {@RectConverter() Rect boundingRect,
      @ContourPointsConverter() List<List<Offset>> contourPoints});
}

/// @nodoc
class _$DetectedOutlineCopyWithImpl<$Res, $Val extends DetectedOutline>
    implements $DetectedOutlineCopyWith<$Res> {
  _$DetectedOutlineCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of DetectedOutline
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? boundingRect = null,
    Object? contourPoints = null,
  }) {
    return _then(_value.copyWith(
      boundingRect: null == boundingRect
          ? _value.boundingRect
          : boundingRect // ignore: cast_nullable_to_non_nullable
              as Rect,
      contourPoints: null == contourPoints
          ? _value.contourPoints
          : contourPoints // ignore: cast_nullable_to_non_nullable
              as List<List<Offset>>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$DetectedOutlineImplCopyWith<$Res>
    implements $DetectedOutlineCopyWith<$Res> {
  factory _$$DetectedOutlineImplCopyWith(_$DetectedOutlineImpl value,
          $Res Function(_$DetectedOutlineImpl) then) =
      __$$DetectedOutlineImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@RectConverter() Rect boundingRect,
      @ContourPointsConverter() List<List<Offset>> contourPoints});
}

/// @nodoc
class __$$DetectedOutlineImplCopyWithImpl<$Res>
    extends _$DetectedOutlineCopyWithImpl<$Res, _$DetectedOutlineImpl>
    implements _$$DetectedOutlineImplCopyWith<$Res> {
  __$$DetectedOutlineImplCopyWithImpl(
      _$DetectedOutlineImpl _value, $Res Function(_$DetectedOutlineImpl) _then)
      : super(_value, _then);

  /// Create a copy of DetectedOutline
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? boundingRect = null,
    Object? contourPoints = null,
  }) {
    return _then(_$DetectedOutlineImpl(
      boundingRect: null == boundingRect
          ? _value.boundingRect
          : boundingRect // ignore: cast_nullable_to_non_nullable
              as Rect,
      contourPoints: null == contourPoints
          ? _value._contourPoints
          : contourPoints // ignore: cast_nullable_to_non_nullable
              as List<List<Offset>>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$DetectedOutlineImpl implements _DetectedOutline {
  const _$DetectedOutlineImpl(
      {@RectConverter() required this.boundingRect,
      @ContourPointsConverter()
      required final List<List<Offset>> contourPoints})
      : _contourPoints = contourPoints;

  factory _$DetectedOutlineImpl.fromJson(Map<String, dynamic> json) =>
      _$$DetectedOutlineImplFromJson(json);

  @override
  @RectConverter()
  final Rect boundingRect;
  final List<List<Offset>> _contourPoints;
  @override
  @ContourPointsConverter()
  List<List<Offset>> get contourPoints {
    if (_contourPoints is EqualUnmodifiableListView) return _contourPoints;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_contourPoints);
  }

  @override
  String toString() {
    return 'DetectedOutline(boundingRect: $boundingRect, contourPoints: $contourPoints)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DetectedOutlineImpl &&
            (identical(other.boundingRect, boundingRect) ||
                other.boundingRect == boundingRect) &&
            const DeepCollectionEquality()
                .equals(other._contourPoints, _contourPoints));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, boundingRect,
      const DeepCollectionEquality().hash(_contourPoints));

  /// Create a copy of DetectedOutline
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$DetectedOutlineImplCopyWith<_$DetectedOutlineImpl> get copyWith =>
      __$$DetectedOutlineImplCopyWithImpl<_$DetectedOutlineImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$DetectedOutlineImplToJson(
      this,
    );
  }
}

abstract class _DetectedOutline implements DetectedOutline {
  const factory _DetectedOutline(
      {@RectConverter() required final Rect boundingRect,
      @ContourPointsConverter()
      required final List<List<Offset>> contourPoints}) = _$DetectedOutlineImpl;

  factory _DetectedOutline.fromJson(Map<String, dynamic> json) =
      _$DetectedOutlineImpl.fromJson;

  @override
  @RectConverter()
  Rect get boundingRect;
  @override
  @ContourPointsConverter()
  List<List<Offset>> get contourPoints;

  /// Create a copy of DetectedOutline
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$DetectedOutlineImplCopyWith<_$DetectedOutlineImpl> get copyWith =>
      throw _privateConstructorUsedError;
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\domain\models\character\detected_outline.g.dart
-----------------------------------
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'detected_outline.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_$DetectedOutlineImpl _$$DetectedOutlineImplFromJson(
        Map<String, dynamic> json) =>
    _$DetectedOutlineImpl(
      boundingRect: const RectConverter()
          .fromJson(json['boundingRect'] as Map<String, dynamic>),
      contourPoints: const ContourPointsConverter()
          .fromJson(json['contourPoints'] as List),
    );

Map<String, dynamic> _$$DetectedOutlineImplToJson(
        _$DetectedOutlineImpl instance) =>
    <String, dynamic>{
      'boundingRect': const RectConverter().toJson(instance.boundingRect),
      'contourPoints':
          const ContourPointsConverter().toJson(instance.contourPoints),
    };



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\domain\models\character\path_info.dart
-----------------------------------
import 'dart:ui';

import 'package:flutter/material.dart';

/// 琛ㄧず涓€涓摝闄よ矾寰勭殑淇℃伅
class PathInfo {
  /// 璺緞鐨勫嚑浣曞畾涔?
  final Path path;

  /// 绗斿埛澶у皬
  final double brushSize;

  /// 绗斿埛棰滆壊
  final Color brushColor;

  /// 鍒涘缓涓€涓柊鐨勮矾寰勪俊鎭疄渚?
  const PathInfo({
    required this.path,
    required this.brushSize,
    required this.brushColor,
  });

  /// 鍒涘缓璺緞淇℃伅鐨勫壇鏈紝鍙互閫夋嫨鎬у湴淇敼閮ㄥ垎灞炴€?
  PathInfo copyWith({
    Path? path,
    double? brushSize,
    Color? brushColor,
  }) {
    return PathInfo(
      path: path ?? this.path,
      brushSize: brushSize ?? this.brushSize,
      brushColor: brushColor ?? this.brushColor,
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\domain\models\character\path_render_data.dart
-----------------------------------
import 'dart:ui';

import '../../../domain/models/character/path_info.dart';

/// 璺緞娓叉煋鏁版嵁绫诲瀷
class PathRenderData {
  /// 宸插畬鎴愮殑璺緞鍒楄〃
  final List<PathInfo> completedPaths;

  /// 褰撳墠姝ｅ湪缁樺埗鐨勮矾寰?
  final PathInfo? currentPath;

  /// 闇€瑕侀噸缁樼殑鍖哄煙
  final Rect? dirtyBounds;

  /// 鍒涘缓璺緞娓叉煋鏁版嵁瀹炰緥
  const PathRenderData({
    required this.completedPaths,
    this.currentPath,
    this.dirtyBounds,
  });

  /// 鍒涘缓绌虹殑娓叉煋鏁版嵁
  factory PathRenderData.empty() {
    return const PathRenderData(completedPaths: []);
  }

  /// 澶嶅埗骞朵慨鏀归儴鍒嗗睘鎬?
  PathRenderData copyWith({
    List<PathInfo>? completedPaths,
    PathInfo? currentPath,
    Rect? dirtyBounds,
  }) {
    return PathRenderData(
      completedPaths: completedPaths ?? this.completedPaths,
      currentPath: currentPath ?? this.currentPath,
      dirtyBounds: dirtyBounds ?? this.dirtyBounds,
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\domain\models\character\processing_options.dart
-----------------------------------
import 'package:freezed_annotation/freezed_annotation.dart';

part 'processing_options.freezed.dart';
part 'processing_options.g.dart';

@freezed
class ProcessingOptions with _$ProcessingOptions {
  const factory ProcessingOptions({
    @Default(false) bool inverted,
    @Default(false) bool showContour,
    @Default(128.0) double threshold,
    @Default(0.5) double noiseReduction,
    @Default(10.0) double brushSize,
    @Default(1.0) double contrast,
    @Default(0.0) double brightness,
  }) = _ProcessingOptions;

  factory ProcessingOptions.fromJson(Map<String, dynamic> json) =>
      _$ProcessingOptionsFromJson(json);
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\domain\models\character\processing_options.freezed.dart
-----------------------------------
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'processing_options.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

ProcessingOptions _$ProcessingOptionsFromJson(Map<String, dynamic> json) {
  return _ProcessingOptions.fromJson(json);
}

/// @nodoc
mixin _$ProcessingOptions {
  bool get inverted => throw _privateConstructorUsedError;
  bool get showContour => throw _privateConstructorUsedError;
  double get threshold => throw _privateConstructorUsedError;
  double get noiseReduction => throw _privateConstructorUsedError;
  double get brushSize => throw _privateConstructorUsedError;
  double get contrast => throw _privateConstructorUsedError;
  double get brightness => throw _privateConstructorUsedError;

  /// Serializes this ProcessingOptions to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of ProcessingOptions
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $ProcessingOptionsCopyWith<ProcessingOptions> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ProcessingOptionsCopyWith<$Res> {
  factory $ProcessingOptionsCopyWith(
          ProcessingOptions value, $Res Function(ProcessingOptions) then) =
      _$ProcessingOptionsCopyWithImpl<$Res, ProcessingOptions>;
  @useResult
  $Res call(
      {bool inverted,
      bool showContour,
      double threshold,
      double noiseReduction,
      double brushSize,
      double contrast,
      double brightness});
}

/// @nodoc
class _$ProcessingOptionsCopyWithImpl<$Res, $Val extends ProcessingOptions>
    implements $ProcessingOptionsCopyWith<$Res> {
  _$ProcessingOptionsCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of ProcessingOptions
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? inverted = null,
    Object? showContour = null,
    Object? threshold = null,
    Object? noiseReduction = null,
    Object? brushSize = null,
    Object? contrast = null,
    Object? brightness = null,
  }) {
    return _then(_value.copyWith(
      inverted: null == inverted
          ? _value.inverted
          : inverted // ignore: cast_nullable_to_non_nullable
              as bool,
      showContour: null == showContour
          ? _value.showContour
          : showContour // ignore: cast_nullable_to_non_nullable
              as bool,
      threshold: null == threshold
          ? _value.threshold
          : threshold // ignore: cast_nullable_to_non_nullable
              as double,
      noiseReduction: null == noiseReduction
          ? _value.noiseReduction
          : noiseReduction // ignore: cast_nullable_to_non_nullable
              as double,
      brushSize: null == brushSize
          ? _value.brushSize
          : brushSize // ignore: cast_nullable_to_non_nullable
              as double,
      contrast: null == contrast
          ? _value.contrast
          : contrast // ignore: cast_nullable_to_non_nullable
              as double,
      brightness: null == brightness
          ? _value.brightness
          : brightness // ignore: cast_nullable_to_non_nullable
              as double,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ProcessingOptionsImplCopyWith<$Res>
    implements $ProcessingOptionsCopyWith<$Res> {
  factory _$$ProcessingOptionsImplCopyWith(_$ProcessingOptionsImpl value,
          $Res Function(_$ProcessingOptionsImpl) then) =
      __$$ProcessingOptionsImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {bool inverted,
      bool showContour,
      double threshold,
      double noiseReduction,
      double brushSize,
      double contrast,
      double brightness});
}

/// @nodoc
class __$$ProcessingOptionsImplCopyWithImpl<$Res>
    extends _$ProcessingOptionsCopyWithImpl<$Res, _$ProcessingOptionsImpl>
    implements _$$ProcessingOptionsImplCopyWith<$Res> {
  __$$ProcessingOptionsImplCopyWithImpl(_$ProcessingOptionsImpl _value,
      $Res Function(_$ProcessingOptionsImpl) _then)
      : super(_value, _then);

  /// Create a copy of ProcessingOptions
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? inverted = null,
    Object? showContour = null,
    Object? threshold = null,
    Object? noiseReduction = null,
    Object? brushSize = null,
    Object? contrast = null,
    Object? brightness = null,
  }) {
    return _then(_$ProcessingOptionsImpl(
      inverted: null == inverted
          ? _value.inverted
          : inverted // ignore: cast_nullable_to_non_nullable
              as bool,
      showContour: null == showContour
          ? _value.showContour
          : showContour // ignore: cast_nullable_to_non_nullable
              as bool,
      threshold: null == threshold
          ? _value.threshold
          : threshold // ignore: cast_nullable_to_non_nullable
              as double,
      noiseReduction: null == noiseReduction
          ? _value.noiseReduction
          : noiseReduction // ignore: cast_nullable_to_non_nullable
              as double,
      brushSize: null == brushSize
          ? _value.brushSize
          : brushSize // ignore: cast_nullable_to_non_nullable
              as double,
      contrast: null == contrast
          ? _value.contrast
          : contrast // ignore: cast_nullable_to_non_nullable
              as double,
      brightness: null == brightness
          ? _value.brightness
          : brightness // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ProcessingOptionsImpl implements _ProcessingOptions {
  const _$ProcessingOptionsImpl(
      {this.inverted = false,
      this.showContour = false,
      this.threshold = 128.0,
      this.noiseReduction = 0.5,
      this.brushSize = 10.0,
      this.contrast = 1.0,
      this.brightness = 0.0});

  factory _$ProcessingOptionsImpl.fromJson(Map<String, dynamic> json) =>
      _$$ProcessingOptionsImplFromJson(json);

  @override
  @JsonKey()
  final bool inverted;
  @override
  @JsonKey()
  final bool showContour;
  @override
  @JsonKey()
  final double threshold;
  @override
  @JsonKey()
  final double noiseReduction;
  @override
  @JsonKey()
  final double brushSize;
  @override
  @JsonKey()
  final double contrast;
  @override
  @JsonKey()
  final double brightness;

  @override
  String toString() {
    return 'ProcessingOptions(inverted: $inverted, showContour: $showContour, threshold: $threshold, noiseReduction: $noiseReduction, brushSize: $brushSize, contrast: $contrast, brightness: $brightness)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ProcessingOptionsImpl &&
            (identical(other.inverted, inverted) ||
                other.inverted == inverted) &&
            (identical(other.showContour, showContour) ||
                other.showContour == showContour) &&
            (identical(other.threshold, threshold) ||
                other.threshold == threshold) &&
            (identical(other.noiseReduction, noiseReduction) ||
                other.noiseReduction == noiseReduction) &&
            (identical(other.brushSize, brushSize) ||
                other.brushSize == brushSize) &&
            (identical(other.contrast, contrast) ||
                other.contrast == contrast) &&
            (identical(other.brightness, brightness) ||
                other.brightness == brightness));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, inverted, showContour, threshold,
      noiseReduction, brushSize, contrast, brightness);

  /// Create a copy of ProcessingOptions
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ProcessingOptionsImplCopyWith<_$ProcessingOptionsImpl> get copyWith =>
      __$$ProcessingOptionsImplCopyWithImpl<_$ProcessingOptionsImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ProcessingOptionsImplToJson(
      this,
    );
  }
}

abstract class _ProcessingOptions implements ProcessingOptions {
  const factory _ProcessingOptions(
      {final bool inverted,
      final bool showContour,
      final double threshold,
      final double noiseReduction,
      final double brushSize,
      final double contrast,
      final double brightness}) = _$ProcessingOptionsImpl;

  factory _ProcessingOptions.fromJson(Map<String, dynamic> json) =
      _$ProcessingOptionsImpl.fromJson;

  @override
  bool get inverted;
  @override
  bool get showContour;
  @override
  double get threshold;
  @override
  double get noiseReduction;
  @override
  double get brushSize;
  @override
  double get contrast;
  @override
  double get brightness;

  /// Create a copy of ProcessingOptions
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ProcessingOptionsImplCopyWith<_$ProcessingOptionsImpl> get copyWith =>
      throw _privateConstructorUsedError;
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\domain\models\character\processing_options.g.dart
-----------------------------------
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'processing_options.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_$ProcessingOptionsImpl _$$ProcessingOptionsImplFromJson(
        Map<String, dynamic> json) =>
    _$ProcessingOptionsImpl(
      inverted: json['inverted'] as bool? ?? false,
      showContour: json['showContour'] as bool? ?? false,
      threshold: (json['threshold'] as num?)?.toDouble() ?? 128.0,
      noiseReduction: (json['noiseReduction'] as num?)?.toDouble() ?? 0.5,
      brushSize: (json['brushSize'] as num?)?.toDouble() ?? 10.0,
      contrast: (json['contrast'] as num?)?.toDouble() ?? 1.0,
      brightness: (json['brightness'] as num?)?.toDouble() ?? 0.0,
    );

Map<String, dynamic> _$$ProcessingOptionsImplToJson(
        _$ProcessingOptionsImpl instance) =>
    <String, dynamic>{
      'inverted': instance.inverted,
      'showContour': instance.showContour,
      'threshold': instance.threshold,
      'noiseReduction': instance.noiseReduction,
      'brushSize': instance.brushSize,
      'contrast': instance.contrast,
      'brightness': instance.brightness,
    };



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\domain\models\character\processing_result.dart
-----------------------------------
import 'dart:convert';
import 'dart:typed_data';

import 'package:archive/archive.dart';
import 'package:flutter/material.dart';

class ProcessingResult {
  final Uint8List originalCrop;
  final Uint8List binaryImage;
  final Uint8List thumbnail;
  final String? svgOutline;
  final Rect boundingBox;

  const ProcessingResult({
    required this.originalCrop,
    required this.binaryImage,
    required this.thumbnail,
    this.svgOutline,
    required this.boundingBox,
  });

  // 鍒涘缓绌虹殑缁撴灉
  factory ProcessingResult.empty() {
    return ProcessingResult(
      originalCrop: Uint8List(0),
      binaryImage: Uint8List(0),
      thumbnail: Uint8List(0),
      boundingBox: Rect.zero,
    );
  }

  // 鏄惁涓烘湁鏁堢殑澶勭悊缁撴灉
  bool get isValid =>
      originalCrop.isNotEmpty &&
      binaryImage.isNotEmpty &&
      thumbnail.isNotEmpty &&
      boundingBox != Rect.zero;

  /// 灏?ProcessingResult 搴忓垪鍖栧苟鍘嬬缉涓?Uint8List
  Uint8List toArchiveBytes() {
    // 鍒涘缓涓€涓柊鐨勫帇缂╂。妗?
    final archive = Archive();

    // 娣诲姞浜岃繘鍒舵暟鎹?
    archive.addFile(
        ArchiveFile('original_crop.bin', originalCrop.length, originalCrop));
    archive.addFile(
        ArchiveFile('binary_image.bin', binaryImage.length, binaryImage));
    archive.addFile(ArchiveFile('thumbnail.bin', thumbnail.length, thumbnail));

    // 娣诲姞鍏冩暟鎹?
    final metadata = {
      'boundingBox': {
        'x': boundingBox.left,
        'y': boundingBox.top,
        'width': boundingBox.width,
        'height': boundingBox.height,
      },
      'svgOutline': svgOutline,
    };

    final metadataBytes = utf8.encode(json.encode(metadata));
    archive.addFile(
        ArchiveFile('metadata.json', metadataBytes.length, metadataBytes));

    // 鍘嬬缉鏁翠釜妗ｆ
    return Uint8List.fromList(ZipEncoder().encode(archive) ?? []);
  }

  /// 浠庡帇缂╃殑瀛楄妭鏁版嵁涓垱寤?ProcessingResult
  static ProcessingResult fromArchiveBytes(Uint8List bytes) {
    try {
      // 瑙ｅ帇缂╂。妗?
      final archive = ZipDecoder().decodeBytes(bytes);

      // 璇诲彇浜岃繘鍒舵暟鎹?
      final originalCrop = _readFileBytes(archive, 'original_crop.bin');
      final binaryImage = _readFileBytes(archive, 'binary_image.bin');
      final thumbnail = _readFileBytes(archive, 'thumbnail.bin');

      // 璇诲彇鍏冩暟鎹?
      final metadataFile = archive.findFile('metadata.json');
      if (metadataFile == null) throw Exception('缂哄皯鍏冩暟鎹枃浠?);

      final metadataString = utf8.decode(metadataFile.content as List<int>);
      final metadata = json.decode(metadataString) as Map<String, dynamic>;

      // 瑙ｆ瀽杈圭晫妗嗘暟鎹?
      final boundingBoxData = metadata['boundingBox'] as Map<String, dynamic>;
      final boundingBox = Rect.fromLTWH(
        boundingBoxData['x'] as double,
        boundingBoxData['y'] as double,
        boundingBoxData['width'] as double,
        boundingBoxData['height'] as double,
      );

      return ProcessingResult(
        originalCrop: originalCrop,
        binaryImage: binaryImage,
        thumbnail: thumbnail,
        svgOutline: metadata['svgOutline'] as String?,
        boundingBox: boundingBox,
      );
    } catch (e) {
      throw Exception('鏃犳硶浠庡帇缂╂暟鎹腑鎭㈠澶勭悊缁撴灉: $e');
    }
  }

  /// 浠庡帇缂╂。妗堜腑璇诲彇鏂囦欢鏁版嵁
  static Uint8List _readFileBytes(Archive archive, String fileName) {
    final file = archive.findFile(fileName);
    if (file == null) {
      throw Exception('鎵句笉鍒版枃浠? $fileName');
    }
    return Uint8List.fromList(file.content as List<int>);
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\domain\models\character\undo_action.dart
-----------------------------------
import 'dart:ui';

class UndoAction {
  final UndoActionType type;
  final dynamic data;
  final DateTime timestamp;

  UndoAction({
    required this.type,
    required this.data,
    DateTime? timestamp,
  }) : timestamp = timestamp ?? DateTime.now();

  // 鍒涘缓鎵归噺鎿嶄綔璁板綍
  factory UndoAction.batch(List<UndoAction> actions) {
    return UndoAction(
      type: UndoActionType.batch,
      data: actions,
    );
  }

  // 鍒涘缓鏂板缓鎿嶄綔璁板綍
  factory UndoAction.create(String characterId) {
    return UndoAction(
      type: UndoActionType.create,
      data: characterId,
    );
  }

  // 鍒涘缓鍒犻櫎鎿嶄綔璁板綍
  factory UndoAction.delete(String characterId, dynamic deletedState) {
    return UndoAction(
      type: UndoActionType.delete,
      data: {
        'id': characterId,
        'deletedState': deletedState,
      },
    );
  }

  // 鍒涘缓鎿﹂櫎鎿嶄綔璁板綍
  factory UndoAction.erase(String characterId, List<List<Offset>> erasePaths) {
    return UndoAction(
      type: UndoActionType.erase,
      data: {
        'id': characterId,
        'erasePaths': erasePaths,
      },
    );
  }

  // 鍒涘缓鏇存柊鎿嶄綔璁板綍
  factory UndoAction.update(String characterId, dynamic originalState) {
    return UndoAction(
      type: UndoActionType.update,
      data: {
        'id': characterId,
        'originalState': originalState,
      },
    );
  }
}

enum UndoActionType {
  create, // 鍒涘缓鏂板瓧绗?
  update, // 鏇存柊瀛楃
  delete, // 鍒犻櫎瀛楃
  erase, // 鎿﹂櫎鎿嶄綔
  batch // 鎵归噺鎿嶄綔
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\domain\models\common\date_range_filter.dart
-----------------------------------
import 'package:flutter/material.dart';

class DateRangeFilter {
  final DateRangePreset? preset;
  final DateTime? start; // Match these parameter names
  final DateTime? end; // with the ones used in constructor

  const DateRangeFilter({
    this.preset,
    this.start,
    this.end,
  });

  // 鍒涘缓涓€涓┖杩囨护鍣ㄧ殑宸ュ巶鏂规硶
  factory DateRangeFilter.empty() => const DateRangeFilter();

  // 鍒涘缓涓€涓?浠庢煇澶╁紑濮?鐨勫伐鍘傛柟娉?
  factory DateRangeFilter.fromDate(DateTime startDate) {
    return DateRangeFilter(start: startDate);
  }

  factory DateRangeFilter.fromJson(Map<String, dynamic> json) {
    return DateRangeFilter(
      start: json['start'] != null ? DateTime.parse(json['start']) : null,
      end: json['end'] != null ? DateTime.parse(json['end']) : null,
      preset: json['preset'] != null
          ? DateRangePreset.values.byName(json['preset'])
          : null,
    );
  }

  factory DateRangeFilter.preset(DateRangePreset preset) {
    return DateRangeFilter(preset: preset);
  }

  // 鍒涘缓涓€涓?鎴鍒颁粖澶?鐨勫伐鍘傛柟娉?
  factory DateRangeFilter.untilToday() {
    return DateRangeFilter(end: DateTime.now());
  }

  // 娣诲姞鏃ユ湡鍖洪棿闀垮害璁＄畻
  int? get dayCount {
    final range = effectiveRange;
    if (range == null) return null;
    return range.duration.inDays + 1;
  }

  // 娣诲姞鏍煎紡鍖栨樉绀烘枃鏈?
  String get displayText {
    if (preset != null) {
      return preset!.label;
    }

    if (start != null && end != null) {
      return '${_formatDate(start!)} 鑷?${_formatDate(end!)}';
    } else if (start != null) {
      return '${_formatDate(start!)} 涔嬪悗';
    } else if (end != null) {
      return '${_formatDate(end!)} 涔嬪墠';
    }

    return '鍏ㄩ儴鏃堕棿';
  }

  DateTimeRange? get effectiveRange {
    if (preset != null) {
      return preset!.getRange();
    }

    if (start != null || end != null) {
      return DateTimeRange(
        start: start ?? DateTime(1900),
        end: end ?? DateTime.now(),
      );
    }

    return null;
  }

  @override
  int get hashCode => Object.hash(preset, start, end);

  bool get isEmpty => start == null && end == null && preset == null;

  // 娣诲姞鏃ユ湡鏍￠獙
  bool get isValid {
    if (preset != null) return true;
    if (start != null && end != null) {
      return !start!.isAfter(end!);
    }
    return true;
  }

  // 娣诲姞鐩哥瓑鎬ф瘮杈?
  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    return other is DateRangeFilter &&
        other.preset == preset &&
        other.start == start &&
        other.end == end;
  }

  bool contains(DateTime date) {
    final range = effectiveRange;
    if (range == null) return true;
    return !date.isBefore(range.start) && !date.isAfter(range.end);
  }

  DateRangeFilter copyWith({
    DateTime? Function()? startDate,
    DateTime? Function()? endDate,
    DateRangePreset? Function()? preset,
  }) {
    return DateRangeFilter(
      start: startDate != null ? startDate() : start,
      end: endDate != null ? endDate() : end,
      preset: preset != null ? preset() : this.preset,
    );
  }

  Map<String, dynamic> toJson() => {
        'start': start?.toIso8601String(),
        'end': end?.toIso8601String(),
        'preset': preset?.name,
      };

  // 杈呭姪鏂规硶锛氭牸寮忓寲鏃ユ湡
  String _formatDate(DateTime date) {
    return '${date.year}-${date.month.toString().padLeft(2, '0')}-'
        '${date.day.toString().padLeft(2, '0')}';
  }
}

enum DateRangePreset {
  today,
  yesterday,
  thisWeek,
  lastWeek,
  thisMonth,
  lastMonth,
  thisYear,
  lastYear,
  last7Days,
  last30Days,
  last90Days,
  last365Days,
  all,
}

extension DateRangePresetX on DateRangePreset {
  String get label => switch (this) {
        DateRangePreset.today => '浠婂ぉ',
        DateRangePreset.yesterday => '鏄ㄥぉ',
        DateRangePreset.last7Days => '鏈€杩?澶?,
        DateRangePreset.last30Days => '鏈€杩?0澶?,
        DateRangePreset.last90Days => '鏈€杩?0澶?,
        DateRangePreset.last365Days => '鏈€杩戜竴骞?,
        DateRangePreset.thisMonth => '鏈湀',
        DateRangePreset.lastMonth => '涓婃湀',
        DateRangePreset.thisYear => '浠婂勾',
        DateRangePreset.lastYear => '鍘诲勾',
        DateRangePreset.thisWeek => '鏈懆',
        DateRangePreset.lastWeek => '涓婂懆',
        DateRangePreset.all => '鍏ㄩ儴鏃堕棿',
      };

  DateTimeRange getRange() {
    final now = DateTime.now();
    return switch (this) {
      DateRangePreset.today => DateTimeRange(
          start: DateTime(now.year, now.month, now.day),
          end: now,
        ),
      DateRangePreset.yesterday => DateTimeRange(
          start: DateTime(now.year, now.month, now.day - 1),
          end: DateTime(now.year, now.month, now.day),
        ),
      DateRangePreset.thisWeek => DateTimeRange(
          start: DateTime(now.year, now.month, now.day - now.weekday + 1),
          end: now,
        ),
      DateRangePreset.lastWeek => DateTimeRange(
          start: DateTime(now.year, now.month, now.day - now.weekday - 6),
          end: DateTime(now.year, now.month, now.day - now.weekday),
        ),
      DateRangePreset.thisMonth => DateTimeRange(
          start: DateTime(now.year, now.month, 1),
          end: now,
        ),
      DateRangePreset.lastMonth => DateTimeRange(
          start: DateTime(now.year, now.month - 1, 1),
          end: DateTime(now.year, now.month, 0),
        ),
      DateRangePreset.thisYear => DateTimeRange(
          start: DateTime(now.year, 1, 1),
          end: now,
        ),
      DateRangePreset.lastYear => DateTimeRange(
          start: DateTime(now.year - 1, 1, 1),
          end: DateTime(now.year - 1, 12, 31),
        ),
      DateRangePreset.last7Days => DateTimeRange(
          start: now.subtract(const Duration(days: 7)),
          end: now,
        ),
      DateRangePreset.last30Days => DateTimeRange(
          start: now.subtract(const Duration(days: 30)),
          end: now,
        ),
      DateRangePreset.last90Days => DateTimeRange(
          start: now.subtract(const Duration(days: 90)),
          end: now,
        ),
      DateRangePreset.last365Days => DateTimeRange(
          start: now.subtract(const Duration(days: 365)),
          end: now,
        ),
      DateRangePreset.all => DateTimeRange(
          start: DateTime(1900),
          end: now,
        ),
    };
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\domain\models\common\result.dart
-----------------------------------
/// 涓氬姟閿欒
class BusinessError implements Exception {
  final String message;
  BusinessError(this.message);

  @override
  String toString() => message;
}

/// 閫氱敤缁撴灉绫伙紝鐢ㄤ簬鍖呰鎿嶄綔缁撴灉
class Result<T> {
  final bool isSuccess;
  final T? data;
  final Object? error;

  const Result._({
    required this.isSuccess,
    this.data,
    this.error,
  });

  /// 鍒涘缓澶辫触缁撴灉
  static Result<T> failure<T>(Object error) {
    return Result._(
      isSuccess: false,
      error: error,
    );
  }

  /// 鍒涘缓鎴愬姛缁撴灉
  static Result<T> success<T>(T data) {
    return Result._(
      isSuccess: true,
      data: data,
    );
  }
}

/// 瀛樺偍閿欒
class StorageError implements Exception {
  final String message;
  StorageError(this.message);

  @override
  String toString() => message;
}

/// 楠岃瘉閿欒
class ValidationError implements Exception {
  final String message;
  ValidationError(this.message);

  @override
  String toString() => message;
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\domain\models\common\size.dart
-----------------------------------
import 'package:freezed_annotation/freezed_annotation.dart';

part 'size.freezed.dart';
part 'size.g.dart';

@freezed
class Size with _$Size {
  const factory Size({
    required int width,
    required int height,
  }) = _Size;

  factory Size.create({
    required int width,
    required int height,
  }) {
    return Size(
      width: width,
      height: height,
    );
  }

  factory Size.fromJson(Map<String, dynamic> json) => _$SizeFromJson(json);

  const Size._();
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\domain\models\common\size.freezed.dart
-----------------------------------
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'size.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

Size _$SizeFromJson(Map<String, dynamic> json) {
  return _Size.fromJson(json);
}

/// @nodoc
mixin _$Size {
  int get width => throw _privateConstructorUsedError;
  int get height => throw _privateConstructorUsedError;

  /// Serializes this Size to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of Size
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $SizeCopyWith<Size> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SizeCopyWith<$Res> {
  factory $SizeCopyWith(Size value, $Res Function(Size) then) =
      _$SizeCopyWithImpl<$Res, Size>;
  @useResult
  $Res call({int width, int height});
}

/// @nodoc
class _$SizeCopyWithImpl<$Res, $Val extends Size>
    implements $SizeCopyWith<$Res> {
  _$SizeCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of Size
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? width = null,
    Object? height = null,
  }) {
    return _then(_value.copyWith(
      width: null == width
          ? _value.width
          : width // ignore: cast_nullable_to_non_nullable
              as int,
      height: null == height
          ? _value.height
          : height // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$SizeImplCopyWith<$Res> implements $SizeCopyWith<$Res> {
  factory _$$SizeImplCopyWith(
          _$SizeImpl value, $Res Function(_$SizeImpl) then) =
      __$$SizeImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int width, int height});
}

/// @nodoc
class __$$SizeImplCopyWithImpl<$Res>
    extends _$SizeCopyWithImpl<$Res, _$SizeImpl>
    implements _$$SizeImplCopyWith<$Res> {
  __$$SizeImplCopyWithImpl(_$SizeImpl _value, $Res Function(_$SizeImpl) _then)
      : super(_value, _then);

  /// Create a copy of Size
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? width = null,
    Object? height = null,
  }) {
    return _then(_$SizeImpl(
      width: null == width
          ? _value.width
          : width // ignore: cast_nullable_to_non_nullable
              as int,
      height: null == height
          ? _value.height
          : height // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$SizeImpl extends _Size {
  const _$SizeImpl({required this.width, required this.height}) : super._();

  factory _$SizeImpl.fromJson(Map<String, dynamic> json) =>
      _$$SizeImplFromJson(json);

  @override
  final int width;
  @override
  final int height;

  @override
  String toString() {
    return 'Size(width: $width, height: $height)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SizeImpl &&
            (identical(other.width, width) || other.width == width) &&
            (identical(other.height, height) || other.height == height));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, width, height);

  /// Create a copy of Size
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$SizeImplCopyWith<_$SizeImpl> get copyWith =>
      __$$SizeImplCopyWithImpl<_$SizeImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$SizeImplToJson(
      this,
    );
  }
}

abstract class _Size extends Size {
  const factory _Size({required final int width, required final int height}) =
      _$SizeImpl;
  const _Size._() : super._();

  factory _Size.fromJson(Map<String, dynamic> json) = _$SizeImpl.fromJson;

  @override
  int get width;
  @override
  int get height;

  /// Create a copy of Size
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$SizeImplCopyWith<_$SizeImpl> get copyWith =>
      throw _privateConstructorUsedError;
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\domain\models\common\size.g.dart
-----------------------------------
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'size.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_$SizeImpl _$$SizeImplFromJson(Map<String, dynamic> json) => _$SizeImpl(
      width: (json['width'] as num).toInt(),
      height: (json['height'] as num).toInt(),
    );

Map<String, dynamic> _$$SizeImplToJson(_$SizeImpl instance) =>
    <String, dynamic>{
      'width': instance.width,
      'height': instance.height,
    };



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\domain\models\common\sort_option.dart
-----------------------------------
import 'package:freezed_annotation/freezed_annotation.dart';

import '../../enums/sort_field.dart';

part 'sort_option.freezed.dart';
part 'sort_option.g.dart';

SortField _sortFieldFromJson(dynamic value) {
  if (value is SortField) return value;
  final str = value?.toString() ?? '';
  return SortFieldParsing.fromString(str);
}

String _sortFieldToJson(SortField field) => field.value;

/// 鎺掑簭閫夐」
@freezed
class SortOption with _$SortOption {
  /// 鎸夊垱寤烘椂闂撮檷搴?榛樿鎺掑簭)
  static const defaultOption = SortOption();

  const factory SortOption({
    @Default(SortField.createTime)
    @JsonKey(fromJson: _sortFieldFromJson, toJson: _sortFieldToJson)
    SortField field,
    @Default(true) bool descending,
  }) = _SortOption;

  factory SortOption.fromJson(Map<String, dynamic> json) =>
      _$SortOptionFromJson(json);

  const SortOption._();

  /// 鏄惁鏄粯璁ゆ帓搴?
  bool get isDefault => field == SortField.createTime && descending;

  /// 鍒囨崲鎺掑簭鏂瑰悜
  SortOption toggleDirection() => copyWith(descending: !descending);

  /// 鍒囨崲鎺掑簭瀛楁
  SortOption withField(SortField field) => copyWith(field: field);
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\domain\models\common\sort_option.freezed.dart
-----------------------------------
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'sort_option.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

SortOption _$SortOptionFromJson(Map<String, dynamic> json) {
  return _SortOption.fromJson(json);
}

/// @nodoc
mixin _$SortOption {
  @JsonKey(fromJson: _sortFieldFromJson, toJson: _sortFieldToJson)
  SortField get field => throw _privateConstructorUsedError;
  bool get descending => throw _privateConstructorUsedError;

  /// Serializes this SortOption to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of SortOption
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $SortOptionCopyWith<SortOption> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SortOptionCopyWith<$Res> {
  factory $SortOptionCopyWith(
          SortOption value, $Res Function(SortOption) then) =
      _$SortOptionCopyWithImpl<$Res, SortOption>;
  @useResult
  $Res call(
      {@JsonKey(fromJson: _sortFieldFromJson, toJson: _sortFieldToJson)
      SortField field,
      bool descending});
}

/// @nodoc
class _$SortOptionCopyWithImpl<$Res, $Val extends SortOption>
    implements $SortOptionCopyWith<$Res> {
  _$SortOptionCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of SortOption
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field = null,
    Object? descending = null,
  }) {
    return _then(_value.copyWith(
      field: null == field
          ? _value.field
          : field // ignore: cast_nullable_to_non_nullable
              as SortField,
      descending: null == descending
          ? _value.descending
          : descending // ignore: cast_nullable_to_non_nullable
              as bool,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$SortOptionImplCopyWith<$Res>
    implements $SortOptionCopyWith<$Res> {
  factory _$$SortOptionImplCopyWith(
          _$SortOptionImpl value, $Res Function(_$SortOptionImpl) then) =
      __$$SortOptionImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {@JsonKey(fromJson: _sortFieldFromJson, toJson: _sortFieldToJson)
      SortField field,
      bool descending});
}

/// @nodoc
class __$$SortOptionImplCopyWithImpl<$Res>
    extends _$SortOptionCopyWithImpl<$Res, _$SortOptionImpl>
    implements _$$SortOptionImplCopyWith<$Res> {
  __$$SortOptionImplCopyWithImpl(
      _$SortOptionImpl _value, $Res Function(_$SortOptionImpl) _then)
      : super(_value, _then);

  /// Create a copy of SortOption
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field = null,
    Object? descending = null,
  }) {
    return _then(_$SortOptionImpl(
      field: null == field
          ? _value.field
          : field // ignore: cast_nullable_to_non_nullable
              as SortField,
      descending: null == descending
          ? _value.descending
          : descending // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$SortOptionImpl extends _SortOption {
  const _$SortOptionImpl(
      {@JsonKey(fromJson: _sortFieldFromJson, toJson: _sortFieldToJson)
      this.field = SortField.createTime,
      this.descending = true})
      : super._();

  factory _$SortOptionImpl.fromJson(Map<String, dynamic> json) =>
      _$$SortOptionImplFromJson(json);

  @override
  @JsonKey(fromJson: _sortFieldFromJson, toJson: _sortFieldToJson)
  final SortField field;
  @override
  @JsonKey()
  final bool descending;

  @override
  String toString() {
    return 'SortOption(field: $field, descending: $descending)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SortOptionImpl &&
            (identical(other.field, field) || other.field == field) &&
            (identical(other.descending, descending) ||
                other.descending == descending));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, field, descending);

  /// Create a copy of SortOption
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$SortOptionImplCopyWith<_$SortOptionImpl> get copyWith =>
      __$$SortOptionImplCopyWithImpl<_$SortOptionImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$SortOptionImplToJson(
      this,
    );
  }
}

abstract class _SortOption extends SortOption {
  const factory _SortOption(
      {@JsonKey(fromJson: _sortFieldFromJson, toJson: _sortFieldToJson)
      final SortField field,
      final bool descending}) = _$SortOptionImpl;
  const _SortOption._() : super._();

  factory _SortOption.fromJson(Map<String, dynamic> json) =
      _$SortOptionImpl.fromJson;

  @override
  @JsonKey(fromJson: _sortFieldFromJson, toJson: _sortFieldToJson)
  SortField get field;
  @override
  bool get descending;

  /// Create a copy of SortOption
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$SortOptionImplCopyWith<_$SortOptionImpl> get copyWith =>
      throw _privateConstructorUsedError;
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\domain\models\common\sort_option.g.dart
-----------------------------------
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'sort_option.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_$SortOptionImpl _$$SortOptionImplFromJson(Map<String, dynamic> json) =>
    _$SortOptionImpl(
      field: json['field'] == null
          ? SortField.createTime
          : _sortFieldFromJson(json['field']),
      descending: json['descending'] as bool? ?? true,
    );

Map<String, dynamic> _$$SortOptionImplToJson(_$SortOptionImpl instance) =>
    <String, dynamic>{
      'field': _sortFieldToJson(instance.field),
      'descending': instance.descending,
    };



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\domain\models\practice\char_element.dart
-----------------------------------
import 'package:freezed_annotation/freezed_annotation.dart';

import 'char_position.dart';
import 'char_style.dart';
import 'char_transform.dart';

part 'char_element.freezed.dart';
part 'char_element.g.dart';

/// 瀛楃鍏冪礌
@freezed
class CharElement with _$CharElement {
  const factory CharElement({
    /// 瀛楃ID
    required String charId,

    /// 鐩稿浣嶇疆
    required CharPosition position,

    /// 鍙樻崲淇℃伅
    @Default(CharTransform()) CharTransform transform,

    /// 鏍峰紡淇℃伅
    @Default(CharStyle()) CharStyle style,
  }) = _CharElement;

  /// 浠嶫SON鍒涘缓瀹炰緥
  factory CharElement.fromJson(Map<String, dynamic> json) =>
      _$CharElementFromJson(json);

  /// 鍒涘缓鏍囧噯瀛楃鍏冪礌
  factory CharElement.standard({
    required String charId,
    double offsetX = 0,
    double offsetY = 0,
  }) {
    return CharElement(
      charId: charId,
      position: CharPosition(
        offsetX: offsetX,
        offsetY: offsetY,
      ),
    );
  }

  const CharElement._();

  /// 绉诲姩瀛楃
  CharElement move(double dx, double dy) {
    return copyWith(
      position: position.copyWith(
        offsetX: position.offsetX + dx,
        offsetY: position.offsetY + dy,
      ),
    );
  }

  /// 鏃嬭浆瀛楃
  CharElement rotate(double angle) {
    return copyWith(
      transform: transform.rotate(angle),
    );
  }

  /// 缂╂斁瀛楃
  CharElement scale(double sx, double sy) {
    return copyWith(
      transform: transform.scale(sx, sy),
    );
  }

  /// 璁剧疆棰滆壊
  CharElement setColor(String color) {
    return copyWith(
      style: style.setColor(color),
    );
  }

  /// 璁剧疆鑷畾涔夋牱寮?
  CharElement setCustomStyle(String key, dynamic value) {
    return copyWith(
      style: style.setCustomStyle(key, value),
    );
  }

  /// 璁剧疆涓嶉€忔槑搴?
  CharElement setOpacity(double opacity) {
    return copyWith(
      style: style.setOpacity(opacity),
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\domain\models\practice\char_element.freezed.dart
-----------------------------------
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'char_element.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

CharElement _$CharElementFromJson(Map<String, dynamic> json) {
  return _CharElement.fromJson(json);
}

/// @nodoc
mixin _$CharElement {
  /// 瀛楃ID
  String get charId => throw _privateConstructorUsedError;

  /// 鐩稿浣嶇疆
  CharPosition get position => throw _privateConstructorUsedError;

  /// 鍙樻崲淇℃伅
  CharTransform get transform => throw _privateConstructorUsedError;

  /// 鏍峰紡淇℃伅
  CharStyle get style => throw _privateConstructorUsedError;

  /// Serializes this CharElement to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of CharElement
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $CharElementCopyWith<CharElement> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CharElementCopyWith<$Res> {
  factory $CharElementCopyWith(
          CharElement value, $Res Function(CharElement) then) =
      _$CharElementCopyWithImpl<$Res, CharElement>;
  @useResult
  $Res call(
      {String charId,
      CharPosition position,
      CharTransform transform,
      CharStyle style});

  $CharPositionCopyWith<$Res> get position;
  $CharTransformCopyWith<$Res> get transform;
  $CharStyleCopyWith<$Res> get style;
}

/// @nodoc
class _$CharElementCopyWithImpl<$Res, $Val extends CharElement>
    implements $CharElementCopyWith<$Res> {
  _$CharElementCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of CharElement
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? charId = null,
    Object? position = null,
    Object? transform = null,
    Object? style = null,
  }) {
    return _then(_value.copyWith(
      charId: null == charId
          ? _value.charId
          : charId // ignore: cast_nullable_to_non_nullable
              as String,
      position: null == position
          ? _value.position
          : position // ignore: cast_nullable_to_non_nullable
              as CharPosition,
      transform: null == transform
          ? _value.transform
          : transform // ignore: cast_nullable_to_non_nullable
              as CharTransform,
      style: null == style
          ? _value.style
          : style // ignore: cast_nullable_to_non_nullable
              as CharStyle,
    ) as $Val);
  }

  /// Create a copy of CharElement
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $CharPositionCopyWith<$Res> get position {
    return $CharPositionCopyWith<$Res>(_value.position, (value) {
      return _then(_value.copyWith(position: value) as $Val);
    });
  }

  /// Create a copy of CharElement
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $CharTransformCopyWith<$Res> get transform {
    return $CharTransformCopyWith<$Res>(_value.transform, (value) {
      return _then(_value.copyWith(transform: value) as $Val);
    });
  }

  /// Create a copy of CharElement
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $CharStyleCopyWith<$Res> get style {
    return $CharStyleCopyWith<$Res>(_value.style, (value) {
      return _then(_value.copyWith(style: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$CharElementImplCopyWith<$Res>
    implements $CharElementCopyWith<$Res> {
  factory _$$CharElementImplCopyWith(
          _$CharElementImpl value, $Res Function(_$CharElementImpl) then) =
      __$$CharElementImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String charId,
      CharPosition position,
      CharTransform transform,
      CharStyle style});

  @override
  $CharPositionCopyWith<$Res> get position;
  @override
  $CharTransformCopyWith<$Res> get transform;
  @override
  $CharStyleCopyWith<$Res> get style;
}

/// @nodoc
class __$$CharElementImplCopyWithImpl<$Res>
    extends _$CharElementCopyWithImpl<$Res, _$CharElementImpl>
    implements _$$CharElementImplCopyWith<$Res> {
  __$$CharElementImplCopyWithImpl(
      _$CharElementImpl _value, $Res Function(_$CharElementImpl) _then)
      : super(_value, _then);

  /// Create a copy of CharElement
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? charId = null,
    Object? position = null,
    Object? transform = null,
    Object? style = null,
  }) {
    return _then(_$CharElementImpl(
      charId: null == charId
          ? _value.charId
          : charId // ignore: cast_nullable_to_non_nullable
              as String,
      position: null == position
          ? _value.position
          : position // ignore: cast_nullable_to_non_nullable
              as CharPosition,
      transform: null == transform
          ? _value.transform
          : transform // ignore: cast_nullable_to_non_nullable
              as CharTransform,
      style: null == style
          ? _value.style
          : style // ignore: cast_nullable_to_non_nullable
              as CharStyle,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CharElementImpl extends _CharElement {
  const _$CharElementImpl(
      {required this.charId,
      required this.position,
      this.transform = const CharTransform(),
      this.style = const CharStyle()})
      : super._();

  factory _$CharElementImpl.fromJson(Map<String, dynamic> json) =>
      _$$CharElementImplFromJson(json);

  /// 瀛楃ID
  @override
  final String charId;

  /// 鐩稿浣嶇疆
  @override
  final CharPosition position;

  /// 鍙樻崲淇℃伅
  @override
  @JsonKey()
  final CharTransform transform;

  /// 鏍峰紡淇℃伅
  @override
  @JsonKey()
  final CharStyle style;

  @override
  String toString() {
    return 'CharElement(charId: $charId, position: $position, transform: $transform, style: $style)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CharElementImpl &&
            (identical(other.charId, charId) || other.charId == charId) &&
            (identical(other.position, position) ||
                other.position == position) &&
            (identical(other.transform, transform) ||
                other.transform == transform) &&
            (identical(other.style, style) || other.style == style));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, charId, position, transform, style);

  /// Create a copy of CharElement
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$CharElementImplCopyWith<_$CharElementImpl> get copyWith =>
      __$$CharElementImplCopyWithImpl<_$CharElementImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$CharElementImplToJson(
      this,
    );
  }
}

abstract class _CharElement extends CharElement {
  const factory _CharElement(
      {required final String charId,
      required final CharPosition position,
      final CharTransform transform,
      final CharStyle style}) = _$CharElementImpl;
  const _CharElement._() : super._();

  factory _CharElement.fromJson(Map<String, dynamic> json) =
      _$CharElementImpl.fromJson;

  /// 瀛楃ID
  @override
  String get charId;

  /// 鐩稿浣嶇疆
  @override
  CharPosition get position;

  /// 鍙樻崲淇℃伅
  @override
  CharTransform get transform;

  /// 鏍峰紡淇℃伅
  @override
  CharStyle get style;

  /// Create a copy of CharElement
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$CharElementImplCopyWith<_$CharElementImpl> get copyWith =>
      throw _privateConstructorUsedError;
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\domain\models\practice\char_element.g.dart
-----------------------------------
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'char_element.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_$CharElementImpl _$$CharElementImplFromJson(Map<String, dynamic> json) =>
    _$CharElementImpl(
      charId: json['charId'] as String,
      position: CharPosition.fromJson(json['position'] as Map<String, dynamic>),
      transform: json['transform'] == null
          ? const CharTransform()
          : CharTransform.fromJson(json['transform'] as Map<String, dynamic>),
      style: json['style'] == null
          ? const CharStyle()
          : CharStyle.fromJson(json['style'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$$CharElementImplToJson(_$CharElementImpl instance) =>
    <String, dynamic>{
      'charId': instance.charId,
      'position': instance.position,
      'transform': instance.transform,
      'style': instance.style,
    };



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\domain\models\practice\char_position.dart
-----------------------------------
import 'package:freezed_annotation/freezed_annotation.dart';

part 'char_position.freezed.dart';
part 'char_position.g.dart';

/// 瀛楃浣嶇疆
@freezed
class CharPosition with _$CharPosition {
  const factory CharPosition({
    /// X杞村亸绉婚噺
    required double offsetX,

    /// Y杞村亸绉婚噺
    required double offsetY,
  }) = _CharPosition;

  /// 浠嶫SON鍒涘缓瀹炰緥
  factory CharPosition.fromJson(Map<String, dynamic> json) =>
      _$CharPositionFromJson(json);

  const CharPosition._();
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\domain\models\practice\char_position.freezed.dart
-----------------------------------
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'char_position.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

CharPosition _$CharPositionFromJson(Map<String, dynamic> json) {
  return _CharPosition.fromJson(json);
}

/// @nodoc
mixin _$CharPosition {
  /// X杞村亸绉婚噺
  double get offsetX => throw _privateConstructorUsedError;

  /// Y杞村亸绉婚噺
  double get offsetY => throw _privateConstructorUsedError;

  /// Serializes this CharPosition to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of CharPosition
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $CharPositionCopyWith<CharPosition> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CharPositionCopyWith<$Res> {
  factory $CharPositionCopyWith(
          CharPosition value, $Res Function(CharPosition) then) =
      _$CharPositionCopyWithImpl<$Res, CharPosition>;
  @useResult
  $Res call({double offsetX, double offsetY});
}

/// @nodoc
class _$CharPositionCopyWithImpl<$Res, $Val extends CharPosition>
    implements $CharPositionCopyWith<$Res> {
  _$CharPositionCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of CharPosition
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? offsetX = null,
    Object? offsetY = null,
  }) {
    return _then(_value.copyWith(
      offsetX: null == offsetX
          ? _value.offsetX
          : offsetX // ignore: cast_nullable_to_non_nullable
              as double,
      offsetY: null == offsetY
          ? _value.offsetY
          : offsetY // ignore: cast_nullable_to_non_nullable
              as double,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$CharPositionImplCopyWith<$Res>
    implements $CharPositionCopyWith<$Res> {
  factory _$$CharPositionImplCopyWith(
          _$CharPositionImpl value, $Res Function(_$CharPositionImpl) then) =
      __$$CharPositionImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({double offsetX, double offsetY});
}

/// @nodoc
class __$$CharPositionImplCopyWithImpl<$Res>
    extends _$CharPositionCopyWithImpl<$Res, _$CharPositionImpl>
    implements _$$CharPositionImplCopyWith<$Res> {
  __$$CharPositionImplCopyWithImpl(
      _$CharPositionImpl _value, $Res Function(_$CharPositionImpl) _then)
      : super(_value, _then);

  /// Create a copy of CharPosition
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? offsetX = null,
    Object? offsetY = null,
  }) {
    return _then(_$CharPositionImpl(
      offsetX: null == offsetX
          ? _value.offsetX
          : offsetX // ignore: cast_nullable_to_non_nullable
              as double,
      offsetY: null == offsetY
          ? _value.offsetY
          : offsetY // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CharPositionImpl extends _CharPosition {
  const _$CharPositionImpl({required this.offsetX, required this.offsetY})
      : super._();

  factory _$CharPositionImpl.fromJson(Map<String, dynamic> json) =>
      _$$CharPositionImplFromJson(json);

  /// X杞村亸绉婚噺
  @override
  final double offsetX;

  /// Y杞村亸绉婚噺
  @override
  final double offsetY;

  @override
  String toString() {
    return 'CharPosition(offsetX: $offsetX, offsetY: $offsetY)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CharPositionImpl &&
            (identical(other.offsetX, offsetX) || other.offsetX == offsetX) &&
            (identical(other.offsetY, offsetY) || other.offsetY == offsetY));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, offsetX, offsetY);

  /// Create a copy of CharPosition
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$CharPositionImplCopyWith<_$CharPositionImpl> get copyWith =>
      __$$CharPositionImplCopyWithImpl<_$CharPositionImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$CharPositionImplToJson(
      this,
    );
  }
}

abstract class _CharPosition extends CharPosition {
  const factory _CharPosition(
      {required final double offsetX,
      required final double offsetY}) = _$CharPositionImpl;
  const _CharPosition._() : super._();

  factory _CharPosition.fromJson(Map<String, dynamic> json) =
      _$CharPositionImpl.fromJson;

  /// X杞村亸绉婚噺
  @override
  double get offsetX;

  /// Y杞村亸绉婚噺
  @override
  double get offsetY;

  /// Create a copy of CharPosition
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$CharPositionImplCopyWith<_$CharPositionImpl> get copyWith =>
      throw _privateConstructorUsedError;
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\domain\models\practice\char_position.g.dart
-----------------------------------
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'char_position.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_$CharPositionImpl _$$CharPositionImplFromJson(Map<String, dynamic> json) =>
    _$CharPositionImpl(
      offsetX: (json['offsetX'] as num).toDouble(),
      offsetY: (json['offsetY'] as num).toDouble(),
    );

Map<String, dynamic> _$$CharPositionImplToJson(_$CharPositionImpl instance) =>
    <String, dynamic>{
      'offsetX': instance.offsetX,
      'offsetY': instance.offsetY,
    };



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\domain\models\practice\char_style.dart
-----------------------------------
import 'package:freezed_annotation/freezed_annotation.dart';

part 'char_style.freezed.dart';
part 'char_style.g.dart';

/// 瀛楃鏍峰紡
@freezed
class CharStyle with _$CharStyle {
  const factory CharStyle({
    /// 棰滆壊锛岄粯璁ら粦鑹?
    @Default('#000000') String color,

    /// 涓嶉€忔槑搴︼紝榛樿瀹屽叏涓嶉€忔槑
    @Default(1.0) double opacity,

    /// 鑷畾涔夋牱寮忓睘鎬?
    @Default({}) Map<String, dynamic> customStyle,
  }) = _CharStyle;

  /// 浠嶫SON鍒涘缓瀹炰緥
  factory CharStyle.fromJson(Map<String, dynamic> json) =>
      _$CharStyleFromJson(json);

  const CharStyle._();

  /// 鍒犻櫎鑷畾涔夋牱寮忓睘鎬?
  CharStyle removeCustomStyle(String key) {
    final newCustomStyle = Map<String, dynamic>.from(customStyle);
    newCustomStyle.remove(key);
    return copyWith(customStyle: newCustomStyle);
  }

  /// 璁剧疆棰滆壊
  CharStyle setColor(String newColor) {
    return copyWith(color: newColor);
  }

  /// 璁剧疆鑷畾涔夋牱寮忓睘鎬?
  CharStyle setCustomStyle(String key, dynamic value) {
    final newCustomStyle = Map<String, dynamic>.from(customStyle);
    newCustomStyle[key] = value;
    return copyWith(customStyle: newCustomStyle);
  }

  /// 璁剧疆涓嶉€忔槑搴?
  CharStyle setOpacity(double newOpacity) {
    return copyWith(opacity: newOpacity.clamp(0.0, 1.0));
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\domain\models\practice\char_style.freezed.dart
-----------------------------------
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'char_style.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

CharStyle _$CharStyleFromJson(Map<String, dynamic> json) {
  return _CharStyle.fromJson(json);
}

/// @nodoc
mixin _$CharStyle {
  /// 棰滆壊锛岄粯璁ら粦鑹?  String get color => throw _privateConstructorUsedError;

  /// 涓嶉€忔槑搴︼紝榛樿瀹屽叏涓嶉€忔槑
  double get opacity => throw _privateConstructorUsedError;

  /// 鑷畾涔夋牱寮忓睘鎬?  Map<String, dynamic> get customStyle => throw _privateConstructorUsedError;

  /// Serializes this CharStyle to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of CharStyle
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $CharStyleCopyWith<CharStyle> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CharStyleCopyWith<$Res> {
  factory $CharStyleCopyWith(CharStyle value, $Res Function(CharStyle) then) =
      _$CharStyleCopyWithImpl<$Res, CharStyle>;
  @useResult
  $Res call({String color, double opacity, Map<String, dynamic> customStyle});
}

/// @nodoc
class _$CharStyleCopyWithImpl<$Res, $Val extends CharStyle>
    implements $CharStyleCopyWith<$Res> {
  _$CharStyleCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of CharStyle
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? color = null,
    Object? opacity = null,
    Object? customStyle = null,
  }) {
    return _then(_value.copyWith(
      color: null == color
          ? _value.color
          : color // ignore: cast_nullable_to_non_nullable
              as String,
      opacity: null == opacity
          ? _value.opacity
          : opacity // ignore: cast_nullable_to_non_nullable
              as double,
      customStyle: null == customStyle
          ? _value.customStyle
          : customStyle // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$CharStyleImplCopyWith<$Res>
    implements $CharStyleCopyWith<$Res> {
  factory _$$CharStyleImplCopyWith(
          _$CharStyleImpl value, $Res Function(_$CharStyleImpl) then) =
      __$$CharStyleImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String color, double opacity, Map<String, dynamic> customStyle});
}

/// @nodoc
class __$$CharStyleImplCopyWithImpl<$Res>
    extends _$CharStyleCopyWithImpl<$Res, _$CharStyleImpl>
    implements _$$CharStyleImplCopyWith<$Res> {
  __$$CharStyleImplCopyWithImpl(
      _$CharStyleImpl _value, $Res Function(_$CharStyleImpl) _then)
      : super(_value, _then);

  /// Create a copy of CharStyle
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? color = null,
    Object? opacity = null,
    Object? customStyle = null,
  }) {
    return _then(_$CharStyleImpl(
      color: null == color
          ? _value.color
          : color // ignore: cast_nullable_to_non_nullable
              as String,
      opacity: null == opacity
          ? _value.opacity
          : opacity // ignore: cast_nullable_to_non_nullable
              as double,
      customStyle: null == customStyle
          ? _value._customStyle
          : customStyle // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CharStyleImpl extends _CharStyle {
  const _$CharStyleImpl(
      {this.color = '#000000',
      this.opacity = 1.0,
      final Map<String, dynamic> customStyle = const {}})
      : _customStyle = customStyle,
        super._();

  factory _$CharStyleImpl.fromJson(Map<String, dynamic> json) =>
      _$$CharStyleImplFromJson(json);

  /// 棰滆壊锛岄粯璁ら粦鑹?  @override
  @JsonKey()
  final String color;

  /// 涓嶉€忔槑搴︼紝榛樿瀹屽叏涓嶉€忔槑
  @override
  @JsonKey()
  final double opacity;

  /// 鑷畾涔夋牱寮忓睘鎬?  final Map<String, dynamic> _customStyle;

  /// 鑷畾涔夋牱寮忓睘鎬?  @override
  @JsonKey()
  Map<String, dynamic> get customStyle {
    if (_customStyle is EqualUnmodifiableMapView) return _customStyle;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_customStyle);
  }

  @override
  String toString() {
    return 'CharStyle(color: $color, opacity: $opacity, customStyle: $customStyle)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CharStyleImpl &&
            (identical(other.color, color) || other.color == color) &&
            (identical(other.opacity, opacity) || other.opacity == opacity) &&
            const DeepCollectionEquality()
                .equals(other._customStyle, _customStyle));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, color, opacity,
      const DeepCollectionEquality().hash(_customStyle));

  /// Create a copy of CharStyle
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$CharStyleImplCopyWith<_$CharStyleImpl> get copyWith =>
      __$$CharStyleImplCopyWithImpl<_$CharStyleImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$CharStyleImplToJson(
      this,
    );
  }
}

abstract class _CharStyle extends CharStyle {
  const factory _CharStyle(
      {final String color,
      final double opacity,
      final Map<String, dynamic> customStyle}) = _$CharStyleImpl;
  const _CharStyle._() : super._();

  factory _CharStyle.fromJson(Map<String, dynamic> json) =
      _$CharStyleImpl.fromJson;

  /// 棰滆壊锛岄粯璁ら粦鑹?  @override
  String get color;

  /// 涓嶉€忔槑搴︼紝榛樿瀹屽叏涓嶉€忔槑
  @override
  double get opacity;

  /// 鑷畾涔夋牱寮忓睘鎬?  @override
  Map<String, dynamic> get customStyle;

  /// Create a copy of CharStyle
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$CharStyleImplCopyWith<_$CharStyleImpl> get copyWith =>
      throw _privateConstructorUsedError;
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\domain\models\practice\char_style.g.dart
-----------------------------------
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'char_style.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_$CharStyleImpl _$$CharStyleImplFromJson(Map<String, dynamic> json) =>
    _$CharStyleImpl(
      color: json['color'] as String? ?? '#000000',
      opacity: (json['opacity'] as num?)?.toDouble() ?? 1.0,
      customStyle: json['customStyle'] as Map<String, dynamic>? ?? const {},
    );

Map<String, dynamic> _$$CharStyleImplToJson(_$CharStyleImpl instance) =>
    <String, dynamic>{
      'color': instance.color,
      'opacity': instance.opacity,
      'customStyle': instance.customStyle,
    };



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\domain\models\practice\char_transform.dart
-----------------------------------
import 'package:freezed_annotation/freezed_annotation.dart';

part 'char_transform.freezed.dart';
part 'char_transform.g.dart';

/// 瀛楃鍙樻崲
@freezed
class CharTransform with _$CharTransform {
  const factory CharTransform({
    /// X杞寸缉鏀?
    @Default(1.0) double scaleX,

    /// Y杞寸缉鏀?
    @Default(1.0) double scaleY,

    /// 鏃嬭浆瑙掑害
    @Default(0.0) double rotation,
  }) = _CharTransform;

  /// 浠嶫SON鍒涘缓瀹炰緥
  factory CharTransform.fromJson(Map<String, dynamic> json) =>
      _$CharTransformFromJson(json);

  const CharTransform._();

  /// 鏃嬭浆
  CharTransform rotate(double angle) {
    return copyWith(
      rotation: rotation + angle,
    );
  }

  /// 鎸夋瘮渚嬬缉鏀?
  CharTransform scale(double sx, double sy) {
    return copyWith(
      scaleX: scaleX * sx,
      scaleY: scaleY * sy,
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\domain\models\practice\char_transform.freezed.dart
-----------------------------------
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'char_transform.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

CharTransform _$CharTransformFromJson(Map<String, dynamic> json) {
  return _CharTransform.fromJson(json);
}

/// @nodoc
mixin _$CharTransform {
  /// X杞寸缉鏀?  double get scaleX => throw _privateConstructorUsedError;

  /// Y杞寸缉鏀?  double get scaleY => throw _privateConstructorUsedError;

  /// 鏃嬭浆瑙掑害
  double get rotation => throw _privateConstructorUsedError;

  /// Serializes this CharTransform to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of CharTransform
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $CharTransformCopyWith<CharTransform> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CharTransformCopyWith<$Res> {
  factory $CharTransformCopyWith(
          CharTransform value, $Res Function(CharTransform) then) =
      _$CharTransformCopyWithImpl<$Res, CharTransform>;
  @useResult
  $Res call({double scaleX, double scaleY, double rotation});
}

/// @nodoc
class _$CharTransformCopyWithImpl<$Res, $Val extends CharTransform>
    implements $CharTransformCopyWith<$Res> {
  _$CharTransformCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of CharTransform
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? scaleX = null,
    Object? scaleY = null,
    Object? rotation = null,
  }) {
    return _then(_value.copyWith(
      scaleX: null == scaleX
          ? _value.scaleX
          : scaleX // ignore: cast_nullable_to_non_nullable
              as double,
      scaleY: null == scaleY
          ? _value.scaleY
          : scaleY // ignore: cast_nullable_to_non_nullable
              as double,
      rotation: null == rotation
          ? _value.rotation
          : rotation // ignore: cast_nullable_to_non_nullable
              as double,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$CharTransformImplCopyWith<$Res>
    implements $CharTransformCopyWith<$Res> {
  factory _$$CharTransformImplCopyWith(
          _$CharTransformImpl value, $Res Function(_$CharTransformImpl) then) =
      __$$CharTransformImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({double scaleX, double scaleY, double rotation});
}

/// @nodoc
class __$$CharTransformImplCopyWithImpl<$Res>
    extends _$CharTransformCopyWithImpl<$Res, _$CharTransformImpl>
    implements _$$CharTransformImplCopyWith<$Res> {
  __$$CharTransformImplCopyWithImpl(
      _$CharTransformImpl _value, $Res Function(_$CharTransformImpl) _then)
      : super(_value, _then);

  /// Create a copy of CharTransform
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? scaleX = null,
    Object? scaleY = null,
    Object? rotation = null,
  }) {
    return _then(_$CharTransformImpl(
      scaleX: null == scaleX
          ? _value.scaleX
          : scaleX // ignore: cast_nullable_to_non_nullable
              as double,
      scaleY: null == scaleY
          ? _value.scaleY
          : scaleY // ignore: cast_nullable_to_non_nullable
              as double,
      rotation: null == rotation
          ? _value.rotation
          : rotation // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CharTransformImpl extends _CharTransform {
  const _$CharTransformImpl(
      {this.scaleX = 1.0, this.scaleY = 1.0, this.rotation = 0.0})
      : super._();

  factory _$CharTransformImpl.fromJson(Map<String, dynamic> json) =>
      _$$CharTransformImplFromJson(json);

  /// X杞寸缉鏀?  @override
  @JsonKey()
  final double scaleX;

  /// Y杞寸缉鏀?  @override
  @JsonKey()
  final double scaleY;

  /// 鏃嬭浆瑙掑害
  @override
  @JsonKey()
  final double rotation;

  @override
  String toString() {
    return 'CharTransform(scaleX: $scaleX, scaleY: $scaleY, rotation: $rotation)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CharTransformImpl &&
            (identical(other.scaleX, scaleX) || other.scaleX == scaleX) &&
            (identical(other.scaleY, scaleY) || other.scaleY == scaleY) &&
            (identical(other.rotation, rotation) ||
                other.rotation == rotation));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, scaleX, scaleY, rotation);

  /// Create a copy of CharTransform
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$CharTransformImplCopyWith<_$CharTransformImpl> get copyWith =>
      __$$CharTransformImplCopyWithImpl<_$CharTransformImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$CharTransformImplToJson(
      this,
    );
  }
}

abstract class _CharTransform extends CharTransform {
  const factory _CharTransform(
      {final double scaleX,
      final double scaleY,
      final double rotation}) = _$CharTransformImpl;
  const _CharTransform._() : super._();

  factory _CharTransform.fromJson(Map<String, dynamic> json) =
      _$CharTransformImpl.fromJson;

  /// X杞寸缉鏀?  @override
  double get scaleX;

  /// Y杞寸缉鏀?  @override
  double get scaleY;

  /// 鏃嬭浆瑙掑害
  @override
  double get rotation;

  /// Create a copy of CharTransform
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$CharTransformImplCopyWith<_$CharTransformImpl> get copyWith =>
      throw _privateConstructorUsedError;
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\domain\models\practice\char_transform.g.dart
-----------------------------------
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'char_transform.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_$CharTransformImpl _$$CharTransformImplFromJson(Map<String, dynamic> json) =>
    _$CharTransformImpl(
      scaleX: (json['scaleX'] as num?)?.toDouble() ?? 1.0,
      scaleY: (json['scaleY'] as num?)?.toDouble() ?? 1.0,
      rotation: (json['rotation'] as num?)?.toDouble() ?? 0.0,
    );

Map<String, dynamic> _$$CharTransformImplToJson(_$CharTransformImpl instance) =>
    <String, dynamic>{
      'scaleX': instance.scaleX,
      'scaleY': instance.scaleY,
      'rotation': instance.rotation,
    };



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\domain\models\practice\element_content.dart
-----------------------------------
import 'package:freezed_annotation/freezed_annotation.dart';

import 'char_element.dart';
import 'image_element.dart';
import 'text_element.dart';

part 'element_content.freezed.dart';
part 'element_content.g.dart';

/// 鍏冪礌鍐呭鍩虹被
@unfreezed
class ElementContent with _$ElementContent {
  /// 瀛楃鍐呭
  @FreezedUnionValue('chars')
  factory ElementContent.chars({
    /// 瀛楃鍒楄〃
    @Default([]) List<CharElement> chars,
  }) = CharsContent;

  /// 浠嶫SON鍒涘缓瀹炰緥
  factory ElementContent.fromJson(Map<String, dynamic> json) =>
      _$ElementContentFromJson(json);

  /// 鍥剧墖鍐呭
  @FreezedUnionValue('image')
  factory ElementContent.image({
    /// 鍥剧墖瀵硅薄
    required ImageElement image,
  }) = ImageContent;

  /// 鏂囨湰鍐呭
  @FreezedUnionValue('text')
  factory ElementContent.text({
    /// 鏂囨湰瀵硅薄
    required TextElement text,
  }) = TextContent;

  const ElementContent._();
}

/// CharsContent 鎵╁睍鏂规硶
extension CharsContentX on CharsContent {
  /// 娣诲姞瀛楃
  CharsContent addChar(CharElement char) {
    return copyWith(chars: [...chars, char]);
  }

  /// 娓呯┖瀛楃
  CharsContent clearChars() {
    return copyWith(chars: const []);
  }

  /// 绉婚櫎瀛楃
  CharsContent removeChar(String id) {
    return copyWith(
      chars: chars.where((c) => c.charId != id).toList(),
    );
  }

  /// 鏇存柊瀛楃
  CharsContent updateChar(CharElement char) {
    return copyWith(
      chars: chars.map((c) => c.charId == char.charId ? char : c).toList(),
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\domain\models\practice\element_content.freezed.dart
-----------------------------------
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'element_content.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

ElementContent _$ElementContentFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'chars':
      return CharsContent.fromJson(json);
    case 'image':
      return ImageContent.fromJson(json);
    case 'text':
      return TextContent.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'runtimeType', 'ElementContent',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$ElementContent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<CharElement> chars) chars,
    required TResult Function(ImageElement image) image,
    required TResult Function(TextElement text) text,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<CharElement> chars)? chars,
    TResult? Function(ImageElement image)? image,
    TResult? Function(TextElement text)? text,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<CharElement> chars)? chars,
    TResult Function(ImageElement image)? image,
    TResult Function(TextElement text)? text,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CharsContent value) chars,
    required TResult Function(ImageContent value) image,
    required TResult Function(TextContent value) text,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CharsContent value)? chars,
    TResult? Function(ImageContent value)? image,
    TResult? Function(TextContent value)? text,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CharsContent value)? chars,
    TResult Function(ImageContent value)? image,
    TResult Function(TextContent value)? text,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;

  /// Serializes this ElementContent to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ElementContentCopyWith<$Res> {
  factory $ElementContentCopyWith(
          ElementContent value, $Res Function(ElementContent) then) =
      _$ElementContentCopyWithImpl<$Res, ElementContent>;
}

/// @nodoc
class _$ElementContentCopyWithImpl<$Res, $Val extends ElementContent>
    implements $ElementContentCopyWith<$Res> {
  _$ElementContentCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of ElementContent
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$CharsContentImplCopyWith<$Res> {
  factory _$$CharsContentImplCopyWith(
          _$CharsContentImpl value, $Res Function(_$CharsContentImpl) then) =
      __$$CharsContentImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<CharElement> chars});
}

/// @nodoc
class __$$CharsContentImplCopyWithImpl<$Res>
    extends _$ElementContentCopyWithImpl<$Res, _$CharsContentImpl>
    implements _$$CharsContentImplCopyWith<$Res> {
  __$$CharsContentImplCopyWithImpl(
      _$CharsContentImpl _value, $Res Function(_$CharsContentImpl) _then)
      : super(_value, _then);

  /// Create a copy of ElementContent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? chars = null,
  }) {
    return _then(_$CharsContentImpl(
      chars: null == chars
          ? _value.chars
          : chars // ignore: cast_nullable_to_non_nullable
              as List<CharElement>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CharsContentImpl extends CharsContent {
  _$CharsContentImpl({this.chars = const [], final String? $type})
      : $type = $type ?? 'chars',
        super._();

  factory _$CharsContentImpl.fromJson(Map<String, dynamic> json) =>
      _$$CharsContentImplFromJson(json);

  /// 瀛楃鍒楄〃
  @override
  @JsonKey()
  List<CharElement> chars;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'ElementContent.chars(chars: $chars)';
  }

  /// Create a copy of ElementContent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$CharsContentImplCopyWith<_$CharsContentImpl> get copyWith =>
      __$$CharsContentImplCopyWithImpl<_$CharsContentImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<CharElement> chars) chars,
    required TResult Function(ImageElement image) image,
    required TResult Function(TextElement text) text,
  }) {
    return chars(this.chars);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<CharElement> chars)? chars,
    TResult? Function(ImageElement image)? image,
    TResult? Function(TextElement text)? text,
  }) {
    return chars?.call(this.chars);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<CharElement> chars)? chars,
    TResult Function(ImageElement image)? image,
    TResult Function(TextElement text)? text,
    required TResult orElse(),
  }) {
    if (chars != null) {
      return chars(this.chars);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CharsContent value) chars,
    required TResult Function(ImageContent value) image,
    required TResult Function(TextContent value) text,
  }) {
    return chars(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CharsContent value)? chars,
    TResult? Function(ImageContent value)? image,
    TResult? Function(TextContent value)? text,
  }) {
    return chars?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CharsContent value)? chars,
    TResult Function(ImageContent value)? image,
    TResult Function(TextContent value)? text,
    required TResult orElse(),
  }) {
    if (chars != null) {
      return chars(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$CharsContentImplToJson(
      this,
    );
  }
}

abstract class CharsContent extends ElementContent {
  factory CharsContent({List<CharElement> chars}) = _$CharsContentImpl;
  CharsContent._() : super._();

  factory CharsContent.fromJson(Map<String, dynamic> json) =
      _$CharsContentImpl.fromJson;

  /// 瀛楃鍒楄〃
  List<CharElement> get chars;

  /// 瀛楃鍒楄〃
  set chars(List<CharElement> value);

  /// Create a copy of ElementContent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$CharsContentImplCopyWith<_$CharsContentImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ImageContentImplCopyWith<$Res> {
  factory _$$ImageContentImplCopyWith(
          _$ImageContentImpl value, $Res Function(_$ImageContentImpl) then) =
      __$$ImageContentImplCopyWithImpl<$Res>;
  @useResult
  $Res call({ImageElement image});

  $ImageElementCopyWith<$Res> get image;
}

/// @nodoc
class __$$ImageContentImplCopyWithImpl<$Res>
    extends _$ElementContentCopyWithImpl<$Res, _$ImageContentImpl>
    implements _$$ImageContentImplCopyWith<$Res> {
  __$$ImageContentImplCopyWithImpl(
      _$ImageContentImpl _value, $Res Function(_$ImageContentImpl) _then)
      : super(_value, _then);

  /// Create a copy of ElementContent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? image = null,
  }) {
    return _then(_$ImageContentImpl(
      image: null == image
          ? _value.image
          : image // ignore: cast_nullable_to_non_nullable
              as ImageElement,
    ));
  }

  /// Create a copy of ElementContent
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ImageElementCopyWith<$Res> get image {
    return $ImageElementCopyWith<$Res>(_value.image, (value) {
      return _then(_value.copyWith(image: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$ImageContentImpl extends ImageContent {
  _$ImageContentImpl({required this.image, final String? $type})
      : $type = $type ?? 'image',
        super._();

  factory _$ImageContentImpl.fromJson(Map<String, dynamic> json) =>
      _$$ImageContentImplFromJson(json);

  /// 鍥剧墖瀵硅薄
  @override
  ImageElement image;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'ElementContent.image(image: $image)';
  }

  /// Create a copy of ElementContent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ImageContentImplCopyWith<_$ImageContentImpl> get copyWith =>
      __$$ImageContentImplCopyWithImpl<_$ImageContentImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<CharElement> chars) chars,
    required TResult Function(ImageElement image) image,
    required TResult Function(TextElement text) text,
  }) {
    return image(this.image);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<CharElement> chars)? chars,
    TResult? Function(ImageElement image)? image,
    TResult? Function(TextElement text)? text,
  }) {
    return image?.call(this.image);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<CharElement> chars)? chars,
    TResult Function(ImageElement image)? image,
    TResult Function(TextElement text)? text,
    required TResult orElse(),
  }) {
    if (image != null) {
      return image(this.image);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CharsContent value) chars,
    required TResult Function(ImageContent value) image,
    required TResult Function(TextContent value) text,
  }) {
    return image(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CharsContent value)? chars,
    TResult? Function(ImageContent value)? image,
    TResult? Function(TextContent value)? text,
  }) {
    return image?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CharsContent value)? chars,
    TResult Function(ImageContent value)? image,
    TResult Function(TextContent value)? text,
    required TResult orElse(),
  }) {
    if (image != null) {
      return image(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$ImageContentImplToJson(
      this,
    );
  }
}

abstract class ImageContent extends ElementContent {
  factory ImageContent({required ImageElement image}) = _$ImageContentImpl;
  ImageContent._() : super._();

  factory ImageContent.fromJson(Map<String, dynamic> json) =
      _$ImageContentImpl.fromJson;

  /// 鍥剧墖瀵硅薄
  ImageElement get image;

  /// 鍥剧墖瀵硅薄
  set image(ImageElement value);

  /// Create a copy of ElementContent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ImageContentImplCopyWith<_$ImageContentImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$TextContentImplCopyWith<$Res> {
  factory _$$TextContentImplCopyWith(
          _$TextContentImpl value, $Res Function(_$TextContentImpl) then) =
      __$$TextContentImplCopyWithImpl<$Res>;
  @useResult
  $Res call({TextElement text});

  $TextElementCopyWith<$Res> get text;
}

/// @nodoc
class __$$TextContentImplCopyWithImpl<$Res>
    extends _$ElementContentCopyWithImpl<$Res, _$TextContentImpl>
    implements _$$TextContentImplCopyWith<$Res> {
  __$$TextContentImplCopyWithImpl(
      _$TextContentImpl _value, $Res Function(_$TextContentImpl) _then)
      : super(_value, _then);

  /// Create a copy of ElementContent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? text = null,
  }) {
    return _then(_$TextContentImpl(
      text: null == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as TextElement,
    ));
  }

  /// Create a copy of ElementContent
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $TextElementCopyWith<$Res> get text {
    return $TextElementCopyWith<$Res>(_value.text, (value) {
      return _then(_value.copyWith(text: value));
    });
  }
}

/// @nodoc
@JsonSerializable()
class _$TextContentImpl extends TextContent {
  _$TextContentImpl({required this.text, final String? $type})
      : $type = $type ?? 'text',
        super._();

  factory _$TextContentImpl.fromJson(Map<String, dynamic> json) =>
      _$$TextContentImplFromJson(json);

  /// 鏂囨湰瀵硅薄
  @override
  TextElement text;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'ElementContent.text(text: $text)';
  }

  /// Create a copy of ElementContent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$TextContentImplCopyWith<_$TextContentImpl> get copyWith =>
      __$$TextContentImplCopyWithImpl<_$TextContentImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<CharElement> chars) chars,
    required TResult Function(ImageElement image) image,
    required TResult Function(TextElement text) text,
  }) {
    return text(this.text);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<CharElement> chars)? chars,
    TResult? Function(ImageElement image)? image,
    TResult? Function(TextElement text)? text,
  }) {
    return text?.call(this.text);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<CharElement> chars)? chars,
    TResult Function(ImageElement image)? image,
    TResult Function(TextElement text)? text,
    required TResult orElse(),
  }) {
    if (text != null) {
      return text(this.text);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CharsContent value) chars,
    required TResult Function(ImageContent value) image,
    required TResult Function(TextContent value) text,
  }) {
    return text(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CharsContent value)? chars,
    TResult? Function(ImageContent value)? image,
    TResult? Function(TextContent value)? text,
  }) {
    return text?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CharsContent value)? chars,
    TResult Function(ImageContent value)? image,
    TResult Function(TextContent value)? text,
    required TResult orElse(),
  }) {
    if (text != null) {
      return text(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$TextContentImplToJson(
      this,
    );
  }
}

abstract class TextContent extends ElementContent {
  factory TextContent({required TextElement text}) = _$TextContentImpl;
  TextContent._() : super._();

  factory TextContent.fromJson(Map<String, dynamic> json) =
      _$TextContentImpl.fromJson;

  /// 鏂囨湰瀵硅薄
  TextElement get text;

  /// 鏂囨湰瀵硅薄
  set text(TextElement value);

  /// Create a copy of ElementContent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$TextContentImplCopyWith<_$TextContentImpl> get copyWith =>
      throw _privateConstructorUsedError;
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\domain\models\practice\element_content.g.dart
-----------------------------------
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'element_content.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_$CharsContentImpl _$$CharsContentImplFromJson(Map<String, dynamic> json) =>
    _$CharsContentImpl(
      chars: (json['chars'] as List<dynamic>?)
              ?.map((e) => CharElement.fromJson(e as Map<String, dynamic>))
              .toList() ??
          const [],
      $type: json['runtimeType'] as String?,
    );

Map<String, dynamic> _$$CharsContentImplToJson(_$CharsContentImpl instance) =>
    <String, dynamic>{
      'chars': instance.chars,
      'runtimeType': instance.$type,
    };

_$ImageContentImpl _$$ImageContentImplFromJson(Map<String, dynamic> json) =>
    _$ImageContentImpl(
      image: ImageElement.fromJson(json['image'] as Map<String, dynamic>),
      $type: json['runtimeType'] as String?,
    );

Map<String, dynamic> _$$ImageContentImplToJson(_$ImageContentImpl instance) =>
    <String, dynamic>{
      'image': instance.image,
      'runtimeType': instance.$type,
    };

_$TextContentImpl _$$TextContentImplFromJson(Map<String, dynamic> json) =>
    _$TextContentImpl(
      text: TextElement.fromJson(json['text'] as Map<String, dynamic>),
      $type: json['runtimeType'] as String?,
    );

Map<String, dynamic> _$$TextContentImplToJson(_$TextContentImpl instance) =>
    <String, dynamic>{
      'text': instance.text,
      'runtimeType': instance.$type,
    };



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\domain\models\practice\element_geometry.dart
-----------------------------------
import 'package:freezed_annotation/freezed_annotation.dart';

part 'element_geometry.freezed.dart';
part 'element_geometry.g.dart';

/// 鍏冪礌鍑犱綍灞炴€?
@freezed
class ElementGeometry with _$ElementGeometry {
  const factory ElementGeometry({
    /// X鍧愭爣
    @Default(0.0) double x,

    /// Y鍧愭爣
    @Default(0.0) double y,

    /// 瀹藉害
    @Default(100.0) double width,

    /// 楂樺害
    @Default(100.0) double height,

    /// 鏃嬭浆瑙掑害(寮у害)
    @Default(0.0) double rotation,

    /// 缂╂斁
    @Default(1.0) double scale,
  }) = _ElementGeometry;

  /// 浠嶫SON鍒涘缓瀹炰緥
  factory ElementGeometry.fromJson(Map<String, dynamic> json) =>
      _$ElementGeometryFromJson(json);

  const ElementGeometry._();

  /// 鑾峰彇涓嬭竟鐣?
  double get bottom => y + height;

  /// 鑾峰彇涓績鐐筙鍧愭爣
  double get centerX => x + width / 2;

  /// 鑾峰彇涓績鐐筜鍧愭爣
  double get centerY => y + height / 2;

  /// 鑾峰彇鍙宠竟鐣?
  double get right => x + width;

  /// 鍒ゆ柇鐐规槸鍚﹀湪杈圭晫鍐?
  bool containsPoint(double px, double py) {
    return px >= x && px <= right && py >= y && py <= bottom;
  }

  /// 绉诲姩鍏冪礌
  ElementGeometry move(double dx, double dy) {
    return copyWith(
      x: x + dx,
      y: y + dy,
    );
  }

  /// 璋冩暣澶у皬
  ElementGeometry resize(double width, double height) {
    return copyWith(
      width: width,
      height: height,
    );
  }

  /// 鏃嬭浆
  ElementGeometry rotate(double angle) {
    return copyWith(
      rotation: rotation + angle,
    );
  }

  /// 璁剧疆缂╂斁
  ElementGeometry setScale(double scale) {
    return copyWith(
      scale: scale,
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\domain\models\practice\element_geometry.freezed.dart
-----------------------------------
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'element_geometry.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

ElementGeometry _$ElementGeometryFromJson(Map<String, dynamic> json) {
  return _ElementGeometry.fromJson(json);
}

/// @nodoc
mixin _$ElementGeometry {
  /// X鍧愭爣
  double get x => throw _privateConstructorUsedError;

  /// Y鍧愭爣
  double get y => throw _privateConstructorUsedError;

  /// 瀹藉害
  double get width => throw _privateConstructorUsedError;

  /// 楂樺害
  double get height => throw _privateConstructorUsedError;

  /// 鏃嬭浆瑙掑害(寮у害)
  double get rotation => throw _privateConstructorUsedError;

  /// 缂╂斁
  double get scale => throw _privateConstructorUsedError;

  /// Serializes this ElementGeometry to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of ElementGeometry
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $ElementGeometryCopyWith<ElementGeometry> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ElementGeometryCopyWith<$Res> {
  factory $ElementGeometryCopyWith(
          ElementGeometry value, $Res Function(ElementGeometry) then) =
      _$ElementGeometryCopyWithImpl<$Res, ElementGeometry>;
  @useResult
  $Res call(
      {double x,
      double y,
      double width,
      double height,
      double rotation,
      double scale});
}

/// @nodoc
class _$ElementGeometryCopyWithImpl<$Res, $Val extends ElementGeometry>
    implements $ElementGeometryCopyWith<$Res> {
  _$ElementGeometryCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of ElementGeometry
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? x = null,
    Object? y = null,
    Object? width = null,
    Object? height = null,
    Object? rotation = null,
    Object? scale = null,
  }) {
    return _then(_value.copyWith(
      x: null == x
          ? _value.x
          : x // ignore: cast_nullable_to_non_nullable
              as double,
      y: null == y
          ? _value.y
          : y // ignore: cast_nullable_to_non_nullable
              as double,
      width: null == width
          ? _value.width
          : width // ignore: cast_nullable_to_non_nullable
              as double,
      height: null == height
          ? _value.height
          : height // ignore: cast_nullable_to_non_nullable
              as double,
      rotation: null == rotation
          ? _value.rotation
          : rotation // ignore: cast_nullable_to_non_nullable
              as double,
      scale: null == scale
          ? _value.scale
          : scale // ignore: cast_nullable_to_non_nullable
              as double,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ElementGeometryImplCopyWith<$Res>
    implements $ElementGeometryCopyWith<$Res> {
  factory _$$ElementGeometryImplCopyWith(_$ElementGeometryImpl value,
          $Res Function(_$ElementGeometryImpl) then) =
      __$$ElementGeometryImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {double x,
      double y,
      double width,
      double height,
      double rotation,
      double scale});
}

/// @nodoc
class __$$ElementGeometryImplCopyWithImpl<$Res>
    extends _$ElementGeometryCopyWithImpl<$Res, _$ElementGeometryImpl>
    implements _$$ElementGeometryImplCopyWith<$Res> {
  __$$ElementGeometryImplCopyWithImpl(
      _$ElementGeometryImpl _value, $Res Function(_$ElementGeometryImpl) _then)
      : super(_value, _then);

  /// Create a copy of ElementGeometry
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? x = null,
    Object? y = null,
    Object? width = null,
    Object? height = null,
    Object? rotation = null,
    Object? scale = null,
  }) {
    return _then(_$ElementGeometryImpl(
      x: null == x
          ? _value.x
          : x // ignore: cast_nullable_to_non_nullable
              as double,
      y: null == y
          ? _value.y
          : y // ignore: cast_nullable_to_non_nullable
              as double,
      width: null == width
          ? _value.width
          : width // ignore: cast_nullable_to_non_nullable
              as double,
      height: null == height
          ? _value.height
          : height // ignore: cast_nullable_to_non_nullable
              as double,
      rotation: null == rotation
          ? _value.rotation
          : rotation // ignore: cast_nullable_to_non_nullable
              as double,
      scale: null == scale
          ? _value.scale
          : scale // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ElementGeometryImpl extends _ElementGeometry {
  const _$ElementGeometryImpl(
      {this.x = 0.0,
      this.y = 0.0,
      this.width = 100.0,
      this.height = 100.0,
      this.rotation = 0.0,
      this.scale = 1.0})
      : super._();

  factory _$ElementGeometryImpl.fromJson(Map<String, dynamic> json) =>
      _$$ElementGeometryImplFromJson(json);

  /// X鍧愭爣
  @override
  @JsonKey()
  final double x;

  /// Y鍧愭爣
  @override
  @JsonKey()
  final double y;

  /// 瀹藉害
  @override
  @JsonKey()
  final double width;

  /// 楂樺害
  @override
  @JsonKey()
  final double height;

  /// 鏃嬭浆瑙掑害(寮у害)
  @override
  @JsonKey()
  final double rotation;

  /// 缂╂斁
  @override
  @JsonKey()
  final double scale;

  @override
  String toString() {
    return 'ElementGeometry(x: $x, y: $y, width: $width, height: $height, rotation: $rotation, scale: $scale)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ElementGeometryImpl &&
            (identical(other.x, x) || other.x == x) &&
            (identical(other.y, y) || other.y == y) &&
            (identical(other.width, width) || other.width == width) &&
            (identical(other.height, height) || other.height == height) &&
            (identical(other.rotation, rotation) ||
                other.rotation == rotation) &&
            (identical(other.scale, scale) || other.scale == scale));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, x, y, width, height, rotation, scale);

  /// Create a copy of ElementGeometry
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ElementGeometryImplCopyWith<_$ElementGeometryImpl> get copyWith =>
      __$$ElementGeometryImplCopyWithImpl<_$ElementGeometryImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ElementGeometryImplToJson(
      this,
    );
  }
}

abstract class _ElementGeometry extends ElementGeometry {
  const factory _ElementGeometry(
      {final double x,
      final double y,
      final double width,
      final double height,
      final double rotation,
      final double scale}) = _$ElementGeometryImpl;
  const _ElementGeometry._() : super._();

  factory _ElementGeometry.fromJson(Map<String, dynamic> json) =
      _$ElementGeometryImpl.fromJson;

  /// X鍧愭爣
  @override
  double get x;

  /// Y鍧愭爣
  @override
  double get y;

  /// 瀹藉害
  @override
  double get width;

  /// 楂樺害
  @override
  double get height;

  /// 鏃嬭浆瑙掑害(寮у害)
  @override
  double get rotation;

  /// 缂╂斁
  @override
  double get scale;

  /// Create a copy of ElementGeometry
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ElementGeometryImplCopyWith<_$ElementGeometryImpl> get copyWith =>
      throw _privateConstructorUsedError;
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\domain\models\practice\element_geometry.g.dart
-----------------------------------
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'element_geometry.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_$ElementGeometryImpl _$$ElementGeometryImplFromJson(
        Map<String, dynamic> json) =>
    _$ElementGeometryImpl(
      x: (json['x'] as num?)?.toDouble() ?? 0.0,
      y: (json['y'] as num?)?.toDouble() ?? 0.0,
      width: (json['width'] as num?)?.toDouble() ?? 100.0,
      height: (json['height'] as num?)?.toDouble() ?? 100.0,
      rotation: (json['rotation'] as num?)?.toDouble() ?? 0.0,
      scale: (json['scale'] as num?)?.toDouble() ?? 1.0,
    );

Map<String, dynamic> _$$ElementGeometryImplToJson(
        _$ElementGeometryImpl instance) =>
    <String, dynamic>{
      'x': instance.x,
      'y': instance.y,
      'width': instance.width,
      'height': instance.height,
      'rotation': instance.rotation,
      'scale': instance.scale,
    };



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\domain\models\practice\element_style.dart
-----------------------------------
import 'package:freezed_annotation/freezed_annotation.dart';

part 'element_style.freezed.dart';
part 'element_style.g.dart';

/// 鍏冪礌鐨勬牱寮忓睘鎬?
@freezed
class ElementStyle with _$ElementStyle {
  const factory ElementStyle({
    /// 閫忔槑搴?
    @Default(1.0) double opacity,

    /// 鏄惁鍙
    @Default(true) bool visible,

    /// 鏄惁閿佸畾
    @Default(false) bool locked,

    /// 鑷畾涔夋牱寮忓睘鎬?
    @Default({}) Map<String, dynamic> properties,
  }) = _ElementStyle;

  /// 浠嶫SON鍒涘缓瀹炰緥
  factory ElementStyle.fromJson(Map<String, dynamic> json) =>
      _$ElementStyleFromJson(json);

  const ElementStyle._();

  /// 绉婚櫎鏍峰紡灞炴€?
  ElementStyle removeProperty(String key) {
    final newProperties = Map<String, dynamic>.from(properties);
    newProperties.remove(key);
    return copyWith(properties: newProperties);
  }

  /// 璁剧疆閿佸畾鐘舵€?
  ElementStyle setLocked(bool value) => copyWith(locked: value);

  /// 璁剧疆閫忔槑搴?
  ElementStyle setOpacity(double value) => copyWith(opacity: value);

  /// 璁剧疆鏍峰紡灞炴€?
  ElementStyle setProperty(String key, dynamic value) {
    final newProperties = Map<String, dynamic>.from(properties);
    newProperties[key] = value;
    return copyWith(properties: newProperties);
  }

  /// 璁剧疆鍙鎬?
  ElementStyle setVisible(bool value) => copyWith(visible: value);
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\domain\models\practice\element_style.freezed.dart
-----------------------------------
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'element_style.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

ElementStyle _$ElementStyleFromJson(Map<String, dynamic> json) {
  return _ElementStyle.fromJson(json);
}

/// @nodoc
mixin _$ElementStyle {
  /// 閫忔槑搴?  double get opacity => throw _privateConstructorUsedError;

  /// 鏄惁鍙
  bool get visible => throw _privateConstructorUsedError;

  /// 鏄惁閿佸畾
  bool get locked => throw _privateConstructorUsedError;

  /// 鑷畾涔夋牱寮忓睘鎬?  Map<String, dynamic> get properties => throw _privateConstructorUsedError;

  /// Serializes this ElementStyle to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of ElementStyle
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $ElementStyleCopyWith<ElementStyle> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ElementStyleCopyWith<$Res> {
  factory $ElementStyleCopyWith(
          ElementStyle value, $Res Function(ElementStyle) then) =
      _$ElementStyleCopyWithImpl<$Res, ElementStyle>;
  @useResult
  $Res call(
      {double opacity,
      bool visible,
      bool locked,
      Map<String, dynamic> properties});
}

/// @nodoc
class _$ElementStyleCopyWithImpl<$Res, $Val extends ElementStyle>
    implements $ElementStyleCopyWith<$Res> {
  _$ElementStyleCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of ElementStyle
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? opacity = null,
    Object? visible = null,
    Object? locked = null,
    Object? properties = null,
  }) {
    return _then(_value.copyWith(
      opacity: null == opacity
          ? _value.opacity
          : opacity // ignore: cast_nullable_to_non_nullable
              as double,
      visible: null == visible
          ? _value.visible
          : visible // ignore: cast_nullable_to_non_nullable
              as bool,
      locked: null == locked
          ? _value.locked
          : locked // ignore: cast_nullable_to_non_nullable
              as bool,
      properties: null == properties
          ? _value.properties
          : properties // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ElementStyleImplCopyWith<$Res>
    implements $ElementStyleCopyWith<$Res> {
  factory _$$ElementStyleImplCopyWith(
          _$ElementStyleImpl value, $Res Function(_$ElementStyleImpl) then) =
      __$$ElementStyleImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {double opacity,
      bool visible,
      bool locked,
      Map<String, dynamic> properties});
}

/// @nodoc
class __$$ElementStyleImplCopyWithImpl<$Res>
    extends _$ElementStyleCopyWithImpl<$Res, _$ElementStyleImpl>
    implements _$$ElementStyleImplCopyWith<$Res> {
  __$$ElementStyleImplCopyWithImpl(
      _$ElementStyleImpl _value, $Res Function(_$ElementStyleImpl) _then)
      : super(_value, _then);

  /// Create a copy of ElementStyle
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? opacity = null,
    Object? visible = null,
    Object? locked = null,
    Object? properties = null,
  }) {
    return _then(_$ElementStyleImpl(
      opacity: null == opacity
          ? _value.opacity
          : opacity // ignore: cast_nullable_to_non_nullable
              as double,
      visible: null == visible
          ? _value.visible
          : visible // ignore: cast_nullable_to_non_nullable
              as bool,
      locked: null == locked
          ? _value.locked
          : locked // ignore: cast_nullable_to_non_nullable
              as bool,
      properties: null == properties
          ? _value._properties
          : properties // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ElementStyleImpl extends _ElementStyle {
  const _$ElementStyleImpl(
      {this.opacity = 1.0,
      this.visible = true,
      this.locked = false,
      final Map<String, dynamic> properties = const {}})
      : _properties = properties,
        super._();

  factory _$ElementStyleImpl.fromJson(Map<String, dynamic> json) =>
      _$$ElementStyleImplFromJson(json);

  /// 閫忔槑搴?  @override
  @JsonKey()
  final double opacity;

  /// 鏄惁鍙
  @override
  @JsonKey()
  final bool visible;

  /// 鏄惁閿佸畾
  @override
  @JsonKey()
  final bool locked;

  /// 鑷畾涔夋牱寮忓睘鎬?  final Map<String, dynamic> _properties;

  /// 鑷畾涔夋牱寮忓睘鎬?  @override
  @JsonKey()
  Map<String, dynamic> get properties {
    if (_properties is EqualUnmodifiableMapView) return _properties;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_properties);
  }

  @override
  String toString() {
    return 'ElementStyle(opacity: $opacity, visible: $visible, locked: $locked, properties: $properties)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ElementStyleImpl &&
            (identical(other.opacity, opacity) || other.opacity == opacity) &&
            (identical(other.visible, visible) || other.visible == visible) &&
            (identical(other.locked, locked) || other.locked == locked) &&
            const DeepCollectionEquality()
                .equals(other._properties, _properties));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, opacity, visible, locked,
      const DeepCollectionEquality().hash(_properties));

  /// Create a copy of ElementStyle
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ElementStyleImplCopyWith<_$ElementStyleImpl> get copyWith =>
      __$$ElementStyleImplCopyWithImpl<_$ElementStyleImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ElementStyleImplToJson(
      this,
    );
  }
}

abstract class _ElementStyle extends ElementStyle {
  const factory _ElementStyle(
      {final double opacity,
      final bool visible,
      final bool locked,
      final Map<String, dynamic> properties}) = _$ElementStyleImpl;
  const _ElementStyle._() : super._();

  factory _ElementStyle.fromJson(Map<String, dynamic> json) =
      _$ElementStyleImpl.fromJson;

  /// 閫忔槑搴?  @override
  double get opacity;

  /// 鏄惁鍙
  @override
  bool get visible;

  /// 鏄惁閿佸畾
  @override
  bool get locked;

  /// 鑷畾涔夋牱寮忓睘鎬?  @override
  Map<String, dynamic> get properties;

  /// Create a copy of ElementStyle
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ElementStyleImplCopyWith<_$ElementStyleImpl> get copyWith =>
      throw _privateConstructorUsedError;
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\domain\models\practice\element_style.g.dart
-----------------------------------
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'element_style.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_$ElementStyleImpl _$$ElementStyleImplFromJson(Map<String, dynamic> json) =>
    _$ElementStyleImpl(
      opacity: (json['opacity'] as num?)?.toDouble() ?? 1.0,
      visible: json['visible'] as bool? ?? true,
      locked: json['locked'] as bool? ?? false,
      properties: json['properties'] as Map<String, dynamic>? ?? const {},
    );

Map<String, dynamic> _$$ElementStyleImplToJson(_$ElementStyleImpl instance) =>
    <String, dynamic>{
      'opacity': instance.opacity,
      'visible': instance.visible,
      'locked': instance.locked,
      'properties': instance.properties,
    };



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\domain\models\practice\image_element.dart
-----------------------------------
import 'package:freezed_annotation/freezed_annotation.dart';

part 'image_element.freezed.dart';
part 'image_element.g.dart';

/// 鍥剧墖鍏冪礌
@freezed
class ImageElement with _$ImageElement {
  const factory ImageElement({
    /// 鍥剧墖ID
    required String imageId,

    /// 鍥剧墖URL
    required String url,

    /// 鍥剧墖鍘熷瀹藉害
    required int width,

    /// 鍥剧墖鍘熷楂樺害
    required int height,

    /// 鍥剧墖MIME绫诲瀷
    @Default('image/jpeg') String mimeType,

    /// 涓嶉€忔槑搴?
    @Default(1.0) double opacity,

    /// 鑷畾涔夊睘鎬?
    @Default({}) Map<String, dynamic> customProps,
  }) = _ImageElement;

  /// 浠嶫SON鍒涘缓瀹炰緥
  factory ImageElement.fromJson(Map<String, dynamic> json) =>
      _$ImageElementFromJson(json);

  const ImageElement._();

  /// 鑾峰彇瀹介珮姣?
  double get aspectRatio => width / height;

  /// 鑾峰彇鑷畾涔夊睘鎬?
  T? getCustomProp<T>(String key) => customProps[key] as T?;

  /// 绉婚櫎鑷畾涔夊睘鎬?
  ImageElement removeCustomProp(String key) {
    final newProps = Map<String, dynamic>.from(customProps);
    newProps.remove(key);
    return copyWith(customProps: newProps);
  }

  /// 璁剧疆鑷畾涔夊睘鎬?
  ImageElement setCustomProp(String key, dynamic value) {
    final newProps = Map<String, dynamic>.from(customProps);
    newProps[key] = value;
    return copyWith(customProps: newProps);
  }

  /// 璁剧疆涓嶉€忔槑搴?
  ImageElement withOpacity(double value) =>
      copyWith(opacity: value.clamp(0.0, 1.0));
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\domain\models\practice\image_element.freezed.dart
-----------------------------------
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'image_element.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

ImageElement _$ImageElementFromJson(Map<String, dynamic> json) {
  return _ImageElement.fromJson(json);
}

/// @nodoc
mixin _$ImageElement {
  /// 鍥剧墖ID
  String get imageId => throw _privateConstructorUsedError;

  /// 鍥剧墖URL
  String get url => throw _privateConstructorUsedError;

  /// 鍥剧墖鍘熷瀹藉害
  int get width => throw _privateConstructorUsedError;

  /// 鍥剧墖鍘熷楂樺害
  int get height => throw _privateConstructorUsedError;

  /// 鍥剧墖MIME绫诲瀷
  String get mimeType => throw _privateConstructorUsedError;

  /// 涓嶉€忔槑搴?  double get opacity => throw _privateConstructorUsedError;

  /// 鑷畾涔夊睘鎬?  Map<String, dynamic> get customProps => throw _privateConstructorUsedError;

  /// Serializes this ImageElement to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of ImageElement
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $ImageElementCopyWith<ImageElement> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ImageElementCopyWith<$Res> {
  factory $ImageElementCopyWith(
          ImageElement value, $Res Function(ImageElement) then) =
      _$ImageElementCopyWithImpl<$Res, ImageElement>;
  @useResult
  $Res call(
      {String imageId,
      String url,
      int width,
      int height,
      String mimeType,
      double opacity,
      Map<String, dynamic> customProps});
}

/// @nodoc
class _$ImageElementCopyWithImpl<$Res, $Val extends ImageElement>
    implements $ImageElementCopyWith<$Res> {
  _$ImageElementCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of ImageElement
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? imageId = null,
    Object? url = null,
    Object? width = null,
    Object? height = null,
    Object? mimeType = null,
    Object? opacity = null,
    Object? customProps = null,
  }) {
    return _then(_value.copyWith(
      imageId: null == imageId
          ? _value.imageId
          : imageId // ignore: cast_nullable_to_non_nullable
              as String,
      url: null == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as String,
      width: null == width
          ? _value.width
          : width // ignore: cast_nullable_to_non_nullable
              as int,
      height: null == height
          ? _value.height
          : height // ignore: cast_nullable_to_non_nullable
              as int,
      mimeType: null == mimeType
          ? _value.mimeType
          : mimeType // ignore: cast_nullable_to_non_nullable
              as String,
      opacity: null == opacity
          ? _value.opacity
          : opacity // ignore: cast_nullable_to_non_nullable
              as double,
      customProps: null == customProps
          ? _value.customProps
          : customProps // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ImageElementImplCopyWith<$Res>
    implements $ImageElementCopyWith<$Res> {
  factory _$$ImageElementImplCopyWith(
          _$ImageElementImpl value, $Res Function(_$ImageElementImpl) then) =
      __$$ImageElementImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String imageId,
      String url,
      int width,
      int height,
      String mimeType,
      double opacity,
      Map<String, dynamic> customProps});
}

/// @nodoc
class __$$ImageElementImplCopyWithImpl<$Res>
    extends _$ImageElementCopyWithImpl<$Res, _$ImageElementImpl>
    implements _$$ImageElementImplCopyWith<$Res> {
  __$$ImageElementImplCopyWithImpl(
      _$ImageElementImpl _value, $Res Function(_$ImageElementImpl) _then)
      : super(_value, _then);

  /// Create a copy of ImageElement
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? imageId = null,
    Object? url = null,
    Object? width = null,
    Object? height = null,
    Object? mimeType = null,
    Object? opacity = null,
    Object? customProps = null,
  }) {
    return _then(_$ImageElementImpl(
      imageId: null == imageId
          ? _value.imageId
          : imageId // ignore: cast_nullable_to_non_nullable
              as String,
      url: null == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as String,
      width: null == width
          ? _value.width
          : width // ignore: cast_nullable_to_non_nullable
              as int,
      height: null == height
          ? _value.height
          : height // ignore: cast_nullable_to_non_nullable
              as int,
      mimeType: null == mimeType
          ? _value.mimeType
          : mimeType // ignore: cast_nullable_to_non_nullable
              as String,
      opacity: null == opacity
          ? _value.opacity
          : opacity // ignore: cast_nullable_to_non_nullable
              as double,
      customProps: null == customProps
          ? _value._customProps
          : customProps // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ImageElementImpl extends _ImageElement {
  const _$ImageElementImpl(
      {required this.imageId,
      required this.url,
      required this.width,
      required this.height,
      this.mimeType = 'image/jpeg',
      this.opacity = 1.0,
      final Map<String, dynamic> customProps = const {}})
      : _customProps = customProps,
        super._();

  factory _$ImageElementImpl.fromJson(Map<String, dynamic> json) =>
      _$$ImageElementImplFromJson(json);

  /// 鍥剧墖ID
  @override
  final String imageId;

  /// 鍥剧墖URL
  @override
  final String url;

  /// 鍥剧墖鍘熷瀹藉害
  @override
  final int width;

  /// 鍥剧墖鍘熷楂樺害
  @override
  final int height;

  /// 鍥剧墖MIME绫诲瀷
  @override
  @JsonKey()
  final String mimeType;

  /// 涓嶉€忔槑搴?  @override
  @JsonKey()
  final double opacity;

  /// 鑷畾涔夊睘鎬?  final Map<String, dynamic> _customProps;

  /// 鑷畾涔夊睘鎬?  @override
  @JsonKey()
  Map<String, dynamic> get customProps {
    if (_customProps is EqualUnmodifiableMapView) return _customProps;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_customProps);
  }

  @override
  String toString() {
    return 'ImageElement(imageId: $imageId, url: $url, width: $width, height: $height, mimeType: $mimeType, opacity: $opacity, customProps: $customProps)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ImageElementImpl &&
            (identical(other.imageId, imageId) || other.imageId == imageId) &&
            (identical(other.url, url) || other.url == url) &&
            (identical(other.width, width) || other.width == width) &&
            (identical(other.height, height) || other.height == height) &&
            (identical(other.mimeType, mimeType) ||
                other.mimeType == mimeType) &&
            (identical(other.opacity, opacity) || other.opacity == opacity) &&
            const DeepCollectionEquality()
                .equals(other._customProps, _customProps));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, imageId, url, width, height,
      mimeType, opacity, const DeepCollectionEquality().hash(_customProps));

  /// Create a copy of ImageElement
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ImageElementImplCopyWith<_$ImageElementImpl> get copyWith =>
      __$$ImageElementImplCopyWithImpl<_$ImageElementImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ImageElementImplToJson(
      this,
    );
  }
}

abstract class _ImageElement extends ImageElement {
  const factory _ImageElement(
      {required final String imageId,
      required final String url,
      required final int width,
      required final int height,
      final String mimeType,
      final double opacity,
      final Map<String, dynamic> customProps}) = _$ImageElementImpl;
  const _ImageElement._() : super._();

  factory _ImageElement.fromJson(Map<String, dynamic> json) =
      _$ImageElementImpl.fromJson;

  /// 鍥剧墖ID
  @override
  String get imageId;

  /// 鍥剧墖URL
  @override
  String get url;

  /// 鍥剧墖鍘熷瀹藉害
  @override
  int get width;

  /// 鍥剧墖鍘熷楂樺害
  @override
  int get height;

  /// 鍥剧墖MIME绫诲瀷
  @override
  String get mimeType;

  /// 涓嶉€忔槑搴?  @override
  double get opacity;

  /// 鑷畾涔夊睘鎬?  @override
  Map<String, dynamic> get customProps;

  /// Create a copy of ImageElement
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ImageElementImplCopyWith<_$ImageElementImpl> get copyWith =>
      throw _privateConstructorUsedError;
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\domain\models\practice\image_element.g.dart
-----------------------------------
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'image_element.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_$ImageElementImpl _$$ImageElementImplFromJson(Map<String, dynamic> json) =>
    _$ImageElementImpl(
      imageId: json['imageId'] as String,
      url: json['url'] as String,
      width: (json['width'] as num).toInt(),
      height: (json['height'] as num).toInt(),
      mimeType: json['mimeType'] as String? ?? 'image/jpeg',
      opacity: (json['opacity'] as num?)?.toDouble() ?? 1.0,
      customProps: json['customProps'] as Map<String, dynamic>? ?? const {},
    );

Map<String, dynamic> _$$ImageElementImplToJson(_$ImageElementImpl instance) =>
    <String, dynamic>{
      'imageId': instance.imageId,
      'url': instance.url,
      'width': instance.width,
      'height': instance.height,
      'mimeType': instance.mimeType,
      'opacity': instance.opacity,
      'customProps': instance.customProps,
    };



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\domain\models\practice\practice_element.dart
-----------------------------------
import 'package:freezed_annotation/freezed_annotation.dart';

import 'element_content.dart';
import 'element_geometry.dart';
import 'element_style.dart';

part 'practice_element.freezed.dart';
part 'practice_element.g.dart';

/// 缁冧範鍏冪礌
@freezed
class PracticeElement with _$PracticeElement {
  const factory PracticeElement({
    /// 鍏冪礌ID
    required String id,

    /// 鍏冪礌绫诲瀷
    @JsonKey(name: 'type') required String elementType,

    /// 鍏冪礌鍑犱綍灞炴€?
    required ElementGeometry geometry,

    /// 鍏冪礌鏍峰紡
    required ElementStyle style,

    /// 鍏冪礌鍐呭
    required ElementContent content,

    /// 鍒涘缓鏃堕棿
    @Default(0) int createTime,

    /// 鏇存柊鏃堕棿
    @Default(0) int updateTime,
  }) = _PracticeElement;

  /// 鍒涘缓瀛楃鍏冪礌
  factory PracticeElement.chars({
    required String id,
    required ElementContent content,
    ElementGeometry? geometry,
    ElementStyle? style,
  }) {
    return PracticeElement(
      id: id,
      elementType: 'chars',
      geometry: geometry ?? const ElementGeometry(),
      style: style ?? const ElementStyle(),
      content: content,
      createTime: DateTime.now().millisecondsSinceEpoch,
      updateTime: DateTime.now().millisecondsSinceEpoch,
    );
  }

  /// 浠嶫SON鍒涘缓瀹炰緥
  factory PracticeElement.fromJson(Map<String, dynamic> json) =>
      _$PracticeElementFromJson(json);

  /// 鍒涘缓鍥剧墖鍏冪礌
  factory PracticeElement.image({
    required String id,
    required ElementContent content,
    ElementGeometry? geometry,
    ElementStyle? style,
  }) {
    return PracticeElement(
      id: id,
      elementType: 'image',
      geometry: geometry ?? const ElementGeometry(),
      style: style ?? const ElementStyle(),
      content: content,
      createTime: DateTime.now().millisecondsSinceEpoch,
      updateTime: DateTime.now().millisecondsSinceEpoch,
    );
  }

  /// 鍒涘缓鏂囨湰鍏冪礌
  factory PracticeElement.text({
    required String id,
    required ElementContent content,
    ElementGeometry? geometry,
    ElementStyle? style,
  }) {
    return PracticeElement(
      id: id,
      elementType: 'text',
      geometry: geometry ?? const ElementGeometry(),
      style: style ?? const ElementStyle(),
      content: content,
      createTime: DateTime.now().millisecondsSinceEpoch,
      updateTime: DateTime.now().millisecondsSinceEpoch,
    );
  }

  const PracticeElement._();

  /// 绉诲姩鍏冪礌
  PracticeElement move(double dx, double dy) {
    return copyWith(
      geometry: geometry.move(dx, dy),
      updateTime: DateTime.now().millisecondsSinceEpoch,
    );
  }

  /// 璋冩暣澶у皬
  PracticeElement resize(double width, double height) {
    return copyWith(
      geometry: geometry.resize(width, height),
      updateTime: DateTime.now().millisecondsSinceEpoch,
    );
  }

  /// 鏃嬭浆
  PracticeElement rotate(double angle) {
    return copyWith(
      geometry: geometry.rotate(angle),
      updateTime: DateTime.now().millisecondsSinceEpoch,
    );
  }

  /// 鏇存柊鏃堕棿鎴?
  PracticeElement touch() {
    return copyWith(
      updateTime: DateTime.now().millisecondsSinceEpoch,
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\domain\models\practice\practice_element.freezed.dart
-----------------------------------
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'practice_element.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

PracticeElement _$PracticeElementFromJson(Map<String, dynamic> json) {
  return _PracticeElement.fromJson(json);
}

/// @nodoc
mixin _$PracticeElement {
  /// 鍏冪礌ID
  String get id => throw _privateConstructorUsedError;

  /// 鍏冪礌绫诲瀷
  @JsonKey(name: 'type')
  String get elementType => throw _privateConstructorUsedError;

  /// 鍏冪礌鍑犱綍灞炴€?  ElementGeometry get geometry => throw _privateConstructorUsedError;

  /// 鍏冪礌鏍峰紡
  ElementStyle get style => throw _privateConstructorUsedError;

  /// 鍏冪礌鍐呭
  ElementContent get content => throw _privateConstructorUsedError;

  /// 鍒涘缓鏃堕棿
  int get createTime => throw _privateConstructorUsedError;

  /// 鏇存柊鏃堕棿
  int get updateTime => throw _privateConstructorUsedError;

  /// Serializes this PracticeElement to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of PracticeElement
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $PracticeElementCopyWith<PracticeElement> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PracticeElementCopyWith<$Res> {
  factory $PracticeElementCopyWith(
          PracticeElement value, $Res Function(PracticeElement) then) =
      _$PracticeElementCopyWithImpl<$Res, PracticeElement>;
  @useResult
  $Res call(
      {String id,
      @JsonKey(name: 'type') String elementType,
      ElementGeometry geometry,
      ElementStyle style,
      ElementContent content,
      int createTime,
      int updateTime});

  $ElementGeometryCopyWith<$Res> get geometry;
  $ElementStyleCopyWith<$Res> get style;
  $ElementContentCopyWith<$Res> get content;
}

/// @nodoc
class _$PracticeElementCopyWithImpl<$Res, $Val extends PracticeElement>
    implements $PracticeElementCopyWith<$Res> {
  _$PracticeElementCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of PracticeElement
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? elementType = null,
    Object? geometry = null,
    Object? style = null,
    Object? content = null,
    Object? createTime = null,
    Object? updateTime = null,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      elementType: null == elementType
          ? _value.elementType
          : elementType // ignore: cast_nullable_to_non_nullable
              as String,
      geometry: null == geometry
          ? _value.geometry
          : geometry // ignore: cast_nullable_to_non_nullable
              as ElementGeometry,
      style: null == style
          ? _value.style
          : style // ignore: cast_nullable_to_non_nullable
              as ElementStyle,
      content: null == content
          ? _value.content
          : content // ignore: cast_nullable_to_non_nullable
              as ElementContent,
      createTime: null == createTime
          ? _value.createTime
          : createTime // ignore: cast_nullable_to_non_nullable
              as int,
      updateTime: null == updateTime
          ? _value.updateTime
          : updateTime // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }

  /// Create a copy of PracticeElement
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ElementGeometryCopyWith<$Res> get geometry {
    return $ElementGeometryCopyWith<$Res>(_value.geometry, (value) {
      return _then(_value.copyWith(geometry: value) as $Val);
    });
  }

  /// Create a copy of PracticeElement
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ElementStyleCopyWith<$Res> get style {
    return $ElementStyleCopyWith<$Res>(_value.style, (value) {
      return _then(_value.copyWith(style: value) as $Val);
    });
  }

  /// Create a copy of PracticeElement
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ElementContentCopyWith<$Res> get content {
    return $ElementContentCopyWith<$Res>(_value.content, (value) {
      return _then(_value.copyWith(content: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$PracticeElementImplCopyWith<$Res>
    implements $PracticeElementCopyWith<$Res> {
  factory _$$PracticeElementImplCopyWith(_$PracticeElementImpl value,
          $Res Function(_$PracticeElementImpl) then) =
      __$$PracticeElementImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      @JsonKey(name: 'type') String elementType,
      ElementGeometry geometry,
      ElementStyle style,
      ElementContent content,
      int createTime,
      int updateTime});

  @override
  $ElementGeometryCopyWith<$Res> get geometry;
  @override
  $ElementStyleCopyWith<$Res> get style;
  @override
  $ElementContentCopyWith<$Res> get content;
}

/// @nodoc
class __$$PracticeElementImplCopyWithImpl<$Res>
    extends _$PracticeElementCopyWithImpl<$Res, _$PracticeElementImpl>
    implements _$$PracticeElementImplCopyWith<$Res> {
  __$$PracticeElementImplCopyWithImpl(
      _$PracticeElementImpl _value, $Res Function(_$PracticeElementImpl) _then)
      : super(_value, _then);

  /// Create a copy of PracticeElement
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? elementType = null,
    Object? geometry = null,
    Object? style = null,
    Object? content = null,
    Object? createTime = null,
    Object? updateTime = null,
  }) {
    return _then(_$PracticeElementImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      elementType: null == elementType
          ? _value.elementType
          : elementType // ignore: cast_nullable_to_non_nullable
              as String,
      geometry: null == geometry
          ? _value.geometry
          : geometry // ignore: cast_nullable_to_non_nullable
              as ElementGeometry,
      style: null == style
          ? _value.style
          : style // ignore: cast_nullable_to_non_nullable
              as ElementStyle,
      content: null == content
          ? _value.content
          : content // ignore: cast_nullable_to_non_nullable
              as ElementContent,
      createTime: null == createTime
          ? _value.createTime
          : createTime // ignore: cast_nullable_to_non_nullable
              as int,
      updateTime: null == updateTime
          ? _value.updateTime
          : updateTime // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$PracticeElementImpl extends _PracticeElement {
  const _$PracticeElementImpl(
      {required this.id,
      @JsonKey(name: 'type') required this.elementType,
      required this.geometry,
      required this.style,
      required this.content,
      this.createTime = 0,
      this.updateTime = 0})
      : super._();

  factory _$PracticeElementImpl.fromJson(Map<String, dynamic> json) =>
      _$$PracticeElementImplFromJson(json);

  /// 鍏冪礌ID
  @override
  final String id;

  /// 鍏冪礌绫诲瀷
  @override
  @JsonKey(name: 'type')
  final String elementType;

  /// 鍏冪礌鍑犱綍灞炴€?  @override
  final ElementGeometry geometry;

  /// 鍏冪礌鏍峰紡
  @override
  final ElementStyle style;

  /// 鍏冪礌鍐呭
  @override
  final ElementContent content;

  /// 鍒涘缓鏃堕棿
  @override
  @JsonKey()
  final int createTime;

  /// 鏇存柊鏃堕棿
  @override
  @JsonKey()
  final int updateTime;

  @override
  String toString() {
    return 'PracticeElement(id: $id, elementType: $elementType, geometry: $geometry, style: $style, content: $content, createTime: $createTime, updateTime: $updateTime)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PracticeElementImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.elementType, elementType) ||
                other.elementType == elementType) &&
            (identical(other.geometry, geometry) ||
                other.geometry == geometry) &&
            (identical(other.style, style) || other.style == style) &&
            (identical(other.content, content) || other.content == content) &&
            (identical(other.createTime, createTime) ||
                other.createTime == createTime) &&
            (identical(other.updateTime, updateTime) ||
                other.updateTime == updateTime));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, id, elementType, geometry, style,
      content, createTime, updateTime);

  /// Create a copy of PracticeElement
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$PracticeElementImplCopyWith<_$PracticeElementImpl> get copyWith =>
      __$$PracticeElementImplCopyWithImpl<_$PracticeElementImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$PracticeElementImplToJson(
      this,
    );
  }
}

abstract class _PracticeElement extends PracticeElement {
  const factory _PracticeElement(
      {required final String id,
      @JsonKey(name: 'type') required final String elementType,
      required final ElementGeometry geometry,
      required final ElementStyle style,
      required final ElementContent content,
      final int createTime,
      final int updateTime}) = _$PracticeElementImpl;
  const _PracticeElement._() : super._();

  factory _PracticeElement.fromJson(Map<String, dynamic> json) =
      _$PracticeElementImpl.fromJson;

  /// 鍏冪礌ID
  @override
  String get id;

  /// 鍏冪礌绫诲瀷
  @override
  @JsonKey(name: 'type')
  String get elementType;

  /// 鍏冪礌鍑犱綍灞炴€?  @override
  ElementGeometry get geometry;

  /// 鍏冪礌鏍峰紡
  @override
  ElementStyle get style;

  /// 鍏冪礌鍐呭
  @override
  ElementContent get content;

  /// 鍒涘缓鏃堕棿
  @override
  int get createTime;

  /// 鏇存柊鏃堕棿
  @override
  int get updateTime;

  /// Create a copy of PracticeElement
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$PracticeElementImplCopyWith<_$PracticeElementImpl> get copyWith =>
      throw _privateConstructorUsedError;
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\domain\models\practice\practice_element.g.dart
-----------------------------------
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'practice_element.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_$PracticeElementImpl _$$PracticeElementImplFromJson(
        Map<String, dynamic> json) =>
    _$PracticeElementImpl(
      id: json['id'] as String,
      elementType: json['type'] as String,
      geometry:
          ElementGeometry.fromJson(json['geometry'] as Map<String, dynamic>),
      style: ElementStyle.fromJson(json['style'] as Map<String, dynamic>),
      content: ElementContent.fromJson(json['content'] as Map<String, dynamic>),
      createTime: (json['createTime'] as num?)?.toInt() ?? 0,
      updateTime: (json['updateTime'] as num?)?.toInt() ?? 0,
    );

Map<String, dynamic> _$$PracticeElementImplToJson(
        _$PracticeElementImpl instance) =>
    <String, dynamic>{
      'id': instance.id,
      'type': instance.elementType,
      'geometry': instance.geometry,
      'style': instance.style,
      'content': instance.content,
      'createTime': instance.createTime,
      'updateTime': instance.updateTime,
    };



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\domain\models\practice\practice_entity.dart
-----------------------------------
import 'package:freezed_annotation/freezed_annotation.dart';

import 'practice_page.dart';

part 'practice_entity.freezed.dart';
part 'practice_entity.g.dart';

/// 瀛楀笘缁冧範瀹炰綋
@freezed
class PracticeEntity with _$PracticeEntity {
  /// 鍒涘缓瀹炰緥
  const factory PracticeEntity({
    /// ID
    required String id,

    /// 鏍囬
    required String title,

    /// 椤甸潰鍒楄〃
    @Default([]) List<PracticePage> pages,

    /// 鏍囩鍒楄〃
    @Default([]) List<String> tags,

    /// 鐘舵€?
    @Default('active') String status,

    /// 鍒涘缓鏃堕棿
    required DateTime createTime,

    /// 鏇存柊鏃堕棿
    required DateTime updateTime,
  }) = _PracticeEntity;

  /// 鏂板缓缁冧範锛岃嚜鍔ㄧ敓鎴怚D鍜屾椂闂存埑
  factory PracticeEntity.create({
    required String title,
    List<String> tags = const [],
    String status = 'active',
  }) {
    final now = DateTime.now();
    return PracticeEntity(
      id: DateTime.now().millisecondsSinceEpoch.toString(),
      title: title,
      tags: tags,
      status: status,
      createTime: now,
      updateTime: now,
    );
  }

  /// 浠嶫SON鍒涘缓瀹炰緥
  factory PracticeEntity.fromJson(Map<String, dynamic> json) =>
      _$PracticeEntityFromJson(json);

  /// 绉佹湁鏋勯€犲嚱鏁?
  const PracticeEntity._();

  /// 鑾峰彇涓嬩竴涓彲鐢ㄧ殑椤甸潰绱㈠紩
  int get nextPageIndex => pages.isEmpty ? 0 : pages.last.index + 1;

  /// 鑾峰彇椤甸潰鏁伴噺
  int get pageCount => pages.length;

  /// 娣诲姞椤甸潰
  PracticeEntity addPage(PracticePage page) {
    return copyWith(
      pages: [...pages, page],
      updateTime: DateTime.now(),
    );
  }

  /// 鍒犻櫎椤甸潰
  PracticeEntity removePage(int index) {
    return copyWith(
      pages: pages.where((p) => p.index != index).toList(),
      updateTime: DateTime.now(),
    );
  }

  /// 鐢ㄤ簬鏄剧ず鐨勬枃鏈弿杩?
  @override
  String toString() => 'PracticeEntity(id: $id, title: $title)';

  /// 鏇存柊椤甸潰
  PracticeEntity updatePage(PracticePage page) {
    return copyWith(
      pages: pages.map((p) => p.index == page.index ? page : p).toList(),
      updateTime: DateTime.now(),
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\domain\models\practice\practice_entity.freezed.dart
-----------------------------------
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'practice_entity.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

PracticeEntity _$PracticeEntityFromJson(Map<String, dynamic> json) {
  return _PracticeEntity.fromJson(json);
}

/// @nodoc
mixin _$PracticeEntity {
  /// ID
  String get id => throw _privateConstructorUsedError;

  /// 鏍囬
  String get title => throw _privateConstructorUsedError;

  /// 椤甸潰鍒楄〃
  List<PracticePage> get pages => throw _privateConstructorUsedError;

  /// 鏍囩鍒楄〃
  List<String> get tags => throw _privateConstructorUsedError;

  /// 鐘舵€?  String get status => throw _privateConstructorUsedError;

  /// 鍒涘缓鏃堕棿
  DateTime get createTime => throw _privateConstructorUsedError;

  /// 鏇存柊鏃堕棿
  DateTime get updateTime => throw _privateConstructorUsedError;

  /// Serializes this PracticeEntity to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of PracticeEntity
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $PracticeEntityCopyWith<PracticeEntity> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PracticeEntityCopyWith<$Res> {
  factory $PracticeEntityCopyWith(
          PracticeEntity value, $Res Function(PracticeEntity) then) =
      _$PracticeEntityCopyWithImpl<$Res, PracticeEntity>;
  @useResult
  $Res call(
      {String id,
      String title,
      List<PracticePage> pages,
      List<String> tags,
      String status,
      DateTime createTime,
      DateTime updateTime});
}

/// @nodoc
class _$PracticeEntityCopyWithImpl<$Res, $Val extends PracticeEntity>
    implements $PracticeEntityCopyWith<$Res> {
  _$PracticeEntityCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of PracticeEntity
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? title = null,
    Object? pages = null,
    Object? tags = null,
    Object? status = null,
    Object? createTime = null,
    Object? updateTime = null,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      title: null == title
          ? _value.title
          : title // ignore: cast_nullable_to_non_nullable
              as String,
      pages: null == pages
          ? _value.pages
          : pages // ignore: cast_nullable_to_non_nullable
              as List<PracticePage>,
      tags: null == tags
          ? _value.tags
          : tags // ignore: cast_nullable_to_non_nullable
              as List<String>,
      status: null == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as String,
      createTime: null == createTime
          ? _value.createTime
          : createTime // ignore: cast_nullable_to_non_nullable
              as DateTime,
      updateTime: null == updateTime
          ? _value.updateTime
          : updateTime // ignore: cast_nullable_to_non_nullable
              as DateTime,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$PracticeEntityImplCopyWith<$Res>
    implements $PracticeEntityCopyWith<$Res> {
  factory _$$PracticeEntityImplCopyWith(_$PracticeEntityImpl value,
          $Res Function(_$PracticeEntityImpl) then) =
      __$$PracticeEntityImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      String title,
      List<PracticePage> pages,
      List<String> tags,
      String status,
      DateTime createTime,
      DateTime updateTime});
}

/// @nodoc
class __$$PracticeEntityImplCopyWithImpl<$Res>
    extends _$PracticeEntityCopyWithImpl<$Res, _$PracticeEntityImpl>
    implements _$$PracticeEntityImplCopyWith<$Res> {
  __$$PracticeEntityImplCopyWithImpl(
      _$PracticeEntityImpl _value, $Res Function(_$PracticeEntityImpl) _then)
      : super(_value, _then);

  /// Create a copy of PracticeEntity
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? title = null,
    Object? pages = null,
    Object? tags = null,
    Object? status = null,
    Object? createTime = null,
    Object? updateTime = null,
  }) {
    return _then(_$PracticeEntityImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      title: null == title
          ? _value.title
          : title // ignore: cast_nullable_to_non_nullable
              as String,
      pages: null == pages
          ? _value._pages
          : pages // ignore: cast_nullable_to_non_nullable
              as List<PracticePage>,
      tags: null == tags
          ? _value._tags
          : tags // ignore: cast_nullable_to_non_nullable
              as List<String>,
      status: null == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as String,
      createTime: null == createTime
          ? _value.createTime
          : createTime // ignore: cast_nullable_to_non_nullable
              as DateTime,
      updateTime: null == updateTime
          ? _value.updateTime
          : updateTime // ignore: cast_nullable_to_non_nullable
              as DateTime,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$PracticeEntityImpl extends _PracticeEntity {
  const _$PracticeEntityImpl(
      {required this.id,
      required this.title,
      final List<PracticePage> pages = const [],
      final List<String> tags = const [],
      this.status = 'active',
      required this.createTime,
      required this.updateTime})
      : _pages = pages,
        _tags = tags,
        super._();

  factory _$PracticeEntityImpl.fromJson(Map<String, dynamic> json) =>
      _$$PracticeEntityImplFromJson(json);

  /// ID
  @override
  final String id;

  /// 鏍囬
  @override
  final String title;

  /// 椤甸潰鍒楄〃
  final List<PracticePage> _pages;

  /// 椤甸潰鍒楄〃
  @override
  @JsonKey()
  List<PracticePage> get pages {
    if (_pages is EqualUnmodifiableListView) return _pages;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_pages);
  }

  /// 鏍囩鍒楄〃
  final List<String> _tags;

  /// 鏍囩鍒楄〃
  @override
  @JsonKey()
  List<String> get tags {
    if (_tags is EqualUnmodifiableListView) return _tags;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_tags);
  }

  /// 鐘舵€?  @override
  @JsonKey()
  final String status;

  /// 鍒涘缓鏃堕棿
  @override
  final DateTime createTime;

  /// 鏇存柊鏃堕棿
  @override
  final DateTime updateTime;

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PracticeEntityImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.title, title) || other.title == title) &&
            const DeepCollectionEquality().equals(other._pages, _pages) &&
            const DeepCollectionEquality().equals(other._tags, _tags) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.createTime, createTime) ||
                other.createTime == createTime) &&
            (identical(other.updateTime, updateTime) ||
                other.updateTime == updateTime));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      title,
      const DeepCollectionEquality().hash(_pages),
      const DeepCollectionEquality().hash(_tags),
      status,
      createTime,
      updateTime);

  /// Create a copy of PracticeEntity
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$PracticeEntityImplCopyWith<_$PracticeEntityImpl> get copyWith =>
      __$$PracticeEntityImplCopyWithImpl<_$PracticeEntityImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$PracticeEntityImplToJson(
      this,
    );
  }
}

abstract class _PracticeEntity extends PracticeEntity {
  const factory _PracticeEntity(
      {required final String id,
      required final String title,
      final List<PracticePage> pages,
      final List<String> tags,
      final String status,
      required final DateTime createTime,
      required final DateTime updateTime}) = _$PracticeEntityImpl;
  const _PracticeEntity._() : super._();

  factory _PracticeEntity.fromJson(Map<String, dynamic> json) =
      _$PracticeEntityImpl.fromJson;

  /// ID
  @override
  String get id;

  /// 鏍囬
  @override
  String get title;

  /// 椤甸潰鍒楄〃
  @override
  List<PracticePage> get pages;

  /// 鏍囩鍒楄〃
  @override
  List<String> get tags;

  /// 鐘舵€?  @override
  String get status;

  /// 鍒涘缓鏃堕棿
  @override
  DateTime get createTime;

  /// 鏇存柊鏃堕棿
  @override
  DateTime get updateTime;

  /// Create a copy of PracticeEntity
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$PracticeEntityImplCopyWith<_$PracticeEntityImpl> get copyWith =>
      throw _privateConstructorUsedError;
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\domain\models\practice\practice_entity.g.dart
-----------------------------------
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'practice_entity.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_$PracticeEntityImpl _$$PracticeEntityImplFromJson(Map<String, dynamic> json) =>
    _$PracticeEntityImpl(
      id: json['id'] as String,
      title: json['title'] as String,
      pages: (json['pages'] as List<dynamic>?)
              ?.map((e) => PracticePage.fromJson(e as Map<String, dynamic>))
              .toList() ??
          const [],
      tags:
          (json['tags'] as List<dynamic>?)?.map((e) => e as String).toList() ??
              const [],
      status: json['status'] as String? ?? 'active',
      createTime: DateTime.parse(json['createTime'] as String),
      updateTime: DateTime.parse(json['updateTime'] as String),
    );

Map<String, dynamic> _$$PracticeEntityImplToJson(
        _$PracticeEntityImpl instance) =>
    <String, dynamic>{
      'id': instance.id,
      'title': instance.title,
      'pages': instance.pages,
      'tags': instance.tags,
      'status': instance.status,
      'createTime': instance.createTime.toIso8601String(),
      'updateTime': instance.updateTime.toIso8601String(),
    };



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\domain\models\practice\practice_filter.dart
-----------------------------------
import 'package:freezed_annotation/freezed_annotation.dart';

part 'practice_filter.freezed.dart';
part 'practice_filter.g.dart';

/// 瀛楀笘缁冧範杩囨护鍣?
@freezed
class PracticeFilter with _$PracticeFilter {
  const factory PracticeFilter({
    /// 鏍囬鍏抽敭璇?
    String? keyword,

    /// 鏍囩鍒楄〃
    @Default([]) List<String> tags,

    /// 寮€濮嬫椂闂?
    DateTime? startTime,

    /// 缁撴潫鏃堕棿
    DateTime? endTime,

    /// 鐘舵€?
    String? status,

    /// 鍒嗛〉澶у皬
    @Default(20) int limit,

    /// 鍋忕Щ閲?
    @Default(0) int offset,

    /// 鎺掑簭瀛楁
    @Default('createTime') String sortField,

    /// 鎺掑簭鏂瑰悜(asc/desc)
    @Default('desc') String sortOrder,
  }) = _PracticeFilter;

  /// 浠嶫SON鍒涘缓瀹炰緥
  factory PracticeFilter.fromJson(Map<String, dynamic> json) =>
      _$PracticeFilterFromJson(json);

  const PracticeFilter._();
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\domain\models\practice\practice_filter.freezed.dart
-----------------------------------
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'practice_filter.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

PracticeFilter _$PracticeFilterFromJson(Map<String, dynamic> json) {
  return _PracticeFilter.fromJson(json);
}

/// @nodoc
mixin _$PracticeFilter {
  /// 鏍囬鍏抽敭璇?  String? get keyword => throw _privateConstructorUsedError;

  /// 鏍囩鍒楄〃
  List<String> get tags => throw _privateConstructorUsedError;

  /// 寮€濮嬫椂闂?  DateTime? get startTime => throw _privateConstructorUsedError;

  /// 缁撴潫鏃堕棿
  DateTime? get endTime => throw _privateConstructorUsedError;

  /// 鐘舵€?  String? get status => throw _privateConstructorUsedError;

  /// 鍒嗛〉澶у皬
  int get limit => throw _privateConstructorUsedError;

  /// 鍋忕Щ閲?  int get offset => throw _privateConstructorUsedError;

  /// 鎺掑簭瀛楁
  String get sortField => throw _privateConstructorUsedError;

  /// 鎺掑簭鏂瑰悜(asc/desc)
  String get sortOrder => throw _privateConstructorUsedError;

  /// Serializes this PracticeFilter to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of PracticeFilter
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $PracticeFilterCopyWith<PracticeFilter> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PracticeFilterCopyWith<$Res> {
  factory $PracticeFilterCopyWith(
          PracticeFilter value, $Res Function(PracticeFilter) then) =
      _$PracticeFilterCopyWithImpl<$Res, PracticeFilter>;
  @useResult
  $Res call(
      {String? keyword,
      List<String> tags,
      DateTime? startTime,
      DateTime? endTime,
      String? status,
      int limit,
      int offset,
      String sortField,
      String sortOrder});
}

/// @nodoc
class _$PracticeFilterCopyWithImpl<$Res, $Val extends PracticeFilter>
    implements $PracticeFilterCopyWith<$Res> {
  _$PracticeFilterCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of PracticeFilter
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? keyword = freezed,
    Object? tags = null,
    Object? startTime = freezed,
    Object? endTime = freezed,
    Object? status = freezed,
    Object? limit = null,
    Object? offset = null,
    Object? sortField = null,
    Object? sortOrder = null,
  }) {
    return _then(_value.copyWith(
      keyword: freezed == keyword
          ? _value.keyword
          : keyword // ignore: cast_nullable_to_non_nullable
              as String?,
      tags: null == tags
          ? _value.tags
          : tags // ignore: cast_nullable_to_non_nullable
              as List<String>,
      startTime: freezed == startTime
          ? _value.startTime
          : startTime // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      endTime: freezed == endTime
          ? _value.endTime
          : endTime // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      status: freezed == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as String?,
      limit: null == limit
          ? _value.limit
          : limit // ignore: cast_nullable_to_non_nullable
              as int,
      offset: null == offset
          ? _value.offset
          : offset // ignore: cast_nullable_to_non_nullable
              as int,
      sortField: null == sortField
          ? _value.sortField
          : sortField // ignore: cast_nullable_to_non_nullable
              as String,
      sortOrder: null == sortOrder
          ? _value.sortOrder
          : sortOrder // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$PracticeFilterImplCopyWith<$Res>
    implements $PracticeFilterCopyWith<$Res> {
  factory _$$PracticeFilterImplCopyWith(_$PracticeFilterImpl value,
          $Res Function(_$PracticeFilterImpl) then) =
      __$$PracticeFilterImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? keyword,
      List<String> tags,
      DateTime? startTime,
      DateTime? endTime,
      String? status,
      int limit,
      int offset,
      String sortField,
      String sortOrder});
}

/// @nodoc
class __$$PracticeFilterImplCopyWithImpl<$Res>
    extends _$PracticeFilterCopyWithImpl<$Res, _$PracticeFilterImpl>
    implements _$$PracticeFilterImplCopyWith<$Res> {
  __$$PracticeFilterImplCopyWithImpl(
      _$PracticeFilterImpl _value, $Res Function(_$PracticeFilterImpl) _then)
      : super(_value, _then);

  /// Create a copy of PracticeFilter
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? keyword = freezed,
    Object? tags = null,
    Object? startTime = freezed,
    Object? endTime = freezed,
    Object? status = freezed,
    Object? limit = null,
    Object? offset = null,
    Object? sortField = null,
    Object? sortOrder = null,
  }) {
    return _then(_$PracticeFilterImpl(
      keyword: freezed == keyword
          ? _value.keyword
          : keyword // ignore: cast_nullable_to_non_nullable
              as String?,
      tags: null == tags
          ? _value._tags
          : tags // ignore: cast_nullable_to_non_nullable
              as List<String>,
      startTime: freezed == startTime
          ? _value.startTime
          : startTime // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      endTime: freezed == endTime
          ? _value.endTime
          : endTime // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      status: freezed == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as String?,
      limit: null == limit
          ? _value.limit
          : limit // ignore: cast_nullable_to_non_nullable
              as int,
      offset: null == offset
          ? _value.offset
          : offset // ignore: cast_nullable_to_non_nullable
              as int,
      sortField: null == sortField
          ? _value.sortField
          : sortField // ignore: cast_nullable_to_non_nullable
              as String,
      sortOrder: null == sortOrder
          ? _value.sortOrder
          : sortOrder // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$PracticeFilterImpl extends _PracticeFilter {
  const _$PracticeFilterImpl(
      {this.keyword,
      final List<String> tags = const [],
      this.startTime,
      this.endTime,
      this.status,
      this.limit = 20,
      this.offset = 0,
      this.sortField = 'createTime',
      this.sortOrder = 'desc'})
      : _tags = tags,
        super._();

  factory _$PracticeFilterImpl.fromJson(Map<String, dynamic> json) =>
      _$$PracticeFilterImplFromJson(json);

  /// 鏍囬鍏抽敭璇?  @override
  final String? keyword;

  /// 鏍囩鍒楄〃
  final List<String> _tags;

  /// 鏍囩鍒楄〃
  @override
  @JsonKey()
  List<String> get tags {
    if (_tags is EqualUnmodifiableListView) return _tags;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_tags);
  }

  /// 寮€濮嬫椂闂?  @override
  final DateTime? startTime;

  /// 缁撴潫鏃堕棿
  @override
  final DateTime? endTime;

  /// 鐘舵€?  @override
  final String? status;

  /// 鍒嗛〉澶у皬
  @override
  @JsonKey()
  final int limit;

  /// 鍋忕Щ閲?  @override
  @JsonKey()
  final int offset;

  /// 鎺掑簭瀛楁
  @override
  @JsonKey()
  final String sortField;

  /// 鎺掑簭鏂瑰悜(asc/desc)
  @override
  @JsonKey()
  final String sortOrder;

  @override
  String toString() {
    return 'PracticeFilter(keyword: $keyword, tags: $tags, startTime: $startTime, endTime: $endTime, status: $status, limit: $limit, offset: $offset, sortField: $sortField, sortOrder: $sortOrder)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PracticeFilterImpl &&
            (identical(other.keyword, keyword) || other.keyword == keyword) &&
            const DeepCollectionEquality().equals(other._tags, _tags) &&
            (identical(other.startTime, startTime) ||
                other.startTime == startTime) &&
            (identical(other.endTime, endTime) || other.endTime == endTime) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.limit, limit) || other.limit == limit) &&
            (identical(other.offset, offset) || other.offset == offset) &&
            (identical(other.sortField, sortField) ||
                other.sortField == sortField) &&
            (identical(other.sortOrder, sortOrder) ||
                other.sortOrder == sortOrder));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      keyword,
      const DeepCollectionEquality().hash(_tags),
      startTime,
      endTime,
      status,
      limit,
      offset,
      sortField,
      sortOrder);

  /// Create a copy of PracticeFilter
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$PracticeFilterImplCopyWith<_$PracticeFilterImpl> get copyWith =>
      __$$PracticeFilterImplCopyWithImpl<_$PracticeFilterImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$PracticeFilterImplToJson(
      this,
    );
  }
}

abstract class _PracticeFilter extends PracticeFilter {
  const factory _PracticeFilter(
      {final String? keyword,
      final List<String> tags,
      final DateTime? startTime,
      final DateTime? endTime,
      final String? status,
      final int limit,
      final int offset,
      final String sortField,
      final String sortOrder}) = _$PracticeFilterImpl;
  const _PracticeFilter._() : super._();

  factory _PracticeFilter.fromJson(Map<String, dynamic> json) =
      _$PracticeFilterImpl.fromJson;

  /// 鏍囬鍏抽敭璇?  @override
  String? get keyword;

  /// 鏍囩鍒楄〃
  @override
  List<String> get tags;

  /// 寮€濮嬫椂闂?  @override
  DateTime? get startTime;

  /// 缁撴潫鏃堕棿
  @override
  DateTime? get endTime;

  /// 鐘舵€?  @override
  String? get status;

  /// 鍒嗛〉澶у皬
  @override
  int get limit;

  /// 鍋忕Щ閲?  @override
  int get offset;

  /// 鎺掑簭瀛楁
  @override
  String get sortField;

  /// 鎺掑簭鏂瑰悜(asc/desc)
  @override
  String get sortOrder;

  /// Create a copy of PracticeFilter
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$PracticeFilterImplCopyWith<_$PracticeFilterImpl> get copyWith =>
      throw _privateConstructorUsedError;
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\domain\models\practice\practice_filter.g.dart
-----------------------------------
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'practice_filter.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_$PracticeFilterImpl _$$PracticeFilterImplFromJson(Map<String, dynamic> json) =>
    _$PracticeFilterImpl(
      keyword: json['keyword'] as String?,
      tags:
          (json['tags'] as List<dynamic>?)?.map((e) => e as String).toList() ??
              const [],
      startTime: json['startTime'] == null
          ? null
          : DateTime.parse(json['startTime'] as String),
      endTime: json['endTime'] == null
          ? null
          : DateTime.parse(json['endTime'] as String),
      status: json['status'] as String?,
      limit: (json['limit'] as num?)?.toInt() ?? 20,
      offset: (json['offset'] as num?)?.toInt() ?? 0,
      sortField: json['sortField'] as String? ?? 'createTime',
      sortOrder: json['sortOrder'] as String? ?? 'desc',
    );

Map<String, dynamic> _$$PracticeFilterImplToJson(
        _$PracticeFilterImpl instance) =>
    <String, dynamic>{
      'keyword': instance.keyword,
      'tags': instance.tags,
      'startTime': instance.startTime?.toIso8601String(),
      'endTime': instance.endTime?.toIso8601String(),
      'status': instance.status,
      'limit': instance.limit,
      'offset': instance.offset,
      'sortField': instance.sortField,
      'sortOrder': instance.sortOrder,
    };



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\domain\models\practice\practice_layer.dart
-----------------------------------
import 'package:demo/domain/models/practice/practice_element.dart';
import 'package:freezed_annotation/freezed_annotation.dart';

part 'practice_layer.freezed.dart';
part 'practice_layer.g.dart';

/// 瀛楀笘缁冧範鍥惧眰
@freezed
class PracticeLayer with _$PracticeLayer {
  const factory PracticeLayer({
    /// 鍥惧眰ID
    required String id,

    /// 鍥惧眰绫诲瀷
    required PracticeLayerType type,

    /// 鍥剧墖璺緞
    required String imagePath,

    /// 鍥惧眰鍚嶇О
    String? name,

    /// 鍥惧眰鎻忚堪
    String? description,

    /// 鍥惧眰鍙鎬?
    @Default(true) bool visible,

    /// 鍥惧眰閿佸畾鐘舵€?
    @Default(false) bool locked,

    /// 鍥惧眰涓嶉€忔槑搴?
    @Default(1.0) double opacity,

    /// 鍥惧眰椤哄簭
    @Default(0) int order,

    /// 鍥惧眰鍏冪礌鍒楄〃
    @Default([]) List<PracticeElement> elements,

    /// 鍥惧眰鍒涘缓鏃堕棿
    required DateTime createTime,

    /// 鍥惧眰鏇存柊鏃堕棿
    required DateTime updateTime,
  }) = _PracticeLayer;

  /// 鏂板缓鍥惧眰
  factory PracticeLayer.create({
    required PracticeLayerType type,
    required String imagePath,
    String? name,
    String? description,
  }) {
    final now = DateTime.now();
    return PracticeLayer(
      id: DateTime.now().millisecondsSinceEpoch.toString(),
      type: type,
      imagePath: imagePath,
      name: name,
      description: description,
      createTime: now,
      updateTime: now,
    );
  }

  /// 浠嶫SON鍒涘缓瀹炰緥
  factory PracticeLayer.fromJson(Map<String, dynamic> json) =>
      _$PracticeLayerFromJson(json);

  /// 绉佹湁鏋勯€犲嚱鏁?
  const PracticeLayer._();

  /// 鍒囨崲閿佸畾鐘舵€?
  PracticeLayer toggleLock() {
    return copyWith(locked: !locked);
  }

  /// 鍒囨崲鍙鎬?
  PracticeLayer toggleVisibility() {
    return copyWith(visible: !visible);
  }
}

/// 瀛楀笘缁冧範鍥惧眰绫诲瀷
enum PracticeLayerType {
  /// 鍘熺鍥惧眰
  source,

  /// 缁冧範鍥惧眰
  practice,

  /// 鍙傝€冨浘灞?
  reference,
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\domain\models\practice\practice_layer.freezed.dart
-----------------------------------
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'practice_layer.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

PracticeLayer _$PracticeLayerFromJson(Map<String, dynamic> json) {
  return _PracticeLayer.fromJson(json);
}

/// @nodoc
mixin _$PracticeLayer {
  /// 鍥惧眰ID
  String get id => throw _privateConstructorUsedError;

  /// 鍥惧眰绫诲瀷
  PracticeLayerType get type => throw _privateConstructorUsedError;

  /// 鍥剧墖璺緞
  String get imagePath => throw _privateConstructorUsedError;

  /// 鍥惧眰鍚嶇О
  String? get name => throw _privateConstructorUsedError;

  /// 鍥惧眰鎻忚堪
  String? get description => throw _privateConstructorUsedError;

  /// 鍥惧眰鍙鎬?  bool get visible => throw _privateConstructorUsedError;

  /// 鍥惧眰閿佸畾鐘舵€?  bool get locked => throw _privateConstructorUsedError;

  /// 鍥惧眰涓嶉€忔槑搴?  double get opacity => throw _privateConstructorUsedError;

  /// 鍥惧眰椤哄簭
  int get order => throw _privateConstructorUsedError;

  /// 鍥惧眰鍏冪礌鍒楄〃
  List<PracticeElement> get elements => throw _privateConstructorUsedError;

  /// 鍥惧眰鍒涘缓鏃堕棿
  DateTime get createTime => throw _privateConstructorUsedError;

  /// 鍥惧眰鏇存柊鏃堕棿
  DateTime get updateTime => throw _privateConstructorUsedError;

  /// Serializes this PracticeLayer to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of PracticeLayer
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $PracticeLayerCopyWith<PracticeLayer> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PracticeLayerCopyWith<$Res> {
  factory $PracticeLayerCopyWith(
          PracticeLayer value, $Res Function(PracticeLayer) then) =
      _$PracticeLayerCopyWithImpl<$Res, PracticeLayer>;
  @useResult
  $Res call(
      {String id,
      PracticeLayerType type,
      String imagePath,
      String? name,
      String? description,
      bool visible,
      bool locked,
      double opacity,
      int order,
      List<PracticeElement> elements,
      DateTime createTime,
      DateTime updateTime});
}

/// @nodoc
class _$PracticeLayerCopyWithImpl<$Res, $Val extends PracticeLayer>
    implements $PracticeLayerCopyWith<$Res> {
  _$PracticeLayerCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of PracticeLayer
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? type = null,
    Object? imagePath = null,
    Object? name = freezed,
    Object? description = freezed,
    Object? visible = null,
    Object? locked = null,
    Object? opacity = null,
    Object? order = null,
    Object? elements = null,
    Object? createTime = null,
    Object? updateTime = null,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as PracticeLayerType,
      imagePath: null == imagePath
          ? _value.imagePath
          : imagePath // ignore: cast_nullable_to_non_nullable
              as String,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      visible: null == visible
          ? _value.visible
          : visible // ignore: cast_nullable_to_non_nullable
              as bool,
      locked: null == locked
          ? _value.locked
          : locked // ignore: cast_nullable_to_non_nullable
              as bool,
      opacity: null == opacity
          ? _value.opacity
          : opacity // ignore: cast_nullable_to_non_nullable
              as double,
      order: null == order
          ? _value.order
          : order // ignore: cast_nullable_to_non_nullable
              as int,
      elements: null == elements
          ? _value.elements
          : elements // ignore: cast_nullable_to_non_nullable
              as List<PracticeElement>,
      createTime: null == createTime
          ? _value.createTime
          : createTime // ignore: cast_nullable_to_non_nullable
              as DateTime,
      updateTime: null == updateTime
          ? _value.updateTime
          : updateTime // ignore: cast_nullable_to_non_nullable
              as DateTime,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$PracticeLayerImplCopyWith<$Res>
    implements $PracticeLayerCopyWith<$Res> {
  factory _$$PracticeLayerImplCopyWith(
          _$PracticeLayerImpl value, $Res Function(_$PracticeLayerImpl) then) =
      __$$PracticeLayerImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      PracticeLayerType type,
      String imagePath,
      String? name,
      String? description,
      bool visible,
      bool locked,
      double opacity,
      int order,
      List<PracticeElement> elements,
      DateTime createTime,
      DateTime updateTime});
}

/// @nodoc
class __$$PracticeLayerImplCopyWithImpl<$Res>
    extends _$PracticeLayerCopyWithImpl<$Res, _$PracticeLayerImpl>
    implements _$$PracticeLayerImplCopyWith<$Res> {
  __$$PracticeLayerImplCopyWithImpl(
      _$PracticeLayerImpl _value, $Res Function(_$PracticeLayerImpl) _then)
      : super(_value, _then);

  /// Create a copy of PracticeLayer
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? type = null,
    Object? imagePath = null,
    Object? name = freezed,
    Object? description = freezed,
    Object? visible = null,
    Object? locked = null,
    Object? opacity = null,
    Object? order = null,
    Object? elements = null,
    Object? createTime = null,
    Object? updateTime = null,
  }) {
    return _then(_$PracticeLayerImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as PracticeLayerType,
      imagePath: null == imagePath
          ? _value.imagePath
          : imagePath // ignore: cast_nullable_to_non_nullable
              as String,
      name: freezed == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String?,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
      visible: null == visible
          ? _value.visible
          : visible // ignore: cast_nullable_to_non_nullable
              as bool,
      locked: null == locked
          ? _value.locked
          : locked // ignore: cast_nullable_to_non_nullable
              as bool,
      opacity: null == opacity
          ? _value.opacity
          : opacity // ignore: cast_nullable_to_non_nullable
              as double,
      order: null == order
          ? _value.order
          : order // ignore: cast_nullable_to_non_nullable
              as int,
      elements: null == elements
          ? _value._elements
          : elements // ignore: cast_nullable_to_non_nullable
              as List<PracticeElement>,
      createTime: null == createTime
          ? _value.createTime
          : createTime // ignore: cast_nullable_to_non_nullable
              as DateTime,
      updateTime: null == updateTime
          ? _value.updateTime
          : updateTime // ignore: cast_nullable_to_non_nullable
              as DateTime,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$PracticeLayerImpl extends _PracticeLayer {
  const _$PracticeLayerImpl(
      {required this.id,
      required this.type,
      required this.imagePath,
      this.name,
      this.description,
      this.visible = true,
      this.locked = false,
      this.opacity = 1.0,
      this.order = 0,
      final List<PracticeElement> elements = const [],
      required this.createTime,
      required this.updateTime})
      : _elements = elements,
        super._();

  factory _$PracticeLayerImpl.fromJson(Map<String, dynamic> json) =>
      _$$PracticeLayerImplFromJson(json);

  /// 鍥惧眰ID
  @override
  final String id;

  /// 鍥惧眰绫诲瀷
  @override
  final PracticeLayerType type;

  /// 鍥剧墖璺緞
  @override
  final String imagePath;

  /// 鍥惧眰鍚嶇О
  @override
  final String? name;

  /// 鍥惧眰鎻忚堪
  @override
  final String? description;

  /// 鍥惧眰鍙鎬?  @override
  @JsonKey()
  final bool visible;

  /// 鍥惧眰閿佸畾鐘舵€?  @override
  @JsonKey()
  final bool locked;

  /// 鍥惧眰涓嶉€忔槑搴?  @override
  @JsonKey()
  final double opacity;

  /// 鍥惧眰椤哄簭
  @override
  @JsonKey()
  final int order;

  /// 鍥惧眰鍏冪礌鍒楄〃
  final List<PracticeElement> _elements;

  /// 鍥惧眰鍏冪礌鍒楄〃
  @override
  @JsonKey()
  List<PracticeElement> get elements {
    if (_elements is EqualUnmodifiableListView) return _elements;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_elements);
  }

  /// 鍥惧眰鍒涘缓鏃堕棿
  @override
  final DateTime createTime;

  /// 鍥惧眰鏇存柊鏃堕棿
  @override
  final DateTime updateTime;

  @override
  String toString() {
    return 'PracticeLayer(id: $id, type: $type, imagePath: $imagePath, name: $name, description: $description, visible: $visible, locked: $locked, opacity: $opacity, order: $order, elements: $elements, createTime: $createTime, updateTime: $updateTime)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PracticeLayerImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.imagePath, imagePath) ||
                other.imagePath == imagePath) &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.description, description) ||
                other.description == description) &&
            (identical(other.visible, visible) || other.visible == visible) &&
            (identical(other.locked, locked) || other.locked == locked) &&
            (identical(other.opacity, opacity) || other.opacity == opacity) &&
            (identical(other.order, order) || other.order == order) &&
            const DeepCollectionEquality().equals(other._elements, _elements) &&
            (identical(other.createTime, createTime) ||
                other.createTime == createTime) &&
            (identical(other.updateTime, updateTime) ||
                other.updateTime == updateTime));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      type,
      imagePath,
      name,
      description,
      visible,
      locked,
      opacity,
      order,
      const DeepCollectionEquality().hash(_elements),
      createTime,
      updateTime);

  /// Create a copy of PracticeLayer
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$PracticeLayerImplCopyWith<_$PracticeLayerImpl> get copyWith =>
      __$$PracticeLayerImplCopyWithImpl<_$PracticeLayerImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$PracticeLayerImplToJson(
      this,
    );
  }
}

abstract class _PracticeLayer extends PracticeLayer {
  const factory _PracticeLayer(
      {required final String id,
      required final PracticeLayerType type,
      required final String imagePath,
      final String? name,
      final String? description,
      final bool visible,
      final bool locked,
      final double opacity,
      final int order,
      final List<PracticeElement> elements,
      required final DateTime createTime,
      required final DateTime updateTime}) = _$PracticeLayerImpl;
  const _PracticeLayer._() : super._();

  factory _PracticeLayer.fromJson(Map<String, dynamic> json) =
      _$PracticeLayerImpl.fromJson;

  /// 鍥惧眰ID
  @override
  String get id;

  /// 鍥惧眰绫诲瀷
  @override
  PracticeLayerType get type;

  /// 鍥剧墖璺緞
  @override
  String get imagePath;

  /// 鍥惧眰鍚嶇О
  @override
  String? get name;

  /// 鍥惧眰鎻忚堪
  @override
  String? get description;

  /// 鍥惧眰鍙鎬?  @override
  bool get visible;

  /// 鍥惧眰閿佸畾鐘舵€?  @override
  bool get locked;

  /// 鍥惧眰涓嶉€忔槑搴?  @override
  double get opacity;

  /// 鍥惧眰椤哄簭
  @override
  int get order;

  /// 鍥惧眰鍏冪礌鍒楄〃
  @override
  List<PracticeElement> get elements;

  /// 鍥惧眰鍒涘缓鏃堕棿
  @override
  DateTime get createTime;

  /// 鍥惧眰鏇存柊鏃堕棿
  @override
  DateTime get updateTime;

  /// Create a copy of PracticeLayer
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$PracticeLayerImplCopyWith<_$PracticeLayerImpl> get copyWith =>
      throw _privateConstructorUsedError;
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\domain\models\practice\practice_layer.g.dart
-----------------------------------
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'practice_layer.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_$PracticeLayerImpl _$$PracticeLayerImplFromJson(Map<String, dynamic> json) =>
    _$PracticeLayerImpl(
      id: json['id'] as String,
      type: $enumDecode(_$PracticeLayerTypeEnumMap, json['type']),
      imagePath: json['imagePath'] as String,
      name: json['name'] as String?,
      description: json['description'] as String?,
      visible: json['visible'] as bool? ?? true,
      locked: json['locked'] as bool? ?? false,
      opacity: (json['opacity'] as num?)?.toDouble() ?? 1.0,
      order: (json['order'] as num?)?.toInt() ?? 0,
      elements: (json['elements'] as List<dynamic>?)
              ?.map((e) => PracticeElement.fromJson(e as Map<String, dynamic>))
              .toList() ??
          const [],
      createTime: DateTime.parse(json['createTime'] as String),
      updateTime: DateTime.parse(json['updateTime'] as String),
    );

Map<String, dynamic> _$$PracticeLayerImplToJson(_$PracticeLayerImpl instance) =>
    <String, dynamic>{
      'id': instance.id,
      'type': _$PracticeLayerTypeEnumMap[instance.type]!,
      'imagePath': instance.imagePath,
      'name': instance.name,
      'description': instance.description,
      'visible': instance.visible,
      'locked': instance.locked,
      'opacity': instance.opacity,
      'order': instance.order,
      'elements': instance.elements,
      'createTime': instance.createTime.toIso8601String(),
      'updateTime': instance.updateTime.toIso8601String(),
    };

const _$PracticeLayerTypeEnumMap = {
  PracticeLayerType.source: 'source',
  PracticeLayerType.practice: 'practice',
  PracticeLayerType.reference: 'reference',
};



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\domain\models\practice\practice_page.dart
-----------------------------------
import 'package:freezed_annotation/freezed_annotation.dart';

import 'practice_layer.dart';

part 'practice_page.freezed.dart';
part 'practice_page.g.dart';

/// 椤甸潰灏哄
@freezed
class PageSize with _$PageSize {
  const factory PageSize({
    /// 灏哄鍗曚綅 (渚嬪: 'mm')
    @Default('mm') String unit,

    /// 鍒嗚鲸鐜囧崟浣?(渚嬪: 'dpi')
    @Default('dpi') String resUnit,

    /// 鍒嗚鲸鐜囧崟浣嶅€?
    @Default(300) int resUnitValue,

    /// 瀹藉害 (榛樿A4瀹藉害210mm)
    @Default(210.0) double width,

    /// 楂樺害 (榛樿A4楂樺害297mm)
    @Default(297.0) double height,
  }) = _PageSize;

  /// 浠嶫SON鍒涘缓瀹炰緥
  factory PageSize.fromJson(Map<String, dynamic> json) =>
      _$PageSizeFromJson(json);

  const PageSize._();
}

/// 瀛楀笘椤甸潰淇℃伅
@freezed
class PracticePage with _$PracticePage {
  const factory PracticePage({
    /// 椤甸潰搴忓彿
    required int index,

    /// 椤甸潰灏哄
    @Default(PageSize()) PageSize size,

    /// 椤甸潰鍥惧眰鍒楄〃
    @Default([]) List<PracticeLayer> layers,

    /// 鍒涘缓鏃堕棿
    @JsonKey(name: 'create_time') required DateTime createTime,

    /// 鏇存柊鏃堕棿
    @JsonKey(name: 'update_time') required DateTime updateTime,
  }) = _PracticePage;

  /// 鍒涘缓鏂伴〉闈?
  factory PracticePage.create(int index, {PageSize? size}) {
    final now = DateTime.now();
    return PracticePage(
      index: index,
      size: size ?? const PageSize(),
      createTime: now,
      updateTime: now,
    );
  }

  /// 浠嶫SON鍒涘缓瀹炰緥
  factory PracticePage.fromJson(Map<String, dynamic> json) =>
      _$PracticePageFromJson(json);

  const PracticePage._();

  /// 鑾峰彇鍥惧眰鏁伴噺
  int get layerCount => layers.length;

  /// 娣诲姞鍥惧眰
  PracticePage addLayer(PracticeLayer layer) {
    return copyWith(
      layers: [...layers, layer],
      updateTime: DateTime.now(),
    );
  }

  /// 鍒犻櫎鍥惧眰
  PracticePage removeLayer(String layerId) {
    return copyWith(
      layers: layers.where((l) => l.id != layerId).toList(),
      updateTime: DateTime.now(),
    );
  }

  /// 鏇存柊鍥惧眰
  PracticePage updateLayer(PracticeLayer layer) {
    return copyWith(
      layers: layers.map((l) => l.id == layer.id ? layer : l).toList(),
      updateTime: DateTime.now(),
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\domain\models\practice\practice_page.freezed.dart
-----------------------------------
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'practice_page.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

PageSize _$PageSizeFromJson(Map<String, dynamic> json) {
  return _PageSize.fromJson(json);
}

/// @nodoc
mixin _$PageSize {
  /// 灏哄鍗曚綅 (渚嬪: 'mm')
  String get unit => throw _privateConstructorUsedError;

  /// 鍒嗚鲸鐜囧崟浣?(渚嬪: 'dpi')
  String get resUnit => throw _privateConstructorUsedError;

  /// 鍒嗚鲸鐜囧崟浣嶅€?  int get resUnitValue => throw _privateConstructorUsedError;

  /// 瀹藉害 (榛樿A4瀹藉害210mm)
  double get width => throw _privateConstructorUsedError;

  /// 楂樺害 (榛樿A4楂樺害297mm)
  double get height => throw _privateConstructorUsedError;

  /// Serializes this PageSize to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of PageSize
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $PageSizeCopyWith<PageSize> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PageSizeCopyWith<$Res> {
  factory $PageSizeCopyWith(PageSize value, $Res Function(PageSize) then) =
      _$PageSizeCopyWithImpl<$Res, PageSize>;
  @useResult
  $Res call(
      {String unit,
      String resUnit,
      int resUnitValue,
      double width,
      double height});
}

/// @nodoc
class _$PageSizeCopyWithImpl<$Res, $Val extends PageSize>
    implements $PageSizeCopyWith<$Res> {
  _$PageSizeCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of PageSize
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? unit = null,
    Object? resUnit = null,
    Object? resUnitValue = null,
    Object? width = null,
    Object? height = null,
  }) {
    return _then(_value.copyWith(
      unit: null == unit
          ? _value.unit
          : unit // ignore: cast_nullable_to_non_nullable
              as String,
      resUnit: null == resUnit
          ? _value.resUnit
          : resUnit // ignore: cast_nullable_to_non_nullable
              as String,
      resUnitValue: null == resUnitValue
          ? _value.resUnitValue
          : resUnitValue // ignore: cast_nullable_to_non_nullable
              as int,
      width: null == width
          ? _value.width
          : width // ignore: cast_nullable_to_non_nullable
              as double,
      height: null == height
          ? _value.height
          : height // ignore: cast_nullable_to_non_nullable
              as double,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$PageSizeImplCopyWith<$Res>
    implements $PageSizeCopyWith<$Res> {
  factory _$$PageSizeImplCopyWith(
          _$PageSizeImpl value, $Res Function(_$PageSizeImpl) then) =
      __$$PageSizeImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String unit,
      String resUnit,
      int resUnitValue,
      double width,
      double height});
}

/// @nodoc
class __$$PageSizeImplCopyWithImpl<$Res>
    extends _$PageSizeCopyWithImpl<$Res, _$PageSizeImpl>
    implements _$$PageSizeImplCopyWith<$Res> {
  __$$PageSizeImplCopyWithImpl(
      _$PageSizeImpl _value, $Res Function(_$PageSizeImpl) _then)
      : super(_value, _then);

  /// Create a copy of PageSize
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? unit = null,
    Object? resUnit = null,
    Object? resUnitValue = null,
    Object? width = null,
    Object? height = null,
  }) {
    return _then(_$PageSizeImpl(
      unit: null == unit
          ? _value.unit
          : unit // ignore: cast_nullable_to_non_nullable
              as String,
      resUnit: null == resUnit
          ? _value.resUnit
          : resUnit // ignore: cast_nullable_to_non_nullable
              as String,
      resUnitValue: null == resUnitValue
          ? _value.resUnitValue
          : resUnitValue // ignore: cast_nullable_to_non_nullable
              as int,
      width: null == width
          ? _value.width
          : width // ignore: cast_nullable_to_non_nullable
              as double,
      height: null == height
          ? _value.height
          : height // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$PageSizeImpl extends _PageSize {
  const _$PageSizeImpl(
      {this.unit = 'mm',
      this.resUnit = 'dpi',
      this.resUnitValue = 300,
      this.width = 210.0,
      this.height = 297.0})
      : super._();

  factory _$PageSizeImpl.fromJson(Map<String, dynamic> json) =>
      _$$PageSizeImplFromJson(json);

  /// 灏哄鍗曚綅 (渚嬪: 'mm')
  @override
  @JsonKey()
  final String unit;

  /// 鍒嗚鲸鐜囧崟浣?(渚嬪: 'dpi')
  @override
  @JsonKey()
  final String resUnit;

  /// 鍒嗚鲸鐜囧崟浣嶅€?  @override
  @JsonKey()
  final int resUnitValue;

  /// 瀹藉害 (榛樿A4瀹藉害210mm)
  @override
  @JsonKey()
  final double width;

  /// 楂樺害 (榛樿A4楂樺害297mm)
  @override
  @JsonKey()
  final double height;

  @override
  String toString() {
    return 'PageSize(unit: $unit, resUnit: $resUnit, resUnitValue: $resUnitValue, width: $width, height: $height)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PageSizeImpl &&
            (identical(other.unit, unit) || other.unit == unit) &&
            (identical(other.resUnit, resUnit) || other.resUnit == resUnit) &&
            (identical(other.resUnitValue, resUnitValue) ||
                other.resUnitValue == resUnitValue) &&
            (identical(other.width, width) || other.width == width) &&
            (identical(other.height, height) || other.height == height));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode =>
      Object.hash(runtimeType, unit, resUnit, resUnitValue, width, height);

  /// Create a copy of PageSize
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$PageSizeImplCopyWith<_$PageSizeImpl> get copyWith =>
      __$$PageSizeImplCopyWithImpl<_$PageSizeImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$PageSizeImplToJson(
      this,
    );
  }
}

abstract class _PageSize extends PageSize {
  const factory _PageSize(
      {final String unit,
      final String resUnit,
      final int resUnitValue,
      final double width,
      final double height}) = _$PageSizeImpl;
  const _PageSize._() : super._();

  factory _PageSize.fromJson(Map<String, dynamic> json) =
      _$PageSizeImpl.fromJson;

  /// 灏哄鍗曚綅 (渚嬪: 'mm')
  @override
  String get unit;

  /// 鍒嗚鲸鐜囧崟浣?(渚嬪: 'dpi')
  @override
  String get resUnit;

  /// 鍒嗚鲸鐜囧崟浣嶅€?  @override
  int get resUnitValue;

  /// 瀹藉害 (榛樿A4瀹藉害210mm)
  @override
  double get width;

  /// 楂樺害 (榛樿A4楂樺害297mm)
  @override
  double get height;

  /// Create a copy of PageSize
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$PageSizeImplCopyWith<_$PageSizeImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

PracticePage _$PracticePageFromJson(Map<String, dynamic> json) {
  return _PracticePage.fromJson(json);
}

/// @nodoc
mixin _$PracticePage {
  /// 椤甸潰搴忓彿
  int get index => throw _privateConstructorUsedError;

  /// 椤甸潰灏哄
  PageSize get size => throw _privateConstructorUsedError;

  /// 椤甸潰鍥惧眰鍒楄〃
  List<PracticeLayer> get layers => throw _privateConstructorUsedError;

  /// 鍒涘缓鏃堕棿
  @JsonKey(name: 'create_time')
  DateTime get createTime => throw _privateConstructorUsedError;

  /// 鏇存柊鏃堕棿
  @JsonKey(name: 'update_time')
  DateTime get updateTime => throw _privateConstructorUsedError;

  /// Serializes this PracticePage to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of PracticePage
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $PracticePageCopyWith<PracticePage> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PracticePageCopyWith<$Res> {
  factory $PracticePageCopyWith(
          PracticePage value, $Res Function(PracticePage) then) =
      _$PracticePageCopyWithImpl<$Res, PracticePage>;
  @useResult
  $Res call(
      {int index,
      PageSize size,
      List<PracticeLayer> layers,
      @JsonKey(name: 'create_time') DateTime createTime,
      @JsonKey(name: 'update_time') DateTime updateTime});

  $PageSizeCopyWith<$Res> get size;
}

/// @nodoc
class _$PracticePageCopyWithImpl<$Res, $Val extends PracticePage>
    implements $PracticePageCopyWith<$Res> {
  _$PracticePageCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of PracticePage
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? index = null,
    Object? size = null,
    Object? layers = null,
    Object? createTime = null,
    Object? updateTime = null,
  }) {
    return _then(_value.copyWith(
      index: null == index
          ? _value.index
          : index // ignore: cast_nullable_to_non_nullable
              as int,
      size: null == size
          ? _value.size
          : size // ignore: cast_nullable_to_non_nullable
              as PageSize,
      layers: null == layers
          ? _value.layers
          : layers // ignore: cast_nullable_to_non_nullable
              as List<PracticeLayer>,
      createTime: null == createTime
          ? _value.createTime
          : createTime // ignore: cast_nullable_to_non_nullable
              as DateTime,
      updateTime: null == updateTime
          ? _value.updateTime
          : updateTime // ignore: cast_nullable_to_non_nullable
              as DateTime,
    ) as $Val);
  }

  /// Create a copy of PracticePage
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $PageSizeCopyWith<$Res> get size {
    return $PageSizeCopyWith<$Res>(_value.size, (value) {
      return _then(_value.copyWith(size: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$PracticePageImplCopyWith<$Res>
    implements $PracticePageCopyWith<$Res> {
  factory _$$PracticePageImplCopyWith(
          _$PracticePageImpl value, $Res Function(_$PracticePageImpl) then) =
      __$$PracticePageImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {int index,
      PageSize size,
      List<PracticeLayer> layers,
      @JsonKey(name: 'create_time') DateTime createTime,
      @JsonKey(name: 'update_time') DateTime updateTime});

  @override
  $PageSizeCopyWith<$Res> get size;
}

/// @nodoc
class __$$PracticePageImplCopyWithImpl<$Res>
    extends _$PracticePageCopyWithImpl<$Res, _$PracticePageImpl>
    implements _$$PracticePageImplCopyWith<$Res> {
  __$$PracticePageImplCopyWithImpl(
      _$PracticePageImpl _value, $Res Function(_$PracticePageImpl) _then)
      : super(_value, _then);

  /// Create a copy of PracticePage
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? index = null,
    Object? size = null,
    Object? layers = null,
    Object? createTime = null,
    Object? updateTime = null,
  }) {
    return _then(_$PracticePageImpl(
      index: null == index
          ? _value.index
          : index // ignore: cast_nullable_to_non_nullable
              as int,
      size: null == size
          ? _value.size
          : size // ignore: cast_nullable_to_non_nullable
              as PageSize,
      layers: null == layers
          ? _value._layers
          : layers // ignore: cast_nullable_to_non_nullable
              as List<PracticeLayer>,
      createTime: null == createTime
          ? _value.createTime
          : createTime // ignore: cast_nullable_to_non_nullable
              as DateTime,
      updateTime: null == updateTime
          ? _value.updateTime
          : updateTime // ignore: cast_nullable_to_non_nullable
              as DateTime,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$PracticePageImpl extends _PracticePage {
  const _$PracticePageImpl(
      {required this.index,
      this.size = const PageSize(),
      final List<PracticeLayer> layers = const [],
      @JsonKey(name: 'create_time') required this.createTime,
      @JsonKey(name: 'update_time') required this.updateTime})
      : _layers = layers,
        super._();

  factory _$PracticePageImpl.fromJson(Map<String, dynamic> json) =>
      _$$PracticePageImplFromJson(json);

  /// 椤甸潰搴忓彿
  @override
  final int index;

  /// 椤甸潰灏哄
  @override
  @JsonKey()
  final PageSize size;

  /// 椤甸潰鍥惧眰鍒楄〃
  final List<PracticeLayer> _layers;

  /// 椤甸潰鍥惧眰鍒楄〃
  @override
  @JsonKey()
  List<PracticeLayer> get layers {
    if (_layers is EqualUnmodifiableListView) return _layers;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_layers);
  }

  /// 鍒涘缓鏃堕棿
  @override
  @JsonKey(name: 'create_time')
  final DateTime createTime;

  /// 鏇存柊鏃堕棿
  @override
  @JsonKey(name: 'update_time')
  final DateTime updateTime;

  @override
  String toString() {
    return 'PracticePage(index: $index, size: $size, layers: $layers, createTime: $createTime, updateTime: $updateTime)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PracticePageImpl &&
            (identical(other.index, index) || other.index == index) &&
            (identical(other.size, size) || other.size == size) &&
            const DeepCollectionEquality().equals(other._layers, _layers) &&
            (identical(other.createTime, createTime) ||
                other.createTime == createTime) &&
            (identical(other.updateTime, updateTime) ||
                other.updateTime == updateTime));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, index, size,
      const DeepCollectionEquality().hash(_layers), createTime, updateTime);

  /// Create a copy of PracticePage
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$PracticePageImplCopyWith<_$PracticePageImpl> get copyWith =>
      __$$PracticePageImplCopyWithImpl<_$PracticePageImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$PracticePageImplToJson(
      this,
    );
  }
}

abstract class _PracticePage extends PracticePage {
  const factory _PracticePage(
          {required final int index,
          final PageSize size,
          final List<PracticeLayer> layers,
          @JsonKey(name: 'create_time') required final DateTime createTime,
          @JsonKey(name: 'update_time') required final DateTime updateTime}) =
      _$PracticePageImpl;
  const _PracticePage._() : super._();

  factory _PracticePage.fromJson(Map<String, dynamic> json) =
      _$PracticePageImpl.fromJson;

  /// 椤甸潰搴忓彿
  @override
  int get index;

  /// 椤甸潰灏哄
  @override
  PageSize get size;

  /// 椤甸潰鍥惧眰鍒楄〃
  @override
  List<PracticeLayer> get layers;

  /// 鍒涘缓鏃堕棿
  @override
  @JsonKey(name: 'create_time')
  DateTime get createTime;

  /// 鏇存柊鏃堕棿
  @override
  @JsonKey(name: 'update_time')
  DateTime get updateTime;

  /// Create a copy of PracticePage
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$PracticePageImplCopyWith<_$PracticePageImpl> get copyWith =>
      throw _privateConstructorUsedError;
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\domain\models\practice\practice_page.g.dart
-----------------------------------
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'practice_page.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_$PageSizeImpl _$$PageSizeImplFromJson(Map<String, dynamic> json) =>
    _$PageSizeImpl(
      unit: json['unit'] as String? ?? 'mm',
      resUnit: json['resUnit'] as String? ?? 'dpi',
      resUnitValue: (json['resUnitValue'] as num?)?.toInt() ?? 300,
      width: (json['width'] as num?)?.toDouble() ?? 210.0,
      height: (json['height'] as num?)?.toDouble() ?? 297.0,
    );

Map<String, dynamic> _$$PageSizeImplToJson(_$PageSizeImpl instance) =>
    <String, dynamic>{
      'unit': instance.unit,
      'resUnit': instance.resUnit,
      'resUnitValue': instance.resUnitValue,
      'width': instance.width,
      'height': instance.height,
    };

_$PracticePageImpl _$$PracticePageImplFromJson(Map<String, dynamic> json) =>
    _$PracticePageImpl(
      index: (json['index'] as num).toInt(),
      size: json['size'] == null
          ? const PageSize()
          : PageSize.fromJson(json['size'] as Map<String, dynamic>),
      layers: (json['layers'] as List<dynamic>?)
              ?.map((e) => PracticeLayer.fromJson(e as Map<String, dynamic>))
              .toList() ??
          const [],
      createTime: DateTime.parse(json['create_time'] as String),
      updateTime: DateTime.parse(json['update_time'] as String),
    );

Map<String, dynamic> _$$PracticePageImplToJson(_$PracticePageImpl instance) =>
    <String, dynamic>{
      'index': instance.index,
      'size': instance.size,
      'layers': instance.layers,
      'create_time': instance.createTime.toIso8601String(),
      'update_time': instance.updateTime.toIso8601String(),
    };



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\domain\models\practice\text_element.dart
-----------------------------------
import 'dart:ui';

import 'package:freezed_annotation/freezed_annotation.dart';

part 'text_element.freezed.dart';
part 'text_element.g.dart';

/// 鏂囨湰鍏冪礌
@freezed
class TextElement with _$TextElement {
  const factory TextElement({
    /// 鏂囨湰鍐呭
    required String text,

    /// 瀛椾綋鍚嶇О
    @Default('Arial') String fontFamily,

    /// 瀛椾綋澶у皬
    @Default(14.0) double fontSize,

    /// 瀛椾綋棰滆壊
    @Default('#000000') String color,

    /// 鏂囨湰瀵归綈鏂瑰紡
    @Default(TextAlign.left) TextAlign textAlign,

    /// 鏄惁鍔犵矖
    @Default(false) bool bold,

    /// 鏄惁鏂滀綋
    @Default(false) bool italic,

    /// 鏄惁涓嬪垝绾?
    @Default(false) bool underline,

    /// 琛岄珮
    @Default(1.2) double lineHeight,

    /// 瀛楅棿璺?
    @Default(0.0) double letterSpacing,

    /// 鑷畾涔夋牱寮忓睘鎬?
    @Default({}) Map<String, dynamic> customStyle,
  }) = _TextElement;

  /// 浠嶫SON鍒涘缓瀹炰緥
  factory TextElement.fromJson(Map<String, dynamic> json) =>
      _$TextElementFromJson(json);

  /// 绠€鍗曟枃鏈?
  factory TextElement.simple(String text) => TextElement(text: text);

  const TextElement._();

  /// 绉婚櫎鑷畾涔夋牱寮?
  TextElement removeCustomStyle(String key) {
    final newCustomStyle = Map<String, dynamic>.from(customStyle);
    newCustomStyle.remove(key);
    return copyWith(customStyle: newCustomStyle);
  }

  /// 璁剧疆瀵归綈
  TextElement withAlign(TextAlign align) => copyWith(textAlign: align);

  /// 璁剧疆鍔犵矖
  TextElement withBold(bool bold) => copyWith(bold: bold);

  /// 璁剧疆棰滆壊
  TextElement withColor(String color) => copyWith(color: color);

  /// 璁剧疆鑷畾涔夋牱寮?
  TextElement withCustomStyle(String key, dynamic value) {
    final newCustomStyle = Map<String, dynamic>.from(customStyle);
    newCustomStyle[key] = value;
    return copyWith(customStyle: newCustomStyle);
  }

  /// 璁剧疆瀛椾綋
  TextElement withFont(String fontFamily) => copyWith(fontFamily: fontFamily);

  /// 璁剧疆鏂滀綋
  TextElement withItalic(bool italic) => copyWith(italic: italic);

  /// 璁剧疆瀛楅棿璺?
  TextElement withLetterSpacing(double spacing) =>
      copyWith(letterSpacing: spacing);

  /// 璁剧疆琛岄珮
  TextElement withLineHeight(double lineHeight) =>
      copyWith(lineHeight: lineHeight);

  /// 璁剧疆瀛楀彿
  TextElement withSize(double fontSize) => copyWith(fontSize: fontSize);

  /// 璁剧疆涓嬪垝绾?
  TextElement withUnderline(bool underline) => copyWith(underline: underline);
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\domain\models\practice\text_element.freezed.dart
-----------------------------------
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'text_element.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

TextElement _$TextElementFromJson(Map<String, dynamic> json) {
  return _TextElement.fromJson(json);
}

/// @nodoc
mixin _$TextElement {
  /// 鏂囨湰鍐呭
  String get text => throw _privateConstructorUsedError;

  /// 瀛椾綋鍚嶇О
  String get fontFamily => throw _privateConstructorUsedError;

  /// 瀛椾綋澶у皬
  double get fontSize => throw _privateConstructorUsedError;

  /// 瀛椾綋棰滆壊
  String get color => throw _privateConstructorUsedError;

  /// 鏂囨湰瀵归綈鏂瑰紡
  TextAlign get textAlign => throw _privateConstructorUsedError;

  /// 鏄惁鍔犵矖
  bool get bold => throw _privateConstructorUsedError;

  /// 鏄惁鏂滀綋
  bool get italic => throw _privateConstructorUsedError;

  /// 鏄惁涓嬪垝绾?  bool get underline => throw _privateConstructorUsedError;

  /// 琛岄珮
  double get lineHeight => throw _privateConstructorUsedError;

  /// 瀛楅棿璺?  double get letterSpacing => throw _privateConstructorUsedError;

  /// 鑷畾涔夋牱寮忓睘鎬?  Map<String, dynamic> get customStyle => throw _privateConstructorUsedError;

  /// Serializes this TextElement to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of TextElement
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $TextElementCopyWith<TextElement> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $TextElementCopyWith<$Res> {
  factory $TextElementCopyWith(
          TextElement value, $Res Function(TextElement) then) =
      _$TextElementCopyWithImpl<$Res, TextElement>;
  @useResult
  $Res call(
      {String text,
      String fontFamily,
      double fontSize,
      String color,
      TextAlign textAlign,
      bool bold,
      bool italic,
      bool underline,
      double lineHeight,
      double letterSpacing,
      Map<String, dynamic> customStyle});
}

/// @nodoc
class _$TextElementCopyWithImpl<$Res, $Val extends TextElement>
    implements $TextElementCopyWith<$Res> {
  _$TextElementCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of TextElement
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? text = null,
    Object? fontFamily = null,
    Object? fontSize = null,
    Object? color = null,
    Object? textAlign = null,
    Object? bold = null,
    Object? italic = null,
    Object? underline = null,
    Object? lineHeight = null,
    Object? letterSpacing = null,
    Object? customStyle = null,
  }) {
    return _then(_value.copyWith(
      text: null == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as String,
      fontFamily: null == fontFamily
          ? _value.fontFamily
          : fontFamily // ignore: cast_nullable_to_non_nullable
              as String,
      fontSize: null == fontSize
          ? _value.fontSize
          : fontSize // ignore: cast_nullable_to_non_nullable
              as double,
      color: null == color
          ? _value.color
          : color // ignore: cast_nullable_to_non_nullable
              as String,
      textAlign: null == textAlign
          ? _value.textAlign
          : textAlign // ignore: cast_nullable_to_non_nullable
              as TextAlign,
      bold: null == bold
          ? _value.bold
          : bold // ignore: cast_nullable_to_non_nullable
              as bool,
      italic: null == italic
          ? _value.italic
          : italic // ignore: cast_nullable_to_non_nullable
              as bool,
      underline: null == underline
          ? _value.underline
          : underline // ignore: cast_nullable_to_non_nullable
              as bool,
      lineHeight: null == lineHeight
          ? _value.lineHeight
          : lineHeight // ignore: cast_nullable_to_non_nullable
              as double,
      letterSpacing: null == letterSpacing
          ? _value.letterSpacing
          : letterSpacing // ignore: cast_nullable_to_non_nullable
              as double,
      customStyle: null == customStyle
          ? _value.customStyle
          : customStyle // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$TextElementImplCopyWith<$Res>
    implements $TextElementCopyWith<$Res> {
  factory _$$TextElementImplCopyWith(
          _$TextElementImpl value, $Res Function(_$TextElementImpl) then) =
      __$$TextElementImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String text,
      String fontFamily,
      double fontSize,
      String color,
      TextAlign textAlign,
      bool bold,
      bool italic,
      bool underline,
      double lineHeight,
      double letterSpacing,
      Map<String, dynamic> customStyle});
}

/// @nodoc
class __$$TextElementImplCopyWithImpl<$Res>
    extends _$TextElementCopyWithImpl<$Res, _$TextElementImpl>
    implements _$$TextElementImplCopyWith<$Res> {
  __$$TextElementImplCopyWithImpl(
      _$TextElementImpl _value, $Res Function(_$TextElementImpl) _then)
      : super(_value, _then);

  /// Create a copy of TextElement
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? text = null,
    Object? fontFamily = null,
    Object? fontSize = null,
    Object? color = null,
    Object? textAlign = null,
    Object? bold = null,
    Object? italic = null,
    Object? underline = null,
    Object? lineHeight = null,
    Object? letterSpacing = null,
    Object? customStyle = null,
  }) {
    return _then(_$TextElementImpl(
      text: null == text
          ? _value.text
          : text // ignore: cast_nullable_to_non_nullable
              as String,
      fontFamily: null == fontFamily
          ? _value.fontFamily
          : fontFamily // ignore: cast_nullable_to_non_nullable
              as String,
      fontSize: null == fontSize
          ? _value.fontSize
          : fontSize // ignore: cast_nullable_to_non_nullable
              as double,
      color: null == color
          ? _value.color
          : color // ignore: cast_nullable_to_non_nullable
              as String,
      textAlign: null == textAlign
          ? _value.textAlign
          : textAlign // ignore: cast_nullable_to_non_nullable
              as TextAlign,
      bold: null == bold
          ? _value.bold
          : bold // ignore: cast_nullable_to_non_nullable
              as bool,
      italic: null == italic
          ? _value.italic
          : italic // ignore: cast_nullable_to_non_nullable
              as bool,
      underline: null == underline
          ? _value.underline
          : underline // ignore: cast_nullable_to_non_nullable
              as bool,
      lineHeight: null == lineHeight
          ? _value.lineHeight
          : lineHeight // ignore: cast_nullable_to_non_nullable
              as double,
      letterSpacing: null == letterSpacing
          ? _value.letterSpacing
          : letterSpacing // ignore: cast_nullable_to_non_nullable
              as double,
      customStyle: null == customStyle
          ? _value._customStyle
          : customStyle // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$TextElementImpl extends _TextElement {
  const _$TextElementImpl(
      {required this.text,
      this.fontFamily = 'Arial',
      this.fontSize = 14.0,
      this.color = '#000000',
      this.textAlign = TextAlign.left,
      this.bold = false,
      this.italic = false,
      this.underline = false,
      this.lineHeight = 1.2,
      this.letterSpacing = 0.0,
      final Map<String, dynamic> customStyle = const {}})
      : _customStyle = customStyle,
        super._();

  factory _$TextElementImpl.fromJson(Map<String, dynamic> json) =>
      _$$TextElementImplFromJson(json);

  /// 鏂囨湰鍐呭
  @override
  final String text;

  /// 瀛椾綋鍚嶇О
  @override
  @JsonKey()
  final String fontFamily;

  /// 瀛椾綋澶у皬
  @override
  @JsonKey()
  final double fontSize;

  /// 瀛椾綋棰滆壊
  @override
  @JsonKey()
  final String color;

  /// 鏂囨湰瀵归綈鏂瑰紡
  @override
  @JsonKey()
  final TextAlign textAlign;

  /// 鏄惁鍔犵矖
  @override
  @JsonKey()
  final bool bold;

  /// 鏄惁鏂滀綋
  @override
  @JsonKey()
  final bool italic;

  /// 鏄惁涓嬪垝绾?  @override
  @JsonKey()
  final bool underline;

  /// 琛岄珮
  @override
  @JsonKey()
  final double lineHeight;

  /// 瀛楅棿璺?  @override
  @JsonKey()
  final double letterSpacing;

  /// 鑷畾涔夋牱寮忓睘鎬?  final Map<String, dynamic> _customStyle;

  /// 鑷畾涔夋牱寮忓睘鎬?  @override
  @JsonKey()
  Map<String, dynamic> get customStyle {
    if (_customStyle is EqualUnmodifiableMapView) return _customStyle;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_customStyle);
  }

  @override
  String toString() {
    return 'TextElement(text: $text, fontFamily: $fontFamily, fontSize: $fontSize, color: $color, textAlign: $textAlign, bold: $bold, italic: $italic, underline: $underline, lineHeight: $lineHeight, letterSpacing: $letterSpacing, customStyle: $customStyle)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$TextElementImpl &&
            (identical(other.text, text) || other.text == text) &&
            (identical(other.fontFamily, fontFamily) ||
                other.fontFamily == fontFamily) &&
            (identical(other.fontSize, fontSize) ||
                other.fontSize == fontSize) &&
            (identical(other.color, color) || other.color == color) &&
            (identical(other.textAlign, textAlign) ||
                other.textAlign == textAlign) &&
            (identical(other.bold, bold) || other.bold == bold) &&
            (identical(other.italic, italic) || other.italic == italic) &&
            (identical(other.underline, underline) ||
                other.underline == underline) &&
            (identical(other.lineHeight, lineHeight) ||
                other.lineHeight == lineHeight) &&
            (identical(other.letterSpacing, letterSpacing) ||
                other.letterSpacing == letterSpacing) &&
            const DeepCollectionEquality()
                .equals(other._customStyle, _customStyle));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      text,
      fontFamily,
      fontSize,
      color,
      textAlign,
      bold,
      italic,
      underline,
      lineHeight,
      letterSpacing,
      const DeepCollectionEquality().hash(_customStyle));

  /// Create a copy of TextElement
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$TextElementImplCopyWith<_$TextElementImpl> get copyWith =>
      __$$TextElementImplCopyWithImpl<_$TextElementImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$TextElementImplToJson(
      this,
    );
  }
}

abstract class _TextElement extends TextElement {
  const factory _TextElement(
      {required final String text,
      final String fontFamily,
      final double fontSize,
      final String color,
      final TextAlign textAlign,
      final bool bold,
      final bool italic,
      final bool underline,
      final double lineHeight,
      final double letterSpacing,
      final Map<String, dynamic> customStyle}) = _$TextElementImpl;
  const _TextElement._() : super._();

  factory _TextElement.fromJson(Map<String, dynamic> json) =
      _$TextElementImpl.fromJson;

  /// 鏂囨湰鍐呭
  @override
  String get text;

  /// 瀛椾綋鍚嶇О
  @override
  String get fontFamily;

  /// 瀛椾綋澶у皬
  @override
  double get fontSize;

  /// 瀛椾綋棰滆壊
  @override
  String get color;

  /// 鏂囨湰瀵归綈鏂瑰紡
  @override
  TextAlign get textAlign;

  /// 鏄惁鍔犵矖
  @override
  bool get bold;

  /// 鏄惁鏂滀綋
  @override
  bool get italic;

  /// 鏄惁涓嬪垝绾?  @override
  bool get underline;

  /// 琛岄珮
  @override
  double get lineHeight;

  /// 瀛楅棿璺?  @override
  double get letterSpacing;

  /// 鑷畾涔夋牱寮忓睘鎬?  @override
  Map<String, dynamic> get customStyle;

  /// Create a copy of TextElement
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$TextElementImplCopyWith<_$TextElementImpl> get copyWith =>
      throw _privateConstructorUsedError;
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\domain\models\practice\text_element.g.dart
-----------------------------------
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'text_element.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_$TextElementImpl _$$TextElementImplFromJson(Map<String, dynamic> json) =>
    _$TextElementImpl(
      text: json['text'] as String,
      fontFamily: json['fontFamily'] as String? ?? 'Arial',
      fontSize: (json['fontSize'] as num?)?.toDouble() ?? 14.0,
      color: json['color'] as String? ?? '#000000',
      textAlign: $enumDecodeNullable(_$TextAlignEnumMap, json['textAlign']) ??
          TextAlign.left,
      bold: json['bold'] as bool? ?? false,
      italic: json['italic'] as bool? ?? false,
      underline: json['underline'] as bool? ?? false,
      lineHeight: (json['lineHeight'] as num?)?.toDouble() ?? 1.2,
      letterSpacing: (json['letterSpacing'] as num?)?.toDouble() ?? 0.0,
      customStyle: json['customStyle'] as Map<String, dynamic>? ?? const {},
    );

Map<String, dynamic> _$$TextElementImplToJson(_$TextElementImpl instance) =>
    <String, dynamic>{
      'text': instance.text,
      'fontFamily': instance.fontFamily,
      'fontSize': instance.fontSize,
      'color': instance.color,
      'textAlign': _$TextAlignEnumMap[instance.textAlign]!,
      'bold': instance.bold,
      'italic': instance.italic,
      'underline': instance.underline,
      'lineHeight': instance.lineHeight,
      'letterSpacing': instance.letterSpacing,
      'customStyle': instance.customStyle,
    };

const _$TextAlignEnumMap = {
  TextAlign.left: 'left',
  TextAlign.right: 'right',
  TextAlign.center: 'center',
  TextAlign.justify: 'justify',
  TextAlign.start: 'start',
  TextAlign.end: 'end',
};



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\domain\models\work\work_entity.dart
-----------------------------------
import 'package:freezed_annotation/freezed_annotation.dart';

import '../../enums/work_status.dart';
import '../../enums/work_style.dart';
import '../../enums/work_tool.dart';
import '../character/character_entity.dart';
import 'work_image.dart';

part 'work_entity.freezed.dart';
part 'work_entity.g.dart';

WorkStyle _workStyleFromJson(dynamic value) => WorkStyle.fromValue(value);

/// 鏋氫妇搴忓垪鍖栬緟鍔╂柟娉?
String _workStyleToJson(WorkStyle style) => style.value;
WorkTool _workToolFromJson(dynamic value) => WorkTool.fromValue(value);
String _workToolToJson(WorkTool tool) => tool.value;

/// 浣滃搧瀹炰綋
@freezed
class WorkEntity with _$WorkEntity {
  const factory WorkEntity({
    /// ID
    required String id,

    /// 鏍囬
    required String title,

    /// 浣滆€?
    required String author,

    /// 澶囨敞
    String? remark,

    /// 瀛椾綋
    @JsonKey(fromJson: _workStyleFromJson, toJson: _workStyleToJson)
    required WorkStyle style,

    /// 宸ュ叿
    @JsonKey(fromJson: _workToolFromJson, toJson: _workToolToJson)
    required WorkTool tool,

    /// 鍒涗綔鏃ユ湡

    required DateTime creationDate,

    /// 鍒涘缓鏃堕棿

    required DateTime createTime,

    /// 淇敼鏃堕棿

    required DateTime updateTime,

    /// 鍥剧墖鏈€鍚庢洿鏂版椂闂?

    DateTime? lastImageUpdateTime,

    /// 鐘舵€?
    @Default(WorkStatus.draft) WorkStatus status,

    /// 棣栧浘ID
    String? firstImageId,

    /// 鍥剧墖鍒楄〃
    @Default([]) List<WorkImage> images,

    /// 鍏宠仈瀛楃鍒楄〃

    @Default([]) List<CharacterEntity> collectedChars,

    /// 鏍囩鍒楄〃
    @Default([]) List<String> tags,

    /// 鍥剧墖鏁伴噺
    int? imageCount,
  }) = _WorkEntity;

  factory WorkEntity.fromJson(Map<String, dynamic> json) =>
      _$WorkEntityFromJson(json);

  const WorkEntity._();

  /// 鑾峰彇棣栧浘
  WorkImage? get firstImage => images.isEmpty ? null : images[0];

  /// 鑾峰彇鍥剧墖鎬绘暟閲?
  int get totalImages => imageCount ?? images.length;

  /// 娣诲姞鍏宠仈瀛?
  WorkEntity addCollectedChar(CharacterEntity char) {
    if (collectedChars.contains(char)) return this;
    return copyWith(collectedChars: [...collectedChars, char]);
  }

  /// 娣诲姞鏍囩
  WorkEntity addTag(String tag) {
    if (tags.contains(tag)) return this;
    return copyWith(tags: [...tags, tag]);
  }

  /// 绉婚櫎鍏宠仈瀛?
  WorkEntity removeCollectedChar(CharacterEntity char) {
    return copyWith(
        collectedChars: collectedChars.where((c) => c != char).toList());
  }

  /// 绉婚櫎鏍囩
  WorkEntity removeTag(String tag) {
    return copyWith(tags: tags.where((t) => t != tag).toList());
  }

  /// 鏇存柊棣栧浘
  WorkEntity updateFirstImage(String? firstImageId) =>
      copyWith(firstImageId: firstImageId);

  /// 鏇存柊鏍囩
  WorkEntity updateTags(List<String> newTags) {
    return copyWith(tags: newTags);
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\domain\models\work\work_entity.freezed.dart
-----------------------------------
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'work_entity.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

WorkEntity _$WorkEntityFromJson(Map<String, dynamic> json) {
  return _WorkEntity.fromJson(json);
}

/// @nodoc
mixin _$WorkEntity {
  /// ID
  String get id => throw _privateConstructorUsedError;

  /// 鏍囬
  String get title => throw _privateConstructorUsedError;

  /// 浣滆€?  String get author => throw _privateConstructorUsedError;

  /// 澶囨敞
  String? get remark => throw _privateConstructorUsedError;

  /// 瀛椾綋
  @JsonKey(fromJson: _workStyleFromJson, toJson: _workStyleToJson)
  WorkStyle get style => throw _privateConstructorUsedError;

  /// 宸ュ叿
  @JsonKey(fromJson: _workToolFromJson, toJson: _workToolToJson)
  WorkTool get tool => throw _privateConstructorUsedError;

  /// 鍒涗綔鏃ユ湡
  DateTime get creationDate => throw _privateConstructorUsedError;

  /// 鍒涘缓鏃堕棿
  DateTime get createTime => throw _privateConstructorUsedError;

  /// 淇敼鏃堕棿
  DateTime get updateTime => throw _privateConstructorUsedError;

  /// 鍥剧墖鏈€鍚庢洿鏂版椂闂?  DateTime? get lastImageUpdateTime => throw _privateConstructorUsedError;

  /// 鐘舵€?  WorkStatus get status => throw _privateConstructorUsedError;

  /// 棣栧浘ID
  String? get firstImageId => throw _privateConstructorUsedError;

  /// 鍥剧墖鍒楄〃
  List<WorkImage> get images => throw _privateConstructorUsedError;

  /// 鍏宠仈瀛楃鍒楄〃
  List<CharacterEntity> get collectedChars =>
      throw _privateConstructorUsedError;

  /// 鏍囩鍒楄〃
  List<String> get tags => throw _privateConstructorUsedError;

  /// 鍥剧墖鏁伴噺
  int? get imageCount => throw _privateConstructorUsedError;

  /// Serializes this WorkEntity to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of WorkEntity
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $WorkEntityCopyWith<WorkEntity> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $WorkEntityCopyWith<$Res> {
  factory $WorkEntityCopyWith(
          WorkEntity value, $Res Function(WorkEntity) then) =
      _$WorkEntityCopyWithImpl<$Res, WorkEntity>;
  @useResult
  $Res call(
      {String id,
      String title,
      String author,
      String? remark,
      @JsonKey(fromJson: _workStyleFromJson, toJson: _workStyleToJson)
      WorkStyle style,
      @JsonKey(fromJson: _workToolFromJson, toJson: _workToolToJson)
      WorkTool tool,
      DateTime creationDate,
      DateTime createTime,
      DateTime updateTime,
      DateTime? lastImageUpdateTime,
      WorkStatus status,
      String? firstImageId,
      List<WorkImage> images,
      List<CharacterEntity> collectedChars,
      List<String> tags,
      int? imageCount});
}

/// @nodoc
class _$WorkEntityCopyWithImpl<$Res, $Val extends WorkEntity>
    implements $WorkEntityCopyWith<$Res> {
  _$WorkEntityCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of WorkEntity
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? title = null,
    Object? author = null,
    Object? remark = freezed,
    Object? style = null,
    Object? tool = null,
    Object? creationDate = null,
    Object? createTime = null,
    Object? updateTime = null,
    Object? lastImageUpdateTime = freezed,
    Object? status = null,
    Object? firstImageId = freezed,
    Object? images = null,
    Object? collectedChars = null,
    Object? tags = null,
    Object? imageCount = freezed,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      title: null == title
          ? _value.title
          : title // ignore: cast_nullable_to_non_nullable
              as String,
      author: null == author
          ? _value.author
          : author // ignore: cast_nullable_to_non_nullable
              as String,
      remark: freezed == remark
          ? _value.remark
          : remark // ignore: cast_nullable_to_non_nullable
              as String?,
      style: null == style
          ? _value.style
          : style // ignore: cast_nullable_to_non_nullable
              as WorkStyle,
      tool: null == tool
          ? _value.tool
          : tool // ignore: cast_nullable_to_non_nullable
              as WorkTool,
      creationDate: null == creationDate
          ? _value.creationDate
          : creationDate // ignore: cast_nullable_to_non_nullable
              as DateTime,
      createTime: null == createTime
          ? _value.createTime
          : createTime // ignore: cast_nullable_to_non_nullable
              as DateTime,
      updateTime: null == updateTime
          ? _value.updateTime
          : updateTime // ignore: cast_nullable_to_non_nullable
              as DateTime,
      lastImageUpdateTime: freezed == lastImageUpdateTime
          ? _value.lastImageUpdateTime
          : lastImageUpdateTime // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      status: null == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as WorkStatus,
      firstImageId: freezed == firstImageId
          ? _value.firstImageId
          : firstImageId // ignore: cast_nullable_to_non_nullable
              as String?,
      images: null == images
          ? _value.images
          : images // ignore: cast_nullable_to_non_nullable
              as List<WorkImage>,
      collectedChars: null == collectedChars
          ? _value.collectedChars
          : collectedChars // ignore: cast_nullable_to_non_nullable
              as List<CharacterEntity>,
      tags: null == tags
          ? _value.tags
          : tags // ignore: cast_nullable_to_non_nullable
              as List<String>,
      imageCount: freezed == imageCount
          ? _value.imageCount
          : imageCount // ignore: cast_nullable_to_non_nullable
              as int?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$WorkEntityImplCopyWith<$Res>
    implements $WorkEntityCopyWith<$Res> {
  factory _$$WorkEntityImplCopyWith(
          _$WorkEntityImpl value, $Res Function(_$WorkEntityImpl) then) =
      __$$WorkEntityImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      String title,
      String author,
      String? remark,
      @JsonKey(fromJson: _workStyleFromJson, toJson: _workStyleToJson)
      WorkStyle style,
      @JsonKey(fromJson: _workToolFromJson, toJson: _workToolToJson)
      WorkTool tool,
      DateTime creationDate,
      DateTime createTime,
      DateTime updateTime,
      DateTime? lastImageUpdateTime,
      WorkStatus status,
      String? firstImageId,
      List<WorkImage> images,
      List<CharacterEntity> collectedChars,
      List<String> tags,
      int? imageCount});
}

/// @nodoc
class __$$WorkEntityImplCopyWithImpl<$Res>
    extends _$WorkEntityCopyWithImpl<$Res, _$WorkEntityImpl>
    implements _$$WorkEntityImplCopyWith<$Res> {
  __$$WorkEntityImplCopyWithImpl(
      _$WorkEntityImpl _value, $Res Function(_$WorkEntityImpl) _then)
      : super(_value, _then);

  /// Create a copy of WorkEntity
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? title = null,
    Object? author = null,
    Object? remark = freezed,
    Object? style = null,
    Object? tool = null,
    Object? creationDate = null,
    Object? createTime = null,
    Object? updateTime = null,
    Object? lastImageUpdateTime = freezed,
    Object? status = null,
    Object? firstImageId = freezed,
    Object? images = null,
    Object? collectedChars = null,
    Object? tags = null,
    Object? imageCount = freezed,
  }) {
    return _then(_$WorkEntityImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      title: null == title
          ? _value.title
          : title // ignore: cast_nullable_to_non_nullable
              as String,
      author: null == author
          ? _value.author
          : author // ignore: cast_nullable_to_non_nullable
              as String,
      remark: freezed == remark
          ? _value.remark
          : remark // ignore: cast_nullable_to_non_nullable
              as String?,
      style: null == style
          ? _value.style
          : style // ignore: cast_nullable_to_non_nullable
              as WorkStyle,
      tool: null == tool
          ? _value.tool
          : tool // ignore: cast_nullable_to_non_nullable
              as WorkTool,
      creationDate: null == creationDate
          ? _value.creationDate
          : creationDate // ignore: cast_nullable_to_non_nullable
              as DateTime,
      createTime: null == createTime
          ? _value.createTime
          : createTime // ignore: cast_nullable_to_non_nullable
              as DateTime,
      updateTime: null == updateTime
          ? _value.updateTime
          : updateTime // ignore: cast_nullable_to_non_nullable
              as DateTime,
      lastImageUpdateTime: freezed == lastImageUpdateTime
          ? _value.lastImageUpdateTime
          : lastImageUpdateTime // ignore: cast_nullable_to_non_nullable
              as DateTime?,
      status: null == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as WorkStatus,
      firstImageId: freezed == firstImageId
          ? _value.firstImageId
          : firstImageId // ignore: cast_nullable_to_non_nullable
              as String?,
      images: null == images
          ? _value._images
          : images // ignore: cast_nullable_to_non_nullable
              as List<WorkImage>,
      collectedChars: null == collectedChars
          ? _value._collectedChars
          : collectedChars // ignore: cast_nullable_to_non_nullable
              as List<CharacterEntity>,
      tags: null == tags
          ? _value._tags
          : tags // ignore: cast_nullable_to_non_nullable
              as List<String>,
      imageCount: freezed == imageCount
          ? _value.imageCount
          : imageCount // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$WorkEntityImpl extends _WorkEntity {
  const _$WorkEntityImpl(
      {required this.id,
      required this.title,
      required this.author,
      this.remark,
      @JsonKey(fromJson: _workStyleFromJson, toJson: _workStyleToJson)
      required this.style,
      @JsonKey(fromJson: _workToolFromJson, toJson: _workToolToJson)
      required this.tool,
      required this.creationDate,
      required this.createTime,
      required this.updateTime,
      this.lastImageUpdateTime,
      this.status = WorkStatus.draft,
      this.firstImageId,
      final List<WorkImage> images = const [],
      final List<CharacterEntity> collectedChars = const [],
      final List<String> tags = const [],
      this.imageCount})
      : _images = images,
        _collectedChars = collectedChars,
        _tags = tags,
        super._();

  factory _$WorkEntityImpl.fromJson(Map<String, dynamic> json) =>
      _$$WorkEntityImplFromJson(json);

  /// ID
  @override
  final String id;

  /// 鏍囬
  @override
  final String title;

  /// 浣滆€?  @override
  final String author;

  /// 澶囨敞
  @override
  final String? remark;

  /// 瀛椾綋
  @override
  @JsonKey(fromJson: _workStyleFromJson, toJson: _workStyleToJson)
  final WorkStyle style;

  /// 宸ュ叿
  @override
  @JsonKey(fromJson: _workToolFromJson, toJson: _workToolToJson)
  final WorkTool tool;

  /// 鍒涗綔鏃ユ湡
  @override
  final DateTime creationDate;

  /// 鍒涘缓鏃堕棿
  @override
  final DateTime createTime;

  /// 淇敼鏃堕棿
  @override
  final DateTime updateTime;

  /// 鍥剧墖鏈€鍚庢洿鏂版椂闂?  @override
  final DateTime? lastImageUpdateTime;

  /// 鐘舵€?  @override
  @JsonKey()
  final WorkStatus status;

  /// 棣栧浘ID
  @override
  final String? firstImageId;

  /// 鍥剧墖鍒楄〃
  final List<WorkImage> _images;

  /// 鍥剧墖鍒楄〃
  @override
  @JsonKey()
  List<WorkImage> get images {
    if (_images is EqualUnmodifiableListView) return _images;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_images);
  }

  /// 鍏宠仈瀛楃鍒楄〃
  final List<CharacterEntity> _collectedChars;

  /// 鍏宠仈瀛楃鍒楄〃
  @override
  @JsonKey()
  List<CharacterEntity> get collectedChars {
    if (_collectedChars is EqualUnmodifiableListView) return _collectedChars;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_collectedChars);
  }

  /// 鏍囩鍒楄〃
  final List<String> _tags;

  /// 鏍囩鍒楄〃
  @override
  @JsonKey()
  List<String> get tags {
    if (_tags is EqualUnmodifiableListView) return _tags;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_tags);
  }

  /// 鍥剧墖鏁伴噺
  @override
  final int? imageCount;

  @override
  String toString() {
    return 'WorkEntity(id: $id, title: $title, author: $author, remark: $remark, style: $style, tool: $tool, creationDate: $creationDate, createTime: $createTime, updateTime: $updateTime, lastImageUpdateTime: $lastImageUpdateTime, status: $status, firstImageId: $firstImageId, images: $images, collectedChars: $collectedChars, tags: $tags, imageCount: $imageCount)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$WorkEntityImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.title, title) || other.title == title) &&
            (identical(other.author, author) || other.author == author) &&
            (identical(other.remark, remark) || other.remark == remark) &&
            (identical(other.style, style) || other.style == style) &&
            (identical(other.tool, tool) || other.tool == tool) &&
            (identical(other.creationDate, creationDate) ||
                other.creationDate == creationDate) &&
            (identical(other.createTime, createTime) ||
                other.createTime == createTime) &&
            (identical(other.updateTime, updateTime) ||
                other.updateTime == updateTime) &&
            (identical(other.lastImageUpdateTime, lastImageUpdateTime) ||
                other.lastImageUpdateTime == lastImageUpdateTime) &&
            (identical(other.status, status) || other.status == status) &&
            (identical(other.firstImageId, firstImageId) ||
                other.firstImageId == firstImageId) &&
            const DeepCollectionEquality().equals(other._images, _images) &&
            const DeepCollectionEquality()
                .equals(other._collectedChars, _collectedChars) &&
            const DeepCollectionEquality().equals(other._tags, _tags) &&
            (identical(other.imageCount, imageCount) ||
                other.imageCount == imageCount));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      title,
      author,
      remark,
      style,
      tool,
      creationDate,
      createTime,
      updateTime,
      lastImageUpdateTime,
      status,
      firstImageId,
      const DeepCollectionEquality().hash(_images),
      const DeepCollectionEquality().hash(_collectedChars),
      const DeepCollectionEquality().hash(_tags),
      imageCount);

  /// Create a copy of WorkEntity
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$WorkEntityImplCopyWith<_$WorkEntityImpl> get copyWith =>
      __$$WorkEntityImplCopyWithImpl<_$WorkEntityImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$WorkEntityImplToJson(
      this,
    );
  }
}

abstract class _WorkEntity extends WorkEntity {
  const factory _WorkEntity(
      {required final String id,
      required final String title,
      required final String author,
      final String? remark,
      @JsonKey(fromJson: _workStyleFromJson, toJson: _workStyleToJson)
      required final WorkStyle style,
      @JsonKey(fromJson: _workToolFromJson, toJson: _workToolToJson)
      required final WorkTool tool,
      required final DateTime creationDate,
      required final DateTime createTime,
      required final DateTime updateTime,
      final DateTime? lastImageUpdateTime,
      final WorkStatus status,
      final String? firstImageId,
      final List<WorkImage> images,
      final List<CharacterEntity> collectedChars,
      final List<String> tags,
      final int? imageCount}) = _$WorkEntityImpl;
  const _WorkEntity._() : super._();

  factory _WorkEntity.fromJson(Map<String, dynamic> json) =
      _$WorkEntityImpl.fromJson;

  /// ID
  @override
  String get id;

  /// 鏍囬
  @override
  String get title;

  /// 浣滆€?  @override
  String get author;

  /// 澶囨敞
  @override
  String? get remark;

  /// 瀛椾綋
  @override
  @JsonKey(fromJson: _workStyleFromJson, toJson: _workStyleToJson)
  WorkStyle get style;

  /// 宸ュ叿
  @override
  @JsonKey(fromJson: _workToolFromJson, toJson: _workToolToJson)
  WorkTool get tool;

  /// 鍒涗綔鏃ユ湡
  @override
  DateTime get creationDate;

  /// 鍒涘缓鏃堕棿
  @override
  DateTime get createTime;

  /// 淇敼鏃堕棿
  @override
  DateTime get updateTime;

  /// 鍥剧墖鏈€鍚庢洿鏂版椂闂?  @override
  DateTime? get lastImageUpdateTime;

  /// 鐘舵€?  @override
  WorkStatus get status;

  /// 棣栧浘ID
  @override
  String? get firstImageId;

  /// 鍥剧墖鍒楄〃
  @override
  List<WorkImage> get images;

  /// 鍏宠仈瀛楃鍒楄〃
  @override
  List<CharacterEntity> get collectedChars;

  /// 鏍囩鍒楄〃
  @override
  List<String> get tags;

  /// 鍥剧墖鏁伴噺
  @override
  int? get imageCount;

  /// Create a copy of WorkEntity
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$WorkEntityImplCopyWith<_$WorkEntityImpl> get copyWith =>
      throw _privateConstructorUsedError;
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\domain\models\work\work_entity.g.dart
-----------------------------------
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'work_entity.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_$WorkEntityImpl _$$WorkEntityImplFromJson(Map<String, dynamic> json) =>
    _$WorkEntityImpl(
      id: json['id'] as String,
      title: json['title'] as String,
      author: json['author'] as String,
      remark: json['remark'] as String?,
      style: _workStyleFromJson(json['style']),
      tool: _workToolFromJson(json['tool']),
      creationDate: DateTime.parse(json['creationDate'] as String),
      createTime: DateTime.parse(json['createTime'] as String),
      updateTime: DateTime.parse(json['updateTime'] as String),
      lastImageUpdateTime: json['lastImageUpdateTime'] == null
          ? null
          : DateTime.parse(json['lastImageUpdateTime'] as String),
      status: $enumDecodeNullable(_$WorkStatusEnumMap, json['status']) ??
          WorkStatus.draft,
      firstImageId: json['firstImageId'] as String?,
      images: (json['images'] as List<dynamic>?)
              ?.map((e) => WorkImage.fromJson(e as Map<String, dynamic>))
              .toList() ??
          const [],
      collectedChars: (json['collectedChars'] as List<dynamic>?)
              ?.map((e) => CharacterEntity.fromJson(e as Map<String, dynamic>))
              .toList() ??
          const [],
      tags:
          (json['tags'] as List<dynamic>?)?.map((e) => e as String).toList() ??
              const [],
      imageCount: (json['imageCount'] as num?)?.toInt(),
    );

Map<String, dynamic> _$$WorkEntityImplToJson(_$WorkEntityImpl instance) =>
    <String, dynamic>{
      'id': instance.id,
      'title': instance.title,
      'author': instance.author,
      'remark': instance.remark,
      'style': _workStyleToJson(instance.style),
      'tool': _workToolToJson(instance.tool),
      'creationDate': instance.creationDate.toIso8601String(),
      'createTime': instance.createTime.toIso8601String(),
      'updateTime': instance.updateTime.toIso8601String(),
      'lastImageUpdateTime': instance.lastImageUpdateTime?.toIso8601String(),
      'status': _$WorkStatusEnumMap[instance.status]!,
      'firstImageId': instance.firstImageId,
      'images': instance.images,
      'collectedChars': instance.collectedChars,
      'tags': instance.tags,
      'imageCount': instance.imageCount,
    };

const _$WorkStatusEnumMap = {
  WorkStatus.draft: 'draft',
  WorkStatus.published: 'published',
  WorkStatus.archived: 'archived',
};



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\domain\models\work\work_filter.dart
-----------------------------------
import 'package:flutter/material.dart';
import 'package:freezed_annotation/freezed_annotation.dart';

import '../../enums/work_style.dart';
import '../../enums/work_tool.dart';
import '../common/date_range_filter.dart';
import '../common/sort_option.dart';

part 'work_filter.freezed.dart';
part 'work_filter.g.dart';

DateTimeRange? _dateRangeFromJson(dynamic value) {
  if (value == null) return null;
  if (value is DateTimeRange) return value;
  return DateTimeRange(
    start: DateTime.parse(value['start']),
    end: DateTime.parse(value['end']),
  );
}

DateRangePreset _dateRangePresetFromJson(dynamic value) {
  if (value is DateRangePreset) return value;
  final str = value?.toString() ?? '';
  return DateRangePreset.values.firstWhere(
    (e) => e.name == str,
    orElse: () => DateRangePreset.all,
  );
}

String _dateRangePresetToJson(DateRangePreset preset) => preset.name;

Map<String, dynamic>? _dateRangeToJson(DateTimeRange? range) {
  if (range == null) return null;
  return {
    'start': range.start.toIso8601String(),
    'end': range.end.toIso8601String()
  };
}

// 澶勭悊鍙┖鐨勯鏍煎€?
WorkStyle? _workStyleFilterFromJson(dynamic value) {
  if (value == null || value.toString().isEmpty) return null;
  return WorkStyle.fromValue(value);
}

/// 鏋氫妇搴忓垪鍖栬緟鍔╂柟娉?
String? _workStyleToJson(WorkStyle? style) => style?.value;

// 澶勭悊鍙┖鐨勫伐鍏峰€?
WorkTool? _workToolFilterFromJson(dynamic value) {
  if (value == null || value.toString().isEmpty) return null;
  return WorkTool.fromValue(value);
}

String? _workToolToJson(WorkTool? tool) => tool?.value;

/// 浣滃搧绛涢€夋潯浠?
@freezed
class WorkFilter with _$WorkFilter {
  const factory WorkFilter({
    /// 鎼滅储鍏抽敭瀛?
    String? keyword,

    /// 浣滃搧椋庢牸
    @JsonKey(fromJson: _workStyleFilterFromJson, toJson: _workStyleToJson)
    WorkStyle? style,

    /// 鍒涗綔宸ュ叿
    @JsonKey(fromJson: _workToolFilterFromJson, toJson: _workToolToJson)
    WorkTool? tool,

    /// 鏍囩
    @Default([]) List<String> tags,

    /// 鍒涗綔鏃ユ湡鍖洪棿
    @JsonKey(fromJson: _dateRangeFromJson, toJson: _dateRangeToJson)
    DateTimeRange? dateRange,

    /// 鍒涘缓鏃堕棿鍖洪棿
    @JsonKey(fromJson: _dateRangeFromJson, toJson: _dateRangeToJson)
    DateTimeRange? createTimeRange,

    /// 淇敼鏃堕棿鍖洪棿
    @JsonKey(fromJson: _dateRangeFromJson, toJson: _dateRangeToJson)
    DateTimeRange? updateTimeRange,

    /// 鏃ユ湡棰勮
    @Default(DateRangePreset.all)
    @JsonKey(fromJson: _dateRangePresetFromJson, toJson: _dateRangePresetToJson)
    DateRangePreset datePreset,

    /// 鎺掑簭閫夐」
    @Default(SortOption()) SortOption sortOption,
  }) = _WorkFilter;

  factory WorkFilter.fromJson(Map<String, dynamic> json) =>
      _$WorkFilterFromJson(json);

  const WorkFilter._();

  /// 鏄惁涓虹┖杩囨护鍣?
  bool get isEmpty =>
      keyword == null &&
      style == null &&
      tool == null &&
      tags.isEmpty &&
      dateRange == null &&
      createTimeRange == null &&
      updateTimeRange == null &&
      datePreset == DateRangePreset.all &&
      sortOption.isDefault;

  /// 娣诲姞鏍囩
  WorkFilter addTag(String tag) {
    if (tags.contains(tag)) return this;
    return copyWith(tags: [...tags, tag]);
  }

  /// 娓呴櫎鍏ㄩ儴绛涢€?
  WorkFilter clear() => const WorkFilter();

  /// 娓呴櫎鏍囩
  WorkFilter clearTags() => copyWith(tags: const []);

  /// 绉婚櫎鏍囩
  WorkFilter removeTag(String tag) {
    return copyWith(tags: [...tags]..remove(tag));
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\domain\models\work\work_filter.freezed.dart
-----------------------------------
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'work_filter.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

WorkFilter _$WorkFilterFromJson(Map<String, dynamic> json) {
  return _WorkFilter.fromJson(json);
}

/// @nodoc
mixin _$WorkFilter {
  /// 鎼滅储鍏抽敭瀛?  String? get keyword => throw _privateConstructorUsedError;

  /// 浣滃搧椋庢牸
  @JsonKey(fromJson: _workStyleFilterFromJson, toJson: _workStyleToJson)
  WorkStyle? get style => throw _privateConstructorUsedError;

  /// 鍒涗綔宸ュ叿
  @JsonKey(fromJson: _workToolFilterFromJson, toJson: _workToolToJson)
  WorkTool? get tool => throw _privateConstructorUsedError;

  /// 鏍囩
  List<String> get tags => throw _privateConstructorUsedError;

  /// 鍒涗綔鏃ユ湡鍖洪棿
  @JsonKey(fromJson: _dateRangeFromJson, toJson: _dateRangeToJson)
  DateTimeRange? get dateRange => throw _privateConstructorUsedError;

  /// 鍒涘缓鏃堕棿鍖洪棿
  @JsonKey(fromJson: _dateRangeFromJson, toJson: _dateRangeToJson)
  DateTimeRange? get createTimeRange => throw _privateConstructorUsedError;

  /// 淇敼鏃堕棿鍖洪棿
  @JsonKey(fromJson: _dateRangeFromJson, toJson: _dateRangeToJson)
  DateTimeRange? get updateTimeRange => throw _privateConstructorUsedError;

  /// 鏃ユ湡棰勮
  @JsonKey(fromJson: _dateRangePresetFromJson, toJson: _dateRangePresetToJson)
  DateRangePreset get datePreset => throw _privateConstructorUsedError;

  /// 鎺掑簭閫夐」
  SortOption get sortOption => throw _privateConstructorUsedError;

  /// Serializes this WorkFilter to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of WorkFilter
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $WorkFilterCopyWith<WorkFilter> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $WorkFilterCopyWith<$Res> {
  factory $WorkFilterCopyWith(
          WorkFilter value, $Res Function(WorkFilter) then) =
      _$WorkFilterCopyWithImpl<$Res, WorkFilter>;
  @useResult
  $Res call(
      {String? keyword,
      @JsonKey(fromJson: _workStyleFilterFromJson, toJson: _workStyleToJson)
      WorkStyle? style,
      @JsonKey(fromJson: _workToolFilterFromJson, toJson: _workToolToJson)
      WorkTool? tool,
      List<String> tags,
      @JsonKey(fromJson: _dateRangeFromJson, toJson: _dateRangeToJson)
      DateTimeRange? dateRange,
      @JsonKey(fromJson: _dateRangeFromJson, toJson: _dateRangeToJson)
      DateTimeRange? createTimeRange,
      @JsonKey(fromJson: _dateRangeFromJson, toJson: _dateRangeToJson)
      DateTimeRange? updateTimeRange,
      @JsonKey(
          fromJson: _dateRangePresetFromJson, toJson: _dateRangePresetToJson)
      DateRangePreset datePreset,
      SortOption sortOption});

  $SortOptionCopyWith<$Res> get sortOption;
}

/// @nodoc
class _$WorkFilterCopyWithImpl<$Res, $Val extends WorkFilter>
    implements $WorkFilterCopyWith<$Res> {
  _$WorkFilterCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of WorkFilter
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? keyword = freezed,
    Object? style = freezed,
    Object? tool = freezed,
    Object? tags = null,
    Object? dateRange = freezed,
    Object? createTimeRange = freezed,
    Object? updateTimeRange = freezed,
    Object? datePreset = null,
    Object? sortOption = null,
  }) {
    return _then(_value.copyWith(
      keyword: freezed == keyword
          ? _value.keyword
          : keyword // ignore: cast_nullable_to_non_nullable
              as String?,
      style: freezed == style
          ? _value.style
          : style // ignore: cast_nullable_to_non_nullable
              as WorkStyle?,
      tool: freezed == tool
          ? _value.tool
          : tool // ignore: cast_nullable_to_non_nullable
              as WorkTool?,
      tags: null == tags
          ? _value.tags
          : tags // ignore: cast_nullable_to_non_nullable
              as List<String>,
      dateRange: freezed == dateRange
          ? _value.dateRange
          : dateRange // ignore: cast_nullable_to_non_nullable
              as DateTimeRange?,
      createTimeRange: freezed == createTimeRange
          ? _value.createTimeRange
          : createTimeRange // ignore: cast_nullable_to_non_nullable
              as DateTimeRange?,
      updateTimeRange: freezed == updateTimeRange
          ? _value.updateTimeRange
          : updateTimeRange // ignore: cast_nullable_to_non_nullable
              as DateTimeRange?,
      datePreset: null == datePreset
          ? _value.datePreset
          : datePreset // ignore: cast_nullable_to_non_nullable
              as DateRangePreset,
      sortOption: null == sortOption
          ? _value.sortOption
          : sortOption // ignore: cast_nullable_to_non_nullable
              as SortOption,
    ) as $Val);
  }

  /// Create a copy of WorkFilter
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $SortOptionCopyWith<$Res> get sortOption {
    return $SortOptionCopyWith<$Res>(_value.sortOption, (value) {
      return _then(_value.copyWith(sortOption: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$WorkFilterImplCopyWith<$Res>
    implements $WorkFilterCopyWith<$Res> {
  factory _$$WorkFilterImplCopyWith(
          _$WorkFilterImpl value, $Res Function(_$WorkFilterImpl) then) =
      __$$WorkFilterImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String? keyword,
      @JsonKey(fromJson: _workStyleFilterFromJson, toJson: _workStyleToJson)
      WorkStyle? style,
      @JsonKey(fromJson: _workToolFilterFromJson, toJson: _workToolToJson)
      WorkTool? tool,
      List<String> tags,
      @JsonKey(fromJson: _dateRangeFromJson, toJson: _dateRangeToJson)
      DateTimeRange? dateRange,
      @JsonKey(fromJson: _dateRangeFromJson, toJson: _dateRangeToJson)
      DateTimeRange? createTimeRange,
      @JsonKey(fromJson: _dateRangeFromJson, toJson: _dateRangeToJson)
      DateTimeRange? updateTimeRange,
      @JsonKey(
          fromJson: _dateRangePresetFromJson, toJson: _dateRangePresetToJson)
      DateRangePreset datePreset,
      SortOption sortOption});

  @override
  $SortOptionCopyWith<$Res> get sortOption;
}

/// @nodoc
class __$$WorkFilterImplCopyWithImpl<$Res>
    extends _$WorkFilterCopyWithImpl<$Res, _$WorkFilterImpl>
    implements _$$WorkFilterImplCopyWith<$Res> {
  __$$WorkFilterImplCopyWithImpl(
      _$WorkFilterImpl _value, $Res Function(_$WorkFilterImpl) _then)
      : super(_value, _then);

  /// Create a copy of WorkFilter
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? keyword = freezed,
    Object? style = freezed,
    Object? tool = freezed,
    Object? tags = null,
    Object? dateRange = freezed,
    Object? createTimeRange = freezed,
    Object? updateTimeRange = freezed,
    Object? datePreset = null,
    Object? sortOption = null,
  }) {
    return _then(_$WorkFilterImpl(
      keyword: freezed == keyword
          ? _value.keyword
          : keyword // ignore: cast_nullable_to_non_nullable
              as String?,
      style: freezed == style
          ? _value.style
          : style // ignore: cast_nullable_to_non_nullable
              as WorkStyle?,
      tool: freezed == tool
          ? _value.tool
          : tool // ignore: cast_nullable_to_non_nullable
              as WorkTool?,
      tags: null == tags
          ? _value._tags
          : tags // ignore: cast_nullable_to_non_nullable
              as List<String>,
      dateRange: freezed == dateRange
          ? _value.dateRange
          : dateRange // ignore: cast_nullable_to_non_nullable
              as DateTimeRange?,
      createTimeRange: freezed == createTimeRange
          ? _value.createTimeRange
          : createTimeRange // ignore: cast_nullable_to_non_nullable
              as DateTimeRange?,
      updateTimeRange: freezed == updateTimeRange
          ? _value.updateTimeRange
          : updateTimeRange // ignore: cast_nullable_to_non_nullable
              as DateTimeRange?,
      datePreset: null == datePreset
          ? _value.datePreset
          : datePreset // ignore: cast_nullable_to_non_nullable
              as DateRangePreset,
      sortOption: null == sortOption
          ? _value.sortOption
          : sortOption // ignore: cast_nullable_to_non_nullable
              as SortOption,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$WorkFilterImpl extends _WorkFilter {
  const _$WorkFilterImpl(
      {this.keyword,
      @JsonKey(fromJson: _workStyleFilterFromJson, toJson: _workStyleToJson)
      this.style,
      @JsonKey(fromJson: _workToolFilterFromJson, toJson: _workToolToJson)
      this.tool,
      final List<String> tags = const [],
      @JsonKey(fromJson: _dateRangeFromJson, toJson: _dateRangeToJson)
      this.dateRange,
      @JsonKey(fromJson: _dateRangeFromJson, toJson: _dateRangeToJson)
      this.createTimeRange,
      @JsonKey(fromJson: _dateRangeFromJson, toJson: _dateRangeToJson)
      this.updateTimeRange,
      @JsonKey(
          fromJson: _dateRangePresetFromJson, toJson: _dateRangePresetToJson)
      this.datePreset = DateRangePreset.all,
      this.sortOption = const SortOption()})
      : _tags = tags,
        super._();

  factory _$WorkFilterImpl.fromJson(Map<String, dynamic> json) =>
      _$$WorkFilterImplFromJson(json);

  /// 鎼滅储鍏抽敭瀛?  @override
  final String? keyword;

  /// 浣滃搧椋庢牸
  @override
  @JsonKey(fromJson: _workStyleFilterFromJson, toJson: _workStyleToJson)
  final WorkStyle? style;

  /// 鍒涗綔宸ュ叿
  @override
  @JsonKey(fromJson: _workToolFilterFromJson, toJson: _workToolToJson)
  final WorkTool? tool;

  /// 鏍囩
  final List<String> _tags;

  /// 鏍囩
  @override
  @JsonKey()
  List<String> get tags {
    if (_tags is EqualUnmodifiableListView) return _tags;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_tags);
  }

  /// 鍒涗綔鏃ユ湡鍖洪棿
  @override
  @JsonKey(fromJson: _dateRangeFromJson, toJson: _dateRangeToJson)
  final DateTimeRange? dateRange;

  /// 鍒涘缓鏃堕棿鍖洪棿
  @override
  @JsonKey(fromJson: _dateRangeFromJson, toJson: _dateRangeToJson)
  final DateTimeRange? createTimeRange;

  /// 淇敼鏃堕棿鍖洪棿
  @override
  @JsonKey(fromJson: _dateRangeFromJson, toJson: _dateRangeToJson)
  final DateTimeRange? updateTimeRange;

  /// 鏃ユ湡棰勮
  @override
  @JsonKey(fromJson: _dateRangePresetFromJson, toJson: _dateRangePresetToJson)
  final DateRangePreset datePreset;

  /// 鎺掑簭閫夐」
  @override
  @JsonKey()
  final SortOption sortOption;

  @override
  String toString() {
    return 'WorkFilter(keyword: $keyword, style: $style, tool: $tool, tags: $tags, dateRange: $dateRange, createTimeRange: $createTimeRange, updateTimeRange: $updateTimeRange, datePreset: $datePreset, sortOption: $sortOption)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$WorkFilterImpl &&
            (identical(other.keyword, keyword) || other.keyword == keyword) &&
            (identical(other.style, style) || other.style == style) &&
            (identical(other.tool, tool) || other.tool == tool) &&
            const DeepCollectionEquality().equals(other._tags, _tags) &&
            (identical(other.dateRange, dateRange) ||
                other.dateRange == dateRange) &&
            (identical(other.createTimeRange, createTimeRange) ||
                other.createTimeRange == createTimeRange) &&
            (identical(other.updateTimeRange, updateTimeRange) ||
                other.updateTimeRange == updateTimeRange) &&
            (identical(other.datePreset, datePreset) ||
                other.datePreset == datePreset) &&
            (identical(other.sortOption, sortOption) ||
                other.sortOption == sortOption));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      keyword,
      style,
      tool,
      const DeepCollectionEquality().hash(_tags),
      dateRange,
      createTimeRange,
      updateTimeRange,
      datePreset,
      sortOption);

  /// Create a copy of WorkFilter
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$WorkFilterImplCopyWith<_$WorkFilterImpl> get copyWith =>
      __$$WorkFilterImplCopyWithImpl<_$WorkFilterImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$WorkFilterImplToJson(
      this,
    );
  }
}

abstract class _WorkFilter extends WorkFilter {
  const factory _WorkFilter(
      {final String? keyword,
      @JsonKey(fromJson: _workStyleFilterFromJson, toJson: _workStyleToJson)
      final WorkStyle? style,
      @JsonKey(fromJson: _workToolFilterFromJson, toJson: _workToolToJson)
      final WorkTool? tool,
      final List<String> tags,
      @JsonKey(fromJson: _dateRangeFromJson, toJson: _dateRangeToJson)
      final DateTimeRange? dateRange,
      @JsonKey(fromJson: _dateRangeFromJson, toJson: _dateRangeToJson)
      final DateTimeRange? createTimeRange,
      @JsonKey(fromJson: _dateRangeFromJson, toJson: _dateRangeToJson)
      final DateTimeRange? updateTimeRange,
      @JsonKey(
          fromJson: _dateRangePresetFromJson, toJson: _dateRangePresetToJson)
      final DateRangePreset datePreset,
      final SortOption sortOption}) = _$WorkFilterImpl;
  const _WorkFilter._() : super._();

  factory _WorkFilter.fromJson(Map<String, dynamic> json) =
      _$WorkFilterImpl.fromJson;

  /// 鎼滅储鍏抽敭瀛?  @override
  String? get keyword;

  /// 浣滃搧椋庢牸
  @override
  @JsonKey(fromJson: _workStyleFilterFromJson, toJson: _workStyleToJson)
  WorkStyle? get style;

  /// 鍒涗綔宸ュ叿
  @override
  @JsonKey(fromJson: _workToolFilterFromJson, toJson: _workToolToJson)
  WorkTool? get tool;

  /// 鏍囩
  @override
  List<String> get tags;

  /// 鍒涗綔鏃ユ湡鍖洪棿
  @override
  @JsonKey(fromJson: _dateRangeFromJson, toJson: _dateRangeToJson)
  DateTimeRange? get dateRange;

  /// 鍒涘缓鏃堕棿鍖洪棿
  @override
  @JsonKey(fromJson: _dateRangeFromJson, toJson: _dateRangeToJson)
  DateTimeRange? get createTimeRange;

  /// 淇敼鏃堕棿鍖洪棿
  @override
  @JsonKey(fromJson: _dateRangeFromJson, toJson: _dateRangeToJson)
  DateTimeRange? get updateTimeRange;

  /// 鏃ユ湡棰勮
  @override
  @JsonKey(fromJson: _dateRangePresetFromJson, toJson: _dateRangePresetToJson)
  DateRangePreset get datePreset;

  /// 鎺掑簭閫夐」
  @override
  SortOption get sortOption;

  /// Create a copy of WorkFilter
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$WorkFilterImplCopyWith<_$WorkFilterImpl> get copyWith =>
      throw _privateConstructorUsedError;
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\domain\models\work\work_filter.g.dart
-----------------------------------
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'work_filter.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_$WorkFilterImpl _$$WorkFilterImplFromJson(Map<String, dynamic> json) =>
    _$WorkFilterImpl(
      keyword: json['keyword'] as String?,
      style: _workStyleFilterFromJson(json['style']),
      tool: _workToolFilterFromJson(json['tool']),
      tags:
          (json['tags'] as List<dynamic>?)?.map((e) => e as String).toList() ??
              const [],
      dateRange: _dateRangeFromJson(json['dateRange']),
      createTimeRange: _dateRangeFromJson(json['createTimeRange']),
      updateTimeRange: _dateRangeFromJson(json['updateTimeRange']),
      datePreset: json['datePreset'] == null
          ? DateRangePreset.all
          : _dateRangePresetFromJson(json['datePreset']),
      sortOption: json['sortOption'] == null
          ? const SortOption()
          : SortOption.fromJson(json['sortOption'] as Map<String, dynamic>),
    );

Map<String, dynamic> _$$WorkFilterImplToJson(_$WorkFilterImpl instance) =>
    <String, dynamic>{
      'keyword': instance.keyword,
      'style': _workStyleToJson(instance.style),
      'tool': _workToolToJson(instance.tool),
      'tags': instance.tags,
      'dateRange': _dateRangeToJson(instance.dateRange),
      'createTimeRange': _dateRangeToJson(instance.createTimeRange),
      'updateTimeRange': _dateRangeToJson(instance.updateTimeRange),
      'datePreset': _dateRangePresetToJson(instance.datePreset),
      'sortOption': instance.sortOption,
    };



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\domain\models\work\work_image.dart
-----------------------------------
import 'package:freezed_annotation/freezed_annotation.dart';
import 'package:path/path.dart' as p;

part 'work_image.freezed.dart';
part 'work_image.g.dart';

/// 浣滃搧鍥剧墖
@freezed
class WorkImage with _$WorkImage {
  factory WorkImage({
    /// ID
    required String id,

    /// 鍏宠仈鐨勪綔鍝両D
    required String workId,

    /// 瀵煎叆鏃剁殑鍘熷璺緞
    required String originalPath,

    /// 鍥剧墖璺緞
    required String path,

    /// 缂╃暐鍥捐矾寰?
    required String thumbnailPath,

    /// 鍦ㄤ綔鍝佷腑鐨勫簭鍙?
    required int index,

    /// 鍥剧墖瀹藉害
    required int width,

    /// 鍥剧墖楂樺害
    required int height,

    /// 鏂囦欢鏍煎紡
    required String format,

    /// 鏂囦欢澶у皬(瀛楄妭)
    required int size,

    /// 鍒涘缓鏃堕棿
    required DateTime createTime,

    /// 鏇存柊鏃堕棿
    required DateTime updateTime,
  }) = _WorkImage;

  /// 鍒涘缓鏂板浘鐗?
  @Deprecated('浣跨敤 WorkImage(...) 鏋勯€犲嚱鏁版浛浠?)
  factory WorkImage.create({
    required String id,
    required String workId,
    required String originalPath,
    required String path,
    required String thumbnailPath,
    required int index,
    required int width,
    required int height,
    required String format,
    required int size,
  }) =>
      WorkImage(
        id: id,
        workId: workId,
        originalPath: originalPath,
        path: path,
        thumbnailPath: thumbnailPath,
        index: index,
        width: width,
        height: height,
        format: format,
        size: size,
        createTime: DateTime.now(),
        updateTime: DateTime.now(),
      );

  factory WorkImage.fromJson(Map<String, dynamic> json) =>
      _$WorkImageFromJson(json);

  const WorkImage._();

  /// 鐩綍璺緞
  String get directory => p.dirname(path);

  /// 鎵╁睍鍚?
  String get extension {
    final ext = p.extension(path);
    return ext.isEmpty ? '' : ext.substring(1);
  }

  /// 鏂囦欢鍚?鍚墿灞曞悕)
  String get filename => p.basename(path);

  /// 鏂囦欢鍚?涓嶅惈鎵╁睍鍚?
  String get name => p.basenameWithoutExtension(path);
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\domain\models\work\work_image.freezed.dart
-----------------------------------
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'work_image.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

WorkImage _$WorkImageFromJson(Map<String, dynamic> json) {
  return _WorkImage.fromJson(json);
}

/// @nodoc
mixin _$WorkImage {
  /// ID
  String get id => throw _privateConstructorUsedError;

  /// 鍏宠仈鐨勪綔鍝両D
  String get workId => throw _privateConstructorUsedError;

  /// 瀵煎叆鏃剁殑鍘熷璺緞
  String get originalPath => throw _privateConstructorUsedError;

  /// 鍥剧墖璺緞
  String get path => throw _privateConstructorUsedError;

  /// 缂╃暐鍥捐矾寰?  String get thumbnailPath => throw _privateConstructorUsedError;

  /// 鍦ㄤ綔鍝佷腑鐨勫簭鍙?  int get index => throw _privateConstructorUsedError;

  /// 鍥剧墖瀹藉害
  int get width => throw _privateConstructorUsedError;

  /// 鍥剧墖楂樺害
  int get height => throw _privateConstructorUsedError;

  /// 鏂囦欢鏍煎紡
  String get format => throw _privateConstructorUsedError;

  /// 鏂囦欢澶у皬(瀛楄妭)
  int get size => throw _privateConstructorUsedError;

  /// 鍒涘缓鏃堕棿
  DateTime get createTime => throw _privateConstructorUsedError;

  /// 鏇存柊鏃堕棿
  DateTime get updateTime => throw _privateConstructorUsedError;

  /// Serializes this WorkImage to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of WorkImage
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $WorkImageCopyWith<WorkImage> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $WorkImageCopyWith<$Res> {
  factory $WorkImageCopyWith(WorkImage value, $Res Function(WorkImage) then) =
      _$WorkImageCopyWithImpl<$Res, WorkImage>;
  @useResult
  $Res call(
      {String id,
      String workId,
      String originalPath,
      String path,
      String thumbnailPath,
      int index,
      int width,
      int height,
      String format,
      int size,
      DateTime createTime,
      DateTime updateTime});
}

/// @nodoc
class _$WorkImageCopyWithImpl<$Res, $Val extends WorkImage>
    implements $WorkImageCopyWith<$Res> {
  _$WorkImageCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of WorkImage
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? workId = null,
    Object? originalPath = null,
    Object? path = null,
    Object? thumbnailPath = null,
    Object? index = null,
    Object? width = null,
    Object? height = null,
    Object? format = null,
    Object? size = null,
    Object? createTime = null,
    Object? updateTime = null,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      workId: null == workId
          ? _value.workId
          : workId // ignore: cast_nullable_to_non_nullable
              as String,
      originalPath: null == originalPath
          ? _value.originalPath
          : originalPath // ignore: cast_nullable_to_non_nullable
              as String,
      path: null == path
          ? _value.path
          : path // ignore: cast_nullable_to_non_nullable
              as String,
      thumbnailPath: null == thumbnailPath
          ? _value.thumbnailPath
          : thumbnailPath // ignore: cast_nullable_to_non_nullable
              as String,
      index: null == index
          ? _value.index
          : index // ignore: cast_nullable_to_non_nullable
              as int,
      width: null == width
          ? _value.width
          : width // ignore: cast_nullable_to_non_nullable
              as int,
      height: null == height
          ? _value.height
          : height // ignore: cast_nullable_to_non_nullable
              as int,
      format: null == format
          ? _value.format
          : format // ignore: cast_nullable_to_non_nullable
              as String,
      size: null == size
          ? _value.size
          : size // ignore: cast_nullable_to_non_nullable
              as int,
      createTime: null == createTime
          ? _value.createTime
          : createTime // ignore: cast_nullable_to_non_nullable
              as DateTime,
      updateTime: null == updateTime
          ? _value.updateTime
          : updateTime // ignore: cast_nullable_to_non_nullable
              as DateTime,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$WorkImageImplCopyWith<$Res>
    implements $WorkImageCopyWith<$Res> {
  factory _$$WorkImageImplCopyWith(
          _$WorkImageImpl value, $Res Function(_$WorkImageImpl) then) =
      __$$WorkImageImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      String workId,
      String originalPath,
      String path,
      String thumbnailPath,
      int index,
      int width,
      int height,
      String format,
      int size,
      DateTime createTime,
      DateTime updateTime});
}

/// @nodoc
class __$$WorkImageImplCopyWithImpl<$Res>
    extends _$WorkImageCopyWithImpl<$Res, _$WorkImageImpl>
    implements _$$WorkImageImplCopyWith<$Res> {
  __$$WorkImageImplCopyWithImpl(
      _$WorkImageImpl _value, $Res Function(_$WorkImageImpl) _then)
      : super(_value, _then);

  /// Create a copy of WorkImage
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? workId = null,
    Object? originalPath = null,
    Object? path = null,
    Object? thumbnailPath = null,
    Object? index = null,
    Object? width = null,
    Object? height = null,
    Object? format = null,
    Object? size = null,
    Object? createTime = null,
    Object? updateTime = null,
  }) {
    return _then(_$WorkImageImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      workId: null == workId
          ? _value.workId
          : workId // ignore: cast_nullable_to_non_nullable
              as String,
      originalPath: null == originalPath
          ? _value.originalPath
          : originalPath // ignore: cast_nullable_to_non_nullable
              as String,
      path: null == path
          ? _value.path
          : path // ignore: cast_nullable_to_non_nullable
              as String,
      thumbnailPath: null == thumbnailPath
          ? _value.thumbnailPath
          : thumbnailPath // ignore: cast_nullable_to_non_nullable
              as String,
      index: null == index
          ? _value.index
          : index // ignore: cast_nullable_to_non_nullable
              as int,
      width: null == width
          ? _value.width
          : width // ignore: cast_nullable_to_non_nullable
              as int,
      height: null == height
          ? _value.height
          : height // ignore: cast_nullable_to_non_nullable
              as int,
      format: null == format
          ? _value.format
          : format // ignore: cast_nullable_to_non_nullable
              as String,
      size: null == size
          ? _value.size
          : size // ignore: cast_nullable_to_non_nullable
              as int,
      createTime: null == createTime
          ? _value.createTime
          : createTime // ignore: cast_nullable_to_non_nullable
              as DateTime,
      updateTime: null == updateTime
          ? _value.updateTime
          : updateTime // ignore: cast_nullable_to_non_nullable
              as DateTime,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$WorkImageImpl extends _WorkImage {
  _$WorkImageImpl(
      {required this.id,
      required this.workId,
      required this.originalPath,
      required this.path,
      required this.thumbnailPath,
      required this.index,
      required this.width,
      required this.height,
      required this.format,
      required this.size,
      required this.createTime,
      required this.updateTime})
      : super._();

  factory _$WorkImageImpl.fromJson(Map<String, dynamic> json) =>
      _$$WorkImageImplFromJson(json);

  /// ID
  @override
  final String id;

  /// 鍏宠仈鐨勪綔鍝両D
  @override
  final String workId;

  /// 瀵煎叆鏃剁殑鍘熷璺緞
  @override
  final String originalPath;

  /// 鍥剧墖璺緞
  @override
  final String path;

  /// 缂╃暐鍥捐矾寰?  @override
  final String thumbnailPath;

  /// 鍦ㄤ綔鍝佷腑鐨勫簭鍙?  @override
  final int index;

  /// 鍥剧墖瀹藉害
  @override
  final int width;

  /// 鍥剧墖楂樺害
  @override
  final int height;

  /// 鏂囦欢鏍煎紡
  @override
  final String format;

  /// 鏂囦欢澶у皬(瀛楄妭)
  @override
  final int size;

  /// 鍒涘缓鏃堕棿
  @override
  final DateTime createTime;

  /// 鏇存柊鏃堕棿
  @override
  final DateTime updateTime;

  @override
  String toString() {
    return 'WorkImage(id: $id, workId: $workId, originalPath: $originalPath, path: $path, thumbnailPath: $thumbnailPath, index: $index, width: $width, height: $height, format: $format, size: $size, createTime: $createTime, updateTime: $updateTime)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$WorkImageImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.workId, workId) || other.workId == workId) &&
            (identical(other.originalPath, originalPath) ||
                other.originalPath == originalPath) &&
            (identical(other.path, path) || other.path == path) &&
            (identical(other.thumbnailPath, thumbnailPath) ||
                other.thumbnailPath == thumbnailPath) &&
            (identical(other.index, index) || other.index == index) &&
            (identical(other.width, width) || other.width == width) &&
            (identical(other.height, height) || other.height == height) &&
            (identical(other.format, format) || other.format == format) &&
            (identical(other.size, size) || other.size == size) &&
            (identical(other.createTime, createTime) ||
                other.createTime == createTime) &&
            (identical(other.updateTime, updateTime) ||
                other.updateTime == updateTime));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      workId,
      originalPath,
      path,
      thumbnailPath,
      index,
      width,
      height,
      format,
      size,
      createTime,
      updateTime);

  /// Create a copy of WorkImage
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$WorkImageImplCopyWith<_$WorkImageImpl> get copyWith =>
      __$$WorkImageImplCopyWithImpl<_$WorkImageImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$WorkImageImplToJson(
      this,
    );
  }
}

abstract class _WorkImage extends WorkImage {
  factory _WorkImage(
      {required final String id,
      required final String workId,
      required final String originalPath,
      required final String path,
      required final String thumbnailPath,
      required final int index,
      required final int width,
      required final int height,
      required final String format,
      required final int size,
      required final DateTime createTime,
      required final DateTime updateTime}) = _$WorkImageImpl;
  _WorkImage._() : super._();

  factory _WorkImage.fromJson(Map<String, dynamic> json) =
      _$WorkImageImpl.fromJson;

  /// ID
  @override
  String get id;

  /// 鍏宠仈鐨勪綔鍝両D
  @override
  String get workId;

  /// 瀵煎叆鏃剁殑鍘熷璺緞
  @override
  String get originalPath;

  /// 鍥剧墖璺緞
  @override
  String get path;

  /// 缂╃暐鍥捐矾寰?  @override
  String get thumbnailPath;

  /// 鍦ㄤ綔鍝佷腑鐨勫簭鍙?  @override
  int get index;

  /// 鍥剧墖瀹藉害
  @override
  int get width;

  /// 鍥剧墖楂樺害
  @override
  int get height;

  /// 鏂囦欢鏍煎紡
  @override
  String get format;

  /// 鏂囦欢澶у皬(瀛楄妭)
  @override
  int get size;

  /// 鍒涘缓鏃堕棿
  @override
  DateTime get createTime;

  /// 鏇存柊鏃堕棿
  @override
  DateTime get updateTime;

  /// Create a copy of WorkImage
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$WorkImageImplCopyWith<_$WorkImageImpl> get copyWith =>
      throw _privateConstructorUsedError;
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\domain\models\work\work_image.g.dart
-----------------------------------
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'work_image.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_$WorkImageImpl _$$WorkImageImplFromJson(Map<String, dynamic> json) =>
    _$WorkImageImpl(
      id: json['id'] as String,
      workId: json['workId'] as String,
      originalPath: json['originalPath'] as String,
      path: json['path'] as String,
      thumbnailPath: json['thumbnailPath'] as String,
      index: (json['index'] as num).toInt(),
      width: (json['width'] as num).toInt(),
      height: (json['height'] as num).toInt(),
      format: json['format'] as String,
      size: (json['size'] as num).toInt(),
      createTime: DateTime.parse(json['createTime'] as String),
      updateTime: DateTime.parse(json['updateTime'] as String),
    );

Map<String, dynamic> _$$WorkImageImplToJson(_$WorkImageImpl instance) =>
    <String, dynamic>{
      'id': instance.id,
      'workId': instance.workId,
      'originalPath': instance.originalPath,
      'path': instance.path,
      'thumbnailPath': instance.thumbnailPath,
      'index': instance.index,
      'width': instance.width,
      'height': instance.height,
      'format': instance.format,
      'size': instance.size,
      'createTime': instance.createTime.toIso8601String(),
      'updateTime': instance.updateTime.toIso8601String(),
    };



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\domain\models\work\work_metadata.dart
-----------------------------------
import 'package:equatable/equatable.dart';

import '../../../domain/enums/work_style.dart';
import '../../../domain/enums/work_tool.dart';

/// 浣滃搧鍏冩暟鎹?
class WorkMetadata extends Equatable {
  /// 鍚嶇О
  final String name;

  /// 浣滆€?
  final String author;

  /// 鍒涗綔鏃ユ湡
  final DateTime? creationDate;

  /// 澶囨敞
  final String? remark;

  /// 椋庢牸
  final WorkStyle style;

  /// 宸ュ叿
  final WorkTool tool;

  /// 鏍囩
  final Set<String> tags;

  /// 鍒涘缓浣滃搧鍏冩暟鎹?
  const WorkMetadata({
    required this.name,
    required this.author,
    required this.style,
    required this.tool,
    this.creationDate,
    this.remark,
    Set<String>? tags,
  }) : tags = tags ?? const {};

  /// 浠嶫SON鍒涘缓
  factory WorkMetadata.fromJson(Map<String, dynamic> json) {
    return WorkMetadata(
      name: json['name'] as String,
      author: json['author'] as String,
      style: WorkStyle.values.byName(json['style'] as String),
      tool: WorkTool.values.byName(json['tool'] as String),
      creationDate: json['creationDate'] == null
          ? null
          : DateTime.parse(json['creationDate'] as String),
      remark: json['remark'] as String?,
      tags: (json['tags'] as List<dynamic>?)?.map((e) => e as String).toSet() ??
          {},
    );
  }

  /// 妫€鏌ユ槸鍚︽湁浠讳綍鏍囩
  bool get hasTags => tags.isNotEmpty;

  @override
  List<Object?> get props => [
        name,
        author,
        style,
        tool,
        creationDate,
        remark,
        tags,
      ];

  /// 娣诲姞鏍囩
  WorkMetadata addTag(String tag) {
    final newTags = Set<String>.from(tags)..add(tag);
    return copyWith(tags: newTags);
  }

  /// 澶嶅埗
  WorkMetadata copyWith({
    String? name,
    String? author,
    WorkStyle? style,
    WorkTool? tool,
    DateTime? creationDate,
    String? remark,
    Set<String>? tags,
  }) {
    return WorkMetadata(
      name: name ?? this.name,
      author: author ?? this.author,
      style: style ?? this.style,
      tool: tool ?? this.tool,
      creationDate: creationDate ?? this.creationDate,
      remark: remark ?? this.remark,
      tags: tags ?? this.tags,
    );
  }

  /// 鏄惁鍖呭惈鏍囩
  bool hasTag(String tag) => tags.contains(tag);

  /// 绉婚櫎鏍囩
  WorkMetadata removeTag(String tag) {
    final newTags = Set<String>.from(tags)..remove(tag);
    return copyWith(tags: newTags);
  }

  /// 杞崲涓篔SON
  Map<String, dynamic> toJson() {
    return {
      'name': name,
      'author': author,
      'style': style.name,
      'tool': tool.name,
      'creationDate': creationDate?.toIso8601String(),
      'remark': remark,
      'tags': tags.toList(),
    };
  }

  @override
  String toString() => 'WorkMetadata(name: $name, author: $author)';

  /// 鏇存柊鏍囩
  WorkMetadata updateTags(Set<String> newTags) {
    return copyWith(tags: newTags);
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\domain\repositories\character_repository.dart
-----------------------------------
import '../models/character/character_entity.dart';
import '../models/character/character_region.dart';

/// 瀛楀舰浠撳簱鎺ュ彛
abstract class CharacterRepository {
  /// 鑾峰彇瀛楀舰鏁伴噺
  Future<int> count(CharacterFilter? filter);

  /// 鍒涘缓瀛楀舰
  Future<CharacterEntity> create(CharacterEntity character);

  /// 鍒犻櫎瀛楀舰
  Future<void> delete(String id);

  /// 鎵归噺鍒犻櫎瀛楃
  Future<void> deleteBatch(List<String> ids);

  /// 鎵归噺鍒犻櫎
  Future<void> deleteMany(List<String> ids);

  /// 鏍规嵁ID鏌ユ壘鍗曚釜瀛楃
  Future<CharacterEntity?> findById(String id);

  /// 鏍规嵁浣滃搧ID鏌ユ壘瀛楃
  Future<List<CharacterEntity>> findByWorkId(String workId);

  /// 鑾峰彇瀛楀舰
  Future<CharacterEntity?> get(String id);

  /// 鑾峰彇鎵€鏈夊瓧褰?
  Future<List<CharacterEntity>> getAll();

  /// 鏍规嵁浣滃搧ID鑾峰彇瀛楀舰
  Future<List<CharacterEntity>> getByWorkId(String workId);

  /// 鏍规嵁椤甸潰ID鑾峰彇瀛楃鍖哄煙
  Future<List<CharacterRegion>> getRegionsByPageId(String pageId);

  /// 鑾峰彇瀛楃鐨勬墍鏈夊尯鍩熶俊鎭?
  Future<List<CharacterRegion>> getRegionsByWorkId(String workId);

  /// 鏉′欢鏌ヨ
  Future<List<CharacterEntity>> query(CharacterFilter filter);

  /// 鏇存柊瀛楀舰
  Future<CharacterEntity> save(CharacterEntity character);

  /// 鎵归噺鏇存柊
  Future<List<CharacterEntity>> saveMany(List<CharacterEntity> characters);

  /// 鎼滅储瀛楀舰
  Future<List<CharacterEntity>> search(String query, {int? limit});

  /// 鏇存柊瀛楃鍖哄煙
  Future<void> updateRegion(CharacterRegion region);
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\domain\repositories\practice_repository.dart
-----------------------------------
import '../models/practice/practice_entity.dart';
import '../models/practice/practice_filter.dart';

/// 瀛楀笘缁冧範浠撳簱鎺ュ彛
abstract class PracticeRepository {
  /// 鍏抽棴浠撳簱
  Future<void> close();

  /// 鑾峰彇缁冧範鏁伴噺
  Future<int> count(PracticeFilter? filter);

  /// 鍒涘缓缁冧範
  Future<PracticeEntity> create(PracticeEntity practice);

  /// 鍒犻櫎缁冧範
  Future<void> delete(String id);

  /// 鎵归噺鍒犻櫎
  Future<void> deleteMany(List<String> ids);

  /// 澶嶅埗缁冧範
  Future<PracticeEntity> duplicate(String id, {String? newId});

  /// 鑾峰彇缁冧範
  Future<PracticeEntity?> get(String id);

  /// 鑾峰彇鎵€鏈夌粌涔?
  Future<List<PracticeEntity>> getAll();

  /// 鑾峰彇鎵€鏈夋爣绛?
  Future<Set<String>> getAllTags();

  /// 鑾峰彇鏌愪簺鏍囩鐨勭粌涔?
  Future<List<PracticeEntity>> getByTags(Set<String> tags);

  /// 鏌ヨ缁冧範
  Future<List<PracticeEntity>> query(PracticeFilter filter);

  /// 鏇存柊缁冧範
  Future<PracticeEntity> save(PracticeEntity practice);

  /// 鎵归噺鏇存柊
  Future<List<PracticeEntity>> saveMany(List<PracticeEntity> practices);

  /// 鎼滅储缁冧範
  Future<List<PracticeEntity>> search(String query, {int? limit});

  /// 鏍囩寤鸿
  Future<List<String>> suggestTags(String prefix, {int limit = 10});
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\domain\repositories\repositories.dart
-----------------------------------
/// 瀵煎嚭鎵€鏈変粨搴撴帴鍙?
export 'character_repository.dart';
export 'practice_repository.dart';
export 'work_image_repository.dart';
export 'work_repository.dart';



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\domain\repositories\settings_repository.dart
-----------------------------------
/// 璁剧疆浠撳偍鎺ュ彛
abstract class SettingsRepository {
  /// 鍒犻櫎璁剧疆鍊?
  Future<void> deleteValue(String key);

  /// 鑾峰彇璁剧疆鍊?
  Future<String?> getValue(String key);

  /// 鎵归噺鑾峰彇璁剧疆鍊?
  Future<Map<String, String>> getValues(List<String> keys);

  /// 淇濆瓨璁剧疆鍊?
  Future<void> setValue(String key, String value);

  /// 鎵归噺淇濆瓨璁剧疆鍊?
  Future<void> setValues(Map<String, String> values);
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\domain\repositories\work_image_repository.dart
-----------------------------------
import '../models/work/work_image.dart';

/// WorkImage浠撳偍鎺ュ彛
abstract class WorkImageRepository {
  /// 鍒涘缓鍥剧墖璁板綍
  Future<WorkImage> create(String workId, WorkImage image);

  /// 鎵归噺鍒涘缓
  Future<List<WorkImage>> createMany(String workId, List<WorkImage> images);

  /// 鍒犻櫎鍥剧墖
  Future<void> delete(String workId, String imageId);

  /// 鎵归噺鍒犻櫎
  Future<void> deleteMany(String workId, List<String> imageIds);

  /// 鑾峰彇鍥剧墖
  Future<WorkImage?> get(String imageId);

  /// 鑾峰彇浣滃搧鐨勬墍鏈夊浘鐗?
  Future<List<WorkImage>> getAllByWorkId(String workId);

  /// 鑾峰彇浣滃搧鐨勭涓€寮犲浘鐗?
  Future<WorkImage?> getFirstByWorkId(String workId);

  /// 鑾峰彇涓嬩竴涓彲鐢ㄧ殑绱㈠紩鍙?
  Future<int> getNextIndex(String workId);

  /// 鎵归噺鏇存柊
  Future<List<WorkImage>> saveMany(List<WorkImage> images);

  /// 鏇存柊鍥剧墖绱㈠紩
  Future<void> updateIndex(String workId, String imageId, int newIndex);
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\domain\repositories\work_repository.dart
-----------------------------------
import '../models/work/work_entity.dart';
import '../models/work/work_filter.dart';

/// 浣滃搧浠撳簱鎺ュ彛
abstract class WorkRepository {
  /// 鍏抽棴浠撳簱
  Future<void> close();

  /// 鑾峰彇浣滃搧鏁伴噺
  Future<int> count(WorkFilter? filter);

  /// 鍒涘缓浣滃搧
  Future<WorkEntity> create(WorkEntity work);

  /// 鍒犻櫎浣滃搧
  Future<void> delete(String id);

  /// 鎵归噺鍒犻櫎
  Future<void> deleteMany(List<String> ids);

  /// 澶嶅埗浣滃搧
  Future<WorkEntity> duplicate(String id, {String? newId});

  /// 鑾峰彇浣滃搧
  Future<WorkEntity?> get(String id);

  /// 鑾峰彇鎵€鏈変綔鍝?
  Future<List<WorkEntity>> getAll();

  /// 鑾峰彇鎵€鏈夋爣绛?
  Future<Set<String>> getAllTags();

  /// 鑾峰彇鏌愪簺鏍囩鐨勪綔鍝?
  Future<List<WorkEntity>> getByTags(Set<String> tags);

  /// 鏌ヨ浣滃搧
  Future<List<WorkEntity>> query(WorkFilter filter);

  /// 鏇存柊浣滃搧
  Future<WorkEntity> save(WorkEntity work);

  /// 鎵归噺鏇存柊
  Future<List<WorkEntity>> saveMany(List<WorkEntity> works);

  /// 鎼滅储浣滃搧
  Future<List<WorkEntity>> search(String query, {int? limit});

  /// 鏍囩寤鸿
  Future<List<String>> suggestTags(String prefix, {int limit = 10});
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\infrastructure\events\event_bus.dart
-----------------------------------
import 'dart:async';

/// 浜嬩欢鎬荤嚎锛岀敤浜庣粍浠堕棿閫氫俊
class EventBus {
  final _controller = StreamController.broadcast();

  /// 鍏抽棴浜嬩欢鎬荤嚎
  void dispose() {
    _controller.close();
  }

  /// 鍙戦€佷簨浠?
  void fire(dynamic event) {
    _controller.add(event);
  }

  /// 鐩戝惉浜嬩欢
  StreamSubscription<T> on<T>() {
    return _controller.stream
        .where((event) => event is T)
        .cast<T>()
        .listen(null);
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\infrastructure\image\default_image_processor.dart
-----------------------------------
import 'dart:io';
import 'dart:math' as math;
import 'dart:typed_data';

import 'package:flutter/material.dart';
import 'package:image/image.dart' as img;
import 'package:path/path.dart' as path;
import 'package:path_provider/path_provider.dart';

import '../../domain/models/character/detected_outline.dart';
import './image_processor.dart';

class DefaultImageProcessor implements ImageProcessor {
  late final String _tempPath;
  late final String _thumbnailPath;

  DefaultImageProcessor() {
    _initPaths();
  }

  @override
  String get tempPath => _tempPath;

  @override
  String get thumbnailCachePath => _thumbnailPath;

  @override
  Future<Uint8List> applyEraseMask(
    Uint8List image,
    List<List<Offset>> erasePaths,
    double brushSize,
  ) async {
    final source = img.decodeImage(image);
    if (source == null) throw Exception('Failed to decode image');

    final result =
        img.copyResize(source, width: source.width, height: source.height);
    final brushRadius = brushSize / 2;
    final white = img.ColorRgb8(255, 255, 255);

    for (final path in erasePaths) {
      for (final point in path) {
        final x = point.dx.clamp(0, source.width - 1).toInt();
        final y = point.dy.clamp(0, source.height - 1).toInt();

        for (var dy = -brushRadius; dy <= brushRadius; dy++) {
          for (var dx = -brushRadius; dx <= brushRadius; dx++) {
            if (dx * dx + dy * dy <= brushRadius * brushRadius) {
              final px = (x + dx).round();
              final py = (y + dy).round();
              if (px >= 0 &&
                  px < result.width &&
                  py >= 0 &&
                  py < result.height) {
                result.setPixel(px, py, white);
              }
            }
          }
        }
      }
    }

    return Uint8List.fromList(img.encodePng(result));
  }

  @override
  Future<Uint8List> binarizeImage(
    Uint8List image,
    double threshold,
    bool inverted,
  ) async {
    final source = img.decodeImage(image);
    if (source == null) throw Exception('Failed to decode image');

    final gray = img.grayscale(source);
    final thresholdValue = threshold.toInt().clamp(0, 255);

    for (int y = 0; y < gray.height; y++) {
      for (int x = 0; x < gray.width; x++) {
        final pixel = gray.getPixel(x, y);
        final luminance = img.getLuminanceRgb(pixel.r, pixel.g, pixel.b);
        gray.setPixel(
          x,
          y,
          luminance > thresholdValue
              ? img.ColorRgb8(255, 255, 255)
              : img.ColorRgb8(0, 0, 0),
        );
      }
    }

    final result = inverted ? img.invert(gray) : gray;
    return Uint8List.fromList(img.encodePng(result));
  }

  @override
  Future<void> cleanupTempFiles() async {
    final tempDir = Directory(_tempPath);
    final thumbDir = Directory(_thumbnailPath);
    if (await tempDir.exists()) await tempDir.delete(recursive: true);
    if (await thumbDir.exists()) await thumbDir.delete(recursive: true);
    await _initPaths();
  }

  @override
  Future<File> createPlaceholder(int width, int height) async {
    final image = img.Image(width: width, height: height);
    img.fill(image, color: img.ColorRgb8(255, 255, 255));
    final data = img.encodePng(image);
    final file = File(path.join(_tempPath, 'placeholder_${width}x$height.png'));
    await file.writeAsBytes(data);
    return file;
  }

  @override
  Future<String> createSvgOutline(DetectedOutline outline) async {
    final width = outline.boundingRect.width;
    final height = outline.boundingRect.height;
    final svg = StringBuffer()
      ..write(
          '<svg viewBox="0 0 $width $height" xmlns="http://www.w3.org/2000/svg">');

    for (final contour in outline.contourPoints) {
      if (contour.isEmpty) continue;
      svg.write('<path d="M${contour[0].dx},${contour[0].dy} ');
      for (int i = 1; i < contour.length; i++) {
        svg.write('L${contour[i].dx},${contour[i].dy} ');
      }
      svg.write('" stroke="black" fill="none" />');
    }

    svg.write('</svg>');
    return svg.toString();
  }

  @override
  Future<File> createTempFile(String prefix) async {
    final timestamp = DateTime.now().millisecondsSinceEpoch;
    return File(path.join(_tempPath, '${prefix}_$timestamp.tmp'));
  }

  @override
  Future<Uint8List> createThumbnail(Uint8List image, int maxSize) async {
    final source = img.decodeImage(image);
    if (source == null) throw Exception('Failed to decode image');

    final ratio = maxSize / math.max(source.width, source.height);
    final thumbnail = img.copyResize(
      source,
      width: (source.width * ratio).round(),
      height: (source.height * ratio).round(),
      interpolation: img.Interpolation.cubic,
    );

    return Uint8List.fromList(img.encodeJpg(thumbnail, quality: 85));
  }

  @override
  Future<Uint8List> cropImage(Uint8List sourceImage, Rect region) async {
    final source = img.decodeImage(sourceImage);
    if (source == null) throw Exception('Failed to decode image');

    final cropped = img.copyCrop(
      source,
      x: region.left.toInt().clamp(0, source.width - 1),
      y: region.top.toInt().clamp(0, source.height - 1),
      width: region.width.toInt().clamp(1, source.width),
      height: region.height.toInt().clamp(1, source.height),
    );

    return Uint8List.fromList(img.encodePng(cropped));
  }

  @override
  Future<Uint8List> denoiseImage(
    Uint8List binaryImage,
    double noiseReduction,
  ) async {
    final source = img.decodeImage(binaryImage);
    if (source == null) throw Exception('Failed to decode image');

    var kernelSize = (noiseReduction * 3).toInt().clamp(1, 9);
    if (kernelSize % 2 == 0) kernelSize++;
    final processed = img.gaussianBlur(source, radius: kernelSize ~/ 2);

    return Uint8List.fromList(img.encodePng(processed));
  }

  @override
  Future<DetectedOutline> detectOutline(Uint8List binaryImage) async {
    final image = img.decodeImage(binaryImage);
    if (image == null) throw Exception('Failed to decode image');

    // Simple bounding box outline
    return DetectedOutline(
      boundingRect: Rect.fromLTWH(
        0,
        0,
        image.width.toDouble(),
        image.height.toDouble(),
      ),
      contourPoints: [
        [
          const Offset(0, 0),
          Offset(image.width.toDouble(), 0),
          Offset(image.width.toDouble(), image.height.toDouble()),
          Offset(0, image.height.toDouble()),
          const Offset(0, 0),
        ]
      ],
    );
  }

  @override
  Future<File> optimizeImage(File input) async {
    final bytes = await input.readAsBytes();
    final image = img.decodeImage(bytes);
    if (image == null) throw Exception('Failed to decode image');

    final optimized = img.encodeJpg(image, quality: 85);
    final output = await createTempFile('optimized');
    await output.writeAsBytes(optimized);
    return output;
  }

  @override
  Future<File> processImage(
    File input, {
    required int maxWidth,
    required int maxHeight,
    required int quality,
  }) async {
    final bytes = await input.readAsBytes();
    final image = img.decodeImage(bytes);
    if (image == null) throw Exception('Failed to decode image');

    final ratio = math.min(
      maxWidth / image.width,
      maxHeight / image.height,
    );

    final processed = ratio < 1
        ? img.copyResize(
            image,
            width: (image.width * ratio).round(),
            height: (image.height * ratio).round(),
            interpolation: img.Interpolation.cubic,
          )
        : image;

    final outputBytes = img.encodeJpg(processed, quality: quality);
    final output = await createTempFile('processed');
    await output.writeAsBytes(outputBytes);
    return output;
  }

  @override
  Future<File> resizeImage(
    File input, {
    required int width,
    required int height,
  }) async {
    final bytes = await input.readAsBytes();
    final image = img.decodeImage(bytes);
    if (image == null) throw Exception('Failed to decode image');

    final resized = img.copyResize(
      image,
      width: width,
      height: height,
      interpolation: img.Interpolation.cubic,
    );

    final output = await createTempFile('resized');
    await output.writeAsBytes(img.encodePng(resized));
    return output;
  }

  @override
  Future<File> rotateImage(File input, int degrees) async {
    final bytes = await input.readAsBytes();
    final image = img.decodeImage(bytes);
    if (image == null) throw Exception('Failed to decode image');

    final rotated = img.copyRotate(image, angle: degrees);
    final output = await createTempFile('rotated');
    await output.writeAsBytes(img.encodePng(rotated));
    return output;
  }

  @override
  Future<bool> validateImageData(Uint8List data) async {
    try {
      final image = img.decodeImage(data);
      return image != null;
    } catch (e) {
      return false;
    }
  }

  Future<void> _initPaths() async {
    final tempDir = await getTemporaryDirectory();
    _tempPath = path.join(tempDir.path, 'image_processing');
    _thumbnailPath = path.join(tempDir.path, 'thumbnails');

    await Directory(_tempPath).create(recursive: true);
    await Directory(_thumbnailPath).create(recursive: true);
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\infrastructure\image\image_processor.dart
-----------------------------------
import 'dart:io';
import 'dart:typed_data';

import 'package:flutter/material.dart';

import '../../domain/models/character/detected_outline.dart';

/// 鍥剧墖澶勭悊鍣ㄦ帴鍙?
abstract class ImageProcessor {
  /// 涓存椂鏂囦欢鐩綍
  String get tempPath;

  /// 缂╃暐鍥剧紦瀛樼洰褰?
  String get thumbnailCachePath;

  /// 搴旂敤鎿﹂櫎鍖哄煙
  Future<Uint8List> applyEraseMask(
      Uint8List image, List<List<Offset>> erasePaths, double brushSize);

  /// 浜屽€煎寲鍥惧儚
  Future<Uint8List> binarizeImage(
      Uint8List image, double threshold, bool inverted);

  /// 娓呯悊涓存椂鏂囦欢
  Future<void> cleanupTempFiles();

  /// 鍒涘缓鍗犱綅鍥?
  ///
  /// 鍒涘缓鎸囧畾灏哄鐨勫崰浣嶅浘
  Future<File> createPlaceholder(int width, int height);

  /// 鍒涘缓SVG杞粨
  Future<String> createSvgOutline(DetectedOutline outline);

  /// 鍒涘缓涓存椂鏂囦欢
  Future<File> createTempFile(String prefix);

  /// 鐢熸垚缂╃暐鍥?
  Future<Uint8List> createThumbnail(Uint8List image, int maxSize);

  /// 瑁佸壀鍥惧儚
  Future<Uint8List> cropImage(Uint8List sourceImage, Rect region);

  /// 闄嶅櫔澶勭悊
  Future<Uint8List> denoiseImage(Uint8List binaryImage, double noiseReduction);

  /// 妫€娴嬭疆寤?
  Future<DetectedOutline> detectOutline(Uint8List binaryImage);

  /// 浼樺寲鍥剧墖
  ///
  /// 浼樺寲鍥剧墖璐ㄩ噺鍜屽ぇ灏?
  Future<File> optimizeImage(File input);

  /// 澶勭悊鍥剧墖
  ///
  /// 鎸夋寚瀹氬昂瀵稿拰璐ㄩ噺澶勭悊鍥剧墖
  Future<File> processImage(
    File input, {
    required int maxWidth,
    required int maxHeight,
    required int quality,
  });

  /// 璋冩暣鍥剧墖澶у皬
  ///
  /// 鎸夋寚瀹氬昂瀵歌皟鏁村浘鐗囷紝淇濇寔瀹介珮姣?
  Future<File> resizeImage(
    File input, {
    required int width,
    required int height,
  });

  /// 鏃嬭浆鍥剧墖
  ///
  /// [degrees] 鏃嬭浆瑙掑害(90, 180, 270)
  Future<File> rotateImage(File input, int degrees);

  /// 楠岃瘉鍥惧儚鏁版嵁鏄惁鍙В鐮?
  Future<bool> validateImageData(Uint8List data);
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\infrastructure\image\image_processor_impl.dart
-----------------------------------
import 'dart:io';
import 'dart:typed_data';
import 'dart:ui' as ui;
import 'dart:ui';

import 'package:image/image.dart' as img;
import 'package:path/path.dart' as path;

import '../../domain/models/character/detected_outline.dart';
import '../../infrastructure/logging/logger.dart';
import './image_processor.dart';

/// 鍥剧墖澶勭悊鍣ㄥ疄鐜?
class ImageProcessorImpl implements ImageProcessor {
  final String _cachePath;

  ImageProcessorImpl({required String cachePath}) : _cachePath = cachePath;

  @override
  String get tempPath => path.join(_cachePath, 'temp');

  @override
  String get thumbnailCachePath => path.join(_cachePath, 'thumbnails');

  @override
  Future<File> adjustImageColors(
    File input, {
    double brightness = 0.0,
    double contrast = 0.0,
    double saturation = 0.0,
  }) async {
    try {
      final bytes = await input.readAsBytes();
      final image = img.decodeImage(bytes);
      if (image == null) throw Exception('Failed to decode image');

      var adjusted = image;

      if (brightness != 0.0) {
        adjusted = img.colorOffset(adjusted,
            red: brightness.round(),
            green: brightness.round(),
            blue: brightness.round());
      }

      if (contrast != 0.0) {
        adjusted = img.contrast(adjusted, contrast: contrast);
      }

      // Note: The image package might not have direct saturation adjustment,
      // this is a simplified example

      final outPath = await _createTempFilePath('adjusted_');
      final outFile = File(outPath);
      await outFile.writeAsBytes(img.encodePng(adjusted));

      return outFile;
    } catch (e, stack) {
      AppLogger.error(
        '璋冩暣鍥剧墖棰滆壊澶辫触',
        error: e,
        stackTrace: stack,
        data: {
          'input': input.path,
          'brightness': brightness,
          'contrast': contrast,
          'saturation': saturation,
        },
      );
      rethrow;
    }
  }

  @override
  Future<Uint8List> applyEraseMask(
      Uint8List input, List<List<Offset>> maskPoints, double brushSize) async {
    try {
      final image = img.decodeImage(input);
      if (image == null) throw Exception('Failed to decode image');

      // Create a mask image with the same dimensions as the original image
      final mask = img.Image(width: image.width, height: image.height);

      // Draw the mask using the provided points and brush size
      for (final path in maskPoints) {
        for (final point in path) {
          // Draw a circle at each point with the given brush size
          final x = point.dx.round();
          final y = point.dy.round();
          final radius = brushSize.round();

          for (var dy = -radius; dy <= radius; dy++) {
            for (var dx = -radius; dx <= radius; dx++) {
              if (dx * dx + dy * dy <= radius * radius) {
                final px = x + dx;
                final py = y + dy;
                if (px >= 0 && px < mask.width && py >= 0 && py < mask.height) {
                  mask.setPixel(px, py, img.ColorRgba8(255, 255, 255, 255));
                }
              }
            }
          }
        }
      }

      // Apply the mask to the image
      for (var y = 0; y < image.height; y++) {
        for (var x = 0; x < image.width; x++) {
          final maskPixel = mask.getPixel(x, y);
          if (maskPixel.a > 127) {
            image.setPixel(x, y, img.ColorRgba8(0, 0, 0, 0));
          }
        }
      }

      return Uint8List.fromList(img.encodePng(image));
    } catch (e, stack) {
      AppLogger.error(
        '搴旂敤鎿﹂櫎钂欑増澶辫触',
        error: e,
        stackTrace: stack,
        data: {'brushSize': brushSize},
      );
      rethrow;
    }
  }

  @override
  Future<Uint8List> binarizeImage(
      Uint8List input, double threshold, bool invertColors) async {
    try {
      final image = img.decodeImage(input);
      if (image == null) throw Exception('Failed to decode image');

      final binarized = img.copyRotate(image, angle: 0); // Create a copy
      for (var y = 0; y < binarized.height; y++) {
        for (var x = 0; x < binarized.width; x++) {
          final pixel = binarized.getPixel(x, y);
          final intensity = img.getLuminance(pixel);
          bool isWhite = intensity > threshold;

          // Apply inversion if needed
          if (invertColors) isWhite = !isWhite;

          if (isWhite) {
            binarized.setPixel(x, y, img.ColorRgb8(255, 255, 255));
          } else {
            binarized.setPixel(x, y, img.ColorRgb8(0, 0, 0));
          }
        }
      }

      return Uint8List.fromList(img.encodePng(binarized));
    } catch (e, stack) {
      AppLogger.error(
        '浜屽€煎寲鍥剧墖澶辫触',
        error: e,
        stackTrace: stack,
        data: {'threshold': threshold, 'invertColors': invertColors},
      );
      rethrow;
    }
  }

  @override
  Future<void> cleanupTempFiles() async {
    try {
      final dir = Directory(tempPath);
      if (await dir.exists()) {
        await dir.delete(recursive: true);
        await dir.create(recursive: true);
      }
    } catch (e, stack) {
      AppLogger.error(
        '娓呯悊涓存椂鏂囦欢澶辫触',
        error: e,
        stackTrace: stack,
      );
      rethrow;
    }
  }

  @override
  Future<File> createPlaceholder(int width, int height) async {
    try {
      final image = img.Image(width: width, height: height);
      img.fill(image, color: img.ColorRgb8(200, 200, 200));

      final outPath = await _createTempFilePath('placeholder_');
      final outFile = File(outPath);
      await outFile.writeAsBytes(img.encodePng(image));

      return outFile;
    } catch (e, stack) {
      AppLogger.error(
        '鍒涘缓鍗犱綅鍥惧け璐?,
        error: e,
        stackTrace: stack,
        data: {'width': width, 'height': height},
      );
      rethrow;
    }
  }

  @override
  Future<String> createSvgOutline(DetectedOutline outline) async {
    try {
      // Calculate bounds and create path data simultaneously
      double minX = double.infinity, minY = double.infinity;
      double maxX = double.negativeInfinity, maxY = double.negativeInfinity;
      String pathData = '';

      if (outline.contourPoints.isNotEmpty &&
          outline.contourPoints.first.isNotEmpty) {
        final firstPoint = outline.contourPoints.first.first;

        // Initialize bounds with the first point
        minX = maxX = firstPoint.dx;
        minY = maxY = firstPoint.dy;

        // Start the path
        pathData = 'M ${firstPoint.dx},${firstPoint.dy}';

        // Process all points in a single pass
        for (final path in outline.contourPoints) {
          for (int i = (path == outline.contourPoints.first) ? 1 : 0;
              i < path.length;
              i++) {
            final point = path[i];

            // Update bounds
            minX = minX < point.dx ? minX : point.dx;
            minY = minY < point.dy ? minY : point.dy;
            maxX = maxX > point.dx ? maxX : point.dx;
            maxY = maxY > point.dy ? maxY : point.dy;

            // Add to path
            pathData += ' L ${point.dx},${point.dy}';
          }
        }

        // Close the path
        pathData += ' Z';
      }

      final width = maxX - minX;
      final height = maxY - minY;

      final svgContent = '''
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<svg width="$width" height="$height" xmlns="http://www.w3.org/2000/svg">
  <path d="$pathData" fill="none" stroke="black" stroke-width="1"/>
</svg>
''';

      return svgContent;
    } catch (e, stack) {
      AppLogger.error(
        '鍒涘缓SVG杞粨澶辫触',
        error: e,
        stackTrace: stack,
        data: {'outline': outline.toString()},
      );
      rethrow;
    }
  }

  @override
  Future<File> createTempFile(String prefix) async {
    final filePath = await _createTempFilePath(prefix);
    return File(filePath);
  }

  @override
  Future<Uint8List> createThumbnail(Uint8List input, int size) async {
    try {
      final image = img.decodeImage(input);
      if (image == null) throw Exception('Failed to decode image');

      // Make a square thumbnail
      int thumbWidth, thumbHeight;
      if (image.width > image.height) {
        thumbHeight = size;
        thumbWidth = (size * (image.width / image.height)).round();
      } else {
        thumbWidth = size;
        thumbHeight = (size * (image.height / image.width)).round();
      }

      final thumbnail = img.copyResize(
        image,
        width: thumbWidth,
        height: thumbHeight,
        interpolation: img.Interpolation.average,
      );

      // Create the thumbnail directory if it doesn't exist
      final dir = Directory(thumbnailCachePath);
      if (!await dir.exists()) {
        await dir.create(recursive: true);
      }

      return Uint8List.fromList(img.encodePng(thumbnail));
    } catch (e, stack) {
      AppLogger.error(
        '鍒涘缓缂╃暐鍥惧け璐?,
        error: e,
        stackTrace: stack,
        data: {'size': size},
      );
      rethrow;
    }
  }

  @override
  Future<Uint8List> cropImage(Uint8List input, Rect rect) async {
    try {
      final image = img.decodeImage(input);
      if (image == null) throw Exception('Failed to decode image');

      final cropped = img.copyCrop(
        image,
        x: rect.left.toInt(),
        y: rect.top.toInt(),
        width: rect.width.toInt(),
        height: rect.height.toInt(),
      );

      return Uint8List.fromList(img.encodePng(cropped));
    } catch (e, stack) {
      AppLogger.error(
        '瑁佸壀鍥剧墖澶辫触',
        error: e,
        stackTrace: stack,
        data: {
          'rect': '${rect.left},${rect.top},${rect.width},${rect.height}',
        },
      );
      rethrow;
    }
  }

  @override
  Future<Uint8List> denoiseImage(Uint8List input, double strength) async {
    try {
      final image = img.decodeImage(input);
      if (image == null) throw Exception('Failed to decode image');

      // Apply a simple blur as denoising
      // You might want to implement a more advanced denoising algorithm
      final denoised = img.gaussianBlur(image, radius: strength.round());

      return Uint8List.fromList(img.encodePng(denoised));
    } catch (e, stack) {
      AppLogger.error(
        '鍥惧儚闄嶅櫔澶辫触',
        error: e,
        stackTrace: stack,
        data: {'strength': strength},
      );
      rethrow;
    }
  }

  @override
  Future<DetectedOutline> detectOutline(Uint8List input) async {
    try {
      final image = img.decodeImage(input);
      if (image == null) throw Exception('Failed to decode image');

      // Simple outline detection implementation
      // In a real application, you'd need a more sophisticated algorithm
      List<List<Offset>> contourPoints = [];
      List<Offset> currentContour = [];

      // This is a placeholder implementation
      // Find edges along the borders of the image as a simple contour
      for (int x = 0; x < image.width; x += 5) {
        currentContour.add(Offset(x.toDouble(), 0));
      }
      for (int y = 0; y < image.height; y += 5) {
        currentContour.add(Offset(image.width.toDouble(), y.toDouble()));
      }
      for (int x = image.width; x > 0; x -= 5) {
        currentContour.add(Offset(x.toDouble(), image.height.toDouble()));
      }
      for (int y = image.height; y > 0; y -= 5) {
        currentContour.add(Offset(0, y.toDouble()));
      }

      contourPoints.add(currentContour);

      return DetectedOutline(
        contourPoints: contourPoints,
        boundingRect: Rect.fromLTWH(
            0, 0, image.width.toDouble(), image.height.toDouble()),
      );
    } catch (e, stack) {
      AppLogger.error(
        '妫€娴嬭疆寤撳け璐?,
        error: e,
        stackTrace: stack,
      );
      rethrow;
    }
  }

  @override
  Future<File> optimizeImage(File input) async {
    try {
      final bytes = await input.readAsBytes();
      final image = img.decodeImage(bytes);
      if (image == null) throw Exception('Failed to decode image');

      final optimized = img.copyResize(
        image,
        width: image.width,
        height: image.height,
        interpolation: img.Interpolation.linear,
      );

      final outPath = await _createTempFilePath('optimized_');
      final outFile = File(outPath);
      await outFile.writeAsBytes(img.encodeJpg(optimized, quality: 85));

      return outFile;
    } catch (e, stack) {
      AppLogger.error(
        '浼樺寲鍥剧墖澶辫触',
        error: e,
        stackTrace: stack,
        data: {'input': input.path},
      );
      rethrow;
    }
  }

  @override
  Future<File> processImage(
    File input, {
    required int maxWidth,
    required int maxHeight,
    required int quality,
  }) async {
    try {
      final bytes = await input.readAsBytes();
      final image = img.decodeImage(bytes);
      if (image == null) throw Exception('Failed to decode image');

      // 璁＄畻淇濇寔瀹介珮姣旂殑灏哄
      final aspectRatio = image.width / image.height;
      var targetWidth = maxWidth;
      var targetHeight = maxHeight;

      if (targetWidth / targetHeight > aspectRatio) {
        targetWidth = (targetHeight * aspectRatio).round();
      } else {
        targetHeight = (targetWidth / aspectRatio).round();
      }

      final processed = img.copyResize(
        image,
        width: targetWidth,
        height: targetHeight,
        interpolation: img.Interpolation.linear,
      );

      final outPath = await _createTempFilePath('processed_');
      final outFile = File(outPath);
      await outFile.writeAsBytes(img.encodeJpg(processed, quality: quality));

      return outFile;
    } catch (e, stack) {
      AppLogger.error(
        '澶勭悊鍥剧墖澶辫触',
        error: e,
        stackTrace: stack,
        data: {
          'input': input.path,
          'maxWidth': maxWidth,
          'maxHeight': maxHeight,
          'quality': quality,
        },
      );
      rethrow;
    }
  }

  @override
  Future<File> resizeImage(
    File input, {
    required int width,
    required int height,
  }) async {
    try {
      final bytes = await input.readAsBytes();
      final image = img.decodeImage(bytes);
      if (image == null) throw Exception('Failed to decode image');

      // 璁＄畻淇濇寔瀹介珮姣旂殑灏哄
      final aspectRatio = image.width / image.height;
      var targetWidth = width;
      var targetHeight = height;

      if (targetWidth / targetHeight > aspectRatio) {
        targetWidth = (targetHeight * aspectRatio).round();
      } else {
        targetHeight = (targetWidth / aspectRatio).round();
      }

      final resized = img.copyResize(
        image,
        width: targetWidth,
        height: targetHeight,
        interpolation: img.Interpolation.linear,
      );

      final outPath = await _createTempFilePath('resized_');
      final outFile = File(outPath);
      await outFile.writeAsBytes(img.encodePng(resized));

      return outFile;
    } catch (e, stack) {
      AppLogger.error(
        '璋冩暣鍥剧墖澶у皬澶辫触',
        error: e,
        stackTrace: stack,
        data: {
          'input': input.path,
          'width': width,
          'height': height,
        },
      );
      rethrow;
    }
  }

  @override
  Future<File> rotateImage(File input, int degrees) async {
    try {
      final bytes = await input.readAsBytes();
      final image = img.decodeImage(bytes);
      if (image == null) throw Exception('Failed to decode image');

      final rotated = img.copyRotate(image, angle: degrees);

      final outPath = await _createTempFilePath('rotated_');
      final outFile = File(outPath);
      await outFile.writeAsBytes(img.encodePng(rotated));

      return outFile;
    } catch (e, stack) {
      AppLogger.error(
        '鏃嬭浆鍥剧墖澶辫触',
        error: e,
        stackTrace: stack,
        data: {
          'input': input.path,
          'degrees': degrees,
        },
      );
      rethrow;
    }
  }

  /// 楠岃瘉鍥惧儚鏁版嵁鏄惁鍙В鐮?
  @override
  Future<bool> validateImageData(Uint8List data) async {
    if (data.isEmpty) return false;
    try {
      // 灏濊瘯瑙ｇ爜鍥惧儚浠ラ獙璇佹暟鎹湁鏁堟€?
      final codec = await ui.instantiateImageCodec(data);
      final frame = await codec.getNextFrame();
      return true;
    } catch (e) {
      AppLogger.warning('鍥惧儚鏁版嵁楠岃瘉澶辫触',
          tag: 'ImageProcessor', error: e, data: {'dataLength': data.length});
      return false;
    }
  }

  /// 鍒涘缓涓存椂鏂囦欢璺緞
  Future<String> _createTempFilePath(String prefix) async {
    final dir = Directory(tempPath);
    if (!await dir.exists()) {
      await dir.create(recursive: true);
    }
    return path.join(
      tempPath,
      '$prefix${DateTime.now().millisecondsSinceEpoch}.tmp',
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\infrastructure\logging\app_error_handler.dart
-----------------------------------
import 'dart:async';
import 'dart:isolate';

import 'package:flutter/foundation.dart';

import 'logger.dart';

/// 鍏ㄥ眬閿欒澶勭悊鍣?
class AppErrorHandler {
  static bool _initialized = false;

  /// 鍒濆鍖栭敊璇鐞?
  static void initialize() {
    if (_initialized) return;
    _initialized = true;

    // 澶勭悊 Flutter 妗嗘灦閿欒
    FlutterError.onError = (FlutterErrorDetails details) {
      FlutterError.presentError(details);
      AppLogger.error(
        '鍙戠敓Flutter妗嗘灦閿欒',
        error: details.exception,
        stackTrace: details.stack,
        tag: 'ErrorHandler',
      );
    };

    // 澶勭悊鏈崟鑾风殑寮傛閿欒
    PlatformDispatcher.instance.onError = (error, stack) {
      AppLogger.error(
        '鍙戠敓鏈崟鑾风殑骞冲彴閿欒',
        error: error,
        stackTrace: stack,
        tag: 'ErrorHandler',
      );
      return true;
    };

    // 澶勭悊Zone鍐呮湭鎹曡幏鐨勯敊璇?
    runZonedGuarded(
      () {},
      (Object error, StackTrace stack) {
        AppLogger.error(
          '鍙戠敓鏈崟鑾风殑Zone閿欒',
          error: error,
          stackTrace: stack,
          tag: 'ErrorHandler',
        );
      },
    );

    // 澶勭悊Isolate閿欒
    Isolate.current.addErrorListener(RawReceivePort((pair) {
      final List<dynamic> errorAndStacktrace = pair as List<dynamic>;
      AppLogger.error(
        '鍙戠敓Isolate閿欒',
        error: errorAndStacktrace.first,
        stackTrace: errorAndStacktrace.last as StackTrace,
        tag: 'ErrorHandler',
      );
    }).sendPort);
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\infrastructure\logging\error_handler.dart
-----------------------------------
import 'package:flutter/foundation.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import 'logger.dart';

class AppErrorHandler {
  static void initialize() {
    // Capture Flutter framework errors
    FlutterError.onError = (FlutterErrorDetails details) {
      AppLogger.error(
        details.exceptionAsString(),
        error: details.exception,
        stackTrace: details.stack,
        tag: 'Flutter',
      );
      // Forward to Flutter's default handler
      FlutterError.presentError(details);
    };

    // Capture Dart uncaught errors
    PlatformDispatcher.instance.onError = (error, stack) {
      AppLogger.fatal(
        'Uncaught exception',
        error: error,
        stackTrace: stack,
        tag: 'Dart',
      );
      // Allow normal handling to continue
      return false;
    };
  }
}

// Riverpod observer example
class ProviderLogger extends ProviderObserver {
  @override
  void didAddProvider(
    ProviderBase<Object?> provider,
    Object? value,
    ProviderContainer container,
  ) {
    AppLogger.debug(
      'Provider ${provider.name ?? provider.runtimeType} was initialized with $value',
      tag: 'Riverpod',
    );
  }

  @override
  void didDisposeProvider(
    ProviderBase<Object?> provider,
    ProviderContainer container,
  ) {
    AppLogger.debug(
      'Provider ${provider.name ?? provider.runtimeType} was disposed',
      tag: 'Riverpod',
    );
  }

  @override
  void providerDidFail(
    ProviderBase<Object?> provider,
    Object error,
    StackTrace stackTrace,
    ProviderContainer container,
  ) {
    AppLogger.error(
      'Provider ${provider.name ?? provider.runtimeType} failed',
      error: error,
      stackTrace: stackTrace,
      tag: 'Riverpod',
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\infrastructure\logging\isolate_logger.dart
-----------------------------------
import 'dart:io';
import 'dart:isolate';

/// Isolate 鏃ュ織杈呭姪绫?
class IsolateLogger {
  /// 鏃ュ織鍙戦€佺鍙?
  static SendPort? _sendPort;

  /// 璋冭瘯鏃ュ織
  static void debug(String message, {Map<String, dynamic>? data}) {
    _sendLog('debug', message, data: data);
  }

  /// 閿欒鏃ュ織
  static void error(String message,
      {Map<String, dynamic>? data, StackTrace? stackTrace}) {
    _sendLog('error', message, data: data, stackTrace: stackTrace);
  }

  /// 鑷村懡閿欒鏃ュ織
  static void fatal(String message,
      {Map<String, dynamic>? data, StackTrace? stackTrace}) {
    _sendLog('fatal', message, data: data, stackTrace: stackTrace);
  }

  /// 淇℃伅鏃ュ織
  static void info(String message, {Map<String, dynamic>? data}) {
    _sendLog('info', message, data: data);
  }

  /// 鍒濆鍖?SendPort
  static void initialize(SendPort sendPort) {
    _sendPort = sendPort;
  }

  /// 璀﹀憡鏃ュ織
  static void warning(String message, {Map<String, dynamic>? data}) {
    _sendLog('warning', message, data: data);
  }

  /// 鍚戞湰鍦版枃浠跺啓鍏ョ畝鍗曟棩蹇楋紝鐢ㄤ簬 Isolate 璋冭瘯
  static void writeToFile(String message) {
    try {
      final file = File('/storage/emulated/0/Download/flutter_isolate_log.txt');
      final now = DateTime.now().toIso8601String();
      file.writeAsStringSync('[$now] $message\n', mode: FileMode.append);
    } catch (e) {
      // 蹇界暐鏂囦欢鍐欏叆閿欒
    }
  }

  /// 鍙戦€佹棩蹇楀埌涓?Isolate
  static void _sendLog(String level, String message,
      {Map<String, dynamic>? data, StackTrace? stackTrace}) {
    if (_sendPort != null) {
      _sendPort!.send(LogMessage(
        level: level,
        message: message,
        data: data,
        stackTrace: stackTrace,
      ));
    }
  }
}

/// Isolate 鏃ュ織浼犻€掓秷鎭?
class LogMessage {
  final String level;
  final String message;
  final Map<String, dynamic>? data;
  final StackTrace? stackTrace;

  LogMessage({
    required this.level,
    required this.message,
    this.data,
    this.stackTrace,
  });
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\infrastructure\logging\logger.dart
-----------------------------------
import 'dart:isolate';

import 'package:flutter/widgets.dart';

import 'handlers/console_handler.dart';
import 'handlers/file_handler.dart';
import 'handlers/log_handler.dart';
import 'isolate_logger.dart';
import 'log_entry.dart';
import 'log_level.dart';

// 鍚屾閿佽緟鍔╁嚱鏁?
Future<T> synchronized<T>(Object lock, T Function() computation) async {
  try {
    return computation();
  } catch (e) {
    rethrow;
  }
}

class AppLogger {
  static LogLevel _minLevel = LogLevel.debug;
  static final List<LogHandler> _handlers = [];
  // 娣诲姞鍚屾閿侊紝闃叉骞跺彂鍐欏叆
  static final _logLock = Object();

  static final _logQueue = <_LogEntry>[];
  static bool _isProcessingLogs = false;

  /// 鍒濆鍖?Isolate 鏃ュ織閫氶亾
  static ReceivePort? _isolateLogReceiver;

  static bool get hasHandlers => _handlers.isNotEmpty;

  // 渚垮埄鏂规硶
  static void debug(dynamic message,
      {String? tag, Map<String, dynamic>? data}) {
    _queueLog(LogLevel.debug, message, tag: tag, data: data);
  }

  static void error(
    dynamic message, {
    String? tag,
    dynamic error,
    StackTrace? stackTrace,
    Map<String, dynamic>? data,
  }) {
    _queueLog(
      LogLevel.error,
      message,
      tag: tag,
      error: error,
      stackTrace: stackTrace,
      data: data,
    );
  }

  static void fatal(
    dynamic message, {
    String? tag,
    dynamic error,
    StackTrace? stackTrace,
    Map<String, dynamic>? data,
  }) {
    _queueLog(
      LogLevel.fatal,
      message,
      tag: tag,
      error: error,
      stackTrace: stackTrace,
      data: data,
    );
  }

  static void info(dynamic message, {String? tag, Map<String, dynamic>? data}) {
    _queueLog(LogLevel.info, message, tag: tag, data: data);
  }

  // 鍒濆鍖栨柟娉?
  static Future<void> init({
    LogLevel minLevel = LogLevel.debug,
    bool enableConsole = true,
    bool enableFile = false,
    String? filePath,
    int? maxFileSizeBytes,
    int? maxFiles,
  }) async {
    _minLevel = minLevel;

    if (enableConsole) {
      _handlers.add(ConsoleLogHandler());
    }

    if (enableFile && filePath != null) {
      final fileHandler = FileLogHandler(
        filePath: filePath,
        maxSizeBytes: maxFileSizeBytes,
        maxFiles: maxFiles,
      );
      await fileHandler.init();
      _handlers.add(fileHandler);
    }
  }

  // 鏃ュ織璁板綍鏂规硶
  static void log(
    LogLevel level,
    dynamic message, {
    String? tag,
    dynamic error,
    StackTrace? stackTrace,
    Map<String, dynamic>? data,
  }) {
    if (level.index < _minLevel.index) return;

    final entry = LogEntry(
      level: level,
      message: message.toString(),
      timestamp: DateTime.now(),
      tag: tag ?? _getCallerTag(),
      error: error,
      stackTrace: stackTrace ?? (error != null ? StackTrace.current : null),
      data: data,
    );

    for (final handler in _handlers) {
      handler.handle(entry);
    }
  }

  /// 鍚姩 Isolate 鏃ュ織鐩戝惉
  static ReceivePort startIsolateLogging() {
    _isolateLogReceiver = ReceivePort();
    _isolateLogReceiver!.listen(_handleIsolateLog);
    return _isolateLogReceiver!;
  }

  /// 鍋滄 Isolate 鏃ュ織鐩戝惉
  static void stopIsolateLogging() {
    _isolateLogReceiver?.close();
    _isolateLogReceiver = null;
  }

  static void warning(
    dynamic message, {
    String? tag,
    dynamic error,
    StackTrace? stackTrace,
    Map<String, dynamic>? data,
  }) {
    _queueLog(
      LogLevel.warning,
      message,
      tag: tag,
      error: error,
      stackTrace: stackTrace,
      data: data,
    );
  }

  // 杈呭姪鏂规硶
  static String? _getCallerTag() {
    try {
      final frames = StackTrace.current.toString().split('\n');
      if (frames.length > 3) {
        final frame = frames[3].trim();
        final classMethodPattern = RegExp(r'#\d+\s+(.+)\s+\(');
        final match = classMethodPattern.firstMatch(frame);
        if (match != null && match.groupCount >= 1) {
          return match.group(1)?.split('.').first;
        }
      }
    } catch (_) {}
    return null;
  }

  /// 澶勭悊鏉ヨ嚜 Isolate 鐨勬棩蹇楁秷鎭?
  static void _handleIsolateLog(dynamic message) {
    if (message is LogMessage) {
      switch (message.level) {
        case 'debug':
          debug('[Isolate] ${message.message}', data: message.data);
          break;
        case 'info':
          info('[Isolate] ${message.message}', data: message.data);
          break;
        case 'warning':
          warning('[Isolate] ${message.message}', data: message.data);
          break;
        case 'error':
          error('[Isolate] ${message.message}',
              data: message.data, stackTrace: message.stackTrace);
          break;
        case 'fatal':
          fatal('[Isolate] ${message.message}',
              data: message.data, stackTrace: message.stackTrace);
          break;
      }
    }
  }

  // 澶勭悊鏃ュ織闃熷垪
  static Future<void> _processLogQueue() async {
    if (_logQueue.isEmpty) {
      _isProcessingLogs = false;
      return;
    }

    _isProcessingLogs = true;
    final entry = _logQueue.removeAt(0);

    try {
      // 瀹為檯鐨勬棩蹇楀鐞?
      log(entry.level, entry.message,
          tag: entry.tag,
          error: entry.error,
          stackTrace: entry.stackTrace,
          data: entry.data);
    } catch (e) {
      debugPrint('Error processing log: $e');
    } finally {
      // 缁х画澶勭悊闃熷垪涓殑涓嬩竴涓棩蹇?
      _processLogQueue();
    }
  }

  // 浣跨敤闃熷垪澶勭悊鏃ュ織锛岄伩鍏嶅苟鍙戦棶棰?
  static void _queueLog(
    LogLevel level,
    dynamic message, {
    String? tag,
    dynamic error,
    StackTrace? stackTrace,
    Map<String, dynamic>? data,
  }) {
    final entry = _LogEntry(
      level: level,
      message: message.toString(),
      tag: tag,
      error: error,
      stackTrace: stackTrace,
      data: data,
      timestamp: DateTime.now(),
    );

    synchronized(_logLock, () {
      _logQueue.add(entry);
      if (!_isProcessingLogs) {
        _processLogQueue();
      }
    });
  }
}

// 杈呭姪绫昏〃绀烘棩蹇楁潯鐩?
class _LogEntry {
  final LogLevel level;
  final String message;
  final String? tag;
  final dynamic error;
  final StackTrace? stackTrace;
  final Map<String, dynamic>? data;
  final DateTime timestamp;

  _LogEntry({
    required this.level,
    required this.message,
    this.tag,
    this.error,
    this.stackTrace,
    this.data,
    required this.timestamp,
  });
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\infrastructure\logging\logging.dart
-----------------------------------
// 闆嗕腑瀵煎嚭鎵€鏈夋棩蹇楃浉鍏崇殑绫诲拰鍔熻兘
export 'error_handler.dart';
export 'handlers/console_handler.dart';
export 'handlers/file_handler.dart' hide synchronized;
export 'handlers/log_handler.dart';
export 'log_entry.dart';
export 'log_level.dart';
export 'logger.dart';



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\infrastructure\logging\log_entry.dart
-----------------------------------
import 'log_level.dart';

class LogEntry {
  final LogLevel level;
  final String message;
  final DateTime timestamp;
  final String? tag;
  final dynamic error;
  final StackTrace? stackTrace;
  final Map<String, dynamic>? data;

  const LogEntry({
    required this.level,
    required this.message,
    required this.timestamp,
    this.tag,
    this.error,
    this.stackTrace,
    this.data,
  });

  String toConsoleString() {
    final buffer = StringBuffer();
    final timeStr =
        '${timestamp.hour.toString().padLeft(2, '0')}:${timestamp.minute.toString().padLeft(2, '0')}:${timestamp.second.toString().padLeft(2, '0')}';

    buffer.write('${level.emoji} ');
    buffer.write('[$timeStr] ');
    buffer.write('[${level.name}] ');
    if (tag != null) buffer.write('[$tag] ');
    buffer.write(message);

    if (error != null) {
      buffer.write('\nError: $error');
    }

    if (stackTrace != null) {
      buffer.write('\nStack Trace:\n$stackTrace');
    }

    if (data != null && data!.isNotEmpty) {
      buffer.write('\nData: ${data.toString()}');
    }

    return buffer.toString();
  }

  Map<String, dynamic> toJson() {
    return {
      'level': level.name,
      'message': message,
      'timestamp': timestamp.toIso8601String(),
      if (tag != null) 'tag': tag,
      if (error != null) 'error': error.toString(),
      if (stackTrace != null) 'stackTrace': stackTrace.toString(),
      if (data != null) 'data': data,
    };
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\infrastructure\logging\log_level.dart
-----------------------------------
import 'package:flutter/material.dart';

enum LogLevel {
  debug,
  info,
  warning,
  error,
  fatal;

  Color get color {
    return switch (this) {
      LogLevel.debug => Colors.grey,
      LogLevel.info => Colors.blue,
      LogLevel.warning => Colors.yellow,
      LogLevel.error => Colors.red,
      LogLevel.fatal => Colors.purple,
    };
  }

  String get emoji {
    return switch (this) {
      LogLevel.debug => '馃攳',
      LogLevel.info => '鈩癸笍',
      LogLevel.warning => '鈿狅笍',
      LogLevel.error => '鉂?,
      LogLevel.fatal => '鈽狅笍',
    };
  }

  String get name => toString().split('.').last.toUpperCase();
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\infrastructure\logging\handlers\console_handler.dart
-----------------------------------
import 'package:flutter/foundation.dart';

import '../log_entry.dart';
import '../log_level.dart';
import 'log_handler.dart';

class ConsoleLogHandler implements LogHandler {
  @override
  void handle(LogEntry entry) {
    final message = entry.toConsoleString();

    switch (entry.level) {
      case LogLevel.debug:
        debugPrint(message);
        break;
      case LogLevel.info:
        debugPrint('\x1B[34m$message\x1B[0m'); // Blue
        break;
      case LogLevel.warning:
        debugPrint('\x1B[33m$message\x1B[0m'); // Yellow
        break;
      case LogLevel.error:
      case LogLevel.fatal:
        debugPrint('\x1B[31m$message\x1B[0m'); // Red
        break;
    }
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\infrastructure\logging\handlers\file_handler.dart
-----------------------------------
import 'dart:async';
import 'dart:io';

import 'package:flutter/foundation.dart';
import 'package:path/path.dart' as path;

import '../log_entry.dart';
import 'log_handler.dart';

// 鍚屾鎿嶄綔鐨勮緟鍔╁嚱鏁?
Future<T> synchronized<T>(Object lock, Future<T> Function() computation) async {
  try {
    return await computation();
  } catch (e) {
    rethrow;
  }
}

class FileLogHandler implements LogHandler {
  final String filePath;
  final int? maxSizeBytes;
  final int? maxFiles;

  File? _currentFile;
  IOSink? _sink;
  bool _isWriting = false;
  final List<LogEntry> _pendingLogs = [];
  final Object _writeLock = Object();

  FileLogHandler({
    required this.filePath,
    this.maxSizeBytes,
    this.maxFiles,
  });

  // 娓呯悊璧勬簮
  Future<void> dispose() async {
    await _sink?.flush();
    await _sink?.close();
    _sink = null;
    _pendingLogs.clear();
  }

  @override
  void handle(LogEntry entry) {
    // 涓嶅啀鐩存帴鍐欏叆锛岃€屾槸娣诲姞鍒板緟澶勭悊闃熷垪
    synchronized(_writeLock, () async {
      _pendingLogs.add(entry);
      return _processLogs();
    });
  }

  Future<void> init() async {
    await _openLogFile();
  }

  Future<void> _checkRotation() async {
    final currentSize = await _currentFile?.length() ?? 0;
    if (maxSizeBytes != null && currentSize > maxSizeBytes!) {
      await _rotateLogFile();
    }
  }

  Future<void> _deleteOldLogFiles() async {
    final directory = Directory(path.dirname(filePath));
    final baseFileName = path.basenameWithoutExtension(filePath);
    final extension = path.extension(filePath);

    final files = await directory
        .list()
        .where((entity) =>
            entity is File &&
            path.basename(entity.path).startsWith(baseFileName) &&
            path.basename(entity.path).endsWith(extension) &&
            entity.path != filePath)
        .toList();

    if (files.length > maxFiles! - 1) {
      // 鎸変慨鏀规椂闂存帓搴忥紙鏃х殑鍏堬級
      files.sort((a, b) {
        return a.statSync().modified.compareTo(b.statSync().modified);
      });

      // 鍒犻櫎鏈€鏃х殑鏂囦欢
      for (var i = 0; i < files.length - maxFiles! + 1; i++) {
        try {
          await (files[i] as File).delete();
        } catch (e) {
          debugPrint('Failed to delete old log file: $e');
        }
      }
    }
  }

  // 鏍煎紡鍖栨棩蹇楁潯鐩?
  String _formatLogEntry(LogEntry entry) {
    final timestamp = entry.timestamp.toIso8601String();
    final level = entry.level.name.padRight(7);
    final tag = entry.tag != null ? '[${entry.tag}] ' : '';

    return '$timestamp [$level] $tag${entry.message}';
  }

  Future<void> _openLogFile() async {
    try {
      final directory = Directory(path.dirname(filePath));
      if (!await directory.exists()) {
        await directory.create(recursive: true);
      }

      _currentFile = File(filePath);
      // 鍏抽敭淇锛氶伩鍏嶉噸鐢ㄧ浉鍚岀殑 StreamSink
      await _sink?.close();
      _sink = _currentFile!.openWrite(mode: FileMode.append);
    } catch (e) {
      debugPrint('Error opening log file: $e');
    }
  }

  // 瀹夊叏鍦板鐞嗘棩蹇楅槦鍒?
  Future<void> _processLogs() async {
    if (_isWriting || _pendingLogs.isEmpty) return;

    _isWriting = true;

    try {
      while (_pendingLogs.isNotEmpty) {
        final entry = _pendingLogs.removeAt(0);
        final formattedLog = _formatLogEntry(entry);

        // 鍒涘缓鏂扮殑 IOSink 浠ラ伩鍏?StreamSink 閲嶇敤闂
        if (_sink == null) {
          await _openLogFile();
        }

        // 瀹夊叏鍐欏叆
        _sink?.writeln(formattedLog);
        await _sink?.flush(); // 绔嬪嵆鍒锋柊纭繚鍐欏叆

        // 娣诲姞閿欒鍜屽爢鏍堣窡韪紙濡傛灉鏈夛級
        if (entry.error != null) {
          _sink?.writeln('Error: ${entry.error}');
        }
        if (entry.stackTrace != null) {
          _sink?.writeln('Stack Trace:');
          _sink?.writeln(entry.stackTrace);
        }

        // 妫€鏌ユ槸鍚﹂渶瑕佽疆鎹㈡棩蹇楁枃浠?
        await _checkRotation();
      }
    } catch (e) {
      debugPrint('Error writing to log file: $e');
    } finally {
      _isWriting = false;

      // 妫€鏌ユ槸鍚﹁繕鏈夋洿澶氭棩蹇楀緟澶勭悊
      if (_pendingLogs.isNotEmpty) {
        _processLogs();
      }
    }
  }

  Future<void> _rotateLogFile() async {
    // 鍏抽棴褰撳墠鏂囦欢
    await _sink?.flush();
    await _sink?.close();
    _sink = null;

    // 鍒涘缓鏂版枃浠跺苟閲嶅懡鍚嶆棫鏂囦欢
    final baseFileName = path.basenameWithoutExtension(filePath);
    final extension = path.extension(filePath);
    final timestamp = DateTime.now().toIso8601String().replaceAll(':', '-');
    final rotatedPath =
        '${path.dirname(filePath)}/${baseFileName}_$timestamp$extension';

    try {
      await _currentFile?.rename(rotatedPath);
    } catch (e) {
      // 濡傛灉閲嶅懡鍚嶅け璐ワ紝灏濊瘯澶嶅埗鐒跺悗鍒犻櫎
      try {
        await _currentFile?.copy(rotatedPath);
        await _currentFile?.delete();
      } catch (e) {
        debugPrint('Failed to rotate log file: $e');
      }
    }

    // 鎵撳紑鏂扮殑鏃ュ織鏂囦欢
    await _openLogFile();

    // 鍒犻櫎鏃ф枃浠讹紙濡傛灉闇€瑕侊級
    if (maxFiles != null) {
      await _deleteOldLogFiles();
    }
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\infrastructure\logging\handlers\log_handler.dart
-----------------------------------
import '../log_entry.dart';

abstract class LogHandler {
  void handle(LogEntry entry);
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\infrastructure\persistence\app_database.dart
-----------------------------------
import 'dart:io';

import 'package:flutter/foundation.dart';
import 'package:path/path.dart' as path;
import 'package:sqflite/sqflite.dart';

import 'database_interface.dart';

class AppDatabase implements DatabaseInterface {
  static const _version = 1;
  final String basePath;
  Database? _database;
  bool _initialized = false;

  AppDatabase({required this.basePath});

  @override
  Future<void> clear(String table) async {
    // TODO: 瀹炵幇娓呯┖琛ㄩ€昏緫
    throw UnimplementedError();
  }

  @override
  Future<void> close() async {
    // TODO: 瀹炵幇鍏抽棴鏁版嵁搴撻€昏緫
    throw UnimplementedError();
  }

  @override
  Future<int> count(String table, [Map<String, dynamic>? filter]) async {
    // TODO: 瀹炵幇鑾峰彇璁板綍鏁伴€昏緫
    throw UnimplementedError();
  }

  @override
  Future<void> delete(String table, String id) async {
    final db = _database;
    if (db == null) {
      throw StateError('Database not initialized');
    }

    await db.delete(table, where: 'key = ?', whereArgs: [id]);
  }

  @override
  Future<void> deleteMany(String table, List<String> ids) async {
    // TODO: 瀹炵幇鎵归噺鍒犻櫎璁板綍閫昏緫
    throw UnimplementedError();
  }

  @override
  Future<Map<String, dynamic>?> get(String table, String id) async {
    final db = _database;
    if (db == null) {
      throw StateError('Database not initialized');
    }

    final results = await db.query(
      table,
      where: 'key = ?',
      whereArgs: [id],
      limit: 1,
    );

    return results.isNotEmpty ? results.first : null;
  }

  @override
  Future<List<Map<String, dynamic>>> getAll(String table) async {
    // TODO: 瀹炵幇鑾峰彇鎵€鏈夎褰曢€昏緫
    throw UnimplementedError();
  }

  @override
  Future<void> initialize() async {
    try {
      if (_initialized) return;

      // 纭繚鐩綍瀛樺湪
      final dbDir = Directory(basePath);
      await dbDir.create(recursive: true);
      final dbPath = path.join(basePath, 'settings.db');
      _database = await openDatabase(
        dbPath,
        version: _version,
        onCreate: (db, version) async {
          await db.execute('''
            CREATE TABLE IF NOT EXISTS settings (
              key TEXT PRIMARY KEY,
              value TEXT,
              updateTime TEXT
            )''');
        },
      );
      _initialized = true;
    } catch (e) {
      debugPrint('Database initialization error: $e');
      rethrow;
    }
  }

  @override
  Future<List<Map<String, dynamic>>> query(
      String table, Map<String, dynamic> filter) async {
    // TODO: 瀹炵幇缁撴瀯鍖栨煡璇㈤€昏緫
    throw UnimplementedError();
  }

  @override
  Future<int> rawDelete(String sql, [List<Object?>? args]) async {
    // TODO: 瀹炵幇鍘熺敓鍒犻櫎閫昏緫
    throw UnimplementedError();
  }

  @override
  Future<List<Map<String, dynamic>>> rawQuery(String sql,
      [List<Object?>? args]) async {
    // TODO: 瀹炵幇鍘熺敓鏌ヨ閫昏緫
    throw UnimplementedError();
  }

  @override
  Future<int> rawUpdate(String sql, [List<Object?>? args]) async {
    // TODO: 瀹炵幇鍘熺敓鏇存柊閫昏緫
    throw UnimplementedError();
  }

  @override
  Future<void> save(String table, String id, Map<String, dynamic> data) async {
    // TODO: 瀹炵幇淇濆瓨璁板綍閫昏緫
    throw UnimplementedError();
  }

  @override
  Future<void> saveMany(
      String table, Map<String, Map<String, dynamic>> data) async {
    // TODO: 瀹炵幇鎵归噺淇濆瓨璁板綍閫昏緫
    throw UnimplementedError();
  }

  @override
  Future<void> set(String table, String id, Map<String, dynamic> data) async {
    final db = _database;
    if (db == null) {
      throw StateError('Database not initialized');
    }

    await db.insert(table, data, conflictAlgorithm: ConflictAlgorithm.replace);
  }

  @override
  Future<void> setMany(
      String table, Map<String, Map<String, dynamic>> data) async {
    // TODO: 瀹炵幇鎵归噺璁剧疆璁板綍閫昏緫
    throw UnimplementedError();
  }

  /// 鐢ㄤ簬妯″紡鍖归厤鐨勮緟鍔╂柟娉?
  T when<T>({
    required T Function() initialized,
    required T Function() uninitialized,
  }) {
    return _database != null ? initialized() : uninitialized();
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\infrastructure\persistence\database_factory.dart
-----------------------------------
import 'package:path_provider/path_provider.dart';

import 'database_interface.dart';
import 'sqlite/sqlite_database.dart';

/// 鏁版嵁搴撻厤缃?
class DatabaseConfig {
  /// 鏁版嵁搴撳悕绉?
  final String name;

  /// 鏁版嵁搴撶洰褰?
  final String? directory;

  /// 鏁版嵁搴撹縼绉昏剼鏈?
  final List<String> migrations;

  const DatabaseConfig({
    required this.name,
    this.directory,
    this.migrations = const [],
  });
}

/// 鏁版嵁搴撳伐鍘?
class DatabaseFactory {
  /// 鍒涘缓SQLite鏁版嵁搴撳疄渚?
  static Future<DatabaseInterface> create(DatabaseConfig config) async {
    final directory =
        config.directory ?? (await getApplicationDocumentsDirectory()).path;

    return SQLiteDatabase.create(
      name: config.name,
      directory: directory,
      migrations: config.migrations,
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\infrastructure\persistence\database_interface.dart
-----------------------------------
/// 鏁版嵁搴撴帴鍙?
abstract class DatabaseInterface {
  /// 娓呯┖琛?
  Future<void> clear(String table);

  /// 鍏抽棴鏁版嵁搴?
  Future<void> close();

  /// 鑾峰彇璁板綍鏁?
  Future<int> count(String table, [Map<String, dynamic>? filter]);

  /// 鍒犻櫎璁板綍
  Future<void> delete(String table, String id);

  /// 鎵归噺鍒犻櫎璁板綍
  Future<void> deleteMany(String table, List<String> ids);

  /// 鑾峰彇鍗曚釜璁板綍
  Future<Map<String, dynamic>?> get(String table, String id);

  /// 鑾峰彇澶氫釜璁板綍
  Future<List<Map<String, dynamic>>> getAll(String table);

  /// 鎵ц鍒濆鍖?
  Future<void> initialize();

  /// 缁撴瀯鍖栨煡璇?
  Future<List<Map<String, dynamic>>> query(
      String table, Map<String, dynamic> filter);

  /// 鎵ц鍘熺敓鍒犻櫎
  Future<int> rawDelete(String sql, [List<Object?>? args]);

  /// 鎵ц鍘熺敓鏌ヨ
  Future<List<Map<String, dynamic>>> rawQuery(String sql,
      [List<Object?>? args]);

  /// 鎵ц鍘熺敓鏇存柊
  Future<int> rawUpdate(String sql, [List<Object?>? args]);

  /// 淇濆瓨/鏇存柊璁板綍
  Future<void> save(String table, String id, Map<String, dynamic> data);

  /// 鎵归噺淇濆瓨/鏇存柊璁板綍
  Future<void> saveMany(String table, Map<String, Map<String, dynamic>> data);

  /// 璁剧疆璁板綍(瑕嗙洊)
  Future<void> set(String table, String id, Map<String, dynamic> data);

  /// 鎵归噺璁剧疆璁板綍(瑕嗙洊)
  Future<void> setMany(String table, Map<String, Map<String, dynamic>> data);
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\infrastructure\persistence\database_state.dart
-----------------------------------
/// 鏁版嵁搴撶姸鎬?
class DatabaseState {
  /// 鏄惁鍒濆鍖栧畬鎴?
  final bool isInitialized;

  /// 褰撳墠鐗堟湰
  final int version;

  /// 涓婃鏇存柊鏃堕棿
  final DateTime? lastUpdate;

  /// 閿欒淇℃伅
  final String? error;

  const DatabaseState({
    this.isInitialized = false,
    this.version = 0,
    this.lastUpdate,
    this.error,
  });

  /// 鍒涘缓閿欒鐘舵€?
  factory DatabaseState.error(String error) => DatabaseState(
        isInitialized: false,
        error: error,
      );

  /// 鍒涘缓鍒濆鐘舵€?
  factory DatabaseState.initial() => const DatabaseState();

  /// 鍒涘缓宸插垵濮嬪寲鐘舵€?
  factory DatabaseState.initialized(int version) => DatabaseState(
        isInitialized: true,
        version: version,
        lastUpdate: DateTime.now(),
      );

  /// 澶嶅埗骞朵慨鏀归儴鍒嗗睘鎬?
  DatabaseState copyWith({
    bool? isInitialized,
    int? version,
    DateTime? lastUpdate,
    String? error,
  }) {
    return DatabaseState(
      isInitialized: isInitialized ?? this.isInitialized,
      version: version ?? this.version,
      lastUpdate: lastUpdate ?? this.lastUpdate,
      error: error ?? this.error,
    );
  }

  @override
  String toString() {
    return 'DatabaseState(initialized: $isInitialized, version: $version, lastUpdate: $lastUpdate, error: $error)';
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\infrastructure\persistence\mock_database.dart
-----------------------------------
import '../../domain/models/work/work_entity.dart';
import '../../domain/models/work/work_filter.dart';
import 'database_interface.dart';

/// 鐢ㄤ簬娴嬭瘯鐨勬€绘槸澶辫触鐨勬暟鎹簱
class FailingMockDatabase implements DatabaseInterface {
  @override
  bool get isInitialized => false;

  @override
  Future<void> clear(String table) async => throw UnimplementedError();
  @override
  Future<void> close() async => throw UnimplementedError();
  @override
  Future<int> count(String table, [Map<String, dynamic>? filter]) async =>
      throw UnimplementedError();
  @override
  Future<void> delete(String table, String id) async =>
      throw UnimplementedError();
  @override
  Future<void> deleteMany(String table, List<String> ids) async =>
      throw UnimplementedError();
  @override
  Future<Map<String, dynamic>?> get(String table, String id) async =>
      throw UnimplementedError();
  @override
  Future<List<Map<String, dynamic>>> getAll(String table) async =>
      throw UnimplementedError();
  @override
  Future<void> initialize() async {
    throw Exception('妯℃嫙鏁版嵁搴撳垵濮嬪寲澶辫触');
  }

  @override
  Future<List<Map<String, dynamic>>> query(
    String table,
    Map<String, dynamic> filter,
  ) async =>
      throw UnimplementedError();
  @override
  Future<int> rawDelete(String sql, [List<Object?>? args]) async =>
      throw UnimplementedError();
  @override
  Future<List<Map<String, dynamic>>> rawQuery(
    String sql, [
    List<Object?>? args,
  ]) async =>
      throw UnimplementedError();
  @override
  Future<int> rawUpdate(String sql, [List<Object?>? args]) async =>
      throw UnimplementedError();
  @override
  Future<void> save(String table, String id, Map<String, dynamic> data) async =>
      throw UnimplementedError();
  @override
  Future<void> saveMany(
    String table,
    Map<String, Map<String, dynamic>> data,
  ) async =>
      throw UnimplementedError();
  @override
  Future<void> set(String table, String id, Map<String, dynamic> data) async =>
      throw UnimplementedError();

  @override
  Future<void> setMany(
    String table,
    Map<String, Map<String, dynamic>> data,
  ) async =>
      throw UnimplementedError();
}

/// 鐢ㄤ簬娴嬭瘯鐨勬ā鎷熸暟鎹簱
class MockDatabase implements DatabaseInterface {
  bool _isInitialized = false;
  final Map<String, Map<String, Map<String, dynamic>>> _storage = {};

  @override
  bool get isInitialized => _isInitialized;

  @override
  Future<void> clear(String table) async {
    _checkInitialized();
    _storage[table]?.clear();
  }

  @override
  Future<void> close() async {
    _storage.clear();
    _isInitialized = false;
  }

  @override
  Future<int> count(String table, [Map<String, dynamic>? filter]) async {
    _checkInitialized();
    return _storage[table]?.length ?? 0;
  }

  @override
  Future<void> delete(String table, String id) async {
    _checkInitialized();
    _storage[table]?.remove(id);
  }

  @override
  Future<void> deleteMany(String table, List<String> ids) async {
    _checkInitialized();
    for (final id in ids) {
      _storage[table]?.remove(id);
    }
  }

  Future<void> deleteWork(String id) async {
    _checkInitialized();
    await delete('works', id);
  }

  @override
  Future<Map<String, dynamic>?> get(String table, String id) async {
    _checkInitialized();
    return _storage[table]?[id];
  }

  @override
  Future<List<Map<String, dynamic>>> getAll(String table) async {
    _checkInitialized();
    if (_storage[table] == null) return [];
    return List<Map<String, dynamic>>.from(_storage[table]!.values);
  }

  Future<WorkEntity?> getWork(String id) async {
    _checkInitialized();
    final map = await get('works', id);
    if (map == null) return null;
    return WorkEntity.fromJson(map);
  }

  @override
  Future<void> initialize() async {
    await Future.delayed(const Duration(milliseconds: 100)); // 妯℃嫙鍒濆鍖栧欢杩?
    _isInitialized = true;
  }

  @override
  Future<List<Map<String, dynamic>>> query(
    String table,
    Map<String, dynamic> filter,
  ) async {
    _checkInitialized();
    if (_storage[table] == null) return [];
    return List<Map<String, dynamic>>.from(_storage[table]!.values);
  }

  // 棰濆鐨勫伐浣滅浉鍏虫柟娉?
  Future<List<WorkEntity>> queryWorks(WorkFilter filter) async {
    _checkInitialized();
    final maps = await query('works', filter.toJson());
    return maps.map((m) => WorkEntity.fromJson(m)).toList();
  }

  @override
  Future<int> rawDelete(String sql, [List<Object?>? args]) async {
    _checkInitialized();
    return 0;
  }

  @override
  Future<List<Map<String, dynamic>>> rawQuery(
    String sql, [
    List<Object?>? args,
  ]) async {
    _checkInitialized();
    return [];
  }

  @override
  Future<int> rawUpdate(String sql, [List<Object?>? args]) async {
    _checkInitialized();
    return 0;
  }

  @override
  Future<void> save(String table, String id, Map<String, dynamic> data) async {
    _checkInitialized();
    _storage.putIfAbsent(table, () => {});
    _storage[table]![id] = Map<String, dynamic>.from(data);
  }

  @override
  Future<void> saveMany(
    String table,
    Map<String, Map<String, dynamic>> data,
  ) async {
    _checkInitialized();
    _storage.putIfAbsent(table, () => {});
    _storage[table]!.addAll(
      Map<String, Map<String, dynamic>>.from(data),
    );
  }

  Future<void> saveWork(WorkEntity work) async {
    _checkInitialized();
    await save('works', work.id, work.toJson());
  }

  @override
  Future<void> set(String table, String id, Map<String, dynamic> data) async {
    await save(table, id, data);
  }

  @override
  Future<void> setMany(
    String table,
    Map<String, Map<String, dynamic>> data,
  ) async {
    await saveMany(table, data);
  }

  void _checkInitialized() {
    if (!_isInitialized) {
      throw StateError('Database not initialized');
    }
  }
}

/// 鐢ㄤ簬娴嬭瘯鐨勬參閫熸暟鎹簱
class SlowMockDatabase implements DatabaseInterface {
  final Duration delay;
  bool _isInitialized = false;
  final MockDatabase _delegate = MockDatabase();

  SlowMockDatabase({this.delay = const Duration(seconds: 3)});

  @override
  bool get isInitialized => _isInitialized;

  @override
  Future<void> clear(String table) async {
    await Future.delayed(delay);
    return _delegate.clear(table);
  }

  @override
  Future<void> close() async {
    await Future.delayed(delay);
    return _delegate.close();
  }

  @override
  Future<int> count(String table, [Map<String, dynamic>? filter]) async {
    await Future.delayed(delay);
    return _delegate.count(table, filter);
  }

  @override
  Future<void> delete(String table, String id) async {
    await Future.delayed(delay);
    return _delegate.delete(table, id);
  }

  @override
  Future<void> deleteMany(String table, List<String> ids) async {
    await Future.delayed(delay);
    return _delegate.deleteMany(table, ids);
  }

  @override
  Future<Map<String, dynamic>?> get(String table, String id) async {
    await Future.delayed(delay);
    return _delegate.get(table, id);
  }

  @override
  Future<List<Map<String, dynamic>>> getAll(String table) async {
    await Future.delayed(delay);
    return _delegate.getAll(table);
  }

  @override
  Future<void> initialize() async {
    await Future.delayed(delay);
    await _delegate.initialize();
    _isInitialized = true;
  }

  @override
  Future<List<Map<String, dynamic>>> query(
    String table,
    Map<String, dynamic> filter,
  ) async {
    await Future.delayed(delay);
    return _delegate.query(table, filter);
  }

  @override
  Future<int> rawDelete(String sql, [List<Object?>? args]) async {
    await Future.delayed(delay);
    return _delegate.rawDelete(sql, args);
  }

  @override
  Future<List<Map<String, dynamic>>> rawQuery(
    String sql, [
    List<Object?>? args,
  ]) async {
    await Future.delayed(delay);
    return _delegate.rawQuery(sql, args);
  }

  @override
  Future<int> rawUpdate(String sql, [List<Object?>? args]) async {
    await Future.delayed(delay);
    return _delegate.rawUpdate(sql, args);
  }

  @override
  Future<void> save(String table, String id, Map<String, dynamic> data) async {
    await Future.delayed(delay);
    return _delegate.save(table, id, data);
  }

  @override
  Future<void> saveMany(
    String table,
    Map<String, Map<String, dynamic>> data,
  ) async {
    await Future.delayed(delay);
    return _delegate.saveMany(table, data);
  }

  @override
  Future<void> set(String table, String id, Map<String, dynamic> data) async {
    await Future.delayed(delay);
    return _delegate.set(table, id, data);
  }

  @override
  Future<void> setMany(
    String table,
    Map<String, Map<String, dynamic>> data,
  ) async {
    await Future.delayed(delay);
    return _delegate.setMany(table, data);
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\infrastructure\persistence\file\file_storage.dart
-----------------------------------
import 'dart:convert';
import 'dart:io';

import 'package:path/path.dart' as path;
import 'package:path_provider/path_provider.dart';

class FileStorage {
  Future<String> get _basePath async {
    final directory = await getApplicationDocumentsDirectory();
    return directory.path;
  }

  // Directory creation
  Future<void> createDirectory(String path) async {
    final directory = Directory(path);
    if (!await directory.exists()) {
      await directory.create(recursive: true);
    }
  }

  Future<String> getBackupDirectory() async {
    final basePath = await _basePath;
    return path.join(basePath, 'storage', 'backup');
  }

  Future<String> getCharsDirectory() async {
    final basePath = await _basePath;
    return path.join(basePath, 'storage', 'chars');
  }

  Future<String> getPracticesDirectory() async {
    final basePath = await _basePath;
    return path.join(basePath, 'storage', 'practices');
  }

  Future<String> getTempDirectory() async {
    final basePath = await _basePath;
    return path.join(basePath, 'storage', 'temp');
  }

  // Work-related methods
  Future<String> getWorkDirectory(String workId) async {
    final worksDirectory = await getWorksDirectory();
    return path.join(worksDirectory, workId);
  }

  Future<File> getWorkImportedPictureFile(String workId, int index) async {
    final pictureDirectory = await getWorkPictureDirectory(workId, index);
    final filePath = path.join(pictureDirectory, 'imported.png');
    return File(filePath);
  }

  Future<File> getWorkMetadataFile(String workId) async {
    final workDirectory = await getWorkDirectory(workId);
    final filePath = path.join(workDirectory, 'metadata.json');
    return File(filePath);
  }

  Future<File> getWorkOriginalPictureFile(
      String workId, int index, String ext) async {
    final pictureDirectory = await getWorkPictureDirectory(workId, index);
    final filePath = path.join(pictureDirectory, 'original.$ext');
    return File(filePath);
  }

  Future<String> getWorkPictureDirectory(String workId, int index) async {
    final workDirectory = await getWorkDirectory(workId);
    return path.join(workDirectory, 'pictures', index.toString());
  }

  Future<String> getWorksDirectory() async {
    final basePath = await _basePath;
    return path.join(basePath, 'storage', 'works');
  }

  Future<File> getWorkThumbnailFile(String workId) async {
    final workDirectory = await getWorkDirectory(workId);
    final filePath = path.join(workDirectory, 'thumbnail.jpg');
    return File(filePath);
  }

  Future<List<int>?> readFile(File file) async {
    try {
      return await file.readAsBytes();
    } catch (e) {
      print('Error reading file: $e');
      return null;
    }
  }

  Future<Map<String, dynamic>?> readJson(File file) async {
    try {
      final jsonString = await file.readAsString();
      return jsonDecode(jsonString);
    } catch (e) {
      print('Error reading JSON from file: $e');
      return null;
    }
  }

  Future<void> writeFile(File file, List<int> data) async {
    await file.writeAsBytes(data);
  }

  // Generic read/write methods
  Future<void> writeJson(File file, Map<String, dynamic> data) async {
    final jsonString = jsonEncode(data);
    await file.writeAsString(jsonString);
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\infrastructure\persistence\models\database_query.dart
-----------------------------------
import '../../../infrastructure/logging/logger.dart';

/// 鏁版嵁搴撴煡璇?
class DatabaseQuery {
  final List<DatabaseQueryCondition> conditions;
  final List<DatabaseQueryGroup>? groups;
  final String? orderBy;
  final int? limit;
  final int? offset;

  const DatabaseQuery({
    this.conditions = const [],
    this.groups,
    this.orderBy,
    this.limit,
    this.offset,
  });

  factory DatabaseQuery.fromJson(Map<String, dynamic> json) {
    AppLogger.debug('DatabaseQuery.fromJson', tag: 'DatabaseQuery', data: {
      'json': json,
      'whereType': json['where']?.runtimeType.toString(),
      'where': json['where'],
    });

    final conditions = <DatabaseQueryCondition>[];
    final groups = <DatabaseQueryGroup>[];

    try {
      if (json.containsKey('where')) {
        if (json['where'] is List) {
          final list = json['where'] as List;
          AppLogger.debug('澶勭悊List绫诲瀷鐨剋here鏉′欢', tag: 'DatabaseQuery', data: {
            'count': list.length,
            'firstItem': list.isNotEmpty ? list.first : null,
          });

          for (var item in list) {
            if (item is Map) {
              final condition = DatabaseQueryCondition.fromJson(
                  Map<String, dynamic>.from(item));
              conditions.add(condition);

              AppLogger.debug('娣诲姞鏌ヨ鏉′欢', tag: 'DatabaseQuery', data: {
                'field': condition.field,
                'op': condition.operator,
                'val': condition.value,
              });
            } else {
              AppLogger.error('鏃犳晥鐨勬煡璇㈡潯浠?,
                  tag: 'DatabaseQuery',
                  error: 'Item is not a Map',
                  data: {
                    'item': item,
                    'type': item.runtimeType.toString(),
                  });
            }
          }
        } else if (json['where'] is Map) {
          final where = Map<String, dynamic>.from(json['where'] as Map);
          AppLogger.debug('澶勭悊Map绫诲瀷鐨剋here鏉′欢', tag: 'DatabaseQuery', data: {
            'fields': where.keys.toList(),
          });

          conditions.addAll(
            where.entries.map((e) => DatabaseQueryCondition(
                  field: e.key,
                  operator: '=',
                  value: e.value,
                )),
          );
        } else {
          AppLogger.warning('涓嶆敮鎸佺殑where绫诲瀷', tag: 'DatabaseQuery', data: {
            'type': json['where']?.runtimeType.toString(),
          });
        }
      }

      if (json.containsKey('conditions')) {
        final list = json['conditions'] as List;
        conditions.addAll(
          list.map((e) => DatabaseQueryCondition.fromJson(
              Map<String, dynamic>.from(e as Map))),
        );
      }

      if (json.containsKey('groups')) {
        final list = json['groups'] as List;
        groups.addAll(
          list.map((e) =>
              DatabaseQueryGroup.fromJson(Map<String, dynamic>.from(e as Map))),
        );
      }

      AppLogger.debug('鏌ヨ鏉′欢鏋勫缓瀹屾垚', tag: 'DatabaseQuery', data: {
        'conditionCount': conditions.length,
        'groupCount': groups.length,
        'orderBy': json['orderBy'],
      });

      return DatabaseQuery(
        conditions: conditions,
        groups: groups.isEmpty ? null : groups,
        orderBy: json['orderBy'] as String?,
        limit: json['limit'] as int?,
        offset: json['offset'] as int?,
      );
    } catch (e, stack) {
      AppLogger.error('鏋勫缓鏌ヨ鏉′欢澶辫触',
          tag: 'DatabaseQuery',
          error: e,
          stackTrace: stack,
          data: {'json': json});
      rethrow;
    }
  }

  Map<String, dynamic> toJson() => {
        'conditions': conditions.map((e) => e.toJson()).toList(),
        if (groups != null) 'groups': groups!.map((e) => e.toJson()).toList(),
        if (orderBy != null) 'orderBy': orderBy,
        if (limit != null) 'limit': limit,
        if (offset != null) 'offset': offset,
      };
}

/// 鏁版嵁搴撴煡璇㈡潯浠?
class DatabaseQueryCondition {
  final String field;
  final String operator;
  final dynamic value;

  const DatabaseQueryCondition({
    required this.field,
    required this.operator,
    required this.value,
  });

  factory DatabaseQueryCondition.fromJson(Map<String, dynamic> json) {
    AppLogger.debug('鍒涘缓鏌ヨ鏉′欢', tag: 'DatabaseQuery', data: {
      'json': json,
    });

    return DatabaseQueryCondition(
      field: json['field'] as String,
      operator: json['op'] as String? ?? '=',
      value: json['val'],
    );
  }

  Map<String, dynamic> toJson() => {
        'field': field,
        'op': operator,
        'val': value,
      };
}

/// 鏌ヨ鏉′欢缁?
class DatabaseQueryGroup {
  final List<DatabaseQueryCondition> conditions;
  final String type; // 'AND' or 'OR'

  const DatabaseQueryGroup({
    required this.conditions,
    required this.type,
  });

  factory DatabaseQueryGroup.and(List<DatabaseQueryCondition> conditions) {
    return DatabaseQueryGroup(conditions: conditions, type: 'AND');
  }

  factory DatabaseQueryGroup.fromJson(Map<String, dynamic> json) {
    return DatabaseQueryGroup(
      conditions: (json['conditions'] as List)
          .map((e) => DatabaseQueryCondition.fromJson(
              Map<String, dynamic>.from(e as Map)))
          .toList(),
      type: json['type'] as String,
    );
  }

  factory DatabaseQueryGroup.or(List<DatabaseQueryCondition> conditions) {
    return DatabaseQueryGroup(conditions: conditions, type: 'OR');
  }

  Map<String, dynamic> toJson() => {
        'conditions': conditions.map((e) => e.toJson()).toList(),
        'type': type,
      };
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\infrastructure\persistence\sqlite\database_error_handler.dart
-----------------------------------
import 'package:sqflite/sqflite.dart';

import '../../logging/logger.dart';

class DatabaseError implements Exception {
  final String message;
  final String operation;
  final dynamic originalError;
  final StackTrace stackTrace;

  DatabaseError(
    this.message,
    this.operation,
    this.originalError,
    this.stackTrace,
  );

  @override
  String toString() => 'DatabaseError: $message (operation: $operation)';
}

/// 鏁版嵁搴撻敊璇鐞嗗櫒
class DatabaseErrorHandler {
  /// 瀹夊叏鎵ц鏁版嵁搴撴搷浣?
  static Future<T> execute<T>(
    String operation,
    Future<T> Function() action,
  ) async {
    try {
      return await action();
    } on DatabaseException catch (e, stack) {
      final error = DatabaseError(
        e.toString(),
        operation,
        e,
        stack,
      );

      AppLogger.error(
        'Database operation failed',
        tag: 'Database',
        error: error,
        stackTrace: stack,
        data: {'operation': operation},
      );
      throw error;
    } catch (e, stack) {
      final error = DatabaseError(
        'Unexpected database error',
        operation,
        e,
        stack,
      );

      AppLogger.error(
        'Unexpected database error',
        tag: 'Database',
        error: error,
        stackTrace: stack,
        data: {'operation': operation},
      );
      throw error;
    }
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\infrastructure\persistence\sqlite\migrations.dart
-----------------------------------
/// SQLite鏁版嵁搴撹縼绉昏剼鏈?
const migrations = [
  // 鐗堟湰 1: 鍒涘缓鍩虹琛ㄧ粨鏋?
  '''
  -- 浣滃搧琛?
  CREATE TABLE IF NOT EXISTS works (
    id TEXT PRIMARY KEY,
    title TEXT NOT NULL,
    author TEXT,
    style TEXT,
    tool TEXT,
    remark TEXT,
    creationDate TEXT,
    createTime TEXT NOT NULL,
    updateTime TEXT NOT NULL,
    tags TEXT,
    status TEXT NOT NULL DEFAULT 'draft',
    imageCount INTEGER DEFAULT 0
  );

  -- 瑙掕壊琛?
  CREATE TABLE IF NOT EXISTS characters (
    id TEXT PRIMARY KEY,
    workId TEXT NOT NULL,
    pageId TEXT NOT NULL,
    character TEXT NOT NULL,
    region TEXT NOT NULL,
    tags TEXT,
    createTime TEXT NOT NULL,
    updateTime TEXT NOT NULL,
    FOREIGN KEY (workId) REFERENCES works (id) ON DELETE CASCADE
  );

  -- 瀛楀笘琛?
  CREATE TABLE IF NOT EXISTS practices (
    id TEXT PRIMARY KEY,
    title TEXT NOT NULL,
    pages TEXT NOT NULL,
    tags TEXT,
    createTime TEXT NOT NULL,
    updateTime TEXT NOT NULL
  );

  -- 鏍囩琛?
  CREATE TABLE IF NOT EXISTS tags (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT
  );

  -- 璁剧疆琛?
  CREATE TABLE IF NOT EXISTS settings (
    key TEXT PRIMARY KEY,
    value TEXT NOT NULL,
    updateTime TEXT NOT NULL
  );

  -- 鍒涘缓绱㈠紩
  CREATE INDEX IF NOT EXISTS idx_characters_workId ON characters(workId);
  CREATE INDEX IF NOT EXISTS idx_characters_char ON characters(character);
  ''',

  // 鐗堟湰 2: 娣诲姞浣滃搧鍥剧墖绠＄悊 - 琛ㄥ拰绱㈠紩
  '''
  CREATE TABLE IF NOT EXISTS work_images (
    id TEXT PRIMARY KEY,
    workId TEXT NOT NULL,
    indexInWork INTEGER NOT NULL,
    path TEXT NOT NULL,
    original_path TEXT,
    thumbnail_path TEXT,
    format TEXT NOT NULL,
    size INTEGER NOT NULL,
    width INTEGER NOT NULL,
    height INTEGER NOT NULL,
    createTime TEXT NOT NULL,
    updateTime TEXT NOT NULL,
    FOREIGN KEY (workId) REFERENCES works (id) ON DELETE CASCADE
  )
  ''',

  '''
  CREATE INDEX IF NOT EXISTS idx_work_images_workId ON work_images(workId);
  CREATE INDEX IF NOT EXISTS idx_work_images_index ON work_images(workId, indexInWork);
  CREATE INDEX IF NOT EXISTS idx_work_images_original_path ON work_images(workId, original_path);
  CREATE UNIQUE INDEX IF NOT EXISTS idx_work_images_unique_path 
  ON work_images(workId, original_path)
  WHERE original_path IS NOT NULL;
  ''',

  // 鐗堟湰 2: 娣诲姞浣滃搧瀛楁
  '''
  ALTER TABLE works ADD COLUMN firstImageId TEXT REFERENCES work_images(id);
  ALTER TABLE works ADD COLUMN lastImageUpdateTime TEXT;
  ''',

  // 鐗堟湰 2: 娣诲姞瑙﹀彂鍣?
  '''
  CREATE TRIGGER IF NOT EXISTS update_work_image_count_insert 
  AFTER INSERT ON work_images
  BEGIN
    UPDATE works 
    SET imageCount = (
      SELECT COUNT(*) 
      FROM work_images 
      WHERE workId = NEW.workId
    )
    WHERE id = NEW.workId;
  END;
  ''',

  '''
  CREATE TRIGGER IF NOT EXISTS update_work_image_count_delete 
  AFTER DELETE ON work_images
  BEGIN
    UPDATE works 
    SET imageCount = (
      SELECT COUNT(*) 
      FROM work_images 
      WHERE workId = OLD.workId
    )
    WHERE id = OLD.workId;
  END;
  ''',

  '''
  CREATE TRIGGER IF NOT EXISTS update_work_first_image_on_insert 
  AFTER INSERT ON work_images
  BEGIN
    UPDATE works 
    SET firstImageId = (
      SELECT id
      FROM work_images
      WHERE workId = NEW.workId
      ORDER BY indexInWork ASC
      LIMIT 1
    ),
    lastImageUpdateTime = strftime('%Y-%m-%dT%H:%M:%fZ', 'now')
    WHERE id = NEW.workId;
  END;
  ''',

  '''
  CREATE TRIGGER IF NOT EXISTS update_work_first_image_on_update 
  AFTER UPDATE OF indexInWork ON work_images
  BEGIN
    UPDATE works 
    SET firstImageId = (
      SELECT id
      FROM work_images
      WHERE workId = NEW.workId
      ORDER BY indexInWork ASC
      LIMIT 1
    ),
    lastImageUpdateTime = strftime('%Y-%m-%dT%H:%M:%fZ', 'now')
    WHERE id = NEW.workId;
  END;
  ''',

  '''
  CREATE TRIGGER IF NOT EXISTS update_work_first_image_on_delete 
  AFTER DELETE ON work_images
  BEGIN
    UPDATE works 
    SET firstImageId = (
      SELECT id FROM work_images WHERE workId = OLD.workId ORDER BY indexInWork ASC LIMIT 1
    ),
    lastImageUpdateTime = strftime('%Y-%m-%dT%H:%M:%fZ', 'now')
    WHERE id = OLD.workId;
  END;
  ''',

  // 鐗堟湰 5: 娣诲姞瀛楃鏀惰棌鍔熻兘
  '''
  ALTER TABLE characters ADD COLUMN isFavorite INTEGER NOT NULL DEFAULT 0;
  ALTER TABLE characters ADD COLUMN note TEXT;
  ''',

  // 鐗堟湰 6: 娣诲姞涓存椂宸ヤ綔椤?
  '''
  INSERT OR IGNORE INTO works (
    id,
    title,
    author,
    status,
    createTime,
    updateTime
  ) VALUES (
    'temp',
    '涓存椂宸ヤ綔椤?,
    'system',
    'draft',
    datetime('now'),
    datetime('now')
  );
  ''',
];



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\infrastructure\persistence\sqlite\sqlite_database.dart
-----------------------------------
import 'package:flutter/foundation.dart';
import 'package:path/path.dart';
import 'package:sqflite/sqflite.dart';
import 'package:sqflite_common_ffi/sqflite_ffi.dart';

import '../../logging/logger.dart';
import '../database_interface.dart';
import '../models/database_query.dart';

/// SQLite鏁版嵁搴撳疄鐜?
class SQLiteDatabase implements DatabaseInterface {
  final Database _db;

  const SQLiteDatabase._(this._db);

  @override
  Future<void> clear(String table) async {
    await _db.delete(table);
  }

  @override
  Future<void> close() async {
    await _db.close();
  }

  @override
  Future<int> count(String table, [Map<String, dynamic>? filter]) async {
    if (filter == null || filter.isEmpty) {
      final result = await _db.rawQuery('SELECT COUNT(*) as count FROM $table');
      return Sqflite.firstIntValue(result) ?? 0;
    }

    final query = DatabaseQuery.fromJson(filter);
    final queryResult = _buildCountSql(table, query);

    final result = await _db.rawQuery(queryResult.sql, queryResult.args);
    AppLogger.debug(
      '缁熻鏌ヨ瀹屾垚',
      tag: 'SQLiteDatabase',
    );

    return Sqflite.firstIntValue(result) ?? 0;
  }

  @override
  Future<void> delete(String table, String id) async {
    await _db.delete(
      table,
      where: 'id = ?',
      whereArgs: [id],
    );
  }

  @override
  Future<void> deleteMany(String table, List<String> ids) async {
    final batch = _db.batch();
    for (final id in ids) {
      batch.delete(
        table,
        where: 'id = ?',
        whereArgs: [id],
      );
    }
    await batch.commit(noResult: true);
  }

  @override
  Future<Map<String, dynamic>?> get(String table, String id) async {
    final results = await _db.query(
      table,
      where: 'id = ?',
      whereArgs: [id],
      limit: 1,
    );
    return results.isEmpty ? null : results.first;
  }

  @override
  Future<List<Map<String, dynamic>>> getAll(String table) async {
    return _db.query(table);
  }

  @override
  Future<void> initialize() async {
    // 鏁版嵁搴撳凡鍦ㄦ瀯閫犳椂鍒濆鍖?
  }

  @override
  Future<List<Map<String, dynamic>>> query(
    String table,
    Map<String, dynamic> filter,
  ) async {
    AppLogger.debug(
      '鎵ц鏁版嵁搴撴煡璇?,
      tag: 'SQLiteDatabase',
      data: {
        'table': table,
        'filter': filter,
      },
    );

    final query = DatabaseQuery.fromJson(filter);
    final queryResult = _buildQuerySql(table, query);

    AppLogger.debug(
      '鐢熸垚SQL鏌ヨ璇彞',
      tag: 'SQLiteDatabase',
      data: {
        'sql': queryResult.sql,
        'args': queryResult.args,
      },
    );

    final results = await _db.rawQuery(queryResult.sql, queryResult.args);

    AppLogger.debug(
      '鏌ヨ瀹屾垚',
      tag: 'SQLiteDatabase',
      data: {
        'resultCount': results.length,
      },
    );

    return results;
  }

  @override
  Future<int> rawDelete(String sql, [List<Object?>? args]) async {
    return _db.rawDelete(sql, args);
  }

  @override
  Future<List<Map<String, dynamic>>> rawQuery(
    String sql, [
    List<Object?>? args,
  ]) async {
    return _db.rawQuery(sql, args);
  }

  @override
  Future<int> rawUpdate(String sql, [List<Object?>? args]) async {
    return _db.rawUpdate(sql, args);
  }

  @override
  Future<void> save(String table, String id, Map<String, dynamic> data) async {
    await _db.update(
      table,
      data,
      where: 'id = ?',
      whereArgs: [id],
    );
  }

  @override
  Future<void> saveMany(
    String table,
    Map<String, Map<String, dynamic>> data,
  ) async {
    final batch = _db.batch();
    for (final entry in data.entries) {
      batch.update(
        table,
        entry.value,
        where: 'id = ?',
        whereArgs: [entry.key],
      );
    }
    await batch.commit(noResult: true);
  }

  @override
  Future<void> set(String table, String id, Map<String, dynamic> data) async {
    await _db.insert(
      table,
      {'id': id, ...data},
      conflictAlgorithm: ConflictAlgorithm.replace,
    );
  }

  @override
  Future<void> setMany(
    String table,
    Map<String, Map<String, dynamic>> data,
  ) async {
    final batch = _db.batch();
    for (final entry in data.entries) {
      batch.insert(
        table,
        {'id': entry.key, ...entry.value},
        conflictAlgorithm: ConflictAlgorithm.replace,
      );
    }
    await batch.commit(noResult: true);
  }

  /// 鏋勫缓COUNT鏌ヨSQL
  ({String sql, List<Object?> args}) _buildCountSql(
      String table, DatabaseQuery query) {
    final where = <String>[];
    final whereArgs = <dynamic>[];

    // 澶勭悊鏅€氭潯浠?
    for (final condition in query.conditions) {
      where.add('${condition.field} ${condition.operator} ?');
      whereArgs.add(condition.value);
    }

    // 澶勭悊鏉′欢缁?
    if (query.groups?.isNotEmpty == true) {
      for (final group in query.groups!) {
        final groupWheres = <String>[];
        for (final condition in group.conditions) {
          groupWheres.add('${condition.field} ${condition.operator} ?');
          whereArgs.add(condition.value);
        }
        if (groupWheres.isNotEmpty) {
          final groupOperator = group.type == 'AND' ? ' AND ' : ' OR ';
          where.add('(${groupWheres.join(groupOperator)})');
        }
      }
    }

    final whereClause = where.isEmpty ? '' : 'WHERE ${where.join(' AND ')}';
    return (
      sql: 'SELECT COUNT(*) as count FROM $table $whereClause',
      args: whereArgs
    );
  }

  /// 鏋勫缓鏌ヨSQL
  ({String sql, List<Object?> args}) _buildQuerySql(
      String table, DatabaseQuery query) {
    final where = <String>[];
    final whereArgs = <dynamic>[];

    // 澶勭悊鏅€氭潯浠?
    for (final condition in query.conditions) {
      where.add('${condition.field} ${condition.operator} ?');
      whereArgs.add(condition.value);
    }

    // 澶勭悊鏉′欢缁?
    if (query.groups?.isNotEmpty == true) {
      for (final group in query.groups!) {
        final groupWheres = <String>[];
        for (final condition in group.conditions) {
          groupWheres.add('${condition.field} ${condition.operator} ?');
          whereArgs.add(condition.value);
        }
        if (groupWheres.isNotEmpty) {
          final groupOperator = group.type == 'AND' ? ' AND ' : ' OR ';
          where.add('(${groupWheres.join(groupOperator)})');
        }
      }
    }

    final whereClause = where.isEmpty ? '' : 'WHERE ${where.join(' AND ')}';
    final orderClause =
        query.orderBy == null ? '' : 'ORDER BY ${query.orderBy}';
    final limitClause = query.limit == null ? '' : 'LIMIT ${query.limit}';
    final offsetClause = query.offset == null ? '' : 'OFFSET ${query.offset}';

    return (
      sql:
          'SELECT * FROM $table $whereClause $orderClause $limitClause $offsetClause',
      args: whereArgs
    );
  }

  /// 鍒涘缓SQLite鏁版嵁搴撳疄渚?
  static Future<SQLiteDatabase> create({
    required String name,
    required String directory,
    List<String> migrations = const [],
  }) async {
    // 鍦?Windows 骞冲彴涓婂垵濮嬪寲 sqflite_ffi
    if (defaultTargetPlatform == TargetPlatform.windows) {
      AppLogger.debug('鍒濆鍖?SQLite FFI', tag: 'App');
      sqfliteFfiInit();
      databaseFactory = databaseFactoryFfi;
    }

    final path = join(directory, name);

    AppLogger.info(
      '鏁版嵁搴撻厤缃俊鎭?\n'
      '  - 鏁版嵁搴撶被鍨? SQLite3\n'
      '  - 鏁版嵁搴撳悕绉? $name\n'
      '  - 鏁版嵁搴撶洰褰? $directory\n'
      '  - 瀹屾暣璺緞: $path\n'
      '  - 鏁版嵁搴撶増鏈? ${migrations.length}\n'
      '  - 杩佺Щ鑴氭湰鏁伴噺: ${migrations.length}',
      tag: 'Database',
    );

    final db = await openDatabase(
      path,
      version: migrations.length,
      onCreate: (db, version) async {
        AppLogger.info(
          '棣栨鍒涘缓鏁版嵁搴擄紝鎵ц鍒濆鍖?..\n'
          '鎵ц杩佺Щ鑴氭湰:\n',
          tag: 'Database',
        );
        for (final sql in migrations) {
          AppLogger.info(
            '鎵цSQL:\n$sql',
            tag: 'Database',
          );
          await db.execute(sql);
        }
      },
      onUpgrade: (db, oldVersion, newVersion) async {
        AppLogger.info(
          '鍗囩骇鏁版嵁搴?\n'
          '  - 褰撳墠鐗堟湰: v$oldVersion\n'
          '  - 鐩爣鐗堟湰: v$newVersion',
          tag: 'Database',
        );
        for (var i = oldVersion; i < newVersion; i++) {
          AppLogger.debug(
            '鎵ц杩佺Щ鑴氭湰 ${i + 1}:\n${migrations[i]}',
            tag: 'Database',
          );
          await db.execute(migrations[i]);
        }
      },
      onConfigure: (db) async {
        await db.execute('PRAGMA foreign_keys = ON');
        AppLogger.debug(
          'SQLite閰嶇疆瀹屾垚: 宸插惎鐢ㄥ閿害鏉?,
          tag: 'Database',
        );
      },
    );
    return SQLiteDatabase._(db);
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\infrastructure\providers\database_providers.dart
-----------------------------------
import 'package:demo/infrastructure/providers/storage_providers.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../persistence/database_interface.dart';
import '../persistence/sqlite/migrations.dart';
import '../persistence/sqlite/sqlite_database.dart';

/// 鏁版嵁搴揚rovider
final databaseProvider = FutureProvider<DatabaseInterface>((ref) async {
  final basePath = await ref.watch(storageProvider.future).then((storage) {
    return storage.getAppDataPath();
  });
  return SQLiteDatabase.create(
    name: 'app.db',
    directory: '$basePath/database',
    migrations: migrations,
  );
});

/// 鏁版嵁搴撳垵濮嬪寲Provider
final initializedDatabaseProvider = Provider<DatabaseInterface>((ref) {
  final databaseState = ref.watch(databaseProvider);
  return databaseState.when(
    data: (database) => database,
    loading: () => throw StateError('Database service not initialized'),
    error: (err, stack) =>
        throw StateError('Database initialization failed: $err'),
  );
});



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\infrastructure\providers\persistence_provider.dart
-----------------------------------
import 'dart:convert';

import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:shared_preferences/shared_preferences.dart';

import '../../domain/models/work/work_filter.dart';

final persistenceProvider = Provider<PersistenceService>((ref) {
  return PersistenceService();
});

class PersistenceService {
  static const String viewModeKey = 'view_mode';
  static const String filterKey = 'work_filter';
  static const String sortKey = 'work_sort';
  static const String sidebarKey = 'sidebar_state';

  late SharedPreferences _sharedPreferences;

  SharedPreferences get sharedPreferences => _sharedPreferences;

  Future<void> init() async {
    _sharedPreferences = await SharedPreferences.getInstance();
  }

  Future<WorkFilter?> loadFilter() async {
    final prefs = await SharedPreferences.getInstance();
    final data = prefs.getString(filterKey);
    if (data == null) return null;
    return WorkFilter.fromJson(jsonDecode(data));
  }

  Future<bool> loadSidebarState() async {
    final prefs = await SharedPreferences.getInstance();
    return prefs.getBool(sidebarKey) ?? true;
  }

  Future<void> saveFilter(WorkFilter filter) async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.setString(filterKey, jsonEncode(filter.toJson()));
  }

  Future<void> saveSidebarState(bool isOpen) async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.setBool(sidebarKey, isOpen);
  }

  Future<void> saveViewMode(String mode) async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.setString(viewModeKey, mode);
  }

  // ...鍏朵粬鎸佷箙鍖栨柟娉?
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\infrastructure\providers\shared_preferences_provider.dart
-----------------------------------
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:shared_preferences/shared_preferences.dart';

// 娣诲姞寮傛鍒濆鍖朠rovider
final initializeSharedPreferencesProvider =
    FutureProvider<SharedPreferences>((ref) async {
  return await SharedPreferences.getInstance();
});

final sharedPreferencesProvider = Provider<SharedPreferences>((ref) {
  throw UnimplementedError(
      'sharedPreferencesProvider not initialized. Use override in ProviderScope.');
});



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\infrastructure\providers\storage_providers.dart
-----------------------------------
import 'package:demo/infrastructure/storage/local_storage.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:path/path.dart' as path;
import 'package:path_provider/path_provider.dart';

import '../../infrastructure/storage/storage_interface.dart';
import '../logging/logger.dart';

/// 鑾峰彇宸插垵濮嬪寲鐨勫瓨鍌ㄥ疄渚?
final initializedStorageProvider = Provider<IStorage>((ref) {
  final storageState = ref.watch(storageProvider);
  return storageState.when(
    data: (storage) => storage,
    loading: () => throw StateError('Storage service not initialized'),
    error: (err, stack) =>
        throw StateError('Storage initialization failed: $err'),
  );
});

/// 瀛樺偍鏈嶅姟 Provider
/// 鎻愪緵搴旂敤鐨勫瓨鍌ㄦ湇鍔″疄渚嬶紝璐熻矗鍒濆鍖栧拰绠＄悊瀛樺偍璧勬簮
final storageProvider = FutureProvider<IStorage>((ref) async {
  AppLogger.debug('鍒濆鍖栧瓨鍌ㄦ湇鍔?, tag: 'Storage');

  try {
    // 1. 鑾峰彇瀛樺偍璺緞
    final appDir = await getApplicationDocumentsDirectory();
    final storagePath = path.join(appDir.path, 'storage');

    // 2. 鍒涘缓瀛樺偍鏈嶅姟瀹炰緥
    final storage = LocalStorage(basePath: storagePath);

    // 3. 鍒濆鍖栫洰褰曠粨鏋?
    await _initializeStorageStructure(storage);

    AppLogger.info('瀛樺偍鏈嶅姟鍒濆鍖栧畬鎴?, tag: 'Storage');
    return storage;
  } catch (e, stack) {
    AppLogger.error('瀛樺偍鏈嶅姟鍒濆鍖栧け璐?, error: e, stackTrace: stack, tag: 'Storage');
    rethrow;
  }
});

/// 鍒涘缓瀛樺偍鏈嶅姟鎵€闇€鐨勫熀纭€鐩綍缁撴瀯
Future<void> _initializeStorageStructure(IStorage storage) async {
  final appDataDir = storage.getAppDataPath();
  final tempDir = await storage.createTempDirectory();

  // 鍒涘缓鎵€闇€鐨勭洰褰曠粨鏋?
  await Future.wait([
    storage.ensureDirectoryExists(appDataDir),
    storage.ensureDirectoryExists(path.join(appDataDir, 'works')),
    storage.ensureDirectoryExists(path.join(appDataDir, 'cache')),
    storage.ensureDirectoryExists(path.join(appDataDir, 'config')),
    storage.ensureDirectoryExists(path.join(appDataDir, 'temp')),
    storage.ensureDirectoryExists(tempDir.path),
  ]);

  AppLogger.debug('瀛樺偍鐩綍缁撴瀯鍒涘缓瀹屾垚', tag: 'Storage');
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\infrastructure\storage\local_storage.dart
-----------------------------------
import 'dart:io';

import 'package:path/path.dart' as path;

import '../logging/logger.dart';
import 'storage_interface.dart';

/// 鍩虹瀛樺偍鏈嶅姟
///
/// 鑱岃矗:
/// 1. 鍩虹鏂囦欢绯荤粺鎿嶄綔
/// 2. 鏂囦欢鍜岀洰褰曠鐞?
/// 3. 璺緞鐢熸垚鍜岄獙璇?
/// 4. 鍩虹閿欒澶勭悊
class LocalStorage implements IStorage {
  final String _basePath;

  LocalStorage({
    required String basePath,
  }) : _basePath = basePath;

  /// 鑾峰彇搴旂敤鏁版嵁鏍圭洰褰?
  String get appDataPath => _basePath;

  /// 澶嶅埗鏂囦欢
  @override
  Future<void> copyFile(String sourcePath, String targetPath) async {
    try {
      _validatePath(targetPath);
      final sourceFile = File(sourcePath);
      if (!await sourceFile.exists()) {
        throw FileSystemException('婧愭枃浠朵笉瀛樺湪', sourcePath);
      }

      // 纭繚鐩爣鐩綍瀛樺湪
      final targetDir = path.dirname(targetPath);
      await createDirectory(targetDir).then((dir) => null);

      await sourceFile.copy(targetPath);
    } catch (e, stack) {
      _handleError(
        '澶嶅埗鏂囦欢澶辫触',
        e,
        stack,
        data: {
          'source': sourcePath,
          'target': targetPath,
        },
      );
    }
  }

  /// 鍒涘缓鐩綍
  @override
  Future<Directory> createDirectory(String dirPath) async {
    try {
      _validatePath(dirPath);
      final dir = Directory(dirPath);
      if (!await dir.exists()) {
        await dir.create(recursive: true);
        return dir;
      }
      return dir;
    } catch (e, stack) {
      _handleError(
        '鍒涘缓鐩綍澶辫触',
        e,
        stack,
        data: {'path': dirPath},
      );
      rethrow;
    }
  }

  // ... Rest of the existing implementation ...

  /// 鑾峰彇涓存椂鐩綍
  @override
  Future<Directory> createTempDirectory() async {
    try {
      final tempBasePath = path.join(_basePath, 'temp');
      final tempDirName = 'app_${DateTime.now().millisecondsSinceEpoch}';
      return await Directory(path.join(tempBasePath, tempDirName))
          .create(recursive: true);
    } catch (e, stack) {
      _handleError('鑾峰彇涓存椂鐩綍澶辫触', e, stack);
      rethrow;
    }
  }

  /// 鍒犻櫎鐩綍
  @override
  Future<void> deleteDirectory(String dirPath) async {
    try {
      _validatePath(dirPath);
      final dir = Directory(dirPath);
      if (await dir.exists()) {
        await dir.delete(recursive: true);
      }
    } catch (e, stack) {
      _handleError(
        '鍒犻櫎鐩綍澶辫触',
        e,
        stack,
        data: {'path': dirPath},
      );
    }
  }

  /// 鍒犻櫎鏂囦欢
  @override
  Future<void> deleteFile(String filePath) async {
    try {
      _validatePath(filePath);
      final file = File(filePath);
      if (await file.exists()) {
        await file.delete();
      }
    } catch (e, stack) {
      _handleError(
        '鍒犻櫎鏂囦欢澶辫触',
        e,
        stack,
        data: {'path': filePath},
      );
    }
  }

  /// 妫€鏌ョ洰褰曟槸鍚﹀瓨鍦?
  @override
  Future<bool> directoryExists(String dirPath) async {
    _validatePath(dirPath);
    return Directory(dirPath).exists();
  }

  /// 纭繚鐩綍瀛樺湪
  @override
  Future<void> ensureDirectoryExists(String dirPath) async {
    try {
      _validatePath(dirPath);
      await Directory(dirPath).create(recursive: true);
    } catch (e, stack) {
      _handleError(
        '纭繚鐩綍瀛樺湪澶辫触',
        e,
        stack,
        data: {'path': dirPath},
      );
    }
  }

  /// 妫€鏌ユ枃浠舵槸鍚﹀瓨鍦?
  @override
  Future<bool> fileExists(String filePath) async {
    _validatePath(filePath);
    return File(filePath).exists();
  }

  /// 鑾峰彇搴旂敤缂撳瓨鐩綍璺緞
  @override
  String getAppCachePath() {
    return path.join(_basePath, 'cache');
  }

  /// 鑾峰彇搴旂敤鏁版嵁鐩綍璺緞
  @override
  String getAppDataPath() {
    return _basePath;
  }

  @override
  String getAppTempPath() {
    return path.join(_basePath, 'temp');
  }

  /// 鑾峰彇鏂囦欢淇敼鏃堕棿
  @override
  Future<DateTime> getFileModifiedTime(String filePath) async {
    try {
      _validatePath(filePath);
      final file = File(filePath);
      if (!await file.exists()) {
        throw FileSystemException('鏂囦欢涓嶅瓨鍦?, filePath);
      }
      return await file.lastModified();
    } catch (e, stack) {
      _handleError(
        '鑾峰彇鏂囦欢淇敼鏃堕棿澶辫触',
        e,
        stack,
        data: {'path': filePath},
      );
      rethrow;
    }
  }

  /// 鑾峰彇鏂囦欢澶у皬
  @override
  Future<int> getFileSize(String filePath) async {
    try {
      _validatePath(filePath);
      final file = File(filePath);
      if (!await file.exists()) {
        throw FileSystemException('鏂囦欢涓嶅瓨鍦?, filePath);
      }
      return await file.length();
    } catch (e, stack) {
      _handleError(
        '鑾峰彇鏂囦欢澶у皬澶辫触',
        e,
        stack,
        data: {'path': filePath},
      );
      rethrow;
    }
  }

  /// 楠岃瘉璺緞鏄惁鍦ㄥ簲鐢ㄧ洰褰曞唴
  bool isPathValid(String targetPath) {
    final normalized = path.normalize(targetPath);
    return normalized.startsWith(_basePath);
  }

  /// 鍒楀嚭鐩綍涓殑鎵€鏈夋枃浠惰矾寰勶紙閫掑綊锛?
  @override
  Future<List<String>> listDirectoryFiles(String dirPath) async {
    try {
      _validatePath(dirPath);
      final dir = Directory(dirPath);
      if (!await dir.exists()) {
        return [];
      }

      final files = <String>[];
      await for (final entity in dir.list(recursive: true)) {
        if (entity is File) {
          files.add(entity.path);
        }
      }

      AppLogger.debug('鍒楀嚭鐩綍鏂囦欢', tag: 'LocalStorage', data: {
        'directory': dirPath,
        'fileCount': files.length,
      });

      return files;
    } catch (e, stack) {
      _handleError(
        '鍒楀嚭鐩綍鏂囦欢澶辫触',
        e,
        stack,
        data: {'path': dirPath},
      );
      return [];
    }
  }

  /// 绉诲姩鏂囦欢
  @override
  Future<void> moveFile(String sourcePath, String targetPath) async {
    try {
      _validatePath(targetPath);
      final sourceFile = File(sourcePath);
      if (!await sourceFile.exists()) {
        throw FileSystemException('婧愭枃浠朵笉瀛樺湪', sourcePath);
      }

      // 纭繚鐩爣鐩綍瀛樺湪
      final targetDir = path.dirname(targetPath);
      await createDirectory(targetDir).then((dir) => null);

      await sourceFile.rename(targetPath);
    } catch (e, stack) {
      _handleError(
        '绉诲姩鏂囦欢澶辫触',
        e,
        stack,
        data: {
          'source': sourcePath,
          'target': targetPath,
        },
      );
    }
  }

  /// 瑙勮寖鍖栬矾寰?
  String normalizePath(String relativePath) =>
      path.join(_basePath, relativePath);

  /// 璇诲彇鏂囦欢
  @override
  Future<List<int>> readFile(String filePath) async {
    try {
      _validatePath(filePath);
      final file = File(filePath);
      if (!await file.exists()) {
        throw FileSystemException('鏂囦欢涓嶅瓨鍦?, filePath);
      }
      return await file.readAsBytes();
    } catch (e, stack) {
      _handleError(
        '璇诲彇鏂囦欢澶辫触',
        e,
        stack,
        data: {'path': filePath},
      );
      rethrow;
    }
  }

  /// 閲嶅懡鍚嶆枃浠?
  @override
  Future<void> renameFile(String oldPath, String newPath) async {
    try {
      _validatePath(oldPath);
      _validatePath(newPath);

      final file = File(oldPath);
      if (!await file.exists()) {
        throw FileSystemException('婧愭枃浠朵笉瀛樺湪', oldPath);
      }

      await file.rename(newPath);
    } catch (e, stack) {
      _handleError(
        '閲嶅懡鍚嶆枃浠跺け璐?,
        e,
        stack,
        data: {
          'oldPath': oldPath,
          'newPath': newPath,
        },
      );
    }
  }

  /// 淇濆瓨涓存椂鏂囦欢
  @override
  Future<String> saveTempFile(String sourcePath) async {
    try {
      final tempDir = await createTempDirectory();
      final fileName = path.basename(sourcePath);
      final tempPath = path.join(tempDir.path, fileName);
      await copyFile(sourcePath, tempPath);
      return tempPath;
    } catch (e, stack) {
      _handleError('淇濆瓨涓存椂鏂囦欢澶辫触', e, stack, data: {'sourcePath': sourcePath});
      rethrow;
    }
  }

  /// 鍐欏叆鏂囦欢
  @override
  Future<void> writeFile(String filePath, List<int> bytes) async {
    try {
      _validatePath(filePath);

      // 纭繚鐩爣鐩綍瀛樺湪
      final dir = path.dirname(filePath);
      await createDirectory(dir).then((dir) => null);

      final file = File(filePath);
      await file.writeAsBytes(bytes);
    } catch (e, stack) {
      _handleError(
        '鍐欏叆鏂囦欢澶辫触',
        e,
        stack,
        data: {'path': filePath},
      );
    }
  }

  /// 缁熶竴閿欒澶勭悊
  void _handleError(
    String message,
    Object error,
    StackTrace stack, {
    Map<String, dynamic>? data,
  }) {
    AppLogger.error(
      message,
      error: error,
      stackTrace: stack,
      tag: 'StorageService',
      data: data,
    );
    throw error;
  }

  /// 妫€鏌ヨ矾寰勬槸鍚︽湁鏁?
  void _validatePath(String targetPath) {
    if (!isPathValid(targetPath)) {
      throw ArgumentError.value(
        targetPath,
        'path',
        '璺緞蹇呴』鍦ㄥ簲鐢ㄧ洰褰曞唴',
      );
    }
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\infrastructure\storage\storage_interface.dart
-----------------------------------
import 'dart:io';

/// 瀛樺偍鎺ュ彛
abstract class IStorage {
  /// 澶嶅埗鏂囦欢
  Future<void> copyFile(String sourcePath, String destinationPath);

  /// 鍒涘缓鐩綍
  Future<Directory> createDirectory(String path);

  /// 鑾峰彇涓存椂鐩綍
  Future<Directory> createTempDirectory();

  /// 鍒犻櫎鐩綍
  Future<void> deleteDirectory(String path);

  /// 鍒犻櫎鏂囦欢
  Future<void> deleteFile(String path);

  /// 妫€鏌ョ洰褰曟槸鍚﹀瓨鍦?
  Future<bool> directoryExists(String path);

  /// 纭繚鐩綍瀛樺湪
  Future<void> ensureDirectoryExists(String path);

  /// 妫€鏌ユ枃浠舵槸鍚﹀瓨鍦?
  Future<bool> fileExists(String path);

  /// 鑾峰彇搴旂敤缂撳瓨鐩綍璺緞
  String getAppCachePath();

  /// 鑾峰彇搴旂敤鏁版嵁鐩綍璺緞
  String getAppDataPath();

  /// 鑾峰彇搴旂敤涓存椂鐩綍璺緞
  String getAppTempPath();

  /// 鑾峰彇鏂囦欢淇敼鏃堕棿
  Future<DateTime> getFileModifiedTime(String path);

  /// 鑾峰彇鏂囦欢澶у皬
  Future<int> getFileSize(String path);

  /// 鍒楀嚭鐩綍涓殑鎵€鏈夋枃浠惰矾寰勶紙閫掑綊锛?
  Future<List<String>> listDirectoryFiles(String path);

  /// 绉诲姩鏂囦欢
  Future<void> moveFile(String sourcePath, String destinationPath);

  /// 璇诲彇鏂囦欢鍐呭
  Future<List<int>> readFile(String path);

  /// 閲嶅懡鍚嶆枃浠?
  Future<void> renameFile(String oldPath, String newPath);

  /// 淇濆瓨涓存椂鏂囦欢
  Future<String> saveTempFile(String sourcePath);

  /// 鍐欏叆鏂囦欢鍐呭
  Future<void> writeFile(String path, List<int> bytes);
}

/// 瀛樺偍鎺ュ彛寮傚父
class StorageException implements Exception {
  final String message;
  final dynamic error;
  final StackTrace? stackTrace;

  StorageException(this.message, [this.error, this.stackTrace]);

  @override
  String toString() => 'StorageException: $message';
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\infrastructure\utils\json_converters.dart
-----------------------------------
import 'package:flutter/material.dart';
import 'package:json_annotation/json_annotation.dart';

/// Offset 鍒楄〃鐨?JSON 杞崲鍣?
class OffsetListConverter
    implements JsonConverter<List<Offset>?, List<dynamic>?> {
  const OffsetListConverter();

  @override
  List<Offset>? fromJson(List<dynamic>? json) {
    if (json == null) return null;
    return json.map((item) {
      final map = item as Map<String, dynamic>;
      return Offset(
        (map['x'] as num).toDouble(),
        (map['y'] as num).toDouble(),
      );
    }).toList();
  }

  @override
  List<dynamic>? toJson(List<Offset>? offsets) {
    if (offsets == null) return null;
    return offsets
        .map((offset) => {
              'x': offset.dx,
              'y': offset.dy,
            })
        .toList();
  }
}

/// Rect 鐨?JSON 杞崲鍣?
class RectConverter implements JsonConverter<Rect, Map<String, dynamic>> {
  const RectConverter();

  @override
  Rect fromJson(Map<String, dynamic> json) {
    return Rect.fromLTWH(
      (json['left'] as num).toDouble(),
      (json['top'] as num).toDouble(),
      (json['width'] as num).toDouble(),
      (json['height'] as num).toDouble(),
    );
  }

  @override
  Map<String, dynamic> toJson(Rect rect) {
    return {
      'left': rect.left,
      'top': rect.top,
      'width': rect.width,
      'height': rect.height,
    };
  }
}

/// Size 鐨?JSON 杞崲鍣?
class SizeConverter implements JsonConverter<Size, Map<String, dynamic>> {
  const SizeConverter();

  @override
  Size fromJson(Map<String, dynamic> json) {
    return Size(
      (json['width'] as num).toDouble(),
      (json['height'] as num).toDouble(),
    );
  }

  @override
  Map<String, dynamic> toJson(Size size) {
    return {
      'width': size.width,
      'height': size.height,
    };
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\app.dart
-----------------------------------
import 'package:flutter/material.dart';
import 'package:flutter_localizations/flutter_localizations.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../application/providers/initialization_providers.dart';
import '../presentation/pages/characters/character_list_page.dart';
import '../presentation/pages/practices/practice_detail_page.dart';
import '../presentation/pages/practices/practice_edit_page.dart';
import '../presentation/pages/practices/practice_list_page.dart';
import '../presentation/pages/settings/settings_page.dart';
import '../presentation/pages/works/work_browse_page.dart';
import '../presentation/pages/works/work_detail_page.dart';
import '../presentation/providers/character/character_region_sync_service.dart';
import '../routes/app_routes.dart';
import '../theme/app_theme.dart';
import 'pages/initialization/initialization_screen.dart';
import 'pages/main/main_window.dart';

class MyApp extends ConsumerWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // Listen to initialization provider to ensure everything is set up
    final initialization = ref.watch(appInitializationProvider);

    // 鍒濆鍖栧尯鍩熷悓姝ユ湇鍔?
    ref.read(characterRegionSyncServiceProvider);

    return initialization.when(
      loading: () => const MaterialApp(
        home: InitializationScreen(),
      ),
      error: (error, stack) => MaterialApp(
        home: Scaffold(
          body: Center(
            child: Text('鍒濆鍖栧け璐? $error'),
          ),
        ),
      ),
      data: (_) => MaterialApp(
        title: '涔︽硶闆嗗瓧',
        theme: AppTheme.light(),
        debugShowCheckedModeBanner: false,
        home: const MainWindow(),
        onGenerateRoute: _generateRoute,
        localizationsDelegates: const [
          GlobalMaterialLocalizations.delegate,
          GlobalWidgetsLocalizations.delegate,
          GlobalCupertinoLocalizations.delegate,
        ],
        supportedLocales: const [
          Locale('zh'),
          Locale('en'),
        ],
      ),
    );
  }

  Route<dynamic>? _generateRoute(RouteSettings settings) {
    final args = settings.arguments;

    switch (settings.name) {
      case AppRoutes.home:
        return MaterialPageRoute(
          builder: (context) => const MainWindow(),
        );

      case AppRoutes.workBrowse:
        return MaterialPageRoute(
          builder: (context) => const WorkBrowsePage(),
        );

      case AppRoutes.workDetail:
        if (args is String) {
          return MaterialPageRoute(
            builder: (context) => WorkDetailPage(workId: args),
          );
        }
        break;

      case AppRoutes.characterList:
        return MaterialPageRoute(
          builder: (context) => const CharacterListPage(),
        );

      case AppRoutes.practiceList:
        return MaterialPageRoute(
          builder: (context) => const PracticeListPage(),
        );

      case AppRoutes.practiceEdit:
        return MaterialPageRoute(
          builder: (context) => PracticeEditPage(
            practiceId: args as String?,
          ),
        );

      case AppRoutes.practiceDetail:
        if (args is String) {
          return MaterialPageRoute(
            builder: (context) => PracticeDetailPage(
              practiceId: args,
            ),
          );
        }
        break;

      case AppRoutes.settings:
        return MaterialPageRoute(
          builder: (context) => const SettingsPage(),
        );
    }

    // Unknown routes return to home
    return MaterialPageRoute(
      builder: (context) => const MainWindow(),
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\constants\work_card_styles.dart
-----------------------------------
import 'package:flutter/material.dart';

import '../../theme/app_sizes.dart';

class WorkCardStyles {
  static const cardAspectRatio = 0.8; // 鍗＄墖瀹介珮姣?
  static const imageAspectRatio = 4 / 3; // 鍥剧墖瀹介珮姣?
  static const thumbnailSize = Size(240, 180); // 缂╃暐鍥惧昂瀵?

  static const gridCardConstraints = BoxConstraints(
    maxWidth: AppSizes.gridCardWidth,
    minHeight: AppSizes.gridCardImageHeight + AppSizes.gridCardInfoHeight,
  );

  static const listItemConstraints = BoxConstraints(
    minHeight: 120,
    maxHeight: 120,
  );
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\dialogs\character_edit_dialog.dart
-----------------------------------
import 'package:flutter/material.dart';

class CharacterEditDialog extends StatefulWidget {
  final String charId;

  const CharacterEditDialog({
    super.key,
    required this.charId,
  });

  @override
  State<CharacterEditDialog> createState() => _CharacterEditDialogState();
}

class _CharacterEditDialogState extends State<CharacterEditDialog> {
  late final TextEditingController _simplifiedController;
  late final TextEditingController _traditionalController;
  late final TextEditingController _remarksController;
  String? _style;
  String? _tool;

  @override
  void initState() {
    super.initState();
    // TODO: 鍔犺浇瀹為檯鏁版嵁
    _simplifiedController = TextEditingController(text: '姘?);
    _traditionalController = TextEditingController(text: '姘?);
    _remarksController = TextEditingController();
    _style = 'kai';
    _tool = 'brush';
  }

  @override
  Widget build(BuildContext context) {
    return Dialog(
      child: Container(
        width: 400,
        padding: const EdgeInsets.all(16),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                const Text('缂栬緫闆嗗瓧淇℃伅', style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold)),
                const Spacer(),
                IconButton(
                  icon: const Icon(Icons.close),
                  onPressed: () => Navigator.of(context).pop(),
                ),
              ],
            ),
            const SizedBox(height: 16),
            TextField(
              controller: _simplifiedController,
              decoration: const InputDecoration(
                labelText: '绠€浣撳瓧 *',
                border: OutlineInputBorder(),
              ),
              maxLength: 1,
            ),
            const SizedBox(height: 16),
            TextField(
              controller: _traditionalController,
              decoration: const InputDecoration(
                labelText: '绻佷綋瀛?,
                border: OutlineInputBorder(),
              ),
              maxLength: 1,
            ),
            const SizedBox(height: 16),
            DropdownButtonFormField<String>(
              value: _style,
              decoration: const InputDecoration(
                labelText: '涔︽硶椋庢牸',
                border: OutlineInputBorder(),
              ),
              items: const [
                DropdownMenuItem(value: 'kai', child: Text('妤蜂功')),
                DropdownMenuItem(value: 'xing', child: Text('琛屼功')),
                DropdownMenuItem(value: 'cao', child: Text('鑽変功')),
              ],
              onChanged: (value) => setState(() => _style = value),
            ),
            const SizedBox(height: 16),
            DropdownButtonFormField<String>(
              value: _tool,
              decoration: const InputDecoration(
                labelText: '涔﹀啓宸ュ叿',
                border: OutlineInputBorder(),
              ),
              items: const [
                DropdownMenuItem(value: 'brush', child: Text('姣涚瑪')),
                DropdownMenuItem(value: 'pen', child: Text('纭瑪')),
              ],
              onChanged: (value) => setState(() => _tool = value),
            ),
            const SizedBox(height: 16),
            TextField(
              controller: _remarksController,
              maxLines: 3,
              decoration: const InputDecoration(
                labelText: '澶囨敞',
                border: OutlineInputBorder(),
              ),
            ),
            const SizedBox(height: 24),
            Row(
              mainAxisAlignment: MainAxisAlignment.end,
              children: [
                TextButton(
                  onPressed: () => Navigator.of(context).pop(),
                  child: const Text('鍙栨秷'),
                ),
                const SizedBox(width: 8),
                ElevatedButton(
                  onPressed: () {
                    // TODO: 淇濆瓨缂栬緫
                    Navigator.of(context).pop();
                  },
                  child: const Text('淇濆瓨'),
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }

  @override
  void dispose() {
    _simplifiedController.dispose();
    _traditionalController.dispose();
    _remarksController.dispose();
    super.dispose();
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\dialogs\common\dialogs.dart
-----------------------------------
import 'package:flutter/material.dart';

Future<bool?> showConfirmDialog({
  required BuildContext context,
  required String title,
  required String message,
  String? cancelText,
  String? confirmText,
}) async {
  return await showDialog<bool>(
    context: context,
    builder: (context) => AlertDialog(
      title: Text(title),
      content: Text(message),
      actions: [
        TextButton(
          onPressed: () => Navigator.of(context).pop(false),
          child: Text(cancelText ?? '鍙栨秷'),
        ),
        FilledButton(
          onPressed: () => Navigator.of(context).pop(true),
          child: Text(confirmText ?? '纭畾'),
        ),
      ],
    ),
  );
}

Future<void> showErrorDialog({
  required BuildContext context,
  required String title,
  required String message,
  String? buttonText,
}) async {
  await showDialog<void>(
    context: context,
    builder: (context) => AlertDialog(
      title: Text(title),
      content: Text(message),
      actions: [
        FilledButton(
          onPressed: () => Navigator.of(context).pop(),
          child: Text(buttonText ?? '纭畾'),
        ),
      ],
    ),
  );
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\dialogs\common\dialog_button_group.dart
-----------------------------------
import 'package:flutter/material.dart';

class DialogButtonGroup extends StatelessWidget {
  final VoidCallback onCancel;
  final VoidCallback onConfirm;
  final String cancelText;
  final String confirmText;
  final bool isProcessing;
  final bool isConfirmEnabled;

  const DialogButtonGroup({
    super.key,
    required this.onCancel,
    required this.onConfirm,
    this.cancelText = '鍙栨秷',
    this.confirmText = '纭畾',
    this.isProcessing = false,
    this.isConfirmEnabled = true,
  });

  @override
  Widget build(BuildContext context) {
    return Row(
      mainAxisAlignment: MainAxisAlignment.end,
      children: [
        if (isProcessing)
          const Padding(
            padding: EdgeInsets.only(right: 16.0),
            child: SizedBox(
              width: 20,
              height: 20,
              child: CircularProgressIndicator(strokeWidth: 2),
            ),
          ),
        TextButton(
          onPressed: isProcessing ? null : onCancel,
          child: Text(cancelText),
        ),
        const SizedBox(width: 8),
        FilledButton(
          onPressed: (isProcessing || !isConfirmEnabled) ? null : onConfirm,
          child: Text(confirmText),
        ),
      ],
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\dialogs\work_import\work_import_dialog.dart
-----------------------------------
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../providers/work_import_provider.dart';
import 'components/form/work_import_form.dart';
import 'components/preview/work_import_preview.dart';

/// Dialog for importing works with preview and metadata input
class WorkImportDialog extends ConsumerWidget {
  const WorkImportDialog({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final state = ref.watch(workImportProvider);
    final viewModel = ref.read(workImportProvider.notifier);

    return Dialog.fullscreen(
      child: LayoutBuilder(builder: (context, constraints) {
        // Calculate responsive sizes based on available space
        final availableWidth = constraints.maxWidth;
        final availableHeight = constraints.maxHeight;
        final isLargeScreen = availableWidth >= 1100;
        final isMediumScreen = availableWidth >= 800 && availableWidth < 1100;
        final isSmallScreen = availableWidth < 800;

        return Material(
          color: Theme.of(context).colorScheme.surface,
          child: PopScope(
            // Prevent dialog dismissal during processing
            canPop: !state.isProcessing,
            child: SafeArea(
              child: Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  // AppBar with action buttons moved here
                  AppBar(
                    title: const Text('瀵煎叆浣滃搧'),
                    actions: [
                      // Cancel button
                      TextButton.icon(
                        onPressed: state.isProcessing
                            ? null
                            : () {
                                viewModel.reset();
                                Navigator.of(context).pop(false);
                              },
                        icon: const Icon(Icons.close),
                        label: const Text('鍙栨秷'),
                        style: TextButton.styleFrom(
                          foregroundColor: state.isProcessing
                              ? Theme.of(context).disabledColor
                              : null,
                        ),
                      ),
                      const SizedBox(width: 8),
                      // Import button
                      FilledButton.icon(
                        onPressed: (state.canSubmit && !state.isProcessing)
                            ? () async {
                                final success = await viewModel.importWork();
                                if (success && context.mounted) {
                                  Navigator.of(context).pop(true);
                                }
                              }
                            : null,
                        icon: const Icon(Icons.save),
                        label: const Text('瀵煎叆'),
                      ),
                      const SizedBox(width: 16),
                    ],
                  ),
                  Expanded(
                    child: Padding(
                      padding: const EdgeInsets.all(24.0),
                      child: _buildResponsiveLayout(
                        context,
                        isLargeScreen,
                        isMediumScreen,
                        isSmallScreen,
                        availableHeight,
                        availableWidth,
                        state,
                        viewModel,
                      ),
                    ),
                  ),
                ],
              ),
            ),
          ),
        );
      }),
    );
  }

  Widget _buildResponsiveLayout(
    BuildContext context,
    bool isLargeScreen,
    bool isMediumScreen,
    bool isSmallScreen,
    double availableHeight,
    double availableWidth,
    dynamic state,
    dynamic viewModel,
  ) {
    // For large and medium screens, use horizontal layout
    if (isLargeScreen || isMediumScreen) {
      return Row(
        crossAxisAlignment: CrossAxisAlignment.start, // Align at the top
        children: [
          // Preview section
          Expanded(
            flex: 3,
            child: ConstrainedBox(
              constraints: BoxConstraints(
                maxHeight: availableHeight - 48, // Account for padding
              ),
              child: const WorkImportPreviewWithoutButtons(),
            ),
          ),

          const SizedBox(width: 24),

          // Form section
          Expanded(
            flex: isLargeScreen ? 2 : 3,
            child: SingleChildScrollView(
              child: ConstrainedBox(
                constraints: BoxConstraints(
                  minHeight: availableHeight - 48, // Account for padding
                ),
                child: WorkImportForm(
                  state: state,
                  viewModel: viewModel,
                ),
              ),
            ),
          ),
        ],
      );
    }

    // For small screens, use vertical layout
    return Column(
      children: [
        // Preview section with proportional height based on screen size
        SizedBox(
          height: availableHeight * 0.5, // 50% of available height
          child: const WorkImportPreviewWithoutButtons(),
        ),

        const SizedBox(height: 16),

        // Form section that can scroll to fit in remaining space
        Expanded(
          child: SingleChildScrollView(
            child: WorkImportForm(
              state: state,
              viewModel: viewModel,
            ),
          ),
        ),
      ],
    );
  }

  /// Show the work import dialog
  static Future<bool?> show(BuildContext context) {
    // 纭繚鍦ㄦ墦寮€瀵硅瘽妗嗗墠閲嶇疆鐘舵€?
    ProviderScope.containerOf(context)
        .read(workImportProvider.notifier)
        .reset();

    return showDialog<bool>(
      context: context,
      barrierDismissible: false,
      builder: (context) => const WorkImportDialog(),
    );
  }
}

/// A version of WorkImportPreview without bottom buttons
class WorkImportPreviewWithoutButtons extends ConsumerWidget {
  const WorkImportPreviewWithoutButtons({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return const WorkImportPreview(showBottomButtons: false);
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\dialogs\work_import\components\form\work_import_form.dart
-----------------------------------
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';

import '../../../../viewmodels/states/work_import_state.dart';
import '../../../../viewmodels/work_import_view_model.dart';
import '../../../../widgets/forms/work_form.dart';

/// Form for entering work metadata during import
class WorkImportForm extends StatefulWidget {
  final WorkImportState state;
  final WorkImportViewModel viewModel;

  const WorkImportForm({
    super.key,
    required this.state,
    required this.viewModel,
  });

  @override
  State<WorkImportForm> createState() => _WorkImportFormState();
}

class _WorkImportFormState extends State<WorkImportForm> {
  final _formKey = GlobalKey<FormState>();
  bool _hasInteracted = false;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final isProcessing = widget.state.isProcessing;

    return Focus(
      onKey: (_, event) {
        _handleKeyPress(event);
        return KeyEventResult.ignored;
      },
      child: WorkForm(
        formKey: _formKey,
        initialTitle: widget.state.title,
        initialAuthor: widget.state.author,
        initialStyle: widget.state.style,
        initialTool: widget.state.tool,
        initialCreationDate: widget.state.creationDate,
        initialRemark: widget.state.remark,
        isProcessing: isProcessing,
        error: widget.state.error,
        onTitleChanged: widget.viewModel.setTitle,
        onAuthorChanged: widget.viewModel.setAuthor,
        onStyleChanged: widget.viewModel.setStyle,
        onToolChanged: widget.viewModel.setTool,
        onCreationDateChanged: _handleDateChange,
        onRemarkChanged: widget.viewModel.setRemark,
        requiredFields: {WorkFormField.title},
        visibleFields: WorkFormPresets.importFields,
        showHelp: true,
        showKeyboardShortcuts: true,
      ),
    );
  }

  void _handleDateChange(DateTime? date) {
    if (date != null) {
      if (date.isAfter(DateTime.now())) {
        // 鏃ユ湡涓嶈兘瓒呰繃褰撳墠鏃ユ湡
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('鍒涗綔鏃ユ湡涓嶈兘瓒呰繃褰撳墠鏃ユ湡'),
            behavior: SnackBarBehavior.floating,
          ),
        );
        return;
      }
      widget.viewModel.setCreationDate(date);
    }
  }

  void _handleKeyPress(RawKeyEvent event) {
    if (event is! RawKeyDownEvent) return;
    if (!event.isControlPressed) return;

    if (event.logicalKey == LogicalKeyboardKey.enter) {
      _handleSubmit();
    }
  }

  Future<void> _handleSubmit() async {
    setState(() => _hasInteracted = true);

    if (_formKey.currentState?.validate() ?? false) {
      try {
        Navigator.of(context).pop(true);
      } catch (e) {
        if (!mounted) return;
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('鎻愪氦澶辫触: ${e.toString()}'),
            backgroundColor: Theme.of(context).colorScheme.error,
            behavior: SnackBarBehavior.floating,
            action: SnackBarAction(
              label: '閲嶈瘯',
              onPressed: _handleSubmit,
              textColor: Theme.of(context).colorScheme.onError,
            ),
          ),
        );
      }
    }
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\dialogs\work_import\components\preview\drop_target.dart
-----------------------------------
import 'dart:io';

import 'package:flutter/material.dart';

class ImageDropTarget extends StatefulWidget {
  final Widget child;
  final void Function(List<File>) onFilesDropped;

  const ImageDropTarget({
    super.key,
    required this.child,
    required this.onFilesDropped,
  });

  @override
  State<ImageDropTarget> createState() => _ImageDropTargetState();
}

class _ImageDropTargetState extends State<ImageDropTarget> {
  bool _isDragging = false;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return DragTarget<List<String>>(
      onWillAcceptWithDetails: (data) {
        setState(() => _isDragging = true);
        return data.data.isNotEmpty;
      },
      onAcceptWithDetails: (details) {
        setState(() => _isDragging = false);
        final files = details.data.map((path) => File(path)).toList();
        widget.onFilesDropped(files);
      },
      onLeave: (_) {
        setState(() => _isDragging = false);
      },
      builder: (context, candidateData, rejectedData) {
        return AnimatedContainer(
          duration: const Duration(milliseconds: 200),
          decoration: BoxDecoration(
            border: Border.all(
              color:
                  _isDragging ? theme.colorScheme.primary : Colors.transparent,
              width: 2,
            ),
          ),
          child: widget.child,
        );
      },
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\dialogs\work_import\components\preview\image_drop_target.dart
-----------------------------------
import 'dart:io';

import 'package:flutter/material.dart';
import 'package:flutter/services.dart';

import '../../../../../theme/app_sizes.dart';

class ImageDropTarget extends StatefulWidget {
  final Widget child;
  final void Function(List<File>) onFilesDropped;

  const ImageDropTarget({
    super.key,
    required this.child,
    required this.onFilesDropped,
  });

  @override
  State<ImageDropTarget> createState() => _ImageDropTargetState();
}

class _ImageDropTargetState extends State<ImageDropTarget> {
  bool _isDragging = false;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return DragTarget<List<String>>(
      onWillAcceptWithDetails: (data) {
        final hasValidFiles = data.data.any((path) {
              final ext = path.toLowerCase();
              return ext.endsWith('.jpg') ||
                  ext.endsWith('.jpeg') ||
                  ext.endsWith('.png') ||
                  ext.endsWith('.webp');
            }) ??
            false;

        setState(() => _isDragging = hasValidFiles);
        return hasValidFiles;
      },
      onAcceptWithDetails: (data) {
        setState(() => _isDragging = false);
        final files = data.data
            .map((path) => File(path))
            .where((file) => file.existsSync())
            .toList();

        if (files.isNotEmpty) {
          HapticFeedback.selectionClick();
          widget.onFilesDropped(files);
        }
      },
      onLeave: (_) => setState(() => _isDragging = false),
      builder: (context, candidateData, rejectedData) {
        return Stack(
          fit: StackFit.expand,
          children: [
            widget.child,
            if (_isDragging)
              Container(
                color: theme.colorScheme.primary.withOpacity(0.1),
                child: Center(
                  child: Container(
                    padding: const EdgeInsets.symmetric(
                      horizontal: AppSizes.l,
                      vertical: AppSizes.m,
                    ),
                    decoration: BoxDecoration(
                      color: theme.colorScheme.surface,
                      borderRadius: BorderRadius.circular(AppSizes.xs),
                      border: Border.all(
                        color: theme.colorScheme.primary,
                      ),
                    ),
                    child: Column(
                      mainAxisSize: MainAxisSize.min,
                      children: [
                        const Icon(Icons.file_upload),
                        const SizedBox(height: AppSizes.s),
                        Text(
                          '鏉惧紑榧犳爣娣诲姞鍥剧墖',
                          style: theme.textTheme.bodyLarge?.copyWith(
                            color: theme.colorScheme.primary,
                          ),
                        ),
                      ],
                    ),
                  ),
                ),
              ),
          ],
        );
      },
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\dialogs\work_import\components\preview\image_viewer.dart
-----------------------------------
import 'dart:io';

import 'package:flutter/material.dart';

import '../../../../../theme/app_sizes.dart';

class ImageViewer extends StatelessWidget {
  final File image;
  final double rotation;
  final double scale;
  final ValueChanged<double>? onScaleChanged;

  const ImageViewer({
    super.key,
    required this.image,
    required this.rotation,
    this.scale = 1.0,
    this.onScaleChanged,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Stack(
      fit: StackFit.expand,
      children: [
        // 鍥剧墖棰勮鍖哄煙
        InteractiveViewer(
          minScale: 0.5,
          maxScale: 4.0,
          onInteractionUpdate: (details) {
            if (details.pointerCount > 0 && details.scale != scale) {
              onScaleChanged?.call(details.scale);
            }
          },
          child: Center(
            child: Transform.rotate(
              angle: rotation * (3.1415927 / 180.0),
              child: Image.file(
                image,
                fit: BoxFit.contain,
                errorBuilder: (context, error, stackTrace) {
                  return Center(
                    child: Column(
                      mainAxisSize: MainAxisSize.min,
                      children: [
                        Icon(
                          Icons.broken_image_outlined,
                          size: 48,
                          color: theme.colorScheme.error,
                        ),
                        const SizedBox(height: AppSizes.s),
                        Text(
                          '鍥剧墖鍔犺浇澶辫触',
                          style: theme.textTheme.bodyMedium?.copyWith(
                            color: theme.colorScheme.error,
                          ),
                        ),
                      ],
                    ),
                  );
                },
              ),
            ),
          ),
        ),
      ],
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\dialogs\work_import\components\preview\preview_toolbar.dart
-----------------------------------
import 'package:flutter/material.dart';

import '../../../../../theme/app_sizes.dart';

class PreviewToolbar extends StatelessWidget {
  final bool hasImages;
  final bool hasSelection;
  final VoidCallback? onAddImages; // 娣诲姞
  final VoidCallback? onRotateLeft;
  final VoidCallback? onRotateRight;
  final VoidCallback? onDelete;
  final VoidCallback? onDeleteAll;

  const PreviewToolbar({
    super.key,
    this.hasImages = false,
    this.hasSelection = false,
    this.onAddImages, // 娣诲姞
    this.onRotateLeft,
    this.onRotateRight,
    this.onDelete,
    this.onDeleteAll,
  });

  @override
  Widget build(BuildContext context) {
    return SizedBox(
      height: 48, // 鍥哄畾宸ュ叿鏍忛珮搴?
      child: Padding(
        padding: const EdgeInsets.symmetric(
          horizontal: AppSizes.m,
          vertical: AppSizes.s,
        ),
        child: Row(
          children: [
            // 娣诲姞鍥剧墖
            _ToolbarIconButton(
              icon: Icons.add_photo_alternate_outlined,
              tooltip: '娣诲姞鍥剧墖',
              onPressed: onAddImages,
            ),
            const SizedBox(width: AppSizes.m),
            // 鍚戝乏鏃嬭浆
            _ToolbarIconButton(
              icon: Icons.rotate_left,
              tooltip: '鍚戝乏鏃嬭浆',
              onPressed: hasSelection ? onRotateLeft : null,
            ),
            // 鍚戝彸鏃嬭浆
            _ToolbarIconButton(
              icon: Icons.rotate_right,
              tooltip: '鍚戝彸鏃嬭浆',
              onPressed: hasSelection ? onRotateRight : null,
            ),
            const Spacer(),
            // 鍒犻櫎閫変腑
            _ToolbarIconButton(
              icon: Icons.delete_outline,
              tooltip: '鍒犻櫎閫変腑',
              onPressed: hasSelection ? onDelete : null,
              isDestructive: true,
            ),
            // 鍏ㄩ儴鍒犻櫎
            _ToolbarIconButton(
              icon: Icons.delete_sweep_outlined,
              tooltip: '鍏ㄩ儴鍒犻櫎',
              onPressed: hasImages ? onDeleteAll : null,
              isDestructive: true,
            ),
          ],
        ),
      ),
    );
  }
}

class _ToolbarIconButton extends StatelessWidget {
  final IconData icon;
  final String tooltip;
  final VoidCallback? onPressed;
  final bool isDestructive;

  const _ToolbarIconButton({
    required this.icon,
    required this.tooltip,
    this.onPressed,
    this.isDestructive = false,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final bool isEnabled = onPressed != null;

    return IconButton(
      onPressed: onPressed,
      icon: Icon(
        icon,
        size: 20,
        color: isEnabled
            ? (isDestructive
                ? theme.colorScheme.error
                : theme.colorScheme.onSurfaceVariant)
            : theme.colorScheme.onSurfaceVariant.withOpacity(0.38),
      ),
      tooltip: tooltip,
      visualDensity: VisualDensity.compact,
      style: IconButton.styleFrom(
        foregroundColor: isDestructive
            ? theme.colorScheme.error
            : theme.colorScheme.onSurfaceVariant,
        backgroundColor: Colors.transparent,
        hoverColor: (isDestructive
                ? theme.colorScheme.error
                : theme.colorScheme.onSurfaceVariant)
            .withOpacity(0.08),
        disabledBackgroundColor: Colors.transparent,
        disabledForegroundColor:
            theme.colorScheme.onSurfaceVariant.withOpacity(0.38),
      ),
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\dialogs\work_import\components\preview\work_import_preview.dart
-----------------------------------
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../../domain/models/work/work_image.dart';
import '../../../../../infrastructure/logging/logger.dart';
import '../../../../providers/work_import_provider.dart';
import '../../../../widgets/works/enhanced_work_preview.dart';
import '../../../common/dialog_button_group.dart';
import '../../../common/dialogs.dart';

/// Displays a preview of work images during import with editing capabilities
class WorkImportPreview extends ConsumerStatefulWidget {
  final bool showBottomButtons;

  const WorkImportPreview({
    super.key,
    this.showBottomButtons = true,
  });

  @override
  ConsumerState<WorkImportPreview> createState() => _WorkImportPreviewState();
}

class _WorkImportPreviewState extends ConsumerState<WorkImportPreview> {
  @override
  Widget build(BuildContext context) {
    final state = ref.watch(workImportProvider);
    final theme = Theme.of(context);

    AppLogger.debug(
        'Building WorkImportPreview with ${state.images.length} images');

    final images = state.images
        .map((file) => WorkImage(
              id: file.path,
              path: file.path,
              workId: '', // Will be set during import
              originalPath: file.path,
              thumbnailPath: file.path,
              index: state.images.indexOf(file),
              width: 0, // Will be set during import
              height: 0, // Will be set during import
              format: 'image',
              size: 0, // Will be set during import
              createTime: DateTime.now(),
              updateTime: DateTime.now(),
            ))
        .toList();

    // 鍒涘缓涓€涓嚱鏁版潵澶勭悊"娣诲姞鍥剧墖"鎸夐挳鐨勭偣鍑?
    VoidCallback? handleAdd =
        state.isProcessing ? null : () => _handleAddImages();

    // 鍒涘缓涓€涓嚱鏁版潵澶勭悊"鍒犻櫎鍥剧墖"鎸夐挳鐨勭偣鍑?
    VoidCallback? handleDelete = (images.isEmpty || state.isProcessing)
        ? null
        : () => _handleDeleteSelected();

    return LayoutBuilder(
      builder: (context, constraints) {
        // Use constraints to adapt layout
        final isSmallWidth = constraints.maxWidth < 500;
        final buttonHeight = 60.0; // Approximate height for buttons
        final previewHeight = constraints.maxHeight - buttonHeight;

        return Column(
          children: [
            Expanded(
              child: Card(
                clipBehavior: Clip.antiAlias,
                elevation: 0, // Remove card elevation for cleaner UI
                shape: RoundedRectangleBorder(
                  borderRadius: BorderRadius.circular(8),
                  side: BorderSide(
                    color: theme.colorScheme.outlineVariant.withOpacity(0.5),
                    width: 1,
                  ),
                ),
                child: EnhancedWorkPreview(
                  images: images,
                  selectedIndex: state.selectedImageIndex,
                  isEditing: !state.isProcessing, // 澶勭悊涓鐢ㄧ紪杈?
                  showToolbar: true,
                  toolbarActions: [
                    Padding(
                      padding: const EdgeInsets.symmetric(horizontal: 8.0),
                      child: FilledButton.tonalIcon(
                        onPressed: handleAdd, // 澶勭悊涓鐢?
                        icon: const Icon(Icons.add_photo_alternate),
                        label: isSmallWidth
                            ? const Text('娣诲姞')
                            : const Text('娣诲姞鍥剧墖'),
                      ),
                    ),
                    Padding(
                      padding: const EdgeInsets.symmetric(horizontal: 8.0),
                      child: OutlinedButton.icon(
                        onPressed: handleDelete, // 澶勭悊涓鐢?
                        icon: const Icon(
                          Icons.delete_outline,
                        ),
                        label: isSmallWidth
                            ? const Text('鍒犻櫎')
                            : const Text('鍒犻櫎鍥剧墖'),
                        style: OutlinedButton.styleFrom(
                          foregroundColor: theme.colorScheme.error,
                          side: BorderSide(
                            color: theme.colorScheme.error.withOpacity(
                              images.isEmpty || state.isProcessing ? 0.38 : 1.0,
                            ),
                          ),
                        ),
                      ),
                    ),
                  ],
                  onIndexChanged:
                      state.isProcessing ? null : _handleIndexChanged,
                  onImagesReordered:
                      state.isProcessing ? null : _handleImagesReordered,
                ),
              ),
            ),
            // Only show the bottom buttons if requested
            if (widget.showBottomButtons) const SizedBox(height: 16),
            if (widget.showBottomButtons)
              DialogButtonGroup(
                // 濡傛灉姝ｅ湪澶勭悊锛岃繑鍥炰竴涓┖鍑芥暟锛屽惁鍒欒繑鍥炲疄闄呯殑鍙栨秷澶勭悊鍑芥暟
                onCancel: state.isProcessing
                    ? () {}
                    : () => Navigator.of(context).pop(),
                // 濡傛灉绂佺敤鎴栧鐞嗕腑锛岃繑鍥炰竴涓┖鍑芥暟锛屽惁鍒欒繑鍥炲疄闄呯殑纭澶勭悊鍑芥暟
                onConfirm: (images.isEmpty || state.isProcessing)
                    ? () {}
                    : () async {
                        final success = await _handleConfirm();
                        if (success && mounted) {
                          Navigator.of(context).pop(true);
                        }
                      },
                confirmText: '瀵煎叆',
                isProcessing: state.isProcessing,
              ),
          ],
        );
      },
    );
  }

  Future<void> _handleAddImages() async {
    final viewModel = ref.read(workImportProvider.notifier);
    AppLogger.debug('WorkImportPreview handling addImages');
    await viewModel.addImages([]);
  }

  Future<bool> _handleConfirm() async {
    final viewModel = ref.read(workImportProvider.notifier);
    return viewModel.importWork();
  }

  Future<void> _handleDeleteSelected() async {
    final state = ref.read(workImportProvider);
    if (state.images.isEmpty) return;

    final isLastImage = state.images.length == 1;
    String title = isLastImage ? '纭鍒犻櫎' : '鍒犻櫎鍥剧墖';
    String message = isLastImage ? '杩欐槸鏈€鍚庝竴寮犲浘鐗囷紝鍒犻櫎鍚庡皢閫€鍑哄鍏ャ€傜‘瀹氳鍒犻櫎鍚楋紵' : '纭畾瑕佸垹闄ら€変腑鐨勫浘鐗囧悧锛?;

    final confirmed = await showConfirmDialog(
      context: context,
      title: title,
      message: message,
    );

    if (confirmed == true) {
      final viewModel = ref.read(workImportProvider.notifier);
      AppLogger.debug(
          'WorkImportPreview removing image at index: ${state.selectedImageIndex}');
      viewModel.removeImage(state.selectedImageIndex);

      if (isLastImage && mounted) {
        Navigator.of(context).pop();
      }
    }
  }

  void _handleImagesReordered(int oldIndex, int newIndex) {
    final viewModel = ref.read(workImportProvider.notifier);
    AppLogger.debug(
        'WorkImportPreview reordering images: $oldIndex -> $newIndex');
    viewModel.reorderImages(oldIndex, newIndex);
  }

  void _handleIndexChanged(int index) {
    final viewModel = ref.read(workImportProvider.notifier);
    AppLogger.debug('WorkImportPreview selecting image: $index');
    viewModel.selectImage(index);
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\pages\communication_example.dart
-----------------------------------



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\pages\home_page.dart
-----------------------------------
import 'package:flutter/material.dart';

/// Placeholder home page widget.
class HomePagePlaceholder extends StatelessWidget {
  const HomePagePlaceholder({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Home Page')),
      body: const Center(
        child: Text('Home Page'),
      ),
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\pages\characters\character_detail_page.dart
-----------------------------------
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../application/providers/repository_providers.dart';
import '../../../domain/models/character/character_entity.dart';
import '../../../infrastructure/logging/logger.dart';
import '../../providers/character_detail_provider.dart';
import '../../widgets/common/detail_toolbar.dart';
import '../../widgets/common/loading_indicator.dart';
import '../../widgets/page_layout.dart';

class CharacterDetailPage extends ConsumerStatefulWidget {
  final String charId;
  final VoidCallback? onBack;

  const CharacterDetailPage({
    super.key,
    required this.charId,
    this.onBack,
  });

  @override
  ConsumerState<CharacterDetailPage> createState() =>
      _CharacterDetailPageState();
}

class _CharacterDetailPageState extends ConsumerState<CharacterDetailPage> {
  var _isLoading = false;
  CharacterEntity? _character;
  String? _errorMessage;

  @override
  Widget build(BuildContext context) {
    return PageLayout(
      toolbar: _buildToolbar(),
      body: _buildBody(),
    );
  }

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addPostFrameCallback((_) {
      _loadCharacter();
    });
  }

  List<DetailToolbarAction> _buildActions() {
    if (_character == null) return [];

    return [
      DetailToolbarAction(
        icon: Icons.edit,
        tooltip: '缂栬緫瀛楀舰',
        onPressed: () {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(content: Text('缂栬緫鍔熻兘灏氭湭瀹炵幇')),
          );
        },
      ),
      DetailToolbarAction(
        icon: Icons.image,
        tooltip: '鏌ョ湅鍘熷浘',
        onPressed: () {
          // Todo: 瀹炵幇鏌ョ湅鍘熷浘鍔熻兘
        },
      ),
      DetailToolbarAction(
        icon: Icons.delete,
        tooltip: '鍒犻櫎瀛楀舰',
        onPressed: _confirmDelete,
      ),
    ];
  }

  Widget _buildBody() {
    if (_isLoading) {
      return const Center(
        child: LoadingIndicator(message: '鍔犺浇瀛楀舰涓?..'),
      );
    }

    if (_errorMessage != null) {
      return Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            const Icon(Icons.error_outline, size: 48, color: Colors.red),
            const SizedBox(height: 16),
            Text(_errorMessage!, style: const TextStyle(fontSize: 16)),
            const SizedBox(height: 24),
            ElevatedButton(
              onPressed: _loadCharacter,
              child: const Text('閲嶈瘯'),
            ),
          ],
        ),
      );
    }

    if (_character == null) {
      return const Center(
        child: Text('瀛楀舰涓嶅瓨鍦ㄦ垨宸茶鍒犻櫎'),
      );
    }

    return _buildCharacterInfo(_character!);
  }

  Widget _buildCharacterInfo(CharacterEntity character) {
    return SingleChildScrollView(
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          const AspectRatio(
            aspectRatio: 1.0,
            child: Card(
              clipBehavior: Clip.antiAlias,
              child: Center(
                child: Icon(Icons.image_not_supported, size: 64),
              ),
            ),
          ),
          const SizedBox(height: 24),
          Card(
            child: Padding(
              padding: const EdgeInsets.all(16.0),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text('鍩烘湰淇℃伅', style: Theme.of(context).textTheme.titleLarge),
                  const Divider(),
                  _buildInfoRow('姹夊瓧', character.character),
                  _buildInfoRow('鍒涘缓鏃堕棿', _formatDateTime(character.createTime)),
                  _buildInfoRow('鏇存柊鏃堕棿', _formatDateTime(character.updateTime)),
                ],
              ),
            ),
          ),
          ...[
            const SizedBox(height: 16),
            Card(
              child: Padding(
                padding: const EdgeInsets.all(16.0),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Row(
                      children: [
                        const Icon(Icons.crop, size: 20),
                        const SizedBox(width: 8),
                        Text('鍘熷浘鍖哄煙',
                            style: Theme.of(context).textTheme.titleLarge),
                      ],
                    ),
                    const Divider(),
                    Text(
                      '宸? ${character.region.rect.left}, '
                      '涓? ${character.region.rect.top}, '
                      '瀹? ${character.region.rect.width}, '
                      '楂? ${character.region.rect.height}',
                      style: Theme.of(context).textTheme.bodyMedium,
                    ),
                  ],
                ),
              ),
            ),
          ],
        ],
      ),
    );
  }

  Widget _buildInfoRow(String label, String value) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 8.0),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          SizedBox(
            width: 80,
            child: Text(
              label,
              style: TextStyle(
                fontWeight: FontWeight.bold,
                color: Theme.of(context).colorScheme.primary,
              ),
            ),
          ),
          Expanded(
            child: Text(value),
          ),
        ],
      ),
    );
  }

  Widget _buildToolbar() {
    return DetailToolbar(
      title: '瀛楀舰璇︽儏',
      leadingIcon: Icons.text_fields,
      badge:
          _character != null ? DetailBadge(text: _character!.character) : null,
      actions: _buildActions(),
    );
  }

  Future<void> _confirmDelete() async {
    final confirmed = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('鍒犻櫎瀛楀舰'),
        content: Text('纭畾瑕佸垹闄ゅ瓧褰?${_character!.character}"鍚楋紵姝ゆ搷浣滀笉鍙挙閿€銆?),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(false),
            child: const Text('鍙栨秷'),
          ),
          FilledButton(
            onPressed: () => Navigator.of(context).pop(true),
            style: FilledButton.styleFrom(
              backgroundColor: Colors.red,
              foregroundColor: Colors.white,
            ),
            child: const Text('鍒犻櫎'),
          ),
        ],
      ),
    );

    if (confirmed == true) {
      await _deleteCharacter();
    }
  }

  Future<void> _deleteCharacter() async {
    try {
      setState(() {
        _isLoading = true;
      });

      final repository = ref.read(characterRepositoryProvider);
      await repository.delete(widget.charId);
      ref.invalidate(characterDetailProvider);

      if (mounted) {
        if (widget.onBack != null) {
          widget.onBack!();
        } else {
          Navigator.of(context).pop();
        }
      }
    } catch (e, stack) {
      AppLogger.error(
        'Failed to delete character',
        tag: 'CharacterDetailPage',
        error: e,
        stackTrace: stack,
        data: {'id': widget.charId},
      );

      if (mounted) {
        setState(() {
          _isLoading = false;
          _errorMessage = '鍒犻櫎澶辫触: ${e.toString()}';
        });

        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('鍒犻櫎澶辫触: ${e.toString()}')),
        );
      }
    }
  }

  String _formatDateTime(DateTime? dateTime) {
    if (dateTime == null) return '鏈煡';

    return '${dateTime.year}-'
        '${dateTime.month.toString().padLeft(2, '0')}-'
        '${dateTime.day.toString().padLeft(2, '0')} '
        '${dateTime.hour.toString().padLeft(2, '0')}:'
        '${dateTime.minute.toString().padLeft(2, '0')}';
  }

  Future<void> _loadCharacter() async {
    setState(() {
      _isLoading = true;
      _errorMessage = null;
    });

    try {
      final character =
          await ref.read(characterDetailProvider(widget.charId).future);

      if (mounted) {
        setState(() {
          _character = character;
          _isLoading = false;
        });
      }
    } catch (e, stack) {
      AppLogger.error(
        'Failed to load character',
        tag: 'CharacterDetailPage',
        error: e,
        stackTrace: stack,
        data: {'id': widget.charId},
      );

      if (mounted) {
        setState(() {
          _errorMessage = '鏃犳硶鍔犺浇瀛楀舰淇℃伅: ${e.toString()}';
          _isLoading = false;
        });
      }
    }
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\pages\characters\character_list_page.dart
-----------------------------------
import 'package:flutter/material.dart';

import '../../../theme/app_sizes.dart';
import '../../dialogs/character_edit_dialog.dart';
import '../../widgets/character/character_detail_view.dart';
import '../../widgets/page_layout.dart';
import '../../widgets/page_toolbar.dart';
import '../../widgets/search/search_box.dart';
import '../../widgets/section_header.dart';

class CharacterListPage extends StatefulWidget {
  const CharacterListPage({super.key});

  @override
  State<CharacterListPage> createState() => _CharacterListPageState();
}

class _CharacterListPageState extends State<CharacterListPage> {
  String? _selectedCharId;
  final _searchController = TextEditingController();

  @override
  Widget build(BuildContext context) {
    return PageLayout(
      toolbar: PageToolbar(
        leading: [
          FilledButton.icon(
            onPressed: _showAddCharacterDialog,
            icon: const Icon(Icons.add),
            label: const Text('鏂板缓瀛楃'),
          ),
        ],
        trailing: [
          SearchBox(
            controller: _searchController,
            hintText: '鎼滅储瀛楃...',
            onSubmitted: _handleSearch,
          ),
        ],
      ),
      body: Row(
        children: [
          Expanded(
            flex: 2,
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                const SectionHeader(
                  title: '鎵€鏈夊瓧绗?,
                  padding: EdgeInsets.fromLTRB(
                    AppSizes.spacingMedium,
                    AppSizes.spacingMedium,
                    AppSizes.spacingMedium,
                    0,
                  ),
                ),
                Expanded(
                  child: _buildCharacterGrid(),
                ),
              ],
            ),
          ),
          if (_selectedCharId != null) ...[
            const VerticalDivider(width: 1),
            Expanded(
              child: CharacterDetailView(charId: _selectedCharId!),
            ),
          ],
        ],
      ),
    );
  }

  @override
  void dispose() {
    _searchController.dispose();
    super.dispose();
  }

  Widget _buildCharacterGrid() {
    return GridView.builder(
      padding: const EdgeInsets.all(AppSizes.spacingMedium),
      gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
        crossAxisCount: 6,
        mainAxisSpacing: AppSizes.spacingMedium,
        crossAxisSpacing: AppSizes.spacingMedium,
        childAspectRatio: 1,
      ),
      itemCount: 20,
      itemBuilder: _buildCharacterItem,
    );
  }

  Widget _buildCharacterItem(BuildContext context, int index) {
    final theme = Theme.of(context);
    final charId = 'char_$index';
    final isSelected = charId == _selectedCharId;

    return Card(
      elevation:
          isSelected ? AppSizes.cardElevationSelected : AppSizes.cardElevation,
      color: isSelected ? theme.primaryColor.withOpacity(0.1) : null,
      child: InkWell(
        onTap: () => setState(() => _selectedCharId = charId),
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Expanded(
              child: Center(
                child: Text(
                  '瀛?index',
                  style: theme.textTheme.headlineLarge,
                ),
              ),
            ),
            Padding(
              padding: const EdgeInsets.all(AppSizes.spacingSmall),
              child: Text(
                '鏉ヨ嚜锛氫綔鍝乆',
                style: theme.textTheme.bodySmall,
                overflow: TextOverflow.ellipsis,
              ),
            ),
          ],
        ),
      ),
    );
  }

  void _handleSearch() {
    // 瀹炵幇鎼滅储閫昏緫
  }

  void _showAddCharacterDialog() {
    showDialog(
      context: context,
      builder: (context) => const CharacterEditDialog(
        charId: '',
      ),
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\pages\initialization\initialization_screen.dart
-----------------------------------
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../application/providers/initialization_providers.dart';

class InitializationScreen extends ConsumerWidget {
  const InitializationScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final initState = ref.watch(appInitializationProvider);

    return Scaffold(
      body: Center(
        child: initState.when(
          data: (_) => const Text('鍒濆鍖栧畬鎴?),
          loading: () => const Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              CircularProgressIndicator(),
              SizedBox(height: 16),
              Text('姝ｅ湪鍒濆鍖?..'),
              Text(
                '鍔犺浇涓?..',
                style: TextStyle(color: Colors.red),
              ),
            ],
          ),
          error: (error, stack) => Text(
            '鍒濆鍖栧け璐? $error',
            style: const TextStyle(color: Colors.red),
          ),
        ),
      ),
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\pages\main\main_window.dart
-----------------------------------
import 'package:flutter/material.dart';

import '../../../presentation/pages/characters/character_list_page.dart';
import '../../../presentation/pages/practices/practice_list_page.dart';
import '../../../presentation/pages/settings/settings_page.dart';
import '../../../presentation/pages/works/work_browse_page.dart';
import '../../../presentation/pages/works/work_detail_page.dart';
import '../../../presentation/widgets/navigation/side_nav.dart';
import '../../../presentation/widgets/window/title_bar.dart';
import '../../../routes/app_routes.dart';

class MainWindow extends StatefulWidget {
  const MainWindow({super.key});

  @override
  State<MainWindow> createState() => _MainWindowState();
}

class _MainWindowState extends State<MainWindow> with WidgetsBindingObserver {
  int _selectedIndex = 0;

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: Column(
        children: [
          // Title bar - unchanged
          const TitleBar(),

          // Content area - including side navigation bar and right content
          Expanded(
            child: Row(
              children: [
                // Side navigation - always shown
                SideNavigation(
                  selectedIndex: _selectedIndex,
                  onDestinationSelected: (index) {
                    setState(() {
                      _selectedIndex = index;
                    });
                  },
                ),

                // Content area - dynamically changing part
                Expanded(
                  child: _buildContent(),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }

  @override
  void dispose() {
    WidgetsBinding.instance.removeObserver(this);
    super.dispose();
  }

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addObserver(this);
  }

  Widget _buildContent() {
    // Build different content based on selected tab
    switch (_selectedIndex) {
      case 0:
        return Navigator(
          key: ValueKey('work_navigator_$_selectedIndex'),
          onGenerateRoute: (settings) {
            if (settings.name == AppRoutes.workDetail &&
                settings.arguments != null) {
              final workId = settings.arguments as String;
              return MaterialPageRoute<bool>(
                // 鎸囧畾杩斿洖鍊肩被鍨嬩负bool
                builder: (context) => WorkDetailPage(workId: workId),
              );
            }
            // Default to work browse page
            return MaterialPageRoute(
              builder: (context) => const WorkBrowsePage(),
            );
          },
        );
      case 1:
        return const CharacterListPage();
      case 2:
        return const PracticeListPage();
      case 3:
        return const SettingsPage();
      default:
        return const Center(child: Text('Page not implemented'));
    }
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\pages\practices\practice_detail_page.dart
-----------------------------------
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../domain/models/practice/practice_entity.dart';
import '../../../domain/models/practice/practice_layer.dart';
import '../../../infrastructure/logging/logger.dart';
import '../../../routes/app_routes.dart';
import '../../providers/practice_detail_provider.dart';
import '../../widgets/common/detail_toolbar.dart';
import '../../widgets/common/loading_indicator.dart';
import '../../widgets/page_layout.dart';
import 'components/practice_page_viewer.dart';

class PracticeDetailPage extends ConsumerStatefulWidget {
  final String practiceId;

  const PracticeDetailPage({super.key, required this.practiceId});

  @override
  ConsumerState<PracticeDetailPage> createState() => _PracticeDetailPageState();
}

class _PracticeDetailPageState extends ConsumerState<PracticeDetailPage> {
  int _currentPageIndex = 0;

  @override
  Widget build(BuildContext context) {
    final state = ref.watch(practiceDetailProvider(widget.practiceId));

    return PageLayout(
      toolbar: _buildToolbar(state.practice),
      body: _buildBody(state),
    );
  }

  @override
  void initState() {
    super.initState();
    _loadPractice();
  }

  Widget _buildBody(PracticeDetailState state) {
    if (state.isLoading) {
      return const Center(
        child: LoadingIndicator(message: '鍔犺浇缁冧範涓?..'),
      );
    }

    if (state.error != null) {
      return Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            const Icon(Icons.error_outline, size: 48, color: Colors.red),
            const SizedBox(height: 16),
            Text(state.error!, style: const TextStyle(fontSize: 16)),
            const SizedBox(height: 24),
            ElevatedButton(
              onPressed: _loadPractice,
              child: const Text('閲嶈瘯'),
            ),
          ],
        ),
      );
    }

    if (state.practice == null) {
      return const Center(
        child: Text('缁冧範涓嶅瓨鍦ㄦ垨宸茶鍒犻櫎'),
      );
    }

    return _buildPracticeContent(state.practice!);
  }

  Widget _buildPageSelector(PracticeEntity practice) {
    final pages = practice.pages;

    return SizedBox(
      height: 50,
      child: ListView.builder(
        scrollDirection: Axis.horizontal,
        itemCount: pages.length,
        itemBuilder: (context, index) {
          return Padding(
            padding: const EdgeInsets.symmetric(horizontal: 4.0),
            child: ChoiceChip(
              label: Text('绗?{index + 1}椤?),
              selected: index == _currentPageIndex,
              onSelected: (selected) {
                if (selected) {
                  setState(() {
                    _currentPageIndex = index;
                  });
                }
              },
            ),
          );
        },
      ),
    );
  }

  Widget _buildPracticeContent(PracticeEntity practice) {
    final pages = practice.pages;
    if (pages.isEmpty) {
      return const Center(
        child: Text('姝ょ粌涔犳病鏈夐〉闈?),
      );
    }

    return Column(
      children: [
        // 椤甸潰閫夋嫨鍣紙濡傛灉鏈夊椤碉級
        if (pages.length > 1) _buildPageSelector(practice),

        // 椤甸潰鍐呭鏌ョ湅鍣?
        Expanded(
          child: PracticePageViewer(
            page: pages[_currentPageIndex], // 褰撳墠椤?
            readOnly: true,
            onLayerToggle: _handleLayerToggle,
          ),
        ),
      ],
    );
  }

  Widget _buildPracticeMetadata(PracticeEntity practice) {
    final theme = Theme.of(context);

    return Card(
      margin: const EdgeInsets.all(8.0),
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Text(
                  '缁冧範淇℃伅',
                  style: theme.textTheme.titleMedium,
                ),
                Text(
                  '鍏?${practice.pages.length} 椤?,
                  style: theme.textTheme.bodySmall,
                ),
              ],
            ),
            const Divider(),
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Text('鍒涘缓鏃堕棿: ${_formatDateTime(practice.createTime)}'),
                Text('鏇存柊鏃堕棿: ${_formatDateTime(practice.updateTime)}'),
              ],
            ),
            if (practice.tags.isNotEmpty)
              Padding(
                padding: const EdgeInsets.only(top: 8.0),
                child: Wrap(
                  spacing: 8,
                  children: practice.tags
                      .map((tag) => Chip(label: Text(tag)))
                      .toList(),
                ),
              ),
          ],
        ),
      ),
    );
  }

  Widget _buildToolbar(PracticeEntity? practice) {
    return DetailToolbar(
      title: practice?.title ?? '缁冧範璇︽儏',
      leadingIcon: Icons.auto_stories,
      subtitle: practice != null
          ? '鍒涘缓浜?${_formatDateShort(practice.createTime)}'
          : null,
      badge: practice != null && practice.pages.isNotEmpty
          ? DetailBadge(text: '${practice.pages.length}椤?)
          : null,
      actions: practice != null
          ? [
              DetailToolbarAction(
                icon: Icons.edit,
                tooltip: '缂栬緫缁冧範',
                onPressed: _navigateToEdit,
                primary: true,
              ),
              DetailToolbarAction(
                icon: Icons.add_photo_alternate_outlined,
                tooltip: '娣诲姞椤甸潰',
                onPressed: () {
                  // 娣诲姞椤甸潰鍔熻兘
                },
              ),
              DetailToolbarAction(
                icon: Icons.delete,
                tooltip: '鍒犻櫎缁冧範',
                onPressed: _confirmDelete,
                primary: false,
              ),
            ]
          : [],
    );
  }

  Future<void> _confirmDelete() async {
    final confirmed = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('鍒犻櫎缁冧範'),
        content: Text(
            '纭畾瑕佸垹闄ょ粌涔?${ref.read(practiceDetailProvider(widget.practiceId)).practice?.title}"鍚楋紵姝ゆ搷浣滀笉鍙挙閿€銆?),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(false),
            child: const Text('鍙栨秷'),
          ),
          FilledButton(
            onPressed: () => Navigator.of(context).pop(true),
            style: FilledButton.styleFrom(
              backgroundColor: Colors.red,
              foregroundColor: Colors.white,
            ),
            child: const Text('鍒犻櫎'),
          ),
        ],
      ),
    );

    if (confirmed == true) {
      await _deletePractice();
    }
  }

  Future<void> _deletePractice() async {
    try {
      await ref
          .read(practiceDetailProvider(widget.practiceId).notifier)
          .deletePractice(widget.practiceId);

      if (mounted) {
        Navigator.of(context).pop(); // 杩斿洖涓婁竴椤?
      } else if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('鍒犻櫎澶辫触')),
        );
      }
    } catch (e, stack) {
      AppLogger.error(
        'Failed to delete practice',
        tag: 'PracticeDetailPage',
        error: e,
        stackTrace: stack,
        data: {'id': widget.practiceId},
      );

      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('鍒犻櫎澶辫触: ${e.toString()}')),
        );
      }
    }
  }

  String _formatDateShort(DateTime? date) {
    if (date == null) return '鏈煡';
    return '${date.year}/${date.month}/${date.day}';
  }

  String _formatDateTime(DateTime? dateTime) {
    if (dateTime == null) return '鏈煡';

    return '${dateTime.year}-'
        '${dateTime.month.toString().padLeft(2, '0')}-'
        '${dateTime.day.toString().padLeft(2, '0')} '
        '${dateTime.hour.toString().padLeft(2, '0')}:'
        '${dateTime.minute.toString().padLeft(2, '0')}';
  }

  void _handleLayerToggle(PracticeLayer layer) {
    ref
        .read(practiceDetailProvider(widget.practiceId).notifier)
        .updateLayer(layer.order, layer);
  }

  Future<void> _loadPractice() async {
    await ref
        .read(practiceDetailProvider(widget.practiceId).notifier)
        .loadPractice(widget.practiceId);
  }

  void _navigateToEdit() {
    Navigator.pushNamed(
      context,
      AppRoutes.practiceDetail,
      arguments: widget.practiceId,
    ).then((_) => _loadPractice()); // 缂栬緫鍚庡埛鏂?
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\pages\practices\practice_edit_page.dart
-----------------------------------
import 'package:flutter/material.dart';

import '../../widgets/practice/practice_layer_panel.dart';
import '../../widgets/practice/practice_property_panel.dart';
import '../../widgets/practice/practice_tool_panel.dart';
import '../../widgets/window/title_bar.dart';

class PracticeEditPage extends StatefulWidget {
  final String? practiceId; // 鍙€塈D锛屽鏋滀负null鍒欒〃绀烘柊寤?

  const PracticeEditPage({
    super.key,
    this.practiceId,
  });

  @override
  State<PracticeEditPage> createState() => _PracticeEditPageState();
}

class _PracticeEditPageState extends State<PracticeEditPage> {
  bool _hasUnsavedChanges = false;
  List<Map<String, dynamic>> _layers = [];
  Map<String, dynamic>? _selectedElement;

  @override
  Widget build(BuildContext context) {
    return WillPopScope(
      onWillPop: _onWillPop,
      child: Scaffold(
        body: Column(
          children: [
            const TitleBar(),
            AppBar(
              leading: IconButton(
                icon: const Icon(Icons.arrow_back),
                onPressed: () async {
                  if (await _onWillPop()) {
                    Navigator.pop(context);
                  }
                },
              ),
              title: Text(
                widget.practiceId == null ? '鏂板缓瀛楀笘' : '缂栬緫瀛楀笘',
                style: const TextStyle(fontSize: 20),
              ),
              actions: [
                TextButton.icon(
                  onPressed: _handleSave,
                  icon: const Icon(Icons.save),
                  label: const Text('淇濆瓨'),
                ),
                TextButton.icon(
                  onPressed: () {},
                  icon: const Icon(Icons.print),
                  label: const Text('鎵撳嵃'),
                ),
                TextButton.icon(
                  onPressed: () {},
                  icon: const Icon(Icons.file_download),
                  label: const Text('瀵煎嚭'),
                ),
              ],
            ),
            Expanded(
              child: Row(
                children: [
                  // 宸︿晶宸ュ叿闈㈡澘鍜屽浘灞傚垪琛?
                  SizedBox(
                    width: 250,
                    child: Column(
                      children: [
                        Expanded(
                          child: PracticeToolPanel(
                            onToolSelected: _handleToolSelected,
                          ),
                        ),
                        const Divider(height: 1),
                        Expanded(
                          child: PracticeLayerPanel(
                            layers: _layers,
                            onLayerSelected: _handleLayerSelected,
                            onLayerVisibilityChanged:
                                _handleLayerVisibilityChanged,
                            onLayerLockChanged: _handleLayerLockChanged,
                            onLayerDeleted: _handleLayerDeleted,
                            onLayerReordered: _handleLayerReordered,
                          ),
                        ),
                      ],
                    ),
                  ),
                  const VerticalDivider(width: 1),
                  // 涓ぎ缂栬緫鍖?
                  Expanded(
                    child: Container(
                      color: Colors.grey[100],
                      child: Center(
                        child: Container(
                          width: 595, // A4绾稿搴?
                          height: 842, // A4绾搁珮搴?
                          color: Colors.white,
                          child: const Stack(
                            children: [
                              // TODO: 瀹炵幇鐢诲竷鍜岀紪杈戝姛鑳?
                            ],
                          ),
                        ),
                      ),
                    ),
                  ),
                  const VerticalDivider(width: 1),
                  // 鍙充晶灞炴€ч潰鏉?
                  SizedBox(
                    width: 280,
                    child: PracticePropertyPanel(
                      selectedElement: _selectedElement,
                      onPropertyChanged: _handlePropertyChanged,
                    ),
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }

  @override
  void initState() {
    super.initState();
    // TODO: 鍔犺浇瀛楀笘鏁版嵁
    _layers = [
      {
        'id': '1',
        'name': '鑳屾櫙灞?,
        'visible': true,
        'locked': false,
        'selected': false,
      },
      {
        'id': '2',
        'name': '鍐呭灞?,
        'visible': true,
        'locked': false,
        'selected': true,
      },
    ];
  }

  void _handleLayerDeleted(int index) {
    setState(() {
      _layers.removeAt(index);
      _hasUnsavedChanges = true;
    });
  }

  void _handleLayerLockChanged(int index, bool locked) {
    setState(() {
      _layers[index]['locked'] = locked;
      _hasUnsavedChanges = true;
    });
  }

  void _handleLayerReordered(int oldIndex, int newIndex) {
    setState(() {
      if (oldIndex < newIndex) {
        newIndex -= 1;
      }
      final item = _layers.removeAt(oldIndex);
      _layers.insert(newIndex, item);
      _hasUnsavedChanges = true;
    });
  }

  void _handleLayerSelected(int index) {
    setState(() {
      for (var i = 0; i < _layers.length; i++) {
        _layers[i]['selected'] = i == index;
      }
    });
  }

  void _handleLayerVisibilityChanged(int index, bool visible) {
    setState(() {
      _layers[index]['visible'] = visible;
      _hasUnsavedChanges = true;
    });
  }

  void _handlePropertyChanged(Map<String, dynamic> updatedElement) {
    setState(() {
      _selectedElement = updatedElement;
      _hasUnsavedChanges = true;
    });
  }

  Future<void> _handleSave() async {
    // TODO: 瀹炵幇淇濆瓨閫昏緫
    setState(() => _hasUnsavedChanges = false);
  }

  void _handleToolSelected(String tool) {
    setState(() {
      _hasUnsavedChanges = true;
    });
  }

  Future<bool> _onWillPop() async {
    if (!_hasUnsavedChanges) return true;

    final result = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('纭閫€鍑?),
        content: const Text('鏈夋湭淇濆瓨鐨勬洿鏀癸紝纭畾瑕侀€€鍑哄悧锛?),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context, false),
            child: const Text('鍙栨秷'),
          ),
          TextButton(
            onPressed: () => Navigator.pop(context, true),
            child: const Text('纭畾'),
          ),
        ],
      ),
    );

    return result ?? false;
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\pages\practices\practice_list_page.dart
-----------------------------------
import 'package:flutter/material.dart';

// 娣诲姞
import '../../../theme/app_sizes.dart';
import '../../widgets/page_layout.dart';
import '../../widgets/page_toolbar.dart';
import 'practice_detail_page.dart';
import 'practice_edit_page.dart'; // 娣诲姞

class PracticeListPage extends StatefulWidget {
  const PracticeListPage({super.key});

  @override
  State<PracticeListPage> createState() => _PracticeListPageState();
}

class _PracticeListPageState extends State<PracticeListPage> {
  bool _isGridView = true;

  @override
  Widget build(BuildContext context) {
    return PageLayout(
      toolbar: PageToolbar(
        leading: [
          FilledButton.icon(
            onPressed: () => _navigateToEditPage(),
            icon: const Icon(Icons.add),
            label: const Text('鏂板缓缁冧範'),
          ),
          const SizedBox(width: AppSizes.spacingMedium),
          IconButton(
            onPressed: () => setState(() => _isGridView = !_isGridView),
            icon: Icon(_isGridView ? Icons.list : Icons.grid_view),
            tooltip: _isGridView ? '鍒楄〃瑙嗗浘' : '缃戞牸瑙嗗浘',
          ),
        ],
        trailing: [
          const SizedBox(
            width: 240,
            child: SearchBar(
              hintText: '鎼滅储缁冧範...',
              leading: Icon(Icons.search),
              padding: WidgetStatePropertyAll(
                EdgeInsets.symmetric(horizontal: AppSizes.spacingMedium),
              ),
            ),
          ),
        ],
      ),
      body: _isGridView ? _buildGridView() : _buildListView(),
    );
  }

  Widget _buildGridView() {
    return GridView.builder(
      padding: const EdgeInsets.all(AppSizes.spacingMedium), // 鏇存柊
      gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
        crossAxisCount: AppSizes.gridCrossAxisCount, // 浣跨敤甯搁噺
        mainAxisSpacing: AppSizes.gridMainAxisSpacing, // 浣跨敤甯搁噺
        crossAxisSpacing: AppSizes.gridCrossAxisSpacing, // 浣跨敤甯搁噺
        childAspectRatio: 1,
      ),
      itemCount: 20,
      itemBuilder: (context, index) {
        return Card(
          child: InkWell(
            onTap: () {
              _navigateToPracticeDetail(context, 'practice_$index'); // 娣诲姞瀵艰埅
            },
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Expanded(
                  child: Stack(
                    children: [
                      Container(
                        color: Colors.grey[300],
                        child: Center(child: Text('瀛楀笘 $index')),
                      ),
                      Positioned(
                        right: 8,
                        bottom: 8,
                        child: Chip(
                          label: const Text('鑽夌'),
                          backgroundColor: Colors.yellow[100],
                        ),
                      ),
                    ],
                  ),
                ),
                Padding(
                  padding: const EdgeInsets.all(8.0),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text('瀛楀笘鏍囬 $index',
                          style: Theme.of(context).textTheme.titleMedium),
                      Text('鍒涘缓鏃堕棿: 2024-01-01',
                          style: Theme.of(context).textTheme.bodySmall),
                    ],
                  ),
                ),
              ],
            ),
          ),
        );
      },
    );
  }

  Widget _buildListView() {
    return ListView.builder(
      padding: const EdgeInsets.all(AppSizes.spacingMedium), // 鏇存柊
      itemCount: 20,
      itemBuilder: (context, index) {
        return Card(
          child: ListTile(
            leading: Container(
              width: 48,
              color: Colors.grey[300],
              child: Center(child: Text('$index')),
            ),
            title: Text('瀛楀笘鏍囬 $index'),
            subtitle: const Text('鍒涘缓鏃堕棿: 2024-01-01'),
            trailing: const Icon(Icons.chevron_right),
            onTap: () {
              _navigateToPracticeDetail(context, 'practice_$index'); // 娣诲姞瀵艰埅
            },
          ),
        );
      },
    );
  }

  void _navigateToEditPage([String? practiceId]) {
    Navigator.push(
      context,
      MaterialPageRoute(
        builder: (context) => PracticeEditPage(practiceId: practiceId),
      ),
    );
  }

  void _navigateToPracticeDetail(BuildContext context, String practiceId) {
    Navigator.push(
      context,
      MaterialPageRoute(
        builder: (context) => PracticeDetailPage(practiceId: practiceId),
      ),
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\pages\practices\components\practice_page_viewer.dart
-----------------------------------
import 'dart:io';
import 'dart:math';

import 'package:flutter/material.dart';

import '../../../../domain/models/practice/element_content.dart';
import '../../../../domain/models/practice/practice_element.dart';
import '../../../../domain/models/practice/practice_layer.dart';
import '../../../../domain/models/practice/practice_page.dart';
import '../../../../theme/app_colors.dart';
import '../../../widgets/common/empty_state.dart';

/// 瀛楀笘椤甸潰棰勮缁勪欢
class PracticePageViewer extends StatefulWidget {
  /// 瀛楀笘椤甸潰
  final PracticePage page;

  /// 鏄惁鍙妯″紡
  final bool readOnly;

  /// 鍏冪礌鐐瑰嚮鍥炶皟
  final void Function(PracticeElement element)? onElementTap;

  /// 鍥惧眰鍒囨崲鍥炶皟
  final void Function(PracticeLayer layer)? onLayerToggle;

  const PracticePageViewer({
    super.key,
    required this.page,
    this.readOnly = true,
    this.onElementTap,
    this.onLayerToggle,
  });

  @override
  State<PracticePageViewer> createState() => _PracticePageViewerState();
}

class _PracticePageViewerState extends State<PracticePageViewer> {
  /// 缂╂斁姣斾緥
  double _scale = 1.0;

  /// 鏄惁鏄剧ず鍥惧眰鎺у埗闈㈡澘
  bool _showLayers = false;

  /// 褰撳墠閫変腑鐨勫厓绱營D
  String? _selectedElementId;

  @override
  Widget build(BuildContext context) {
    // 濡傛灉椤甸潰娌℃湁鍥惧眰锛屾樉绀虹┖鐘舵€?
    if (widget.page.layers.isEmpty) {
      return const EmptyState();
    }

    return Scaffold(
      // 浣跨敤Scaffold鍙负浜嗚幏鍙栬儗鏅壊鍜孎loatingActionButton鏀寔
      backgroundColor: Colors.transparent,
      floatingActionButton: widget.readOnly ? null : _buildFab(),
      body: Column(
        children: [
          // 椤堕儴鎺у埗鍖?
          _buildControls(),

          // 椤甸潰鍐呭鍖?(鍗犳嵁澶ч儴鍒嗙┖闂?
          Expanded(
            child: _buildPageContent(),
          ),
        ],
      ),
    );
  }

  /// 鏋勫缓瀛楃鍏冪礌
  Widget _buildCharsElement(PracticeElement element) {
    final charsContent = element.content as CharsContent;

    // 濡傛灉娌℃湁瀛楃锛屾樉绀哄崰浣嶇
    if (charsContent.chars.isEmpty) {
      return const Center(
        child: Text('鏃犲瓧绗﹀唴瀹?),
      );
    }

    // 缁樺埗鎵€鏈夊瓧绗?(澶嶆潅閫昏緫绠€鍖栫ず渚?
    return Stack(
      children: charsContent.chars.map((charElement) {
        // 杩欓噷绠€鍖栦簡瀛楃瀹氫綅鍜屽彉鎹紝瀹為檯瀹炵幇闇€鏇村鏉?
        return Center(
          child: Text(
            '瀛楃: ${charElement.charId}',
            style: TextStyle(
              color: Color(int.parse(
                    charElement.style.color.substring(1) ?? 'FF000000',
                    radix: 16,
                  ) |
                  0xFF000000),
              fontSize: 16.0 * charElement.transform.scaleX,
            ),
          ),
        );
      }).toList(),
    );
  }

  /// 鏋勫缓椤堕儴鎺у埗鍖?
  Widget _buildControls() {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
      child: Row(
        children: [
          // 缂╂斁鎺у埗
          Text(
            '缂╂斁: ${(_scale * 100).toStringAsFixed(0)}%',
            style: Theme.of(context).textTheme.bodySmall,
          ),
          const SizedBox(width: 8),
          IconButton(
            icon: const Icon(Icons.zoom_in),
            onPressed: () {
              setState(() {
                _scale = min(_scale + 0.1, 2.0);
              });
            },
            tooltip: '鏀惧ぇ',
            iconSize: 20,
            constraints: const BoxConstraints(
              minWidth: 36,
              minHeight: 36,
            ),
          ),
          IconButton(
            icon: const Icon(Icons.zoom_out),
            onPressed: () {
              setState(() {
                _scale = max(_scale - 0.1, 0.5);
              });
            },
            tooltip: '缂╁皬',
            iconSize: 20,
            constraints: const BoxConstraints(
              minWidth: 36,
              minHeight: 36,
            ),
          ),

          const Spacer(),

          // 椤甸潰淇℃伅
          Text(
            '${widget.page.size.width.toStringAsFixed(0)}脳${widget.page.size.height.toStringAsFixed(0)} ${widget.page.size.unit}',
            style: Theme.of(context).textTheme.bodySmall,
          ),
        ],
      ),
    );
  }

  /// 鏍规嵁鍏冪礌绫诲瀷鏋勫缓瀵瑰簲鐨刉idget
  Widget? _buildElementWidget(PracticeElement element) {
    final geometry = element.geometry;
    final isSelected = element.id == _selectedElementId;

    // 璁＄畻鍏冪礌瀹為檯浣嶇疆鍜屽ぇ灏?搴旂敤缂╂斁)
    final left = geometry.x * _scale;
    final top = geometry.y * _scale;
    final width = geometry.width * _scale;
    final height = geometry.height * _scale;

    // 鍩虹瀹瑰櫒
    Widget? contentWidget;

    // 鏍规嵁鍏冪礌绫诲瀷鍒涘缓鍐呭
    switch (element.elementType) {
      case 'chars':
        // 澶勭悊瀛楃绫诲瀷鍏冪礌
        if (element.content is CharsContent) {
          contentWidget = _buildCharsElement(element);
        }
        break;
      case 'text':
        // 澶勭悊鏂囨湰绫诲瀷鍏冪礌
        if (element.content is TextContent) {
          contentWidget = _buildTextElement(element);
        }
        break;
      case 'image':
        // 澶勭悊鍥惧儚绫诲瀷鍏冪礌
        if (element.content is ImageContent) {
          contentWidget = _buildImageElement(element);
        }
        break;
      default:
        // 鏈煡鍏冪礌绫诲瀷
        contentWidget = const Center(
          child: Text('鏈煡鍏冪礌绫诲瀷'),
        );
    }

    if (contentWidget == null) return null;

    // 鍒涘缓鍙氦浜掑厓绱?
    return Positioned(
      left: left,
      top: top,
      width: width,
      height: height,
      child: Transform.rotate(
        angle: geometry.rotation * (pi / 180), // 杞崲涓哄姬搴?
        child: Opacity(
          opacity: element.style.opacity,
          child: GestureDetector(
            onTap: widget.readOnly
                ? null
                : () {
                    setState(() {
                      _selectedElementId = element.id;
                    });
                    widget.onElementTap?.call(element);
                  },
            child: Container(
              decoration: isSelected
                  ? BoxDecoration(
                      border: Border.all(
                        color: AppColors.primary,
                        width: 2.0,
                      ),
                    )
                  : null,
              child: contentWidget,
            ),
          ),
        ),
      ),
    );
  }

  /// 鏋勫缓搴曢儴娴姩鎸夐挳
  Widget? _buildFab() {
    if (widget.readOnly) return null;

    return FloatingActionButton(
      onPressed: () {
        setState(() {
          _showLayers = !_showLayers;
        });
      },
      tooltip: _showLayers ? '闅愯棌鍥惧眰闈㈡澘' : '鏄剧ず鍥惧眰闈㈡澘',
      child: Icon(_showLayers ? Icons.layers_clear : Icons.layers),
    );
  }

  /// 鏋勫缓鍥惧儚鍏冪礌
  Widget _buildImageElement(PracticeElement element) {
    final imagePath = (element.content as ImageContent).image.url;

    try {
      // 灏濊瘯鍔犺浇鍥惧儚
      final file = File(imagePath);
      if (!file.existsSync()) {
        return const Center(
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              Icon(Icons.broken_image, size: 32, color: Colors.grey),
              SizedBox(height: 4),
              Text('鍥剧墖涓嶅瓨鍦?, style: TextStyle(color: Colors.grey)),
            ],
          ),
        );
      }

      return Image.file(
        file,
        fit: BoxFit.contain,
        errorBuilder: (context, error, stackTrace) {
          return const Center(
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                Icon(Icons.error_outline, size: 32, color: Colors.red),
                SizedBox(height: 4),
                Text('鍥剧墖鎹熷潖', style: TextStyle(color: Colors.red)),
              ],
            ),
          );
        },
      );
    } catch (e) {
      return Center(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            const Icon(Icons.error, size: 32, color: Colors.red),
            const SizedBox(height: 4),
            Text(
                '鍔犺浇閿欒: ${e.toString().substring(0, min(20, e.toString().length))}...'),
          ],
        ),
      );
    }
  }

  /// 鏋勫缓鎵€鏈夊浘灞傜殑鎵€鏈夊厓绱?
  List<Widget> _buildLayeredElements() {
    final List<Widget> elements = [];

    // 鎸夌収鍥惧眰椤哄簭鏋勫缓鍏冪礌锛堢储寮曡緝灏忕殑鍥惧眰鍦ㄤ笅鏂癸級
    final visibleLayers = widget.page.layers
        .where((layer) => layer.visible)
        .toList()
      ..sort((a, b) => a.order.compareTo(b.order));

    for (final layer in visibleLayers) {
      for (final element in layer.elements) {
        // 濡傛灉鍏冪礌涓嶅彲瑙侊紝鍒欒烦杩?
        if (!element.style.visible) continue;

        // 鏍规嵁鍏冪礌绫诲瀷鏋勫缓涓嶅悓鐨勮鍥?
        final elementWidget = _buildElementWidget(element);
        if (elementWidget != null) {
          elements.add(elementWidget);
        }
      }
    }

    return elements;
  }

  /// 鏋勫缓鍗曚釜鍥惧眰椤?
  Widget _buildLayerItem(PracticeLayer layer) {
    return ListTile(
      title: Text(
        layer.name!,
        style: TextStyle(
          fontWeight: layer.locked ? FontWeight.normal : FontWeight.bold,
          color: !layer.visible
              ? Theme.of(context).disabledColor
              : Theme.of(context).textTheme.bodyLarge?.color,
        ),
      ),
      subtitle: Text('${layer.elements.length} 涓厓绱?),
      leading: Icon(
        layer.type == 'background' ? Icons.landscape : Icons.layers,
        color: layer.visible
            ? (layer.type == 'background'
                ? Colors.green
                : Theme.of(context).colorScheme.primary)
            : Theme.of(context).disabledColor,
      ),
      trailing: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          // 鍙鎬у垏鎹?
          IconButton(
            icon: Icon(
              layer.visible ? Icons.visibility : Icons.visibility_off,
            ),
            onPressed: widget.readOnly
                ? null
                : () {
                    final updatedLayer = layer.toggleVisibility();
                    widget.onLayerToggle?.call(updatedLayer);
                    // 濡傛灉娌℃湁澶栭儴澶勭悊锛屽湪鏈湴鏇存柊鐘舵€?
                    if (widget.onLayerToggle == null) {
                      setState(() {});
                    }
                  },
            tooltip: layer.visible ? '闅愯棌鍥惧眰' : '鏄剧ず鍥惧眰',
            iconSize: 20,
            padding: EdgeInsets.zero,
            constraints: const BoxConstraints(
              minWidth: 36,
              minHeight: 36,
            ),
          ),

          // 閿佸畾鍒囨崲
          IconButton(
            icon: Icon(
              layer.locked ? Icons.lock_outline : Icons.lock_open,
            ),
            onPressed: widget.readOnly
                ? null
                : () {
                    final updatedLayer = layer.toggleLock();
                    widget.onLayerToggle?.call(updatedLayer);
                    // 濡傛灉娌℃湁澶栭儴澶勭悊锛屽湪鏈湴鏇存柊鐘舵€?
                    if (widget.onLayerToggle == null) {
                      setState(() {});
                    }
                  },
            tooltip: layer.locked ? '瑙ｉ攣鍥惧眰' : '閿佸畾鍥惧眰',
            iconSize: 20,
            padding: EdgeInsets.zero,
            constraints: const BoxConstraints(
              minWidth: 36,
              minHeight: 36,
            ),
          ),
        ],
      ),
      onTap: widget.readOnly
          ? null
          : () {
              // 鐐瑰嚮鍥惧眰椤圭殑琛屼负锛屼緥濡傞€夋嫨璇ュ浘灞?
            },
    );
  }

  /// 鏋勫缓鍥惧眰鎺у埗闈㈡澘
  Widget _buildLayersPanel() {
    return Container(
      width: 250,
      decoration: BoxDecoration(
        color: Theme.of(context).cardColor,
        border: Border(
          left: BorderSide(
            color: Theme.of(context).dividerColor,
            width: 1,
          ),
        ),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.stretch,
        children: [
          // 闈㈡澘鏍囬
          Padding(
            padding: const EdgeInsets.all(16),
            child: Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Text(
                  '鍥惧眰',
                  style: Theme.of(context).textTheme.titleMedium,
                ),
                IconButton(
                  icon: const Icon(Icons.close),
                  onPressed: () {
                    setState(() {
                      _showLayers = false;
                    });
                  },
                  tooltip: '鍏抽棴鍥惧眰闈㈡澘',
                  iconSize: 20,
                  padding: EdgeInsets.zero,
                  constraints: const BoxConstraints(
                    minWidth: 36,
                    minHeight: 36,
                  ),
                ),
              ],
            ),
          ),

          const Divider(height: 1),

          // 鍥惧眰鍒楄〃
          Expanded(
            child: ListView.builder(
              itemCount: widget.page.layers.length,
              itemBuilder: (context, index) {
                final layer = widget.page.layers[index];
                return _buildLayerItem(layer);
              },
            ),
          ),
        ],
      ),
    );
  }

  /// 鏋勫缓椤甸潰鐢诲竷
  Widget _buildPageCanvas() {
    final pageSize = widget.page.size;

    // 璁＄畻瀹為檯鏄剧ず灏哄 (搴旂敤缂╂斁姣斾緥)
    final displayWidth = pageSize.width * _scale;
    final displayHeight = pageSize.height * _scale;

    return Container(
      margin: const EdgeInsets.all(20),
      width: displayWidth,
      height: displayHeight,
      decoration: BoxDecoration(
        color: Colors.white,
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.1),
            blurRadius: 10,
            offset: const Offset(0, 2),
          ),
        ],
      ),
      child: ClipRect(
        child: Stack(
          children: _buildLayeredElements(),
        ),
      ),
    );
  }

  /// 鏋勫缓椤甸潰鍐呭鍖?
  Widget _buildPageContent() {
    return Row(
      crossAxisAlignment: CrossAxisAlignment.stretch,
      children: [
        // 涓诲唴瀹瑰尯鍩?
        Expanded(
          child: Center(
            child: SingleChildScrollView(
              scrollDirection: Axis.vertical,
              child: SingleChildScrollView(
                scrollDirection: Axis.horizontal,
                child: _buildPageCanvas(),
              ),
            ),
          ),
        ),

        // 鏄剧ず鍥惧眰闈㈡澘 (濡傛灉鍚敤)
        if (_showLayers && !widget.readOnly) _buildLayersPanel(),
      ],
    );
  }

  /// 鏋勫缓鏂囨湰鍏冪礌
  Widget _buildTextElement(PracticeElement element) {
    final textContent = (element.content as TextContent).text;

    // 璁剧疆瀵归綈鏂瑰紡
    TextAlign textAlign = textContent.textAlign;

    return Container(
      padding: const EdgeInsets.all(4),
      child: Text(
        textContent.text,
        style: TextStyle(
          fontFamily: textContent.fontFamily,
          fontSize: textContent.fontSize * _scale,
          color: Color(int.parse(
                textContent.color.substring(1),
                radix: 16,
              ) |
              0xFF000000),
        ),
        textAlign: textAlign,
      ),
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\pages\settings\settings_page.dart
-----------------------------------
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../widgets/page_layout.dart';
import 'components/appearance_settings.dart';
import 'components/storage_settings.dart';

class SettingsPage extends ConsumerWidget {
  const SettingsPage({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return PageLayout(
      toolbar: const Text('璁剧疆'),
      body: _buildSettingsContent(context, ref),
    );
  }

  Widget _buildSettingsContent(BuildContext context, WidgetRef ref) {
    return ListView(
      children: const [
        AppearanceSettings(),
        Divider(),
        StorageSettings(),
      ],
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\pages\settings\components\appearance_settings.dart
-----------------------------------
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../domain/enums/app_theme_mode.dart';
import '../../../providers/settings_provider.dart';
import '../../../widgets/settings/settings_section.dart';

class AppearanceSettings extends ConsumerWidget {
  const AppearanceSettings({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final themeMode = ref.watch(settingsProvider.select((s) => s.themeMode));
    final isDarkMode = themeMode == AppThemeMode.dark;
    final isSystemMode = themeMode == AppThemeMode.system;

    return SettingsSection(
      title: '澶栬',
      icon: Icons.palette_outlined,
      children: [
        ListTile(
          title: const Text('娣辫壊妯″紡'),
          subtitle: const Text('浣跨敤娣辫壊涓婚'),
          leading: const Icon(Icons.dark_mode),
          trailing: Switch(
            value: isDarkMode,
            onChanged: (value) {
              ref.read(settingsProvider.notifier).setThemeMode(
                    value ? AppThemeMode.dark : AppThemeMode.light,
                  );
            },
          ),
        ),
        ListTile(
          title: const Text('璺熼殢绯荤粺'),
          subtitle: const Text('鏍规嵁绯荤粺璁剧疆鑷姩鍒囨崲娣辫壊/娴呰壊妯″紡'),
          leading: const Icon(Icons.settings_system_daydream_outlined),
          trailing: Switch(
            value: isSystemMode,
            onChanged: (value) {
              if (value) {
                ref
                    .read(settingsProvider.notifier)
                    .setThemeMode(AppThemeMode.system);
              } else {
                ref.read(settingsProvider.notifier).setThemeMode(
                      isDarkMode ? AppThemeMode.dark : AppThemeMode.light,
                    );
              }
            },
          ),
        ),
      ],
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\pages\settings\components\storage_settings.dart
-----------------------------------
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../presentation/providers/storage_info_provider.dart';
import '../../../../theme/app_colors.dart';
import '../../../../theme/app_sizes.dart';
import '../../../../theme/app_text_styles.dart';
import '../../../../utils/file_size_formatter.dart';

class StorageSettings extends ConsumerWidget {
  const StorageSettings({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final storageInfo = ref.watch(storageInfoProvider);

    return Card(
      child: Padding(
        padding: const EdgeInsets.all(AppSizes.p16),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const Text('瀛樺偍绌洪棿', style: AppTextStyles.titleLarge),
            const SizedBox(height: AppSizes.p16),
            storageInfo.when(
              data: (info) => _buildStorageInfo(info),
              loading: () => const CircularProgressIndicator(),
              error: (err, stack) => Text('鍔犺浇澶辫触: $err'),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildDetailsSection(StorageInfo info) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text('瀛樺偍浣嶇疆: ${info.path}', style: AppTextStyles.bodyMedium),
        const SizedBox(height: AppSizes.p8),
        Text(
          '缂撳瓨澶у皬: ${FileSizeFormatter.format(info.cacheSize)}',
          style: AppTextStyles.bodyMedium,
        ),
        const SizedBox(height: AppSizes.p16),
        for (final dir in info.subdirectories) ...[
          Text(
            '${dir.name}: ${FileSizeFormatter.format(dir.size)}',
            style: AppTextStyles.bodyMedium,
          ),
          const SizedBox(height: AppSizes.p4),
        ],
      ],
    );
  }

  Widget _buildInfoItem({
    required String label,
    required String value,
    required IconData icon,
  }) {
    return Row(
      children: [
        Icon(icon, size: 20),
        const SizedBox(width: AppSizes.p8),
        Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(label, style: AppTextStyles.labelMedium),
            Text(value, style: AppTextStyles.bodyLarge),
          ],
        ),
      ],
    );
  }

  Widget _buildStorageBar(StorageInfo info) {
    final usagePercentage = info.usagePercentage.clamp(0, 100);

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          '宸蹭娇鐢?${FileSizeFormatter.format(info.usedSize)} / ${FileSizeFormatter.format(info.totalSize)}',
          style: AppTextStyles.bodyMedium,
        ),
        const SizedBox(height: AppSizes.p8),
        LinearProgressIndicator(
          value: usagePercentage / 100,
          backgroundColor: AppColors.background,
          valueColor: const AlwaysStoppedAnimation<Color>(
            AppColors.primary,
          ),
        ),
      ],
    );
  }

  Widget _buildStorageInfo(StorageInfo info) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        _buildSummarySection(info),
        const SizedBox(height: AppSizes.p16),
        _buildStorageBar(info),
        const SizedBox(height: AppSizes.p16),
        _buildDetailsSection(info),
      ],
    );
  }

  Widget _buildSummarySection(StorageInfo info) {
    return Row(
      children: [
        _buildInfoItem(
          label: '浣滃搧鏁伴噺',
          value: '${info.workCount}',
          icon: Icons.image_outlined,
        ),
        const SizedBox(width: AppSizes.p24),
        _buildInfoItem(
          label: '鏂囦欢鏁伴噺',
          value: '${info.fileCount}',
          icon: Icons.folder_outlined,
        ),
      ],
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\pages\settings\panels\general_settings_panel.dart
-----------------------------------
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

class GeneralSettingsPanel extends ConsumerWidget {
  const GeneralSettingsPanel({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return SingleChildScrollView(
      padding: const EdgeInsets.all(24),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          const Text('鐣岄潰璁剧疆', style: TextStyle(fontSize: 20, fontWeight: FontWeight.bold)),
          const SizedBox(height: 16),
          _buildThemeSettings(context),
          const Divider(height: 32),
          
          const Text('瑙嗗浘璁剧疆', style: TextStyle(fontSize: 20, fontWeight: FontWeight.bold)),
          const SizedBox(height: 16),
          _buildViewSettings(context),
          const Divider(height: 32),
          
          const Text('璇█璁剧疆', style: TextStyle(fontSize: 20, fontWeight: FontWeight.bold)),
          const SizedBox(height: 16),
          _buildLanguageSettings(context),
          const Divider(height: 32),
          
          const Text('鏇存柊璁剧疆', style: TextStyle(fontSize: 20, fontWeight: FontWeight.bold)),
          const SizedBox(height: 16),
          _buildUpdateSettings(context),
        ],
      ),
    );
  }

  Widget _buildThemeSettings(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        DropdownButtonFormField<String>(
          decoration: const InputDecoration(
            labelText: '涓婚妯″紡',
            border: OutlineInputBorder(),
          ),
          items: const [
            DropdownMenuItem(value: 'system', child: Text('璺熼殢绯荤粺')),
            DropdownMenuItem(value: 'light', child: Text('鏄庝寒妯″紡')),
            DropdownMenuItem(value: 'dark', child: Text('鏆楅粦妯″紡')),
          ],
          onChanged: (value) {},
        ),
        const SizedBox(height: 16),
        Row(
          children: [
            const Text('鐣岄潰缂╂斁'),
            Expanded(
              child: Slider(
                value: 1.0,
                min: 0.75,
                max: 1.5,
                divisions: 15,
                label: '100%',
                onChanged: (value) {},
              ),
            ),
          ],
        ),
      ],
    );
  }

  Widget _buildViewSettings(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        DropdownButtonFormField<String>(
          decoration: const InputDecoration(
            labelText: '榛樿瑙嗗浘妯″紡',
            border: OutlineInputBorder(),
          ),
          items: const [
            DropdownMenuItem(value: 'grid', child: Text('缃戞牸瑙嗗浘')),
            DropdownMenuItem(value: 'list', child: Text('鍒楄〃瑙嗗浘')),
          ],
          onChanged: (value) {},
        ),
        const SizedBox(height: 16),
        DropdownButtonFormField<int>(
          decoration: const InputDecoration(
            labelText: '缂╃暐鍥惧昂瀵?,
            border: OutlineInputBorder(),
          ),
          items: const [
            DropdownMenuItem(value: 100, child: Text('灏?(100px)')),
            DropdownMenuItem(value: 150, child: Text('涓?(150px)')),
            DropdownMenuItem(value: 200, child: Text('澶?(200px)')),
          ],
          onChanged: (value) {},
        ),
      ],
    );
  }

  Widget _buildLanguageSettings(BuildContext context) {
    return DropdownButtonFormField<String>(
      decoration: const InputDecoration(
        labelText: '鐣岄潰璇█',
        border: OutlineInputBorder(),
      ),
      items: const [
        DropdownMenuItem(value: 'system', child: Text('璺熼殢绯荤粺')),
        DropdownMenuItem(value: 'zh_CN', child: Text('绠€浣撲腑鏂?)),
        DropdownMenuItem(value: 'en_US', child: Text('English')),
      ],
      onChanged: (value) {},
    );
  }

  Widget _buildUpdateSettings(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        SwitchListTile(
          title: const Text('鑷姩妫€鏌ユ洿鏂?),
          value: true,
          onChanged: (value) {},
        ),
        const SizedBox(height: 8),
        DropdownButtonFormField<String>(
          decoration: const InputDecoration(
            labelText: '鏇存柊鎻愰啋鏂瑰紡',
            border: OutlineInputBorder(),
          ),
          items: const [
            DropdownMenuItem(value: 'immediate', child: Text('绔嬪嵆鎻愰啋')),
            DropdownMenuItem(value: 'daily', child: Text('姣忓ぉ鎻愰啋涓€娆?)),
            DropdownMenuItem(value: 'weekly', child: Text('姣忓懆鎻愰啋涓€娆?)),
          ],
          onChanged: (value) {},
        ),
      ],
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\pages\settings\panels\storage_settings_panel.dart
-----------------------------------
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

class StorageSettingsPanel extends ConsumerWidget {
  const StorageSettingsPanel({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return SingleChildScrollView(
      padding: const EdgeInsets.all(24),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          _buildStoragePathSettings(context),
          const Divider(height: 32),
          _buildStorageManagement(context),
          const Divider(height: 32),
          _buildBackupSettings(context),
        ],
      ),
    );
  }

  Widget _buildStoragePathSettings(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        const Text('瀛樺偍璺緞璁剧疆', style: TextStyle(fontSize: 20, fontWeight: FontWeight.bold)),
        const SizedBox(height: 16),
        _buildPathSelector(
          context,
          label: '榛樿瀛樺偍浣嶇疆',
          value: 'C:/Users/Documents/Demo/Storage',
          onSelectPath: () async {
            // TODO: 瀹炵幇璺緞閫夋嫨
          },
        ),
        const SizedBox(height: 16),
        _buildPathSelector(
          context,
          label: '涓存椂鏂囦欢浣嶇疆',
          value: 'C:/Users/AppData/Local/Demo/Temp',
          onSelectPath: () async {
            // TODO: 瀹炵幇璺緞閫夋嫨
          },
        ),
        const SizedBox(height: 16),
        _buildPathSelector(
          context,
          label: '瀵煎嚭鏂囦欢榛樿浣嶇疆',
          value: 'C:/Users/Documents/Demo/Exports',
          onSelectPath: () async {
            // TODO: 瀹炵幇璺緞閫夋嫨
          },
        ),
      ],
    );
  }

  Widget _buildStorageManagement(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        const Text('瀛樺偍绠＄悊', style: TextStyle(fontSize: 20, fontWeight: FontWeight.bold)),
        const SizedBox(height: 16),
        // 瀛樺偍绌洪棿浣跨敤缁熻
        Card(
          child: Padding(
            padding: const EdgeInsets.all(16),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                const Text('瀛樺偍绌洪棿浣跨敤缁熻', style: TextStyle(fontSize: 16, fontWeight: FontWeight.bold)),
                const SizedBox(height: 16),
                _buildStorageUsageRow('浣滃搧鏂囦欢', '1.2 GB'),
                _buildStorageUsageRow('涓存椂鏂囦欢', '156 MB'),
                _buildStorageUsageRow('缂撳瓨鏂囦欢', '328 MB'),
                const SizedBox(height: 16),
                Row(
                  mainAxisAlignment: MainAxisAlignment.end,
                  children: [
                    TextButton(
                      onPressed: () {
                        // TODO: 瀹炵幇娓呯悊涓存椂鏂囦欢
                      },
                      child: const Text('娓呯悊涓存椂鏂囦欢'),
                    ),
                    const SizedBox(width: 8),
                    TextButton(
                      onPressed: () {
                        // TODO: 瀹炵幇娓呯悊缂撳瓨
                      },
                      child: const Text('娓呯悊缂撳瓨'),
                    ),
                    const SizedBox(width: 8),
                    ElevatedButton(
                      onPressed: () {
                        // TODO: 瀹炵幇涓€閿竻鐞?
                      },
                      child: const Text('涓€閿竻鐞?),
                    ),
                  ],
                ),
              ],
            ),
          ),
        ),
        const SizedBox(height: 16),
        // 鑷姩娓呯悊璁剧疆
        Card(
          child: Padding(
            padding: const EdgeInsets.all(16),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                const Text('鑷姩娓呯悊璁剧疆', style: TextStyle(fontSize: 16, fontWeight: FontWeight.bold)),
                const SizedBox(height: 16),
                DropdownButtonFormField<String>(
                  decoration: const InputDecoration(
                    labelText: '瀹氭湡娓呯悊涓存椂鏂囦欢',
                    border: OutlineInputBorder(),
                  ),
                  value: 'week',
                  items: const [
                    DropdownMenuItem(value: 'week', child: Text('姣忓懆')),
                    DropdownMenuItem(value: 'month', child: Text('姣忔湀')),
                    DropdownMenuItem(value: 'quarter', child: Text('姣忓搴?)),
                    DropdownMenuItem(value: 'never', child: Text('浠庝笉')),
                  ],
                  onChanged: (value) {},
                ),
                const SizedBox(height: 16),
                DropdownButtonFormField<int>(
                  decoration: const InputDecoration(
                    labelText: '缂撳瓨鏂囦欢澶у皬闄愬埗',
                    border: OutlineInputBorder(),
                  ),
                  value: 1024,
                  items: const [
                    DropdownMenuItem(value: 1024, child: Text('1 GB')),
                    DropdownMenuItem(value: 5120, child: Text('5 GB')),
                    DropdownMenuItem(value: 10240, child: Text('10 GB')),
                    DropdownMenuItem(value: -1, child: Text('涓嶉檺鍒?)),
                  ],
                  onChanged: (value) {},
                ),
              ],
            ),
          ),
        ),
      ],
    );
  }

  Widget _buildBackupSettings(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        const Text('澶囦唤璁剧疆', style: TextStyle(fontSize: 20, fontWeight: FontWeight.bold)),
        const SizedBox(height: 16),
        Card(
          child: Padding(
            padding: const EdgeInsets.all(16),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                SwitchListTile(
                  title: const Text('鍚敤鑷姩澶囦唤'),
                  value: true,
                  onChanged: (value) {},
                ),
                const SizedBox(height: 16),
                DropdownButtonFormField<String>(
                  decoration: const InputDecoration(
                    labelText: '澶囦唤鍛ㄦ湡',
                    border: OutlineInputBorder(),
                  ),
                  value: 'daily',
                  items: const [
                    DropdownMenuItem(value: 'daily', child: Text('姣忓ぉ')),
                    DropdownMenuItem(value: 'weekly', child: Text('姣忓懆')),
                    DropdownMenuItem(value: 'monthly', child: Text('姣忔湀')),
                  ],
                  onChanged: (value) {},
                ),
                const SizedBox(height: 16),
                DropdownButtonFormField<int>(
                  decoration: const InputDecoration(
                    labelText: '淇濈暀澶囦唤鏁伴噺',
                    border: OutlineInputBorder(),
                  ),
                  value: 5,
                  items: const [
                    DropdownMenuItem(value: 3, child: Text('淇濈暀3涓?)),
                    DropdownMenuItem(value: 5, child: Text('淇濈暀5涓?)),
                    DropdownMenuItem(value: 10, child: Text('淇濈暀10涓?)),
                  ],
                  onChanged: (value) {},
                ),
                const SizedBox(height: 16),
                _buildPathSelector(
                  context,
                  label: '鏈湴澶囦唤璺緞',
                  value: 'C:/Users/Documents/Demo/Backups',
                  onSelectPath: () async {
                    // TODO: 瀹炵幇璺緞閫夋嫨
                  },
                ),
                const SizedBox(height: 16),
                SwitchListTile(
                  title: const Text('鍚敤浜戠澶囦唤'),
                  subtitle: const Text('闇€瑕佺櫥褰曡处鍙?),
                  value: false,
                  onChanged: (value) {},
                ),
              ],
            ),
          ),
        ),
      ],
    );
  }

  Widget _buildPathSelector(
    BuildContext context, {
    required String label,
    required String value,
    required VoidCallback onSelectPath,
  }) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(label),
        const SizedBox(height: 8),
        Row(
          children: [
            Expanded(
              child: Container(
                padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
                decoration: BoxDecoration(
                  border: Border.all(color: Colors.grey[400]!),
                  borderRadius: BorderRadius.circular(4),
                ),
                child: Text(value, style: const TextStyle(fontFamily: 'monospace')),
              ),
            ),
            const SizedBox(width: 8),
            ElevatedButton(
              onPressed: onSelectPath,
              child: const Text('閫夋嫨'),
            ),
          ],
        ),
      ],
    );
  }

  Widget _buildStorageUsageRow(String label, String value) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 4),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.spaceBetween,
        children: [
          Text(label),
          Text(value),
        ],
      ),
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\pages\works\character_collection_page.dart
-----------------------------------
import 'dart:math' as Math;
import 'dart:typed_data';

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../application/providers/service_providers.dart';
import '../../../infrastructure/logging/logger.dart';
import '../../providers/character/character_collection_provider.dart';
import '../../providers/character/work_image_provider.dart';
import '../../widgets/character_collection/image_preview_panel.dart';
import '../../widgets/character_collection/navigation_bar.dart';
import '../../widgets/character_collection/right_panel.dart';

class CharacterCollectionPage extends ConsumerStatefulWidget {
  final String workId;
  final String initialPageId;

  const CharacterCollectionPage({
    Key? key,
    required this.workId,
    required this.initialPageId,
  }) : super(key: key);

  @override
  ConsumerState<CharacterCollectionPage> createState() =>
      _CharacterCollectionPageState();
}

// 鍔犺浇瑕嗙洊灞傜粍浠?(宸插瓨鍦ㄤ絾涓哄畬鏁存€ф坊鍔?
class LoadingOverlay extends StatelessWidget {
  const LoadingOverlay({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Container(
      color: Colors.black.withOpacity(0.5),
      child: const Center(
        child: Card(
          child: Padding(
            padding: EdgeInsets.symmetric(horizontal: 24, vertical: 16),
            child: Row(
              mainAxisSize: MainAxisSize.min,
              children: [
                CircularProgressIndicator(),
                SizedBox(width: 16),
                Text('澶勭悊涓?..', style: TextStyle(fontSize: 16)),
              ],
            ),
          ),
        ),
      ),
    );
  }
}

class _CharacterCollectionPageState
    extends ConsumerState<CharacterCollectionPage> {
  bool _isImageValid = false;
  String? _imageError;

  @override
  Widget build(BuildContext context) {
    final collectionState = ref.watch(characterCollectionProvider);
    final imageState = ref.watch(workImageProvider);

    return PopScope(
      canPop: false,
      onPopInvoked: (bool didPop) async {
        if (didPop) return;
        final canPop = await _onWillPop();
        if (canPop) {
          if (context.mounted) {
            Navigator.of(context).pop();
          }
        }
      },
      child: Scaffold(
        body: Column(
          children: [
            // 瀵艰埅鏍?            CharacterNavigationBar(
              workId: widget.workId,
              onBack: () => _onBackPressed(),
            ),

            // 涓讳綋鍐呭
            Expanded(
              child: Stack(
                children: [
                  if (_isImageValid)
                    Row(
                      children: [
                        // 宸︿晶鍥剧墖棰勮鍖?                        const Expanded(
                          flex: 6,
                          child: ImagePreviewPanel(),
                        ),

                        // 鍙充晶闈㈡澘
                        Expanded(
                          flex: 4,
                          child: RightPanel(workId: widget.workId),
                        ),
                      ],
                    )
                  else
                    _buildImageErrorState(),

                  // 浣跨敤Stack鏄剧ず鍔犺浇瑕嗙洊灞傚拰閿欒娑堟伅
                  if (collectionState.loading ||
                      collectionState.processing ||
                      imageState.loading)
                    const Positioned.fill(child: LoadingOverlay()),

                  // 閿欒鎻愮ず
                  if (collectionState.error != null)
                    Positioned(
                      left: 0,
                      right: 0,
                      bottom: 20,
                      child: _buildErrorMessage(collectionState.error!),
                    ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }

  @override
  void initState() {
    super.initState();

    // 鍔犺浇鍒濆鏁版嵁褰撻〉闈㈤娆″垱寤烘椂
    WidgetsBinding.instance.addPostFrameCallback((_) {
      _loadInitialData();
    });
  }

  // 鏋勫缓閿欒娑堟伅鏄剧ず
  Widget _buildErrorMessage(String error) {
    return Center(
      child: Container(
        padding: const EdgeInsets.symmetric(
          horizontal: 16,
          vertical: 8,
        ),
        decoration: BoxDecoration(
          color: Colors.red.shade800,
          borderRadius: BorderRadius.circular(8),
        ),
        child: Text(
          '閿欒: $error',
          style: const TextStyle(color: Colors.white),
        ),
      ),
    );
  }

  // 鏄剧ず鍥惧儚鍔犺浇閿欒鐘舵€?  Widget _buildImageErrorState() {
    return Center(
      child: Container(
        padding: const EdgeInsets.all(24),
        decoration: BoxDecoration(
          color: Colors.grey.shade100,
          borderRadius: BorderRadius.circular(8),
        ),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Icon(Icons.broken_image, size: 64, color: Colors.grey.shade600),
            const SizedBox(height: 16),
            Text(
              '鏃犳硶鍔犺浇鍥惧儚',
              style: TextStyle(
                fontSize: 18,
                fontWeight: FontWeight.bold,
                color: Colors.grey.shade800,
              ),
            ),
            const SizedBox(height: 8),
            Text(
              _imageError ?? '鍥惧儚鏁版嵁鏃犳晥鎴栧凡鎹熷潖',
              style: TextStyle(color: Colors.grey.shade700),
              textAlign: TextAlign.center,
            ),
            const SizedBox(height: 24),
            ElevatedButton.icon(
              icon: const Icon(Icons.refresh),
              label: const Text('閲嶈瘯'),
              onPressed: _loadInitialData,
            ),
            const SizedBox(height: 8),
            TextButton(
              onPressed: () => Navigator.of(context).pop(),
              child: const Text('杩斿洖浣滃搧璇︽儏'),
            ),
          ],
        ),
      ),
    );
  }

  // 妫€鏌ユ槸鍚︽湁鏈繚瀛樼殑淇敼锛屾樉绀虹‘璁ゅ璇濇
  Future<bool> _checkUnsavedChanges() async {
    final state = ref.read(characterCollectionProvider);
    final notifier = ref.read(characterCollectionProvider.notifier);

    AppLogger.debug('妫€鏌ユ湭淇濆瓨淇敼鐘舵€?, data: {
      'hasUnsavedChanges': state.hasUnsavedChanges,
      'modifiedIds': state.modifiedIds.toList(),
      'regionCount': state.regions.length,
      'savedRegionCount': state.regions.where((r) => r.isSaved).length,
      'currentId': state.currentId,
      'isAdjusting': state.isAdjusting,
    });

    // // 濡傛灉褰撳墠姝ｅ湪璋冩暣鎴栬€呮湁閫変腑鐨勫尯鍩燂紝闇€瑕佸厛瀹屾垚璋冩暣
    // if (state.isAdjusting || state.currentId != null) {
    //   notifier.finishCurrentAdjustment();
    //   // 璇诲彇鏇存柊鍚庣殑鐘舵€?    //   final updatedState = ref.read(characterCollectionProvider);

    //   AppLogger.debug('瀹屾垚璋冩暣鍚庣殑鐘舵€?, data: {
    //     'hasUnsavedChanges': updatedState.hasUnsavedChanges,
    //     'modifiedIds': updatedState.modifiedIds.toList(),
    //     'isAdjusting': updatedState.isAdjusting,
    //     'currentId': updatedState.currentId,
    //   });
    // }

    // // 鑾峰彇鏈€鏂扮姸鎬?    // final finalState = ref.read(characterCollectionProvider);

    // // 鍙湁褰搈odifiedIds涓嶄负绌烘椂鎵嶈涓烘湁鏈繚瀛樼殑淇敼
    // final bool reallyHasUnsavedChanges = finalState.modifiedIds.isNotEmpty;

    // // 妫€鏌ユ槸鍚︽湁鏈繚瀛樼殑淇敼
    // if (reallyHasUnsavedChanges) {
    if (state.hasUnsavedChanges) {
      // 鏄剧ず纭瀵硅瘽妗?      final result = await showDialog<bool>(
        context: context,
        barrierDismissible: false,
        builder: (context) => AlertDialog(
          title: const Text('鏈繚瀛樼殑淇敼'),
          content: const Text('鎮ㄦ湁鏈繚瀛樼殑鍖哄煙淇敼锛岀寮€灏嗕涪澶辫繖浜涗慨鏀广€俓n\n鏄惁纭畾绂诲紑锛?),
          actions: [
            TextButton(
              onPressed: () => Navigator.of(context).pop(false), // 鍙栨秷
              child: const Text('鍙栨秷'),
            ),
            TextButton(
              onPressed: () {
                // 鐢ㄦ埛纭绂诲紑锛屾竻闄ゆ墍鏈変慨鏀规爣璁?                if (state.modifiedIds.isNotEmpty) {
                  final notifier =
                      ref.read(characterCollectionProvider.notifier);
                  for (final id in List.from(state.modifiedIds)) {
                    notifier.markAsSaved(id);
                    AppLogger.debug('寮哄埗鏍囪鍖哄煙涓哄凡淇濆瓨', data: {'regionId': id});
                  }
                }
                Navigator.of(context).pop(true); // 纭绂诲紑
              },
              style: TextButton.styleFrom(foregroundColor: Colors.red),
              child: const Text('绂诲紑'),
            ),
          ],
        ),
      );

      return result ?? false;
    }

    // 娌℃湁鏈繚瀛樼殑淇敼锛屽彲浠ョ洿鎺ョ寮€
    return true;
  }

  // 鍔犺浇瀛楃鏁版嵁
  Future<void> _loadCharacterData() async {
    try {
      await ref.read(characterCollectionProvider.notifier).loadWorkData(
            widget.workId,
            pageId: widget.initialPageId,
          );
    } catch (e) {
      AppLogger.error('鍔犺浇瀛楃鏁版嵁澶辫触',
          tag: 'CharacterCollectionPage',
          error: e,
          data: {'workId': widget.workId, 'pageId': widget.initialPageId});
    }
  }

  // 鍔犺浇鍒濆鏁版嵁
  Future<void> _loadInitialData() async {
    setState(() {
      _isImageValid = false;
      _imageError = null;
    });

    try {
      await _loadWorkImage();

      if (_isImageValid) {
        await _loadCharacterData();
      }
    } catch (e) {
      AppLogger.error('鍔犺浇鍒濆鏁版嵁澶辫触',
          tag: 'CharacterCollectionPage',
          error: e,
          data: {'workId': widget.workId, 'pageId': widget.initialPageId});
    }
  }

  // 鍔犺浇浣滃搧鍥惧儚
  Future<void> _loadWorkImage() async {
    try {
      final imageProvider = ref.read(workImageProvider.notifier);
      final imageService = ref.read(workImageServiceProvider);

      // 鍏堝皾璇曡幏鍙栧浘鍍忔暟鎹?      final imageBytes = await imageService.getWorkPageImage(
          widget.workId, widget.initialPageId);

      if (imageBytes == null || imageBytes.isEmpty) {
        setState(() {
          _isImageValid = false;
          _imageError = '鎵句笉鍒板浘鍍忔暟鎹?;
        });
        return;
      }

      // 楠岃瘉鍥惧儚鏁版嵁鏄惁鏈夋晥
      try {
        // 鍔犺浇鍥惧儚鍓嶈繘琛岄獙璇?        bool isValid = await _validateImageData(imageBytes);

        if (!isValid) {
          setState(() {
            _isImageValid = false;
            _imageError = '鍥惧儚鏁版嵁鏃犳晥鎴栧凡鎹熷潖';
          });
          return;
        }

        // 濡傛灉鍥惧儚鏈夋晥锛屽姞杞藉埌鐘舵€佷腑
        await imageProvider.loadWorkImage(
          widget.workId,
          widget.initialPageId,
        );

        // 鏇存柊瀛楃鎻愬彇鐘舵€?        ref
            .read(characterCollectionProvider.notifier)
            .setCurrentPageImage(imageBytes);

        setState(() {
          _isImageValid = true;
          _imageError = null;
        });
      } catch (e) {
        AppLogger.error('鍥惧儚楠岃瘉澶辫触',
            tag: 'CharacterCollectionPage',
            error: e,
            data: {
              'workId': widget.workId,
              'pageId': widget.initialPageId,
              'imageLength': imageBytes.length
            });

        setState(() {
          _isImageValid = false;
          _imageError = '鍥惧儚鏁版嵁楠岃瘉澶辫触: ${e.toString()}';
        });
      }
    } catch (e) {
      AppLogger.error('鍔犺浇浣滃搧鍥惧儚澶辫触',
          tag: 'CharacterCollectionPage',
          error: e,
          data: {'workId': widget.workId, 'pageId': widget.initialPageId});

      setState(() {
        _isImageValid = false;
        _imageError = '鍔犺浇鍥惧儚澶辫触: ${e.toString()}';
      });
    }
  }

  // 澶勭悊杩斿洖鎸夐挳鐐瑰嚮
  void _onBackPressed() {
    _checkUnsavedChanges().then((canPop) {
      if (canPop) {
        Navigator.of(context).pop();
      }
    });
  }

  // 妫€鏌ユ湭淇濆瓨鐨勪慨鏀?  Future<bool> _onWillPop() async {
    return await _checkUnsavedChanges();
  }

  // 楠岃瘉鍥惧儚鏁版嵁鏄惁鏈夋晥
  Future<bool> _validateImageData(Uint8List imageData) async {
    if (imageData.length < 100) {
      // 鍥惧儚澶皬锛屽彲鑳芥槸鏃犳晥鏁版嵁
      return false;
    }

    try {
      // 妫€鏌ュ浘鍍忓ご淇℃伅鏄惁绗﹀悎甯歌鍥惧儚鏍煎紡
      final header = imageData.sublist(0, Math.min(12, imageData.length));

      // 妫€鏌NG澶翠俊鎭?      if (header.length >= 8 &&
          header[0] == 0x89 &&
          header[1] == 0x50 &&
          header[2] == 0x4E &&
          header[3] == 0x47) {
        return true;
      }

      // 妫€鏌PEG澶翠俊鎭?      if (header.length >= 3 &&
          header[0] == 0xFF &&
          header[1] == 0xD8 &&
          header[2] == 0xFF) {
        return true;
      }

      // 杩欓噷鍙互娣诲姞鍏朵粬鍥惧儚鏍煎紡妫€鏌?
      // 濡傛灉娌℃湁绗﹀悎浠讳綍宸茬煡鏍煎紡锛屽皾璇曚娇鐢ㄥ浘鍍忔湇鍔￠獙璇?      final imageProcessor = ref.read(imageProcessorProvider);
      return imageProcessor.validateImageData(imageData);
    } catch (e) {
      AppLogger.error('楠岃瘉鍥惧儚鏁版嵁鏃跺嚭閿?, tag: 'CharacterCollectionPage', error: e);
      return false;
    }
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\pages\works\work_browse_page.dart
-----------------------------------
import 'dart:async';

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../infrastructure/logging/logger.dart';
import '../../../routes/app_routes.dart';
import '../../dialogs/work_import/work_import_dialog.dart';
import '../../providers/work_browse_provider.dart';
import '../../providers/works_providers.dart';
import '../../viewmodels/states/work_browse_state.dart';
import '../../widgets/common/sidebar_toggle.dart';
import 'components/content/work_grid_view.dart';
import 'components/content/work_list_view.dart';
import 'components/filter/work_filter_panel.dart';
import 'components/work_browse_toolbar.dart';
// 娣诲姞杩欎釜瀵煎叆

class WorkBrowsePage extends ConsumerStatefulWidget {
  const WorkBrowsePage({super.key});

  @override
  ConsumerState<WorkBrowsePage> createState() => _WorkBrowsePageState();
}

class _WorkBrowsePageState extends ConsumerState<WorkBrowsePage>
    with WidgetsBindingObserver {
  @override
  Widget build(BuildContext context) {
    final state = ref.watch(workBrowseProvider);
    final viewModel = ref.read(workBrowseProvider.notifier);
    debugPrint('WorkBrowsePage rebuild - filter: ${state.filter}');

    // 鏀硅繘鍒锋柊鐩戝惉鍣?
    ref.listen(worksNeedsRefreshProvider, (previous, current) async {
      if (current == null) return;

      try {
        AppLogger.debug(
          '鏀跺埌鍒锋柊璇锋眰',
          tag: 'WorkBrowsePage',
          data: {
            'reason': current.reason,
            'priority': current.priority,
            'force': current.force,
          },
        );

        await viewModel.loadWorks(forceRefresh: current.force);
      } catch (e) {
        AppLogger.error('鍒锋柊澶辫触', tag: 'WorkBrowsePage', error: e);
      } finally {
        // 鍒锋柊瀹屾垚鍚庨噸缃姸鎬?
        if (mounted) {
          ref.read(worksNeedsRefreshProvider.notifier).state = null;
        }
      }
    });

    return Scaffold(
      body: Column(
        children: [
          WorkBrowseToolbar(
              viewMode: state.viewMode,
              onViewModeChanged: (mode) => viewModel.setViewMode(mode),
              onImport: () => _showImportDialog(context),
              onSearch: viewModel.setSearchQuery,
              batchMode: state.batchMode,
              onBatchModeChanged: (_) => viewModel.toggleBatchMode(),
              selectedCount: state.selectedWorks.length,
              onDeleteSelected: () => {
                    ref.read(workBrowseProvider.notifier).deleteSelected(),
                    ref.read(worksNeedsRefreshProvider.notifier).state =
                        RefreshInfo.importCompleted()
                  }),
          Expanded(
            child: Row(
              children: [
                Expanded(
                  child: _buildMainContent(),
                ),
                SidebarToggle(
                  isOpen: state.isSidebarOpen,
                  onToggle: () => viewModel.toggleSidebar(),
                ),
                if (state.isSidebarOpen)
                  SizedBox(
                    width: 300,
                    child: WorkFilterPanel(
                      filter: state.filter,
                      onFilterChanged: viewModel.updateFilter,
                    ),
                  ),
              ],
            ),
          ),
        ],
      ),
      floatingActionButton: state.isLoading && state.works.isEmpty
          ? FloatingActionButton(
              onPressed: () {
                _loadWorks(force: true);
              },
              tooltip: '閲嶆柊鍔犺浇',
              child: const Icon(Icons.refresh),
            )
          : null,
    );
  }

  @override
  void didChangeAppLifecycleState(AppLifecycleState state) {
    // 绠€鍖栫敓鍛藉懆鏈熺鐞嗭紝鍙湪搴旂敤鎭㈠鏃跺埛鏂?
    if (state == AppLifecycleState.resumed) {
      try {
        // 搴旂敤鎭㈠鏃惰Е鍙戝埛鏂版爣蹇楋紝鑰岄潪鐩存帴璋冪敤
        ref.read(worksNeedsRefreshProvider.notifier).state =
            RefreshInfo.appResume(); // 浣跨敤宸ュ巶鏂规硶鏇夸唬鐩存帴鏋勯€?
      } catch (e) {
        // 娣诲姞閿欒澶勭悊锛岄槻姝㈡剰澶栧紓甯?
        AppLogger.error('璁剧疆鍒锋柊鏍囧織澶辫触', tag: 'WorkBrowsePage', error: e);
      }
    }
  }

  @override
  void dispose() {
    WidgetsBinding.instance.removeObserver(this);
    super.dispose();
  }

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addObserver(this);

    // 寤惰繜鎵ц鍒濆鍔犺浇锛岀‘淇漺idget瀹屽叏鍒濆鍖?
    Future.microtask(() {
      if (!mounted) return;
      ref.read(worksNeedsRefreshProvider.notifier).state = const RefreshInfo(
        reason: '搴旂敤鍚姩鍒濆鍖?,
        force: true,
        priority: 10,
      );
    });
  }

  Widget _buildMainContent() {
    // 鍦ㄨ繖閲岀洃鍚姸鎬佸彉鍖?
    final state = ref.watch(workBrowseProvider);
    debugPrint(
        '_buildMainContent rebuild - works count: ${state.works.length}');

    // 娣诲姞璇︾粏鏃ュ織锛岃拷韪姸鎬佸彉鍖?
    AppLogger.debug('鏋勫缓娴忚椤典富浣撳唴瀹?, tag: 'WorkBrowsePage', data: {
      'isLoading': state.isLoading,
      'hasError': state.error != null,
      'worksCount': state.works.length
    });

    // 澶勭悊閿欒鐘舵€?
    if (state.error != null) {
      return Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Icon(Icons.error_outline,
                size: 48, color: Theme.of(context).colorScheme.error),
            const SizedBox(height: 16),
            Text('鍙戠敓閿欒: ${state.error}',
                style: TextStyle(color: Theme.of(context).colorScheme.error)),
            const SizedBox(height: 24),
            ElevatedButton(
              onPressed: () => _loadWorks(force: true),
              child: const Text('閲嶆柊鍔犺浇'),
            ),
          ],
        ),
      );
    }

    return Column(
      children: [
        Expanded(
          child: state.isLoading
              ? const Center(child: CircularProgressIndicator())
              : state.works.isEmpty
                  ? Center(
                      child: Column(
                        mainAxisAlignment: MainAxisAlignment.center,
                        children: [
                          const Icon(Icons.inbox, size: 64, color: Colors.grey),
                          const SizedBox(height: 16),
                          const Text('娌℃湁鎵惧埌浣滃搧', style: TextStyle(fontSize: 18)),
                          const SizedBox(height: 8),
                          const Text('灏濊瘯瀵煎叆鏂颁綔鍝佹垨淇敼绛涢€夋潯浠?,
                              style: TextStyle(color: Colors.grey)),
                          const SizedBox(height: 24),
                          ElevatedButton(
                            onPressed: () => _showImportDialog(context),
                            child: const Text('瀵煎叆浣滃搧'),
                          ),
                        ],
                      ),
                    )
                  : state.viewMode == ViewMode.grid
                      ? WorkGridView(
                          works: state.works,
                          batchMode: state.batchMode,
                          selectedWorks: state.selectedWorks,
                          onSelectionChanged: (workId, selected) => ref
                              .read(workBrowseProvider.notifier)
                              .toggleSelection(workId),
                          onItemTap: (workId) =>
                              _handleWorkSelected(context, workId),
                        )
                      : WorkListView(
                          works: state.works,
                          batchMode: state.batchMode,
                          selectedWorks: state.selectedWorks,
                          onSelectionChanged: (workId, selected) => ref
                              .read(workBrowseProvider.notifier)
                              .toggleSelection(workId),
                          onItemTap: (workId) =>
                              _handleWorkSelected(context, workId),
                        ),
        ),
      ],
    );
  }

  void _handleWorkSelected(BuildContext context, String workId) async {
    // 瀵艰埅鍒拌鎯呴〉骞剁瓑寰呯粨鏋?
    await Navigator.pushNamed(
      context,
      AppRoutes.workDetail,
      arguments: workId,
    );
  }

  // 澧炲己閿欒澶勭悊鐨勫姞杞芥柟娉?
  Future<void> _loadWorks({bool force = false}) async {
    try {
      if (!mounted) return;

      AppLogger.debug('鍑洪敊鍚庣敤鎴锋墜鍔ㄨЕ鍙戜綔鍝佸姞杞?,
          tag: 'WorkBrowsePage', data: {'force': force});

      const refreshInfo = RefreshInfo(
        reason: '鍑洪敊鍚庣敤鎴锋墜鍔ㄥ埛鏂?,
        force: true,
        priority: 10, // 楂樹紭鍏堢骇
      );

      if (!mounted) return;
      ref.read(worksNeedsRefreshProvider.notifier).state = refreshInfo;
    } catch (e) {
      AppLogger.error('鍔犺浇浣滃搧澶辫触', tag: 'WorkBrowsePage', error: e);

      if (mounted) {
        final scaffoldMessenger = ScaffoldMessenger.of(context);
        // 鍏堢Щ闄ゆ墍鏈夊凡鏈夌殑SnackBar
        scaffoldMessenger.clearSnackBars();
        // 鏄剧ず鏂扮殑閿欒鎻愮ず
        scaffoldMessenger.showSnackBar(
          SnackBar(content: Text('鍔犺浇澶辫触: $e')),
        );
      }
    }
  }

  // 绠€鍖栦负涓€涓粺涓€鐨勫鍏ュ璇濇鏂规硶
  Future<void> _showImportDialog(BuildContext context) async {
    final result = await showDialog<bool>(
      context: context,
      barrierDismissible: false,
      builder: (context) => const WorkImportDialog(),
    );

    if (result == true) {
      AppLogger.debug('瀵煎叆瀹屾垚锛屽噯澶囧埛鏂板垪琛?, tag: 'WorkBrowsePage');
      if (!mounted) return;

      ref.read(worksNeedsRefreshProvider.notifier).state = const RefreshInfo(
        reason: '瀵煎叆瀹屾垚鍚庡埛鏂?,
        force: true,
        priority: 9,
      );
    }
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\pages\works\work_detail_page.dart
-----------------------------------
import 'dart:async';

import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../application/providers/service_providers.dart';
import '../../../domain/models/work/work_entity.dart';
import '../../../infrastructure/logging/logger.dart';
import '../../../theme/app_sizes.dart';
import '../../providers/work_detail_provider.dart';
import '../../providers/work_image_editor_provider.dart';
import '../../providers/works_providers.dart';
import '../../widgets/common/error_display.dart';
import '../../widgets/common/loading_indicator.dart';
import '../../widgets/common/sidebar_toggle.dart';
import '../../widgets/page_layout.dart';
import './character_collection_page.dart';
import 'components/unified_work_detail_panel.dart';
import 'components/view_mode_image_preview.dart';
import 'components/work_images_management_view.dart';

class WorkDetailPage extends ConsumerStatefulWidget {
  final String workId;

  const WorkDetailPage({
    super.key,
    required this.workId,
  });

  @override
  ConsumerState<WorkDetailPage> createState() => _WorkDetailPageState();
}

class _WorkDetailPageState extends ConsumerState<WorkDetailPage>
    with WidgetsBindingObserver {
  bool _isPanelOpen = true;
  bool _hasCheckedStateRestoration = false;

  @override
  Widget build(BuildContext context) {
    final state = ref.watch(workDetailProvider);

    return WillPopScope(
      onWillPop: () async {
        if (state.isEditing) {
          return _handleBackButton();
        }
        return true;
      },
      child: KeyboardListener(
        focusNode: FocusNode(skipTraversal: true),
        onKeyEvent: (keyEvent) => _handleKeyboardShortcuts(keyEvent, state),
        child: PageLayout(
          toolbar: state.isEditing
              ? _buildEditModeToolbar(context, state)
              : _buildViewModeToolbar(context, state),
          body: _buildBody(context, state),
        ),
      ),
    );
  }

  @override
  Future<bool> didPopRoute() async {
    return _handleBackButton();
  }

  @override
  void dispose() {
    WidgetsBinding.instance.removeObserver(this);
    super.dispose();
  }

  @override
  void initState() {
    super.initState();
    WidgetsBinding.instance.addObserver(this);
    WidgetsBinding.instance.addPostFrameCallback((_) {
      _loadWorkDetails();
    });
  }

  Widget _buildBody(BuildContext context, WorkDetailState state) {
    if (state.isLoading) {
      return const Center(
        child: LoadingIndicator(message: '鍔犺浇浣滃搧璇︽儏涓?..'),
      );
    }

    if (state.error != null) {
      AppLogger.error('Work detail error',
          tag: 'WorkDetailPage', error: state.error);
      return Center(
        child: ErrorDisplay(
          error: state.error!,
          onRetry: _loadWorkDetails,
        ),
      );
    }

    final work = state.isEditing ? state.editingWork : state.work;
    if (work == null) {
      return const Center(
        child: Text('浣滃搧涓嶅瓨鍦ㄦ垨宸茶鍒犻櫎'),
      );
    }

    return state.isEditing
        ? _buildEditModeContent(context, state, work)
        : _buildViewModeContent(context, work, state);
  }

  Widget _buildEditModeContent(
      BuildContext context, WorkDetailState state, WorkEntity work) {
    return Row(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        // 宸︿晶鍥剧墖棰勮鍜岀鐞?
        Expanded(
          flex: 7,
          child: Padding(
            padding: const EdgeInsets.all(AppSizes.spacingMedium),
            child: WorkImagesManagementView(
              work: work,
            ),
          ),
        ),

        // 娣诲姞闈㈡澘鍒囨崲鎸夐挳
        SidebarToggle(
          isOpen: _isPanelOpen,
          onToggle: () {
            setState(() {
              _isPanelOpen = !_isPanelOpen;
            });
          },
          alignRight: true,
        ),

        // 鍙充晶闈㈡澘 - 娣诲姞鏉′欢鏄剧ず
        if (_isPanelOpen)
          SizedBox(
            width: 350,
            child: UnifiedWorkDetailPanel(
              key: ValueKey('form_${work.id}'),
              work: work,
              isEditing: true,
            ),
          ),
      ],
    );
  }

  Widget _buildEditModeToolbar(BuildContext context, WorkDetailState state) {
    final theme = Theme.of(context);

    return AnimatedContainer(
      duration: const Duration(milliseconds: 200),
      height: kToolbarHeight + 8,
      decoration: BoxDecoration(
        color: theme.colorScheme.surface.withOpacity(0.98),
        boxShadow: [
          BoxShadow(
            color: theme.shadowColor.withOpacity(0.08),
            blurRadius: 8,
            offset: const Offset(0, 2),
          ),
          BoxShadow(
            color: theme.shadowColor.withOpacity(0.05),
            blurRadius: 2,
            offset: const Offset(0, 1),
          ),
        ],
        border: Border(
          bottom: BorderSide(
            color: theme.dividerColor.withOpacity(0.15),
            width: 1,
          ),
        ),
      ),
      padding: const EdgeInsets.only(
          left: AppSizes.spacingMedium,
          right: AppSizes.spacingMedium,
          top: 4,
          bottom: 4),
      child: Row(
        children: [
          IconButton(
            icon: Icon(Icons.arrow_back, color: theme.colorScheme.onSurface),
            tooltip: '杩斿洖',
            onPressed: () => _cancelEditing(),
            visualDensity: VisualDensity.compact,
          ),

          Expanded(
            child: Row(
              children: [
                Text(
                  '浣滃搧缂栬緫',
                  style: theme.textTheme.titleMedium?.copyWith(
                    fontWeight: FontWeight.w500,
                  ),
                ),
                if (state.work?.title != null) ...[
                  const SizedBox(width: 8),
                  Flexible(
                    child: Text(
                      '- ${state.work!.title}',
                      style: theme.textTheme.titleMedium?.copyWith(
                        fontWeight: FontWeight.normal,
                        color: theme.colorScheme.onSurface.withOpacity(0.7),
                      ),
                      overflow: TextOverflow.ellipsis,
                    ),
                  ),
                ],
              ],
            ),
          ),

          // 娣诲姞鍒嗛殧绾?
          Container(
            height: 24,
            width: 1,
            margin: const EdgeInsets.symmetric(horizontal: 12),
            color: theme.dividerColor.withOpacity(0.2),
          ),

          FilledButton.icon(
            icon: const Icon(Icons.save, size: 18),
            label: const Text('淇濆瓨'),
            onPressed: state.hasChanges && !state.isSaving
                ? () => _saveChanges()
                : null,
            style: FilledButton.styleFrom(
              backgroundColor: theme.colorScheme.primary,
              foregroundColor: theme.colorScheme.onPrimary,
              visualDensity: VisualDensity.compact,
              padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
              elevation: 0,
              textStyle: theme.textTheme.labelLarge?.copyWith(
                fontWeight: FontWeight.w500,
              ),
              shape: RoundedRectangleBorder(
                borderRadius: BorderRadius.circular(8),
              ),
            ),
          ),
          const SizedBox(width: 8),
          OutlinedButton(
            onPressed: () => _cancelEditing(),
            style: OutlinedButton.styleFrom(
              foregroundColor: theme.colorScheme.onSurface.withOpacity(0.8),
              side: BorderSide(
                color: theme.colorScheme.outline.withOpacity(0.5),
                width: 1,
              ),
              visualDensity: VisualDensity.compact,
              padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
              shape: RoundedRectangleBorder(
                borderRadius: BorderRadius.circular(8),
              ),
            ),
            child: const Text('鍙栨秷'),
          ),
        ],
      ),
    );
  }

  Widget _buildViewModeContent(
      BuildContext context, WorkEntity work, WorkDetailState state) {
    return Row(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Expanded(
          flex: 7,
          child: Padding(
            padding: const EdgeInsets.all(AppSizes.spacingMedium),
            child: ViewModeImagePreview(
              images: work.images,
              selectedIndex: state.selectedImageIndex,
              onImageSelect: (index) =>
                  ref.read(workDetailProvider.notifier).selectImage(index),
            ),
          ),
        ),
        SidebarToggle(
          isOpen: _isPanelOpen,
          onToggle: () {
            setState(() {
              _isPanelOpen = !_isPanelOpen;
            });
          },
          alignRight: true,
        ),
        if (_isPanelOpen)
          SizedBox(
            width: 350,
            child: UnifiedWorkDetailPanel(
              work: work,
              isEditing: false,
            ),
          ),
      ],
    );
  }

  Widget _buildViewModeToolbar(BuildContext context, WorkDetailState state) {
    final theme = Theme.of(context);
    final work = state.work;

    return AnimatedContainer(
      duration: const Duration(milliseconds: 200),
      height: kToolbarHeight + 8,
      decoration: BoxDecoration(
        color: theme.colorScheme.surface.withOpacity(0.98),
        boxShadow: [
          BoxShadow(
            color: theme.shadowColor.withOpacity(0.08),
            blurRadius: 8,
            offset: const Offset(0, 2),
          ),
          BoxShadow(
            color: theme.shadowColor.withOpacity(0.05),
            blurRadius: 2,
            offset: const Offset(0, 1),
          ),
        ],
        border: Border(
          bottom: BorderSide(
            color: theme.dividerColor.withOpacity(0.15),
            width: 1,
          ),
        ),
      ),
      padding: const EdgeInsets.only(
          left: AppSizes.spacingMedium,
          right: AppSizes.spacingMedium,
          top: 4,
          bottom: 4),
      child: Row(
        children: [
          IconButton(
            icon: Icon(Icons.arrow_back, color: theme.colorScheme.onSurface),
            tooltip: '杩斿洖',
            onPressed: () => _handleBackButton(),
            visualDensity: VisualDensity.compact,
          ),

          Expanded(
            child: Row(
              children: [
                Text(
                  '浣滃搧璇︽儏',
                  style: theme.textTheme.titleMedium?.copyWith(
                    fontWeight: FontWeight.w500,
                  ),
                ),
                if (work != null && work.title.isNotEmpty) ...[
                  const SizedBox(width: 8),
                  Flexible(
                    child: Text(
                      '- ${work.title}',
                      style: theme.textTheme.titleMedium?.copyWith(
                        fontWeight: FontWeight.normal,
                        color: theme.colorScheme.onSurface.withOpacity(0.7),
                      ),
                      overflow: TextOverflow.ellipsis,
                    ),
                  ),
                ],
              ],
            ),
          ),

          // 娣诲姞鍒嗛殧绾?
          Container(
            height: 24,
            width: 1,
            margin: const EdgeInsets.symmetric(horizontal: 12),
            color: theme.dividerColor.withOpacity(0.2),
          ),

          FilledButton.icon(
            onPressed: work != null ? _enterEditMode : null,
            icon: const Icon(Icons.edit, size: 18),
            label: const Text('缂栬緫'),
            style: FilledButton.styleFrom(
              backgroundColor: theme.colorScheme.primary,
              foregroundColor: theme.colorScheme.onPrimary,
              visualDensity: VisualDensity.compact,
              padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
              elevation: 0,
              textStyle: theme.textTheme.labelLarge?.copyWith(
                fontWeight: FontWeight.w500,
              ),
              shape: RoundedRectangleBorder(
                borderRadius: BorderRadius.circular(8),
              ),
            ),
          ),
          const SizedBox(width: 8),
          FilledButton.tonal(
            onPressed: work != null ? () => _navigateToExtract() : null,
            style: FilledButton.styleFrom(
              backgroundColor: theme.colorScheme.secondaryContainer,
              foregroundColor: theme.colorScheme.onSecondaryContainer,
              visualDensity: VisualDensity.compact,
              padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
              elevation: 0,
              side: BorderSide(
                color: theme.colorScheme.outline.withOpacity(0.1),
                width: 1,
              ),
              textStyle: theme.textTheme.labelLarge?.copyWith(
                fontWeight: FontWeight.w500,
              ),
              shape: RoundedRectangleBorder(
                borderRadius: BorderRadius.circular(8),
              ),
            ),
            child: const Text('鎻愬彇瀛楀舰'),
          ),
        ],
      ),
    );
  }

  void _cancelEditing() {
    final hasChanges = ref.read(workDetailProvider).hasChanges;
    if (hasChanges) {
      showDialog(
        context: context,
        builder: (context) => AlertDialog(
          title: const Text('鏀惧純鏇存敼锛?),
          content: const Text('浣犳湁鏈繚瀛樼殑鏇存敼锛岀‘瀹氳鏀惧純鍚楋紵'),
          actions: [
            TextButton(
              onPressed: () => Navigator.of(context).pop(),
              child: const Text('鍙栨秷'),
            ),
            FilledButton(
              onPressed: () {
                Navigator.of(context).pop();
                // Reset the image editor state first
                ref.read(workImageEditorProvider.notifier).reset();
                ref.read(workDetailProvider.notifier).cancelEditing();
              },
              child: const Text('鏀惧純鏇存敼'),
            ),
          ],
        ),
      );
    } else {
      // Reset the image editor state first
      ref.read(workImageEditorProvider.notifier).reset();
      ref.read(workDetailProvider.notifier).cancelEditing();
    }
  }

  Future<void> _checkForUnfinishedEditSession() async {
    if (_hasCheckedStateRestoration) return;
    _hasCheckedStateRestoration = true;

    final stateRestorationService = ref.read(stateRestorationServiceProvider);
    final hasUnfinishedSession =
        await stateRestorationService.hasUnfinishedEditSession(widget.workId);

    if (hasUnfinishedSession && mounted) {
      final shouldRestore = await showDialog<bool>(
            context: context,
            barrierDismissible: false,
            builder: (context) => AlertDialog(
              title: const Text('鎭㈠鏈畬鎴愮殑缂栬緫'),
              content: const Text('妫€娴嬪埌涓婃鏈夋湭淇濆瓨鐨勭紪杈戝唴瀹广€傛槸鍚︽仮澶?'),
              actions: [
                TextButton(
                  onPressed: () => Navigator.of(context).pop(false),
                  child: const Text('鏀惧純'),
                ),
                FilledButton(
                  onPressed: () => Navigator.of(context).pop(true),
                  child: const Text('鎭㈠'),
                ),
              ],
            ),
          ) ??
          false;

      if (shouldRestore && mounted) {
        await ref
            .read(workDetailProvider.notifier)
            .tryRestoreEditState(widget.workId);

        if (ref.read(workDetailProvider).isEditing) {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(content: Text('宸叉仮澶嶄笂娆＄殑缂栬緫鐘舵€?)),
          );
        }
      }
    }
  }

  void _enterEditMode() {
    final detailNotifier = ref.read(workDetailProvider.notifier);
    final work = ref.read(workDetailProvider).work;

    if (work != null) {
      // Log the work images to verify they exist
      AppLogger.debug(
        'Entering edit mode with work',
        tag: 'WorkDetailPage',
        data: {
          'workId': work.id,
          'imageCount': work.images.length,
          'firstImageId': work.images.isNotEmpty ? work.images[0].id : 'none',
        },
      );

      // First enter edit mode to ensure the editingWork is set
      detailNotifier.enterEditMode();

      // Ensure image editor state is properly initialized
      if (work.images.isNotEmpty) {
        // Reset the editor provider state
        ref.read(workImageInitializedProvider.notifier).state = false;
        ref.read(workImageEditorProvider.notifier).reset();

        // Initialize with a microtask to ensure it happens after the current frame
        Future.microtask(() {
          // Verify the providers still exist
          if (!ref.exists(workImageEditorProvider)) return;
          if (!context.mounted) return;

          // Initialize the image editor with work images
          final editorNotifier = ref.read(workImageEditorProvider.notifier);
          editorNotifier.initialize(work.images);

          // Set selected index after initialization
          final selectedIndex = ref.read(workDetailProvider).selectedImageIndex;
          editorNotifier.updateSelectedIndex(selectedIndex);
        });
      } else {
        AppLogger.warning(
          'Entering edit mode with no images',
          tag: 'WorkDetailPage',
          data: {'workId': work.id},
        );
      }
    }
  }

  Future<bool> _handleBackButton() async {
    final state = ref.read(workDetailProvider);
    final hasChanges = state.hasChanges;

    // 濡傛灉鍦ㄧ紪杈戞ā寮忥紝鍏堟鏌ユ槸鍚︽湁鏇存敼
    if (state.isEditing) {
      if (hasChanges) {
        final shouldSave = await showDialog<bool?>(
          context: context,
          builder: (context) => AlertDialog(
            title: const Text('淇濆瓨鏇存敼锛?),
            content: const Text('浣犳湁鏈繚瀛樼殑鏇存敼锛屾槸鍚︿繚瀛橈紵'),
            actions: [
              TextButton(
                onPressed: () => Navigator.of(context).pop(false),
                child: const Text('鏀惧純鏇存敼'),
              ),
              TextButton(
                onPressed: () => Navigator.of(context).pop(null),
                child: const Text('鍙栨秷'),
              ),
              FilledButton(
                onPressed: () => Navigator.of(context).pop(true),
                child: const Text('淇濆瓨'),
              ),
            ],
          ),
        );

        if (shouldSave == null) {
          return false; // 鐢ㄦ埛鐐瑰嚮浜嗗彇娑堬紝涓嶆墽琛屼换浣曟搷浣?
        }

        if (shouldSave) {
          try {
            await _saveChanges();
            // 涓嶉€€鍑洪〉闈紝浠呴€€鍑虹紪杈戞ā寮?
            ref.read(workDetailProvider.notifier).completeEditing();
            return false;
          } catch (e) {
            if (mounted) {
              ScaffoldMessenger.of(context).showSnackBar(
                SnackBar(content: Text('淇濆瓨澶辫触: $e')),
              );
            }
            return false;
          }
        }

        // 鐢ㄦ埛閫夋嫨鏀惧純鏇存敼锛屽彇娑堢紪杈戞ā寮?
        ref.read(workDetailProvider.notifier).cancelEditing();
        return false; // 涓嶉€€鍑洪〉闈?
      } else {
        // 娌℃湁鏇存敼锛岀洿鎺ラ€€鍑虹紪杈戞ā寮?
        ref.read(workDetailProvider.notifier).cancelEditing();
        return false; // 涓嶉€€鍑洪〉闈?
      }
    }

    // 鍦ㄦ煡鐪嬫ā寮忎笅锛屾甯搁€€鍑洪〉闈?
    if (mounted) {
      Navigator.of(context).pop();
    }
    return true;
  }

  void _handleKeyboardShortcuts(KeyEvent event, WorkDetailState state) {
    if (state.isEditing) {
      final isCtrlPressed = HardwareKeyboard.instance.isControlPressed ||
          HardwareKeyboard.instance.isMetaPressed;

      if (isCtrlPressed) {
        if (event.logicalKey.keyLabel == 's' ||
            event.logicalKey.keyLabel == 'S') {
          _handleSave(state);
        }
      }
    }
  }

  void _handleSave(WorkDetailState state) {
    if (!state.hasChanges || state.isSaving) return;
    _saveChanges();
  }

  Future<void> _loadWorkDetails() async {
    await ref.read(workDetailProvider.notifier).loadWorkDetails(widget.workId);

    // Verify all work images exist
    final work = ref.read(workDetailProvider).work;
    if (work != null) {
      final storageService = ref.read(workStorageProvider);
      await storageService.verifyWorkImages(widget.workId);
    }

    _checkForUnfinishedEditSession();
  }

  void _navigateToExtract() {
    final work = ref.read(workDetailProvider).work;
    if (work != null) {
      // Check if there are images available
      if (work.images.isNotEmpty) {
        try {
          final initialPageId = work.firstImageId ?? work.images.first.id;

          // Log navigation attempt
          AppLogger.debug(
            'Navigating to character extraction',
            tag: 'WorkDetailPage',
            data: {
              'workId': work.id,
              'initialPageId': initialPageId,
            },
          );

          // Verify image before navigation
          final storageService = ref.read(workStorageProvider);
          storageService
              .verifyWorkImageExists(
                  storageService.getImportedPath(work.id, initialPageId))
              .then((exists) {
            if (!exists && mounted) {
              ScaffoldMessenger.of(context).showSnackBar(
                const SnackBar(content: Text('閫夋嫨鐨勫浘鐗囨棤娉曞姞杞斤紝璇峰皾璇曢噸鏂板鍏ュ浘鐗?)),
              );
              return;
            }

            if (mounted) {
              Navigator.of(context).push(
                MaterialPageRoute(
                  builder: (context) => CharacterCollectionPage(
                    workId: work.id,
                    initialPageId: initialPageId,
                  ),
                ),
              );
            }
          });
        } catch (e, stack) {
          AppLogger.error(
            '瀵艰埅鍒板瓧褰㈡彁鍙栭〉闈㈠嚭閿?,
            tag: 'WorkDetailPage',
            error: e,
            stackTrace: stack,
          );

          if (mounted) {
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(content: Text('鏃犳硶鎵撳紑瀛楀舰鎻愬彇: ${e.toString()}')),
            );
          }
        }
      } else {
        // Handle case where there are no images
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('鏃犳硶鎻愬彇瀛楀舰锛氫綔鍝佹病鏈夊浘鐗?)),
        );
      }
    }
  }

  Future<void> _saveChanges() async {
    final editingWork = ref.read(workDetailProvider).editingWork;

    // 纭繚褰撳墠缂栬緫鐘舵€佺殑瀹屾暣鍓湰
    AppLogger.debug('淇濆瓨鍓嶇殑瀹屾暣浣滃搧鐘舵€?, tag: 'WorkDetailPage', data: {
      'workId': editingWork?.id,
      'title': editingWork?.title,
      'author': editingWork?.author,
      'style': editingWork?.style.value,
      'tool': editingWork?.tool.value,
      'creationDate': editingWork?.creationDate.toString(),
      'remark': editingWork?.remark,
      'tagCount': editingWork?.tags.length,
      'tags': editingWork?.tags,
      'imageCount': editingWork?.images.length,
      'updateTime': editingWork?.updateTime.toString(),
    });

    AppLogger.debug('寮€濮嬩繚瀛樹綔鍝?, tag: 'WorkDetailPage', data: {
      'workId': editingWork?.id,
      'hasImages': editingWork?.images.isNotEmpty ?? false,
      'firstImageId': editingWork?.images.isNotEmpty ?? false
          ? editingWork!.images[0].id
          : 'none',
      'title': editingWork?.title,
      'author': editingWork?.author,
      'tagCount': editingWork?.tags.length,
    });

    if (!context.mounted) return;

    showDialog(
      context: context,
      barrierDismissible: false,
      builder: (context) => WillPopScope(
        onWillPop: () async => false,
        child: const AlertDialog(
          content: Row(
            children: [
              CircularProgressIndicator(),
              SizedBox(width: 16),
              Text('姝ｅ湪淇濆瓨...'),
            ],
          ),
        ),
      ),
    );

    try {
      // Log the state of the editor before saving
      final editorState = ref.read(workImageEditorProvider);
      AppLogger.debug('浣滃搧缂栬緫鍣ㄧ姸鎬?, tag: 'WorkDetailPage', data: {
        'imagesCount': editorState.images.length,
        'hasPendingAdditions': editorState.hasPendingAdditions,
        'deletedImageCount': editorState.deletedImageIds.length,
      });

      // Save images first - this should handle cover generation internally
      final workImageEditorNotifier =
          ref.read(workImageEditorProvider.notifier);
      await workImageEditorNotifier.saveChanges();

      // 鑾峰彇淇濆瓨鍚庣殑鍥剧墖鍒楄〃
      final savedImages = ref.read(workImageEditorProvider).images;

      // 浠呭湪鏈夊浘鐗囨椂澶勭悊灏侀潰
      if (savedImages.isNotEmpty && editingWork != null) {
        final imageService = ref.read(workImageServiceProvider);
        final storageService = ref.read(workStorageProvider);

        // 妫€鏌ュ皝闈㈡槸鍚︿笌褰撳墠棣栧浘鍖归厤
        final coverPath =
            storageService.getWorkCoverImportedPath(editingWork.id);
        final coverExists =
            await storageService.verifyWorkImageExists(coverPath);

        if (!coverExists) {
          AppLogger.info('淇濆瓨鍚庡皝闈笉瀛樺湪锛岄噸鏂扮敓鎴?,
              tag: 'WorkDetailPage', data: {'firstImageId': savedImages[0].id});

          await imageService.updateCover(editingWork.id, savedImages[0].id);
        } else {
          AppLogger.debug('淇濆瓨鍚庡皝闈㈠凡瀛樺湪', tag: 'WorkDetailPage');
        }
      }

      // 淇濆瓨浣滃搧璇︽儏涔嬪墠鍐嶆纭缂栬緫鐘舵€佸畬鏁?
      final currentEditingWork = ref.read(workDetailProvider).editingWork;
      AppLogger.debug('淇濆瓨鍓嶆渶缁堟鏌?, tag: 'WorkDetailPage', data: {
        'workId': currentEditingWork?.id,
        'title': currentEditingWork?.title,
        'tagCount': currentEditingWork?.tags.length,
        'tags': currentEditingWork?.tags,
      });

      // 鐒跺悗淇濆瓨浣滃搧璇︽儏
      final success = await ref.read(workDetailProvider.notifier).saveChanges();

      // 淇濆瓨鍚庣珛鍗宠褰曟渶鏂扮姸鎬?
      final savedWork = ref.read(workDetailProvider).work;
      AppLogger.debug('淇濆瓨鍚庣殑瀹屾暣浣滃搧鐘舵€?, tag: 'WorkDetailPage', data: {
        'workId': savedWork?.id,
        'title': savedWork?.title,
        'author': savedWork?.author,
        'style': savedWork?.style.value,
        'tool': savedWork?.tool.value,
        'creationDate': savedWork?.creationDate.toString(),
        'remark': savedWork?.remark,
        'tagCount': savedWork?.tags.length,
        'tags': savedWork?.tags,
        'imageCount': savedWork?.images.length,
        'updateTime': savedWork?.updateTime.toString(),
        'saveSuccess': success,
      });

      if (!context.mounted) return;

      Navigator.of(context, rootNavigator: true).pop();

      if (success) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('淇濆瓨鎴愬姛')),
        );

        await Future.delayed(const Duration(milliseconds: 300));
        if (!context.mounted) return;

        // 鏍囪浣滃搧鍒楄〃闇€瑕佸埛鏂?
        ref.read(worksNeedsRefreshProvider.notifier).state =
            RefreshInfo.dataChanged();

        // 淇敼杩欓噷 - 涓嶈閲嶆柊鍔犺浇浣滃搧璇︽儏锛屼細瑕嗙洊宸蹭繚瀛樼殑鏇存敼
        // await _loadWorkDetails();

        // 鐩存帴缁撴潫缂栬緫妯″紡锛屼繚鐣欏綋鍓嶇紪杈戠殑鐘舵€?
        ref.read(workDetailProvider.notifier).completeEditing();

        // 寮哄埗鍒锋柊闈㈡澘缁勪欢
        setState(() {});
      } else {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(content: Text('淇濆瓨澶辫触')),
        );
      }
    } catch (e, stack) {
      AppLogger.error(
        '淇濆瓨鍑洪敊',
        tag: 'WorkDetailPage',
        error: e,
        stackTrace: stack,
      );

      if (context.mounted) {
        Navigator.of(context).pop();
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('淇濆瓨鍑洪敊: $e')),
        );
      }
    }
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\pages\works\components\image_error_view.dart
-----------------------------------
import 'package:flutter/material.dart';

/// Widget that displays an error message when image loading fails
class ImageErrorView extends StatelessWidget {
  final String error;
  final VoidCallback onRetry;

  const ImageErrorView({
    super.key,
    required this.error,
    required this.onRetry,
  });

  @override
  Widget build(BuildContext context) {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          const Icon(Icons.error_outline, size: 48, color: Colors.red),
          const SizedBox(height: 16),
          Text(error, textAlign: TextAlign.center),
          const SizedBox(height: 16),
          ElevatedButton(
            onPressed: onRetry,
            child: const Text('閲嶈瘯'),
          ),
        ],
      ),
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\pages\works\components\image_operations_toolbar.dart
-----------------------------------
import 'package:flutter/material.dart';

class ImageOperationsToolbar extends StatelessWidget {
  final VoidCallback? onAddImages;
  final VoidCallback? onDeleteImage;

  const ImageOperationsToolbar({
    super.key,
    this.onAddImages,
    this.onDeleteImage,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Row(
      mainAxisSize: MainAxisSize.min,
      children: [
        // 娣诲姞鍥剧墖鎸夐挳
        Tooltip(
          message: '娣诲姞鍥剧墖',
          preferBelow: false,
          decoration: BoxDecoration(
            color: theme.colorScheme.inverseSurface.withOpacity(0.9),
            borderRadius: BorderRadius.circular(6),
          ),
          child: Container(
            height: 36,
            width: 36,
            decoration: BoxDecoration(
              color: theme.colorScheme.primary,
              borderRadius: BorderRadius.circular(6),
            ),
            child: IconButton(
              onPressed: onAddImages,
              icon: const Icon(Icons.add_photo_alternate, size: 20),
              color: theme.colorScheme.onPrimary,
              padding: EdgeInsets.zero,
            ),
          ),
        ),

        const SizedBox(width: 8),

        // 鍒犻櫎鍥剧墖鎸夐挳
        Tooltip(
          message: '鍒犻櫎鍥剧墖',
          preferBelow: false,
          decoration: BoxDecoration(
            color: theme.colorScheme.inverseSurface.withOpacity(0.9),
            borderRadius: BorderRadius.circular(6),
          ),
          child: Container(
            height: 36,
            width: 36,
            decoration: BoxDecoration(
              color: Colors.transparent,
              border: Border.all(
                color: onDeleteImage == null
                    ? theme.colorScheme.error.withOpacity(0.3)
                    : theme.colorScheme.error.withOpacity(0.8),
                width: 1,
              ),
              borderRadius: BorderRadius.circular(6),
            ),
            child: IconButton(
              onPressed: onDeleteImage,
              icon: const Icon(Icons.delete_outline, size: 20),
              color: onDeleteImage == null
                  ? theme.colorScheme.error.withOpacity(0.3)
                  : theme.colorScheme.error,
              padding: EdgeInsets.zero,
            ),
          ),
        ),
      ],
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\pages\works\components\image_viewer.dart
-----------------------------------
import 'dart:io';

import 'package:flutter/material.dart';

import '../../../../infrastructure/logging/logger.dart';

/// Widget that displays an image with support for zooming
class ImageViewer extends StatelessWidget {
  final String imagePath;
  final int index;
  final VoidCallback onRetry;

  const ImageViewer({
    super.key,
    required this.imagePath,
    required this.index,
    required this.onRetry,
  });

  @override
  Widget build(BuildContext context) {
    // 纭繚鏂囦欢瀛樺湪
    final file = File(imagePath);
    if (!file.existsSync()) {
      return _buildMissingFileError();
    }

    // 濡傛灉鏂囦欢瀛樺湪锛屾樉绀哄浘鐗囨煡鐪嬪櫒
    return Center(
      child: InteractiveViewer(
        minScale: 0.5,
        maxScale: 3.0,
        child: Image.file(
          file,
          fit: BoxFit.contain,
          errorBuilder: (context, error, stackTrace) {
            AppLogger.error(
              '鍥剧墖鏄剧ず澶辫触',
              tag: 'ImageViewer',
              error: error,
              stackTrace: stackTrace,
              data: {'path': imagePath},
            );
            return _buildLoadError(error);
          },
        ),
      ),
    );
  }

  Widget _buildLoadError(Object error) {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          const Icon(Icons.broken_image, size: 48, color: Colors.red),
          const SizedBox(height: 8),
          Text('鏃犳硶鍔犺浇鍥剧墖: $error', textAlign: TextAlign.center),
          const SizedBox(height: 16),
          ElevatedButton(
            onPressed: onRetry,
            child: const Text('閲嶈瘯'),
          ),
        ],
      ),
    );
  }

  Widget _buildMissingFileError() {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          const Icon(Icons.broken_image, size: 48, color: Colors.orange),
          const SizedBox(height: 8),
          Text('鍥剧墖鏂囦欢涓嶅瓨鍦? ${imagePath.split('/').last}'),
          const SizedBox(height: 16),
          ElevatedButton(
            onPressed: onRetry,
            child: const Text('閲嶈瘯'),
          ),
        ],
      ),
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\pages\works\components\info_card.dart
-----------------------------------
import 'package:flutter/material.dart';

import '../../../../domain/models/work/work_entity.dart';
import '../../../../theme/app_sizes.dart';

/// 浣滃搧淇℃伅鍗＄墖
class InfoCard extends StatelessWidget {
  final WorkEntity work;
  final bool isEditMode;
  final Function(String)? onTitleEdit;
  final Function(String)? onAuthorEdit;
  final Function(String)? onStyleEdit;
  final Function(String)? onToolEdit;
  final Function(DateTime)? onDateEdit;
  final Function(String)? onRemarkEdit;

  const InfoCard({
    super.key,
    required this.work,
    this.isEditMode = false,
    this.onTitleEdit,
    this.onAuthorEdit,
    this.onStyleEdit,
    this.onToolEdit,
    this.onDateEdit,
    this.onRemarkEdit,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Card(
      child: Padding(
        padding: const EdgeInsets.all(AppSizes.m),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Title
            Text(
              '鍩烘湰淇℃伅',
              style: theme.textTheme.titleMedium,
            ),
            const SizedBox(height: AppSizes.m),

            // Info rows
            _buildInfoRow(
              context,
              '鏍囬',
              work.title,
              onEdit: isEditMode ? () => _showTitleEditor(context) : null,
            ),
            _buildInfoRow(
              context,
              '浣滆€?,
              work.author ?? '鏈煡',
              onEdit: isEditMode ? () => _showAuthorEditor(context) : null,
            ),
            _buildInfoRow(
              context,
              '鐢婚',
              work.style.toString().split('.').last,
              onEdit: isEditMode ? () => _showStyleEditor(context) : null,
            ),
            _buildInfoRow(
              context,
              '宸ュ叿',
              work.tool.toString().split('.').last,
              onEdit: isEditMode ? () => _showToolEditor(context) : null,
            ),
            _buildInfoRow(
              context,
              '鍒涗綔鏃ユ湡',
              work.creationDate.toString().split(' ')[0] ?? '鏈煡',
              onEdit: isEditMode ? () => _showDateEditor(context) : null,
            ),
            if (work.remark?.isNotEmpty == true)
              _buildInfoRow(
                context,
                '澶囨敞',
                work.remark!,
                onEdit: isEditMode ? () => _showRemarkEditor(context) : null,
              ),
          ],
        ),
      ),
    );
  }

  Widget _buildInfoRow(
    BuildContext context,
    String label,
    String value, {
    VoidCallback? onEdit,
  }) {
    final theme = Theme.of(context);

    return Padding(
      padding: const EdgeInsets.only(bottom: AppSizes.s),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          SizedBox(
            width: 80,
            child: Text(
              label,
              style: theme.textTheme.bodySmall?.copyWith(
                color: theme.colorScheme.onSurfaceVariant,
              ),
            ),
          ),
          Expanded(
            child: Text(value),
          ),
          if (onEdit != null)
            IconButton(
              onPressed: onEdit,
              icon: const Icon(Icons.edit, size: 16),
              visualDensity: VisualDensity.compact,
              padding: EdgeInsets.zero,
              constraints: const BoxConstraints(
                minWidth: 24,
                minHeight: 24,
              ),
            ),
        ],
      ),
    );
  }

  Widget _buildTextEditor(
    BuildContext context,
    String title,
    String initialValue, {
    int maxLines = 1,
  }) {
    final controller = TextEditingController(text: initialValue);
    return AlertDialog(
      title: Text(title),
      content: TextField(
        controller: controller,
        maxLines: maxLines,
        decoration: const InputDecoration(
          border: OutlineInputBorder(),
        ),
      ),
      actions: [
        TextButton(
          onPressed: () => Navigator.of(context).pop(),
          child: const Text('鍙栨秷'),
        ),
        FilledButton(
          onPressed: () => Navigator.of(context).pop(controller.text),
          child: const Text('纭畾'),
        ),
      ],
    );
  }

  void _showAuthorEditor(BuildContext context) async {
    if (onAuthorEdit == null) return;
    final result = await showDialog<String>(
      context: context,
      builder: (context) => _buildTextEditor(
        context,
        '缂栬緫浣滆€?,
        work.author ?? '',
      ),
    );
    if (result != null) {
      onAuthorEdit!(result);
    }
  }

  void _showDateEditor(BuildContext context) async {
    if (onDateEdit == null) return;
    final result = await showDatePicker(
      context: context,
      initialDate: work.creationDate ?? DateTime.now(),
      firstDate: DateTime(1900),
      lastDate: DateTime.now(),
    );
    if (result != null) {
      onDateEdit!(result);
    }
  }

  void _showRemarkEditor(BuildContext context) async {
    if (onRemarkEdit == null) return;
    final result = await showDialog<String>(
      context: context,
      builder: (context) => _buildTextEditor(
        context,
        '缂栬緫澶囨敞',
        work.remark ?? '',
        maxLines: 5,
      ),
    );
    if (result != null) {
      onRemarkEdit!(result);
    }
  }

  void _showStyleEditor(BuildContext context) async {
    if (onStyleEdit == null) return;
    final result = await showDialog<String>(
      context: context,
      builder: (context) => _buildTextEditor(
        context,
        '缂栬緫鐢婚',
        work.style.toString().split('.').last,
      ),
    );
    if (result != null) {
      onStyleEdit!(result);
    }
  }

  void _showTitleEditor(BuildContext context) async {
    if (onTitleEdit == null) return;
    final result = await showDialog<String>(
      context: context,
      builder: (context) => _buildTextEditor(
        context,
        '缂栬緫鏍囬',
        work.title,
      ),
    );
    if (result != null) {
      onTitleEdit!(result);
    }
  }

  void _showToolEditor(BuildContext context) async {
    if (onToolEdit == null) return;
    final result = await showDialog<String>(
      context: context,
      builder: (context) => _buildTextEditor(
        context,
        '缂栬緫宸ュ叿',
        work.tool.toString().split('.').last,
      ),
    );
    if (result != null) {
      onToolEdit!(result);
    }
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\pages\works\components\loading_state.dart
-----------------------------------
import 'package:flutter/material.dart';

class LoadingState extends StatelessWidget {
  final String? message;

  const LoadingState({
    super.key,
    this.message,
  });

  @override
  Widget build(BuildContext context) {
    return Center(
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          const CircularProgressIndicator(),
          if (message != null) ...[
            const SizedBox(height: 16),
            Text(message!),
          ],
        ],
      ),
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\pages\works\components\thumbnail_strip.dart
-----------------------------------
import 'dart:async';
import 'dart:io';
import 'dart:math' as math;

import 'package:flutter/gestures.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';

import '../../../../infrastructure/logging/logger.dart';
import '../../../../theme/app_sizes.dart';

/// 缂╃暐鍥炬潯缁勪欢
/// T 鍙互鏄?File 鎴?WorkImage
class ThumbnailStrip<T> extends StatefulWidget {
  final List<T> images;
  final int selectedIndex;
  final Function(int) onTap;
  final bool isEditable;
  final Function(int, int)? onReorder;
  final bool useOriginalImage;
  final String Function(T image) pathResolver;
  final String Function(T image) keyResolver;
  final Function(int)? onRemove;

  const ThumbnailStrip({
    super.key,
    required this.images,
    required this.selectedIndex,
    required this.onTap,
    required this.pathResolver,
    required this.keyResolver,
    this.isEditable = false,
    this.onReorder,
    this.onRemove,
    this.useOriginalImage = false,
  });

  @override
  State<ThumbnailStrip<T>> createState() => _ThumbnailStripState<T>();
}

class _FileStatus {
  final bool exists;
  final DateTime lastModified;
  int checkAttempts = 0;

  _FileStatus({required this.exists, DateTime? lastModified})
      : lastModified = lastModified ?? DateTime.now();
}

class _ThumbnailStripState<T> extends State<ThumbnailStrip<T>> {
  static const double _thumbWidth = 100.0;
  static const double _thumbHeight = 100.0;
  static const double _thumbSpacing = 8.0;
  static const int _maxRetryAttempts = 3;
  static const Duration _scrollAnimationDuration = Duration(milliseconds: 100);
  static const double _scrollMultiplier = 2.0;

  final ScrollController _scrollController = ScrollController();
  final Map<String, _FileStatus> _fileStatus = {};
  bool _isDragging = false;
  Timer? _retryTimer;

  @override
  Widget build(BuildContext context) {
    AppLogger.debug(
        'Building ThumbnailStrip with ${widget.images.length} images');
    final theme = Theme.of(context);

    if (!widget.isEditable) {
      return SizedBox(
        height: 120,
        child: Listener(
          onPointerSignal: _handlePointerSignal,
          child: ScrollConfiguration(
            behavior: ScrollConfiguration.of(context).copyWith(
              scrollbars: false,
              dragDevices: PointerDeviceKind.values.toSet(),
              physics: const BouncingScrollPhysics(),
            ),
            child: ListView.builder(
              controller: _scrollController,
              scrollDirection: Axis.horizontal,
              itemCount: widget.images.length,
              itemBuilder: (context, index) =>
                  _buildThumbnail(context, index, theme),
            ),
          ),
        ),
      );
    }

    // 缂栬緫妯″紡锛氬彲閲嶆帓搴忕殑鍒楄〃
    return SizedBox(
      height: 120,
      child: Listener(
        onPointerSignal: _handlePointerSignal,
        child: ScrollConfiguration(
          behavior: ScrollConfiguration.of(context).copyWith(
            scrollbars: false,
            dragDevices: PointerDeviceKind.values.toSet(),
            physics: const BouncingScrollPhysics(),
          ),
          child: ReorderableListView.builder(
            scrollController: _scrollController,
            scrollDirection: Axis.horizontal,
            buildDefaultDragHandles: false,
            onReorderStart: (index) {
              setState(() => _isDragging = true);
              HapticFeedback.selectionClick();
            },
            onReorderEnd: (_) {
              setState(() => _isDragging = false);
              HapticFeedback.lightImpact();
            },
            onReorder: (oldIndex, newIndex) {
              if (oldIndex < newIndex) newIndex--;
              widget.onReorder?.call(oldIndex, newIndex);
            },
            proxyDecorator: (child, index, animation) {
              return AnimatedBuilder(
                animation: animation,
                builder: (context, child) {
                  final elevationValue = animation.value * 8.0;
                  final scaleValue = 1.0 + math.min(0.2, animation.value * 0.1);
                  final rotateValue = (1.0 - animation.value) * 0.1;

                  return Transform(
                    transform: Matrix4.identity()
                      ..scale(scaleValue, scaleValue)
                      ..rotateZ(rotateValue),
                    alignment: Alignment.center,
                    child: Material(
                      elevation: elevationValue,
                      color: Colors.transparent,
                      shadowColor: Colors.black38,
                      borderRadius: BorderRadius.circular(4),
                      child: child,
                    ),
                  );
                },
                child: child,
              );
            },
            itemBuilder: (context, index) {
              final thumbnail = _buildThumbnail(context, index, theme);
              return ReorderableDragStartListener(
                key: ValueKey(widget.keyResolver(widget.images[index])),
                index: index,
                enabled: !_isDragging,
                child: MouseRegion(
                  cursor: _isDragging
                      ? SystemMouseCursors.grabbing
                      : SystemMouseCursors.grab,
                  child: thumbnail,
                ),
              );
            },
            itemCount: widget.images.length,
          ),
        ),
      ),
    );
  }

  @override
  void didUpdateWidget(ThumbnailStrip<T> oldWidget) {
    super.didUpdateWidget(oldWidget);

    if (widget.images.length != oldWidget.images.length ||
        !_listsEqual(widget.images, oldWidget.images, widget.keyResolver)) {
      _fileStatus.clear();
      _checkImageFiles();
    }
    if (widget.selectedIndex != oldWidget.selectedIndex) {
      _scrollToSelected();
    }
  }

  @override
  void dispose() {
    _scrollController.dispose();
    _retryTimer?.cancel();
    super.dispose();
  }

  @override
  void initState() {
    super.initState();
    _checkImageFiles();
    WidgetsBinding.instance.addPostFrameCallback((_) => _scrollToSelected());
  }

  Widget _buildThumbnail(BuildContext context, int index, ThemeData theme) {
    final image = widget.images[index];
    final isSelected = index == widget.selectedIndex;
    final path = widget.pathResolver(image);
    final status = _fileStatus[path];
    final fileExists = status?.exists ?? false;
    final attemptCount = status?.checkAttempts ?? 0;

    String errorMessage = '鍥剧墖鏂囦欢涓嶅瓨鍦?;
    if (attemptCount > 0 && attemptCount < _maxRetryAttempts) {
      errorMessage = '姝ｅ湪閲嶈瘯鍔犺浇鍥剧墖 ($attemptCount/$_maxRetryAttempts)';
    } else if (attemptCount >= _maxRetryAttempts) {
      errorMessage = '鍥剧墖鍔犺浇澶辫触锛岃妫€鏌ユ枃浠惰矾寰?;
    }

    final heroTag = fileExists
        ? '${path}_${status?.lastModified.millisecondsSinceEpoch}'
        : path;

    return GestureDetector(
      onTap: () {
        if (!_isDragging) {
          HapticFeedback.selectionClick();
          widget.onTap(index);
        }
      },
      child: Container(
        width: _thumbWidth,
        height: _thumbHeight,
        margin: const EdgeInsets.symmetric(horizontal: AppSizes.xs),
        decoration: BoxDecoration(
          border: Border.all(
            color: isSelected
                ? theme.colorScheme.primary
                : theme.colorScheme.outlineVariant,
            width: isSelected ? 2.0 : 1.0,
          ),
          borderRadius: BorderRadius.circular(4),
          boxShadow: [
            if (isSelected)
              BoxShadow(
                color: theme.colorScheme.primary.withOpacity(0.2),
                blurRadius: 4,
                spreadRadius: 1,
              ),
          ],
        ),
        child: ClipRRect(
          borderRadius: BorderRadius.circular(3),
          child: Stack(
            fit: StackFit.expand,
            children: [
              if (fileExists)
                Hero(
                  tag: heroTag,
                  child: Image.file(
                    File(path),
                    fit: BoxFit.cover,
                    frameBuilder:
                        (context, child, frame, wasSynchronouslyLoaded) {
                      if (wasSynchronouslyLoaded) return child;
                      return AnimatedSwitcher(
                        duration: const Duration(milliseconds: 200),
                        child: frame != null
                            ? child
                            : Container(
                                color:
                                    theme.colorScheme.surfaceContainerHighest,
                                child: const Center(
                                  child:
                                      CircularProgressIndicator(strokeWidth: 2),
                                ),
                              ),
                      );
                    },
                    errorBuilder: (context, error, stack) => Center(
                      child: Icon(Icons.broken_image,
                          size: 32, color: theme.colorScheme.error),
                    ),
                  ),
                )
              else
                Center(
                  child: Icon(Icons.image_not_supported,
                      size: 32,
                      color: theme.colorScheme.surfaceContainerHighest),
                ),

              // Index label
              Positioned(
                left: 4,
                top: 4,
                child: Container(
                  padding: const EdgeInsets.symmetric(
                    horizontal: 6,
                    vertical: 2,
                  ),
                  decoration: BoxDecoration(
                    color: Colors.black54,
                    borderRadius: BorderRadius.circular(2),
                  ),
                  child: Text(
                    '${index + 1}',
                    style: const TextStyle(
                      color: Colors.white,
                      fontSize: 12,
                    ),
                  ),
                ),
              ),

              // Selected indicator
              if (isSelected)
                Positioned(
                  top: 4,
                  right: 4,
                  child: Container(
                    padding: const EdgeInsets.all(2),
                    decoration: BoxDecoration(
                      color: theme.colorScheme.primary,
                      shape: BoxShape.circle,
                    ),
                    child: const Icon(
                      Icons.check,
                      size: 12,
                      color: Colors.white,
                    ),
                  ),
                ),

              // Remove button
              if (isSelected && widget.onRemove != null)
                Positioned(
                  bottom: 4,
                  right: 4,
                  child: IconButton.filled(
                    onPressed: () {
                      HapticFeedback.lightImpact();
                      widget.onRemove!(index);
                    },
                    icon: const Icon(Icons.close, size: 16),
                    style: IconButton.styleFrom(
                      backgroundColor: theme.colorScheme.error,
                      foregroundColor: theme.colorScheme.onError,
                      padding: const EdgeInsets.all(4),
                      minimumSize: const Size(24, 24),
                      tapTargetSize: MaterialTapTargetSize.shrinkWrap,
                      shape: RoundedRectangleBorder(
                        borderRadius: BorderRadius.circular(AppSizes.xxs),
                      ),
                    ),
                  ),
                ),

              // Drag handle
              if (widget.isEditable && !_isDragging)
                Positioned(
                  right: 4,
                  bottom: isSelected && widget.onRemove != null ? 32 : 4,
                  child: Container(
                    padding: const EdgeInsets.all(2),
                    decoration: BoxDecoration(
                      color: theme.colorScheme.surfaceContainerHighest
                          .withOpacity(0.8),
                      borderRadius: BorderRadius.circular(2),
                    ),
                    child: Icon(
                      Icons.drag_indicator,
                      size: 16,
                      color: theme.colorScheme.onSurfaceVariant,
                    ),
                  ),
                ),

              // Error indicator
              if (!fileExists)
                Center(
                  child: Tooltip(
                    message: errorMessage,
                    child: Column(
                      mainAxisSize: MainAxisSize.min,
                      children: [
                        Icon(
                          Icons.circle_rounded,
                          size: 24,
                          color: theme.colorScheme.surface,
                        ),
                        if (attemptCount > 0 &&
                            attemptCount < _maxRetryAttempts)
                          const SizedBox(
                            width: 16,
                            height: 16,
                            child: CircularProgressIndicator(strokeWidth: 2),
                          ),
                      ],
                    ),
                  ),
                ),
            ],
          ),
        ),
      ),
    );
  }

  Future<void> _checkImageFiles() async {
    // Cancel any pending retries
    _retryTimer?.cancel();

    bool hasFailures = false;

    for (final image in widget.images) {
      try {
        final path = widget.pathResolver(image);

        try {
          final file = File(path);
          if (await file.exists()) {
            final randomAccessFile = await file.open(mode: FileMode.read);
            try {
              await randomAccessFile.read(4);
              _fileStatus[path] = _FileStatus(
                exists: true,
                lastModified: await file.lastModified(),
              );
            } finally {
              await randomAccessFile.close();
            }
          } else {
            final status = _fileStatus[path];
            final attempts = status?.checkAttempts ?? 0;

            _fileStatus[path] = _FileStatus(exists: false)
              ..checkAttempts = attempts + 1;

            if (attempts < _maxRetryAttempts) {
              hasFailures = true;
            }
          }
        } catch (e) {
          AppLogger.debug(
            'File exists but not accessible yet',
            tag: 'ThumbnailStrip',
            data: {'path': path, 'error': e.toString()},
          );

          final status = _fileStatus[path];
          final attempts = status?.checkAttempts ?? 0;

          _fileStatus[path] = _FileStatus(exists: false)
            ..checkAttempts = attempts + 1;

          if (attempts < _maxRetryAttempts) {
            hasFailures = true;
          }
        }
      } catch (e) {
        _fileStatus[widget.pathResolver(image)] = _FileStatus(exists: false);
        hasFailures = true;
      }
    }

    if (mounted) setState(() {});

    if (hasFailures) {
      _retryTimer = Timer(const Duration(milliseconds: 500), () {
        if (mounted) _checkImageFiles();
      });
    }
  }

  void _handlePointerSignal(PointerSignalEvent event) {
    AppLogger.debug('鏀跺埌鎸囬拡淇″彿浜嬩欢: ${event.runtimeType}');

    if (event is PointerScrollEvent) {
      AppLogger.debug('婊氬姩浜嬩欢: delta=${event.scrollDelta}, kind=${event.kind}');

      if (!mounted || !_scrollController.hasClients) {
        AppLogger.debug('缁勪欢鏈寕杞芥垨婊氬姩鎺у埗鍣ㄦ湭灏辩华');
        return;
      }

      final delta = event.scrollDelta;
      // 濡傛灉鏄按骞虫粴鍔ㄥ垯鐩存帴浣跨敤锛屽鏋滄槸鍨傜洿婊氬姩鍒欒浆鎹负姘村钩鏂瑰悜
      final adjustedDelta =
          (delta.dx != 0 ? delta.dx : -delta.dy) * _scrollMultiplier;

      AppLogger.debug('璋冩暣鍚庣殑婊氬姩澧為噺: $adjustedDelta');

      final newOffset = (_scrollController.offset + adjustedDelta)
          .clamp(0.0, _scrollController.position.maxScrollExtent);

      _scrollController.animateTo(
        newOffset,
        duration: _scrollAnimationDuration,
        curve: Curves.easeOutCubic,
      );
    }
  }

  bool _listsEqual(List<T> a, List<T> b, String Function(T) keyResolver) {
    if (a.length != b.length) return false;
    for (int i = 0; i < a.length; i++) {
      if (keyResolver(a[i]) != keyResolver(b[i])) return false;
    }
    return true;
  }

  void _scrollToSelected() {
    if (!mounted || !_scrollController.hasClients) return;

    final itemWidth = _thumbWidth + _thumbSpacing * 2;
    final viewportWidth = MediaQuery.of(context).size.width;
    final targetOffset = widget.selectedIndex * itemWidth;

    final offset = (targetOffset - (viewportWidth - itemWidth) / 2)
        .clamp(0.0, _scrollController.position.maxScrollExtent);

    _scrollController.animateTo(
      offset,
      duration: const Duration(milliseconds: 300),
      curve: Curves.easeOutCubic,
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\pages\works\components\unified_work_detail_panel.dart
-----------------------------------
import 'dart:math' as math;

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:intl/intl.dart';

import '../../../../domain/models/work/work_entity.dart';
import '../../../../infrastructure/logging/logger.dart';
import '../../../../theme/app_sizes.dart';
import '../../../providers/work_detail_provider.dart';
import '../../../widgets/common/tab_bar_theme_wrapper.dart';
import '../../../widgets/forms/work_form.dart';
import '../../../widgets/tag_editor.dart';

class UnifiedWorkDetailPanel extends ConsumerStatefulWidget {
  final WorkEntity work;
  final bool isEditing;

  const UnifiedWorkDetailPanel({
    super.key,
    required this.work,
    required this.isEditing,
  });

  @override
  ConsumerState<UnifiedWorkDetailPanel> createState() =>
      _UnifiedWorkDetailPanelState();
}

class _UnifiedWorkDetailPanelState extends ConsumerState<UnifiedWorkDetailPanel>
    with SingleTickerProviderStateMixin {
  late TabController _tabController;

  @override
  Widget build(BuildContext context) {
    // 纭繚姣忔鏋勫缓鏃堕兘浣跨敤鏈€鏂扮殑鏍囩鏁版嵁
    final tags = List<String>.from(widget.work.tags);

    // 娣诲姞璋冭瘯鏃ュ織锛屽府鍔╄瘖鏂棶棰?
    AppLogger.debug('Building UnifiedWorkDetailPanel',
        tag: 'WorkDetailPanel',
        data: {
          'isEditing': widget.isEditing,
          'workId': widget.work.id,
          'tagCount': tags.length,
          'title': widget.work.title,
        });

    return Card(
      margin: const EdgeInsets.only(
        top: AppSizes.spacingMedium,
        right: AppSizes.spacingMedium,
        bottom: AppSizes.spacingMedium,
      ),
      clipBehavior: Clip.antiAlias,
      child: Column(
        children: [
          TabBarThemeWrapper(
            child: TabBar(
              controller: _tabController,
              tabs: const [
                Tab(text: '鍩烘湰淇℃伅'),
                Tab(text: '鏍囩'), // 绉诲埌绗簩浣嶇疆
                Tab(text: '闆嗗瓧'),
              ],
              indicatorSize: TabBarIndicatorSize.tab,
            ),
          ),
          Expanded(
            child: TabBarView(
              controller: _tabController,
              children: [
                _buildBasicInfoTab(context),
                _buildTagsTab(context, tags), // 绉诲埌绗簩浣嶇疆
                _buildCharactersTab(context),
              ],
            ),
          ),
        ],
      ),
    );
  }

  @override
  void didUpdateWidget(UnifiedWorkDetailPanel oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (oldWidget.work != widget.work ||
        oldWidget.isEditing != widget.isEditing) {
      // 璁板綍鐘舵€佸彉鍖?
      AppLogger.debug('UnifiedWorkDetailPanel updated',
          tag: 'WorkDetailPanel',
          data: {
            'oldTitle': oldWidget.work.title,
            'newTitle': widget.work.title,
            'oldTagCount': oldWidget.work.tags.length,
            'newTagCount': widget.work.tags.length,
            'isEditingChanged': oldWidget.isEditing != widget.isEditing,
          });

      setState(() {
        // 寮哄埗鏇存柊鐘舵€佷互鍙嶆槧鏂扮殑鏁版嵁
      });
    }
  }

  @override
  void dispose() {
    _tabController.dispose();
    super.dispose();
  }

  @override
  void initState() {
    super.initState();
    _tabController = TabController(length: 3, vsync: this);
  }

  // Additional metadata not included in the form
  Widget _buildAdditionalMetadata(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        const Divider(),
        const SizedBox(height: AppSizes.spacingSmall),
        Text(
          '鍏朵粬淇℃伅',
          style: Theme.of(context).textTheme.titleMedium,
        ),
        const SizedBox(height: AppSizes.spacingSmall),
        _buildInfoRow('鍥剧墖鏁伴噺', (widget.work.imageCount ?? 0).toString()),
        _buildInfoRow('鍒涘缓鏃堕棿', _formatDateTime(widget.work.createTime)),
        _buildInfoRow('淇敼鏃堕棿', _formatDateTime(widget.work.updateTime)),
      ],
    );
  }

  Widget _buildBasicInfoTab(BuildContext context) {
    return ListView(
      padding: const EdgeInsets.all(AppSizes.spacingMedium),
      children: [
        // Use WorkForm for both view and edit modes
        WorkForm(
          title: '鍩烘湰淇℃伅',
          initialTitle: widget.work.title,
          initialAuthor: widget.work.author,
          initialStyle: widget.work.style,
          initialTool: widget.work.tool,
          initialCreationDate: widget.work.creationDate,
          initialRemark: widget.work.remark,
          isProcessing: false,
          // Only enable editing in edit mode
          onTitleChanged: widget.isEditing
              ? (value) => _updateWorkField('title', value)
              : null,
          onAuthorChanged: widget.isEditing
              ? (value) => _updateWorkField('author', value)
              : null,
          onStyleChanged: widget.isEditing
              ? (value) => _updateWorkField('style', value)
              : null,
          onToolChanged: widget.isEditing
              ? (value) => _updateWorkField('tool', value)
              : null,
          onCreationDateChanged: widget.isEditing
              ? (value) => _updateWorkField('creationDate', value)
              : null,
          onRemarkChanged: widget.isEditing
              ? (value) => _updateWorkField('remark', value)
              : null,
          // Configure form appearance
          visibleFields: WorkFormPresets.editFields,
          requiredFields: {WorkFormField.title},
          showHelp: false,
          showKeyboardShortcuts: false,
        ),

        // Display additional metadata in view mode
        if (!widget.isEditing) ...[
          const SizedBox(height: AppSizes.spacingMedium),
          _buildAdditionalMetadata(context),
        ],
      ],
    );
  }

  Widget _buildCharacterChip(BuildContext context) {
    return Chip(
      avatar: const CircleAvatar(
        child: Icon(Icons.text_fields, size: 14),
      ),
      label: const Text('瀛?),
      backgroundColor: Theme.of(context).colorScheme.surfaceContainerHighest,
    );
  }

  Widget _buildCharactersSection(BuildContext context) {
    final theme = Theme.of(context);
    final charCount = widget.work.collectedChars.length;

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text('$charCount 涓?, style: theme.textTheme.bodySmall),
        if (charCount == 0)
          const Padding(
            padding: EdgeInsets.symmetric(vertical: 16.0),
            child: Center(child: Text('鏆傛棤闆嗗瓧')),
          )
        else
          Wrap(
            spacing: 8,
            runSpacing: 8,
            children: List.generate(
              math.min(charCount, 20),
              (index) => _buildCharacterChip(context),
            ),
          ),
        if (charCount > 20)
          Center(
            child: TextButton(
              onPressed: () {},
              child: const Text('鏌ョ湅鏇村'),
            ),
          ),
      ],
    );
  }

  Widget _buildCharactersTab(BuildContext context) {
    return ListView(
      padding: const EdgeInsets.all(AppSizes.spacingMedium),
      children: [
        _buildCharactersSection(context),
      ],
    );
  }

  Widget _buildInfoRow(String label, String value) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 4),
      child: Row(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          SizedBox(
            width: 80,
            child: Text(
              label,
              style: const TextStyle(fontWeight: FontWeight.bold),
            ),
          ),
          Expanded(
            child: Text(value),
          ),
        ],
      ),
    );
  }

  // 淇敼鏍囩鏍囩椤垫瀯寤烘柟娉曪紝鐩存帴浣跨敤浼犲叆鐨勬爣绛炬暟鎹?
  Widget _buildTagsTab(BuildContext context, List<String> tags) {
    final theme = Theme.of(context);

    return ListView(
      padding: const EdgeInsets.all(AppSizes.spacingMedium),
      children: [
        Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              '鏍囩绠＄悊',
              style: theme.textTheme.titleMedium,
            ),
            const SizedBox(height: 16),
            TagEditor(
              tags: tags,
              readOnly: !widget.isEditing,
              onTagsChanged: (newTags) {
                _updateWorkField('tags', newTags);
                // 娣诲姞璋冭瘯鏃ュ織浠ヨ窡韪爣绛惧彉鍖?
                AppLogger.debug('鏍囩宸叉洿鏂?, tag: 'UnifiedWorkDetailPanel', data: {
                  'workId': widget.work.id,
                  'oldTags': tags,
                  'newTags': newTags,
                  'isEditing': widget.isEditing,
                });
              },
            ),
          ],
        ),
      ],
    );
  }

  String _formatDate(DateTime? date) {
    if (date == null) return '鏈煡';
    return DateFormat('yyyy-MM-dd').format(date);
  }

  String _formatDateTime(DateTime? date) {
    if (date == null) return '鏈煡';
    return DateFormat('yyyy-MM-dd HH:mm').format(date);
  }

  // 鑾峰彇褰撳墠瀛楁鍊肩殑杈呭姪鏂规硶
  dynamic _getCurrentFieldValue(String field) {
    final currentWork = widget.work;
    switch (field) {
      case 'title':
        return currentWork.title;
      case 'author':
        return currentWork.author;
      case 'style':
        return currentWork.style;
      case 'tool':
        return currentWork.tool;
      case 'creationDate':
        return currentWork.creationDate;
      case 'remark':
        return currentWork.remark;
      case 'tags':
        return currentWork.tags;
      default:
        return null;
    }
  }

  void _updateWorkField(String field, dynamic value) {
    final notifier = ref.read(workDetailProvider.notifier);
    final currentState = ref.read(workDetailProvider);
    final currentValue = _getCurrentFieldValue(field);

    // 璁板綍鏇磋缁嗙殑瀛楁淇敼鍓嶅悗瀵规瘮淇℃伅
    AppLogger.debug('瀛楁淇敼', tag: 'WorkDetailPanel', data: {
      'field': field,
      'oldValue': field == 'tags'
          ? '${widget.work.tags.length} tags: ${widget.work.tags}'
          : currentValue.toString(),
      'newValue': field == 'tags'
          ? '${(value as List<String>).length} tags: $value'
          : value.toString(),
      'workId': widget.work.id,
      'isChanged': currentValue != value,
    });

    switch (field) {
      case 'title':
        notifier.updateWorkBasicInfo(title: value);
        break;
      case 'author':
        notifier.updateWorkBasicInfo(author: value);
        break;
      case 'style':
        notifier.updateWorkBasicInfo(style: value);
        break;
      case 'tool':
        notifier.updateWorkBasicInfo(tool: value);
        break;
      case 'creationDate':
        notifier.updateWorkBasicInfo(creationDate: value);
        break;
      case 'remark':
        notifier.updateWorkBasicInfo(remark: value);
        break;
      case 'tags':
        // 浣跨敤涓撻棬鐨勬柟娉曟洿鏂版爣绛?
        notifier.updateWorkTags(List<String>.from(value));
        break;
    }

    // 纭繚鏍囪鐘舵€佸凡鏇存敼
    notifier.markAsChanged();

    // 璁板綍淇敼鍚庣殑瀹屾暣鐘舵€?
    Future.microtask(() {
      final updatedState = ref.read(workDetailProvider);
      AppLogger.debug('瀛楁淇敼鍚庣殑缂栬緫鐘舵€?, tag: 'WorkDetailPanel', data: {
        'editingWorkTitle': updatedState.editingWork?.title,
        'editingWorkAuthor': updatedState.editingWork?.author,
        'editingWorkStyle': updatedState.editingWork?.style.value,
        'editingWorkTool': updatedState.editingWork?.tool.value,
        'editingWorkTagCount': updatedState.editingWork?.tags.length,
        'editingWorkTags': updatedState.editingWork?.tags,
        'hasChanges': updatedState.hasChanges,
      });

      if (mounted) {
        setState(() {});
      }
    });
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\pages\works\components\view_mode_image_preview.dart
-----------------------------------
import 'dart:io';

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../domain/models/work/work_image.dart';
import '../../../../infrastructure/logging/logger.dart';
import '../../../widgets/common/zoomable_image_view.dart';
import 'thumbnail_strip.dart';

class ViewModeImagePreview extends ConsumerStatefulWidget {
  final List<WorkImage> images;
  final int selectedIndex;
  final Function(int) onImageSelect;

  const ViewModeImagePreview({
    super.key,
    required this.images,
    required this.selectedIndex,
    required this.onImageSelect,
  });

  @override
  ConsumerState<ViewModeImagePreview> createState() =>
      _ViewModeImagePreviewState();
}

class _ViewModeImagePreviewState extends ConsumerState<ViewModeImagePreview> {
  static const double _toolbarHeight =
      48.0; // Match EnhancedWorkPreview toolbar height
  final Map<String, bool> _fileExistsCache = {};

  @override
  Widget build(BuildContext context) {
    if (widget.images.isEmpty) {
      return const Column(
        children: [
          // Add toolbar height space for consistency with edit mode
          SizedBox(height: _toolbarHeight),
          Expanded(
            child: Center(
              child: Text('娌℃湁鍙樉绀虹殑鍥剧墖'),
            ),
          ),
        ],
      );
    }

    // Get the current image
    final currentImage = widget.selectedIndex < widget.images.length
        ? widget.images[widget.selectedIndex]
        : widget.images.first;

    // Use LayoutBuilder to match EnhancedWorkPreview's layout calculation
    return LayoutBuilder(builder: (context, constraints) {
      final availableHeight = constraints.maxHeight;
      final thumbnailHeight = 120.0;
      final imageHeight = availableHeight - _toolbarHeight - thumbnailHeight;

      return Column(
        children: [
          // Add empty space matching toolbar height for visual consistency with edit mode
          const SizedBox(height: _toolbarHeight),

          // Main image display area
          Expanded(
            child: Center(
              child: FutureBuilder<bool>(
                // Check if file exists when building the widget
                future: _checkFileExists(currentImage.path),
                builder: (context, snapshot) {
                  final fileExists = snapshot.data ?? false;

                  if (!fileExists) {
                    return Column(
                      mainAxisAlignment: MainAxisAlignment.center,
                      children: [
                        Icon(
                          Icons
                              .image_not_supported_outlined, // Changed to outlined version
                          size: 64,
                          color: Theme.of(context)
                              .colorScheme
                              .onSurface
                              .withOpacity(0.7), // More subtle color
                        ),
                        const SizedBox(height: 16),
                        Text(
                          '鏃犳硶鍔犺浇鍥剧墖: ${currentImage.path}',
                          style: TextStyle(
                              color: Theme.of(context)
                                  .colorScheme
                                  .onSurface
                                  .withOpacity(0.7)), // More subtle color
                        ),
                        const SizedBox(height: 16),
                        ElevatedButton(
                          onPressed: () {
                            _fileExistsCache.remove(currentImage.path);
                            setState(() {}); // Force rebuild
                          },
                          child: const Text('閲嶈瘯'),
                        ),
                      ],
                    );
                  }

                  return ZoomableImageView(
                    imagePath: currentImage.path,
                    enableMouseWheel: true,
                    minScale: 0.5,
                    maxScale: 4.0,
                    showControls: true, // Add controls to match edit mode
                  );
                },
              ),
            ),
          ),

          // Thumbnail strip below the main image
          SizedBox(
            height: thumbnailHeight,
            child: ThumbnailStrip<WorkImage>(
              images: widget.images,
              selectedIndex: widget.selectedIndex,
              onTap: widget.onImageSelect,
              pathResolver: (image) => image.thumbnailPath,
              keyResolver: (image) => image.id,
            ),
          ),
        ],
      );
    });
  }

  @override
  void didUpdateWidget(ViewModeImagePreview oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (widget.images != oldWidget.images) {
      _fileExistsCache.clear();
      _verifyImageFiles();
    }
  }

  @override
  void initState() {
    super.initState();
    _verifyImageFiles();
  }

  // Check if a file exists, using the cache when possible
  Future<bool> _checkFileExists(String path) async {
    if (_fileExistsCache.containsKey(path)) {
      return _fileExistsCache[path] ?? false;
    }

    try {
      final exists = await File(path).exists();
      _fileExistsCache[path] = exists;
      return exists;
    } catch (e) {
      _fileExistsCache[path] = false;
      return false;
    }
  }

  // Verify that image files exist and log any issues
  Future<void> _verifyImageFiles() async {
    for (final image in widget.images) {
      try {
        final file = File(image.path);
        final exists = await file.exists();
        _fileExistsCache[image.path] = exists;

        if (!exists) {
          AppLogger.warning(
            'Image file not found',
            tag: 'ViewModeImagePreview',
            data: {
              'path': image.path,
              'imageId': image.id,
              'workId': image.workId
            },
          );
        }
      } catch (e, stack) {
        AppLogger.error(
          'Error checking image file',
          tag: 'ViewModeImagePreview',
          error: e,
          stackTrace: stack,
          data: {'path': image.path},
        );
        _fileExistsCache[image.path] = false;
      }
    }
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\pages\works\components\work_browse_toolbar.dart
-----------------------------------
import 'package:flutter/material.dart';

import '../../../../theme/app_sizes.dart';
import '../../../viewmodels/states/work_browse_state.dart';

class WorkBrowseToolbar extends StatefulWidget {
  // 鏀逛负 StatefulWidget
  final ViewMode viewMode;
  final ValueChanged<ViewMode> onViewModeChanged;
  final VoidCallback onImport;
  final ValueChanged<String> onSearch;
  final bool batchMode;
  final ValueChanged<bool> onBatchModeChanged;
  final int selectedCount;
  final VoidCallback onDeleteSelected;

  const WorkBrowseToolbar({
    super.key,
    required this.viewMode,
    required this.onViewModeChanged,
    required this.onImport,
    required this.onSearch,
    required this.batchMode,
    required this.onBatchModeChanged,
    required this.selectedCount,
    required this.onDeleteSelected,
  });

  @override
  State<WorkBrowseToolbar> createState() => _WorkBrowseToolbarState();
}

class _WorkBrowseToolbarState extends State<WorkBrowseToolbar> {
  late final TextEditingController _searchController;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Container(
      height: kToolbarHeight,
      padding: const EdgeInsets.symmetric(horizontal: AppSizes.m),
      decoration: BoxDecoration(
        color: theme.colorScheme.surface,
        border: Border(
          bottom: BorderSide(
            color: theme.colorScheme.outlineVariant.withOpacity(0.5),
          ),
        ),
      ),
      child: Row(
        children: [
          // 宸︿晶鎸夐挳缁?
          FilledButton.icon(
            icon: const Icon(Icons.add),
            label: const Text('瀵煎叆浣滃搧'),
            onPressed: widget.onImport,
          ),
          const SizedBox(width: AppSizes.s),
          OutlinedButton.icon(
            icon: Icon(widget.batchMode ? Icons.close : Icons.checklist),
            label: Text(widget.batchMode ? '瀹屾垚' : '鎵归噺澶勭悊'),
            onPressed: () => widget.onBatchModeChanged(!widget.batchMode),
          ),

          // 鎵归噺鎿嶄綔鐘舵€?- 绉诲埌涓棿
          if (widget.batchMode) ...[
            const SizedBox(width: AppSizes.m),
            Text(
              '宸查€夋嫨 ${widget.selectedCount} 椤?,
              style: theme.textTheme.bodyMedium,
            ),
            if (widget.selectedCount > 0)
              Padding(
                padding: const EdgeInsets.only(left: AppSizes.s),
                child: FilledButton.tonalIcon(
                  icon: const Icon(Icons.delete),
                  label: Text('鍒犻櫎${widget.selectedCount}椤?),
                  onPressed: widget.onDeleteSelected,
                ),
              ),
          ],

          const Spacer(),

          // 鍙充晶鎺у埗缁?
          SizedBox(
            width: 240,
            child: TextField(
              controller: _searchController, // 浣跨敤鎺у埗鍣?
              onChanged: widget.onSearch,
              decoration: InputDecoration(
                hintText: '鎼滅储浣滃搧...',
                prefixIcon: Icon(
                  Icons.search,
                  size: 20,
                  color: theme.colorScheme.outline,
                ),
                suffixIcon: ValueListenableBuilder<TextEditingValue>(
                  valueListenable: _searchController, // 鐩戝惉鎺у埗鍣?
                  builder: (context, value, child) {
                    return AnimatedOpacity(
                      opacity: value.text.isNotEmpty ? 1.0 : 0.0,
                      duration: const Duration(milliseconds: 200),
                      child: IconButton(
                        icon: Icon(
                          Icons.clear,
                          size: 16,
                          color: theme.colorScheme.outline,
                        ),
                        onPressed: () {
                          _searchController.clear(); // 娓呴櫎鏂囨湰
                          widget.onSearch(''); // 瑙﹀彂鎼滅储
                        },
                      ),
                    );
                  },
                ),
                isDense: true,
                filled: true,
                fillColor:
                    theme.colorScheme.surfaceContainerHighest.withOpacity(0.3),
                contentPadding: const EdgeInsets.symmetric(
                  horizontal: AppSizes.s,
                  vertical: AppSizes.xs,
                ),
                border: OutlineInputBorder(
                  borderRadius: BorderRadius.circular(AppSizes.m),
                  borderSide: BorderSide.none,
                ),
                focusedBorder: OutlineInputBorder(
                  borderRadius: BorderRadius.circular(AppSizes.m),
                  borderSide: BorderSide(
                    color: theme.colorScheme.primary,
                    width: 1.5,
                  ),
                ),
                hoverColor:
                    theme.colorScheme.surfaceContainerHighest.withOpacity(0.5),
              ),
            ),
          ),
          const SizedBox(width: AppSizes.m),

          // 瑙嗗浘鍒囨崲鎸夐挳
          IconButton(
            icon: Icon(
              widget.viewMode == ViewMode.grid
                  ? Icons.view_list
                  : Icons.grid_view,
              color: theme.colorScheme.primary,
            ),
            style: IconButton.styleFrom(
              shape: RoundedRectangleBorder(
                borderRadius: BorderRadius.circular(AppSizes.s),
              ),
            ),
            onPressed: () => widget.onViewModeChanged(
                widget.viewMode == ViewMode.grid
                    ? ViewMode.list
                    : ViewMode.grid),
            tooltip: widget.viewMode == ViewMode.grid ? '鍒楄〃瑙嗗浘' : '缃戞牸瑙嗗浘',
          ),
        ],
      ),
    );
  }

  @override
  void dispose() {
    _searchController.dispose();
    super.dispose();
  }

  @override
  void initState() {
    super.initState();
    _searchController = TextEditingController();
  }

  void _showDeleteConfirmation(BuildContext context) async {
    final confirmed = await showDialog<bool>(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('纭鍒犻櫎'),
        content: Text('纭畾瑕佸垹闄ら€変腑鐨?${widget.selectedCount} 涓綔鍝佸悧锛熸鎿嶄綔涓嶅彲鎭㈠銆?),
        actions: [
          TextButton(
            child: const Text('鍙栨秷'),
            onPressed: () => Navigator.pop(context, false),
          ),
          FilledButton(
            child: const Text('鍒犻櫎'),
            onPressed: () => Navigator.pop(context, true),
          ),
        ],
      ),
    );

    if (confirmed == true) {
      widget.onDeleteSelected();
    }
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\pages\works\components\work_card.dart
-----------------------------------
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../application/providers/service_providers.dart';
import '../../../../domain/models/work/work_entity.dart';
import '../../../../theme/app_colors.dart';
import '../../../../theme/app_sizes.dart';
import '../../../../theme/app_text_styles.dart';
import '../../../widgets/image/cached_image.dart';
import '../../../widgets/skeleton_loader.dart';
import '../../../widgets/tag_list.dart';

class WorkCard extends ConsumerWidget {
  final WorkEntity work;
  final void Function()? onTap;
  final bool selected;
  final double? width;
  final double? height;

  const WorkCard({
    super.key,
    required this.work,
    this.onTap,
    this.selected = false,
    this.width,
    this.height,
  });

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final storageService = ref.watch(workStorageProvider);

    return FutureBuilder<String>(
      future: Future.value(storageService.getWorkCoverThumbnailPath(work.id)),
      builder: (context, snapshot) {
        if (!snapshot.hasData) {
          return SkeletonLoader(
            width: width ?? 200,
            height: height ?? 280,
          );
        }

        final coverPath = snapshot.data!;

        return Card(
          clipBehavior: Clip.antiAlias,
          color: selected ? AppColors.selectedCard : null,
          child: InkWell(
            onTap: onTap,
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.stretch,
              children: [
                // 缂╃暐鍥?
                Expanded(
                  child: CachedImage(
                    path: coverPath,
                    width: width,
                    height: height,
                    cacheKey:
                        '${work.id}_${work.updateTime.millisecondsSinceEpoch}',
                    fit: BoxFit.cover,
                  ),
                ),
                // 鏍囬鍜屾爣绛?
                Padding(
                  padding: const EdgeInsets.all(AppSizes.p8),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                        work.title,
                        style: AppTextStyles.bodyMedium,
                        maxLines: 1,
                        overflow: TextOverflow.ellipsis,
                      ),
                      const SizedBox(height: AppSizes.p4),
                      if (work.tags.isNotEmpty)
                        TagList(
                          tags: work.tags,
                          maxLines: 1,
                        ),
                    ],
                  ),
                ),
              ],
            ),
          ),
        );
      },
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\pages\works\components\work_grid.dart
-----------------------------------
import 'package:demo/domain/models/work/work_entity.dart';
import 'package:flutter/material.dart';

import '../../../widgets/common/grid_placeholder.dart';
import 'work_card.dart';

class WorkGrid extends StatelessWidget {
  final List<WorkEntity> works;
  final Function(WorkEntity) onWorkTap;
  final bool isLoading;

  const WorkGrid({
    super.key,
    required this.works,
    required this.onWorkTap,
    this.isLoading = false,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return LayoutBuilder(
      builder: (context, constraints) {
        // Calculate optimal grid dimensions
        final double width = constraints.maxWidth;
        final int crossAxisCount = _calculateCrossAxisCount(width);
        final double itemWidth = width / crossAxisCount;
        final double itemHeight = itemWidth * 1.4; // 10:14 aspect ratio

        // Apply padding for smaller screens
        final double padding = width < 600 ? 8.0 : 16.0;

        return GridView.builder(
          padding: EdgeInsets.all(padding),
          gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(
            crossAxisCount: crossAxisCount,
            childAspectRatio: itemWidth / itemHeight,
            crossAxisSpacing: padding,
            mainAxisSpacing: padding,
          ),
          itemCount: works.length,
          cacheExtent: 500, // Increase cache to reduce rebuilds when scrolling
          itemBuilder: (context, index) {
            // Use indexed key to ensure proper recycling
            return WorkCard(
              key: ValueKey('work-${works[index].id}'),
              work: works[index],
              onTap: () => onWorkTap(works[index]),
            );
          },
        );
      },
    );
  }

  // Calculate optimal number of columns based on screen width
  int _calculateCrossAxisCount(double width) {
    if (width > 1200) return 6;
    if (width > 900) return 5;
    if (width > 600) return 4;
    if (width > 400) return 3;
    return 2;
  }
}

// A placeholder grid to show while loading
class WorkGridPlaceholder extends StatelessWidget {
  final int itemCount;

  const WorkGridPlaceholder({
    super.key,
    this.itemCount = 12,
  });

  @override
  Widget build(BuildContext context) {
    return LayoutBuilder(
      builder: (context, constraints) {
        final double width = constraints.maxWidth;
        final int crossAxisCount = _calculateCrossAxisCount(width);
        final double itemWidth = width / crossAxisCount;
        final double itemHeight = itemWidth * 1.4;
        final double padding = width < 600 ? 8.0 : 16.0;

        return GridView.builder(
          padding: EdgeInsets.all(padding),
          physics: const NeverScrollableScrollPhysics(),
          gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(
            crossAxisCount: crossAxisCount,
            childAspectRatio: itemWidth / itemHeight,
            crossAxisSpacing: padding,
            mainAxisSpacing: padding,
          ),
          itemCount: itemCount,
          itemBuilder: (context, index) {
            return const GridPlaceholder();
          },
        );
      },
    );
  }

  int _calculateCrossAxisCount(double width) {
    if (width > 1200) return 6;
    if (width > 900) return 5;
    if (width > 600) return 4;
    if (width > 400) return 3;
    return 2;
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\pages\works\components\work_images_management_view.dart
-----------------------------------
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../domain/models/work/work_entity.dart';
import '../../../../infrastructure/logging/logger.dart';
import '../../../providers/work_detail_provider.dart';
import '../../../providers/work_image_editor_provider.dart';
import '../../../widgets/works/enhanced_work_preview.dart';

/// 浣滃搧鍥剧墖绠＄悊瑙嗗浘
class WorkImagesManagementView extends ConsumerWidget {
  final WorkEntity work;

  const WorkImagesManagementView({
    super.key,
    required this.work,
  });

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final state = ref.watch(workImageEditorProvider);
    final notifier = ref.read(workImageEditorProvider.notifier);
    final isProcessing = state.isProcessing;
    final currentIndex = ref.watch(currentWorkImageIndexProvider);
    final isInitialized = ref.watch(workImageInitializedProvider);

    // Add debugging to understand what state we're getting
    AppLogger.debug(
      'Building WorkImagesManagementView',
      tag: 'WorkImagesManagementView',
      data: {
        'imageCount': state.images.length,
        'selectedIndex': currentIndex,
        'isProcessing': isProcessing,
        'hasError': state.error != null,
        'workImagesCount': work.images.length,
        'isInitialized': isInitialized,
        'stateMatch': state.images.length == work.images.length,
        'deletedImageCount': state.deletedImageIds.length,
      },
    );

    // Detect inconsistent state with improved logic that accounts for deleted images
    final hasInconsistentState =
        _detectInconsistentState(state, work, isInitialized);

    if (hasInconsistentState) {
      AppLogger.warning(
        'Inconsistent state detected in WorkImagesManagementView',
        tag: 'WorkImagesManagementView',
        data: {
          'workId': work.id,
          'workImagesCount': work.images.length,
          'editorImagesCount': state.images.length,
          'isInitialized': isInitialized,
        },
      );

      // Force reinitialization to recover from inconsistent state
      WidgetsBinding.instance.addPostFrameCallback((_) {
        if (ref.exists(workImageEditorProvider)) {
          ref.read(workImageInitializedProvider.notifier).state = false;
          notifier.reset(); // Clear state first
          notifier.initialize(work.images);

          // After initialization, set the selected index
          final selectedIndex = ref.read(workDetailProvider).selectedImageIndex;
          notifier.updateSelectedIndex(selectedIndex);
        }
      });

      return const Center(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            CircularProgressIndicator(),
            SizedBox(height: 16),
            Text('姝ｅ湪鎭㈠鍥剧墖鏁版嵁...'),
          ],
        ),
      );
    }

    // Check for normal initialization status
    if (!isInitialized && work.images.isNotEmpty) {
      AppLogger.debug(
        'Editor not initialized yet, initializing with work images',
        tag: 'WorkImagesManagementView',
        data: {
          'workId': work.id,
          'workImagesCount': work.images.length,
        },
      );

      // Try initializing the editor
      WidgetsBinding.instance.addPostFrameCallback((_) {
        if (ref.exists(workImageEditorProvider)) {
          notifier.initialize(work.images);

          // After initialization, set the selected index
          final selectedIndex = ref.read(workDetailProvider).selectedImageIndex;
          notifier.updateSelectedIndex(selectedIndex);
        }
      });

      return const Center(
        child: CircularProgressIndicator(),
      );
    }

    // If images are empty but should exist, provide a loading state
    // but don't try to reinitialize here - that's handled by the provider
    if (state.images.isEmpty && work.images.isNotEmpty) {
      AppLogger.warning(
        'Editor has no images but work does',
        tag: 'WorkImagesManagementView',
        data: {
          'workId': work.id,
          'workImageCount': work.images.length,
        },
      );

      return const Center(
        child: CircularProgressIndicator(),
      );
    }

    return LayoutBuilder(
      builder: (context, constraints) {
        final isSmallWidth = constraints.maxWidth < 500;
        final theme = Theme.of(context);

        return Stack(
          children: [
            // Enhanced Work Preview
            EnhancedWorkPreview(
              images: state.images,
              selectedIndex: currentIndex,
              isEditing: true,
              showToolbar: true,
              toolbarActions: [
                // 娣诲姞鍥剧墖鎸夐挳 - 鏀逛负鍥炬爣鎸夐挳
                Tooltip(
                  message: '娣诲姞鍥剧墖',
                  preferBelow: false,
                  decoration: BoxDecoration(
                    color: theme.colorScheme.inverseSurface.withOpacity(0.9),
                    borderRadius: BorderRadius.circular(6),
                  ),
                  child: Container(
                    height: 36,
                    width: 36,
                    decoration: BoxDecoration(
                      color: isProcessing
                          ? theme.colorScheme.primary.withOpacity(0.3)
                          : theme.colorScheme.primary,
                      borderRadius: BorderRadius.circular(6),
                    ),
                    child: IconButton(
                      onPressed:
                          isProcessing ? null : () => notifier.addImages(),
                      icon: const Icon(Icons.add_photo_alternate, size: 20),
                      color: theme.colorScheme.onPrimary,
                      padding: EdgeInsets.zero,
                    ),
                  ),
                ),

                const SizedBox(width: 8),

                // 鍒犻櫎鍥剧墖鎸夐挳 - 鏀逛负鍥炬爣鎸夐挳
                Tooltip(
                  message: '鍒犻櫎褰撳墠鍥剧墖',
                  preferBelow: false,
                  decoration: BoxDecoration(
                    color: theme.colorScheme.inverseSurface.withOpacity(0.9),
                    borderRadius: BorderRadius.circular(6),
                  ),
                  child: Container(
                    height: 36,
                    width: 36,
                    decoration: BoxDecoration(
                      color: Colors.transparent,
                      border: Border.all(
                        color: (isProcessing || state.images.isEmpty)
                            ? theme.colorScheme.error.withOpacity(0.3)
                            : theme.colorScheme.error.withOpacity(0.8),
                        width: 1,
                      ),
                      borderRadius: BorderRadius.circular(6),
                    ),
                    child: IconButton(
                      onPressed: (isProcessing || state.images.isEmpty)
                          ? null
                          : () => _handleDeleteSelected(context, ref),
                      icon: const Icon(Icons.delete_outline, size: 20),
                      color: (isProcessing || state.images.isEmpty)
                          ? theme.colorScheme.error.withOpacity(0.3)
                          : theme.colorScheme.error,
                      padding: EdgeInsets.zero,
                    ),
                  ),
                ),
              ],
              onIndexChanged: isProcessing
                  ? null
                  : (index) => _handleIndexChanged(ref, index),
              onImagesReordered: isProcessing
                  ? null
                  : (oldIndex, newIndex) =>
                      _handleReorder(ref, oldIndex, newIndex),
            ),

            // Error message display
            if (state.error != null)
              Positioned(
                bottom: 0,
                left: 0,
                right: 0,
                child: Material(
                  color: Theme.of(context).colorScheme.errorContainer,
                  child: Padding(
                    padding: const EdgeInsets.all(8.0),
                    child: Text(
                      state.error!,
                      style: TextStyle(
                        color: Theme.of(context).colorScheme.onErrorContainer,
                      ),
                      textAlign: TextAlign.center,
                    ),
                  ),
                ),
              ),

            // Processing overlay
            if (isProcessing)
              Positioned.fill(
                child: Container(
                  color: Colors.black.withOpacity(0.3),
                  child: const Center(
                    child: CircularProgressIndicator(),
                  ),
                ),
              ),
          ],
        );
      },
    );
  }

  /// Helper method to detect inconsistent state with better logic
  bool _detectInconsistentState(
      WorkImageEditorState state, WorkEntity work, bool isInitialized) {
    // If we're not initialized, can't be inconsistent yet
    if (!isInitialized) return false;

    // If we have no images in state but should have some, that's inconsistent
    if (state.images.isEmpty && work.images.isNotEmpty) return true;

    // When adding images, we expect editor to have more images than work entity
    // This is normal during editing and shouldn't trigger a reset
    if (state.images.length > work.images.length) {
      AppLogger.debug(
        'Editor has more images than work - this is expected during editing',
        tag: 'WorkImagesManagementView',
        data: {
          'editorImagesCount': state.images.length,
          'workImagesCount': work.images.length,
          'difference': state.images.length - work.images.length,
        },
      );
      return false; // Not inconsistent, just new images being added
    }

    // If there are deleted images, account for them in the comparison
    final expectedCount = work.images.length - state.deletedImageIds.length;

    // Calculate if we have a legitimate inconsistency
    // Only flag as inconsistent if the current count is less than expected
    // after accounting for deletions - missing images is a real inconsistency
    final countMismatch = state.images.length < expectedCount;

    // Log the decision factors for debugging
    if (countMismatch) {
      AppLogger.debug(
        'Image count mismatch after deletion checks',
        tag: 'WorkImagesManagementView',
        data: {
          'stateImagesCount': state.images.length,
          'workImagesCount': work.images.length,
          'deletedCount': state.deletedImageIds.length,
          'expectedCount': expectedCount,
        },
      );
    }

    return countMismatch;
  }

  /// 澶勭悊鍒犻櫎閫変腑鍥剧墖
  Future<void> _handleDeleteSelected(
      BuildContext context, WidgetRef ref) async {
    try {
      final state = ref.read(workImageEditorProvider);
      if (state.images.isEmpty) {
        AppLogger.warning('Attempted to delete image but no images exist',
            tag: 'WorkImagesManagementView');
        return;
      }

      final notifier = ref.read(workImageEditorProvider.notifier);
      final currentIndex = ref.read(currentWorkImageIndexProvider);

      // Ensure index is valid
      if (currentIndex < 0 || currentIndex >= state.images.length) {
        AppLogger.error('Invalid selected index for deletion',
            tag: 'WorkImagesManagementView',
            data: {
              'currentIndex': currentIndex,
              'imageCount': state.images.length
            });
        return;
      }

      final selectedImage = state.images[currentIndex];

      AppLogger.debug('Preparing to delete image',
          tag: 'WorkImagesManagementView',
          data: {'imageId': selectedImage.id, 'index': currentIndex});

      // 纭鍒犻櫎
      final shouldDelete = await showDialog<bool>(
        context: context,
        barrierDismissible: false, // Prevent dismiss by tapping outside
        builder: (context) => AlertDialog(
          title: const Text('纭鍒犻櫎'),
          content: const Text('纭畾瑕佸垹闄ゅ綋鍓嶉€変腑鐨勫浘鐗囧悧锛?),
          actions: [
            TextButton(
              onPressed: () => Navigator.of(context).pop(false),
              child: const Text('鍙栨秷'),
            ),
            FilledButton(
              onPressed: () => Navigator.of(context).pop(true),
              style: FilledButton.styleFrom(
                backgroundColor: Theme.of(context).colorScheme.error,
                foregroundColor: Theme.of(context).colorScheme.onError,
              ),
              child: const Text('鍒犻櫎'),
            ),
          ],
        ),
      );

      AppLogger.debug('Delete confirmation result',
          tag: 'WorkImagesManagementView', data: {'confirmed': shouldDelete});

      if (shouldDelete == true) {
        // Immediately update UI to show processing state
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('姝ｅ湪鍒犻櫎鍥剧墖...'),
            duration: Duration(seconds: 1),
          ),
        );

        await notifier.deleteImage(selectedImage.id);

        // 濡傛灉鍒犻櫎鍚庢病鏈夊浘鐗囦簡锛屾爣璁颁綔鍝佽鎯呭彂鐢熶簡鍙樺寲
        if (ref.read(workImageEditorProvider).images.isEmpty) {
          ref.read(workDetailProvider.notifier).markAsChanged();
        }
      }
    } catch (e, stack) {
      AppLogger.error('Error in delete operation',
          tag: 'WorkImagesManagementView', error: e, stackTrace: stack);

      if (context.mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('鍒犻櫎鍥剧墖澶辫触: ${e.toString()}'),
            backgroundColor: Theme.of(context).colorScheme.error,
          ),
        );
      }
    }
  }

  /// 澶勭悊鍥剧墖绱㈠紩鍙樺寲
  void _handleIndexChanged(WidgetRef ref, int index) {
    ref.read(currentWorkImageIndexProvider.notifier).state = index;
  }

  /// 澶勭悊鍥剧墖閲嶆柊鎺掑簭
  void _handleReorder(WidgetRef ref, int oldIndex, int newIndex) {
    ref
        .read(workImageEditorProvider.notifier)
        .reorderImages(oldIndex, newIndex);
    // 鏇存柊璇︽儏椤电姸鎬侊紝鏍囪涓哄凡鏇存敼
    ref.read(workDetailProvider.notifier).markAsChanged();
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\pages\works\components\work_tabs.dart
-----------------------------------
import 'package:flutter/material.dart';

/// 浣滃搧璇︽儏椤电殑鏍囩椤电粍浠?
class WorkTabs extends StatelessWidget {
  /// 褰撳墠閫変腑鐨勬爣绛鹃〉绱㈠紩
  final int selectedIndex;

  /// 鏍囩椤靛垏鎹㈠洖璋?
  final Function(int) onTabSelected;

  const WorkTabs({
    super.key,
    required this.selectedIndex,
    required this.onTabSelected,
  });

  @override
  Widget build(BuildContext context) {
    return DefaultTabController(
      length: 3,
      initialIndex: selectedIndex,
      child: TabBar(
        onTap: onTabSelected,
        tabs: const [
          Tab(text: '鍩烘湰淇℃伅'),
          Tab(text: '鏍囩绠＄悊'), // 鍘熶负"鍥剧墖绠＄悊"
          Tab(text: '闆嗗瓧淇℃伅'), // 鍘熶负"瀛楀舰鏍囨敞"
        ],
      ),
    );
  }

  /// 鏋勫缓鍗曚釜鏍囩椤垫寜閽?
  Widget _buildTab(
      BuildContext context, int index, String label, IconData icon) {
    final theme = Theme.of(context);
    final isSelected = selectedIndex == index;

    return InkWell(
      onTap: () => onTabSelected(index),
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
        decoration: BoxDecoration(
          border: Border(
            bottom: BorderSide(
              color:
                  isSelected ? theme.colorScheme.primary : Colors.transparent,
              width: 2.0,
            ),
          ),
        ),
        child: Row(
          children: [
            Icon(
              icon,
              size: 18,
              color: isSelected
                  ? theme.colorScheme.primary
                  : theme.colorScheme.onSurface.withOpacity(0.7),
            ),
            const SizedBox(width: 8),
            Text(
              label,
              style: theme.textTheme.bodyMedium?.copyWith(
                color: isSelected
                    ? theme.colorScheme.primary
                    : theme.colorScheme.onSurface.withOpacity(0.7),
                fontWeight: isSelected ? FontWeight.bold : FontWeight.normal,
              ),
            ),
          ],
        ),
      ),
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\pages\works\components\work_toolbar.dart
-----------------------------------
import 'package:demo/domain/models/work/work_entity.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../infrastructure/logging/logger.dart';
import '../../../widgets/dialogs/confirmation_dialog.dart';

class WorkToolbar extends ConsumerWidget {
  final WorkEntity work;

  const WorkToolbar({
    super.key,
    required this.work,
  });

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return Row(
      children: [
        // 瀵煎嚭鎸夐挳
        IconButton(
          icon: const Icon(Icons.download),
          tooltip: '瀵煎嚭浣滃搧',
          onPressed: () => _exportWork(context),
        ),

        // 缂栬緫鎸夐挳
        IconButton(
          icon: const Icon(Icons.edit),
          tooltip: '缂栬緫浣滃搧',
          onPressed: () => _editWork(context),
        ),

        // 鍏朵粬鎿嶄綔鎸夐挳
        PopupMenuButton<String>(
          icon: const Icon(Icons.more_vert),
          tooltip: '鏇村鎿嶄綔',
          onSelected: (value) => _handleMenuSelection(context, value),
          itemBuilder: (BuildContext context) => [
            const PopupMenuItem<String>(
              value: 'extract',
              child: Row(
                children: [
                  Icon(Icons.text_format, size: 20),
                  SizedBox(width: 8),
                  Text('鎻愬彇瀛楀舰'),
                ],
              ),
            ),
            const PopupMenuItem<String>(
              value: 'share',
              child: Row(
                children: [
                  Icon(Icons.share, size: 20),
                  SizedBox(width: 8),
                  Text('鍒嗕韩浣滃搧'),
                ],
              ),
            ),
            const PopupMenuItem<String>(
              value: 'delete',
              child: Row(
                children: [
                  Icon(Icons.delete, color: Colors.red, size: 20),
                  SizedBox(width: 8),
                  Text('鍒犻櫎浣滃搧', style: TextStyle(color: Colors.red)),
                ],
              ),
            ),
          ],
        ),
      ],
    );
  }

  Future<void> _confirmDelete(BuildContext context) async {
    final confirmed = await showDialog<bool>(
      context: context,
      builder: (context) => ConfirmationDialog(
        title: '鍒犻櫎浣滃搧',
        message: '纭畾瑕佸垹闄や綔鍝併€?{work.title}銆嬪悧锛熸鎿嶄綔涓嶅彲鎾ら攢銆?,
        confirmText: '鍒犻櫎',
        cancelText: '鍙栨秷',
        isDestructive: true,
      ),
    );

    if (confirmed == true) {
      // 鎵ц鍒犻櫎鎿嶄綔
      try {
        await _deleteWork(context);
      } catch (e) {
        AppLogger.error('鍒犻櫎浣滃搧澶辫触',
            tag: 'WorkToolbar', error: e, data: {'workId': work.id});

        if (context.mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            SnackBar(content: Text('鍒犻櫎浣滃搧澶辫触: ${e.toString()}')),
          );
        }
      }
    }
  }

  Future<void> _deleteWork(BuildContext context) async {
    // 杩欓噷搴旇璋冪敤瀹為檯鐨勫垹闄ら€昏緫
    // await ref.read(workServiceProvider).deleteWork(work.id!);

    ScaffoldMessenger.of(context).showSnackBar(
      const SnackBar(content: Text('鍒犻櫎鍔熻兘灏氭湭瀹炵幇')),
    );
  }

  Future<void> _editWork(BuildContext context) async {
    try {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('缂栬緫鍔熻兘灏氭湭瀹炵幇')),
      );
    } catch (e) {
      AppLogger.error('缂栬緫浣滃搧澶辫触',
          tag: 'WorkToolbar', error: e, data: {'workId': work.id});
    }
  }

  Future<void> _exportWork(BuildContext context) async {
    try {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('瀵煎嚭鍔熻兘灏氭湭瀹炵幇')),
      );
    } catch (e) {
      AppLogger.error('瀵煎嚭浣滃搧澶辫触',
          tag: 'WorkToolbar', error: e, data: {'workId': work.id});
    }
  }

  Future<void> _extractCharacters(BuildContext context) async {
    ScaffoldMessenger.of(context).showSnackBar(
      const SnackBar(content: Text('鎻愬彇瀛楀舰鍔熻兘灏氭湭瀹炵幇')),
    );
  }

  Future<void> _handleMenuSelection(BuildContext context, String value) async {
    switch (value) {
      case 'extract':
        _extractCharacters(context);
        break;
      case 'share':
        _shareWork(context);
        break;
      case 'delete':
        _confirmDelete(context);
        break;
    }
  }

  Future<void> _shareWork(BuildContext context) async {
    ScaffoldMessenger.of(context).showSnackBar(
      const SnackBar(content: Text('鍒嗕韩鍔熻兘灏氭湭瀹炵幇')),
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\pages\works\components\content\work_grid_view.dart
-----------------------------------
import 'package:demo/domain/models/work/work_entity.dart';
import 'package:flutter/material.dart';

import '../../../../../theme/app_sizes.dart';
import 'items/work_grid_item.dart';

class WorkGridView extends StatelessWidget {
  final List<WorkEntity> works;
  final bool batchMode;
  final Set<String> selectedWorks;
  final Function(String, bool) onSelectionChanged;
  final Function(String)? onItemTap;

  const WorkGridView({
    super.key,
    required this.works,
    required this.batchMode,
    required this.selectedWorks,
    required this.onSelectionChanged,
    this.onItemTap,
  });

  @override
  Widget build(BuildContext context) {
    return LayoutBuilder(
      builder: (context, constraints) {
        final width = constraints.maxWidth - (AppSizes.m * 2);
        final columns = (width / 280.0).floor();
        final crossAxisCount = columns < 2 ? 2 : columns;

        const spacing = AppSizes.m;
        final availableWidth =
            (width - (spacing * (crossAxisCount - 1))) / crossAxisCount;
        final aspectRatio = availableWidth / (availableWidth * 1.4);

        return GridView.builder(
          padding: const EdgeInsets.all(AppSizes.m),
          gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(
            crossAxisCount: crossAxisCount,
            mainAxisSpacing: spacing,
            crossAxisSpacing: spacing,
            childAspectRatio: aspectRatio,
          ),
          itemCount: works.length,
          itemBuilder: (context, index) {
            final work = works[index];
            return WorkGridItem(
              work: work,
              isSelected: selectedWorks.contains(work.id),
              isSelectionMode: batchMode,
              onTap: () => batchMode
                  ? onSelectionChanged(
                      work.id, !selectedWorks.contains(work.id))
                  : onItemTap?.call(work.id),
            );
          },
        );
      },
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\pages\works\components\content\work_list_view.dart
-----------------------------------
import 'package:demo/domain/models/work/work_entity.dart';
import 'package:flutter/material.dart';

import '../../../../../theme/app_sizes.dart';
import 'items/work_list_item.dart';

class WorkListView extends StatelessWidget {
  final List<WorkEntity> works;
  final bool batchMode;
  final Set<String> selectedWorks;
  final void Function(String workId, bool selected) onSelectionChanged;
  final Function(String)? onItemTap;

  const WorkListView({
    super.key,
    required this.works,
    required this.batchMode,
    required this.selectedWorks,
    required this.onSelectionChanged,
    this.onItemTap,
  });

  @override
  Widget build(BuildContext context) {
    return ListView.separated(
      padding: const EdgeInsets.all(AppSizes.m),
      itemCount: works.length,
      separatorBuilder: (_, __) => const SizedBox(height: AppSizes.s),
      itemBuilder: (context, index) {
        final work = works[index];
        return WorkListItem(
          work: work,
          isSelected: selectedWorks.contains(work.id),
          isSelectionMode: batchMode,
          onTap: () => batchMode
              ? onSelectionChanged(work.id, !selectedWorks.contains(work.id))
              : onItemTap?.call(work.id),
        );
      },
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\pages\works\components\content\items\work_grid_item.dart
-----------------------------------
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../../../application/providers/service_providers.dart';
import '../../../../../../domain/models/work/work_entity.dart';
import '../../../../../../infrastructure/providers/storage_providers.dart';
import '../../../../../../theme/app_colors.dart';
import '../../../../../../theme/app_sizes.dart';
import '../../../../../widgets/image/cached_image.dart';

class WorkGridItem extends ConsumerWidget {
  final WorkEntity work;
  final bool isSelected;
  final bool isSelectionMode;
  final VoidCallback onTap;

  const WorkGridItem({
    super.key,
    required this.work,
    required this.isSelected,
    required this.isSelectionMode,
    required this.onTap,
  });

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final theme = Theme.of(context);

    return Card(
      elevation:
          isSelected ? AppSizes.cardElevationSelected : AppSizes.cardElevation,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(AppSizes.cardRadius),
        side: isSelected
            ? BorderSide(
                color: theme.colorScheme.primary,
                width: 2,
              )
            : BorderSide.none,
      ),
      clipBehavior: Clip.antiAlias,
      child: InkWell(
        onTap: onTap,
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            // 缂╃暐鍥惧尯鍩?- 鍥哄畾瀹藉害锛岀淮鎸佹瘮渚?
            Expanded(
              child: AspectRatio(
                aspectRatio: 4 / 3,
                child: _buildThumbnail(context, ref),
              ),
            ),

            // 搴曢儴淇℃伅鍖哄煙
            Padding(
              padding: const EdgeInsets.all(AppSizes.s),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    work.title,
                    style: theme.textTheme.titleMedium,
                    maxLines: 1,
                    overflow: TextOverflow.ellipsis,
                  ),
                  const SizedBox(height: AppSizes.xs),
                  Text(
                    work.author,
                    style: theme.textTheme.bodySmall,
                    maxLines: 1,
                    overflow: TextOverflow.ellipsis,
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }

  // 鏋勫缓缂╃暐鍥惧崰浣嶇
  Widget _buildPlaceholder(BuildContext context) {
    return Container(
      color: Theme.of(context).colorScheme.surfaceContainerHighest,
      child: const Center(
        child: Icon(
          Icons.image_outlined,
          size: 48,
          color: AppColors.textHint,
        ),
      ),
    );
  }

  // 鏋勫缓缂╃暐鍥?
  Widget _buildThumbnail(BuildContext context, WidgetRef ref) {
    final storage = ref.watch(initializedStorageProvider);
    final workStorage = ref.watch(workStorageProvider);
    final thumbnailPath = workStorage.getWorkCoverThumbnailPath(work.id);

    return FutureBuilder<bool>(
      future: storage.fileExists(thumbnailPath),
      builder: (context, snapshot) {
        if (!snapshot.hasData || !snapshot.data!) {
          return _buildPlaceholder(context);
        }

        return CachedImage(
          path: thumbnailPath,
          fit: BoxFit.cover,
        );
      },
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\pages\works\components\content\items\work_list_item.dart
-----------------------------------
import 'dart:io';

import 'package:demo/domain/models/work/work_entity.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../../../application/providers/service_providers.dart';
import '../../../../../../infrastructure/providers/storage_providers.dart';
import '../../../../../../theme/app_sizes.dart';
import '../../../../../../utils/date_formatter.dart';

class WorkListItem extends ConsumerWidget {
  final WorkEntity work;
  final bool isSelected;
  final bool isSelectionMode;
  final VoidCallback onTap;

  const WorkListItem({
    super.key,
    required this.work,
    required this.isSelected,
    required this.isSelectionMode,
    required this.onTap,
  });

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final theme = Theme.of(context);

    return Card(
      elevation:
          isSelected ? AppSizes.cardElevationSelected : AppSizes.cardElevation,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(AppSizes.cardRadius),
        side: isSelected
            ? BorderSide(
                color: theme.colorScheme.primary,
                width: 2,
              )
            : BorderSide.none,
      ),
      clipBehavior: Clip.antiAlias,
      child: InkWell(
        onTap: onTap,
        child: SizedBox(
          height: 160, // 鍥哄畾楂樺害
          child: Row(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // 缂╃暐鍥惧尯鍩?- 鍥哄畾200px瀹斤紝缁存寔4:3姣斾緥
              SizedBox(
                width: 200,
                child: AspectRatio(
                  aspectRatio: 4 / 3,
                  child: _buildThumbnail(context, ref),
                ),
              ),

              // 鍙充晶鍐呭鍖哄煙
              Expanded(
                child: Padding(
                  padding: const EdgeInsets.all(AppSizes.m),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      // 椤堕儴锛氭爣棰樿
                      Row(
                        children: [
                          Expanded(
                            child: Text(
                              work.title,
                              style: theme.textTheme.titleMedium,
                              maxLines: 1,
                              overflow: TextOverflow.ellipsis,
                            ),
                          ),
                          if (work.imageCount != null && work.imageCount! > 0)
                            _buildImageCount(context, work.imageCount!),
                        ],
                      ),
                      const SizedBox(height: AppSizes.xxs),

                      // 浣滆€呰
                      ...[
                        Text(
                          work.author,
                          style: theme.textTheme.bodyLarge,
                          maxLines: 1,
                          overflow: TextOverflow.ellipsis,
                        ),
                        const SizedBox(height: AppSizes.xs),
                      ],

                      // 椋庢牸鍜屽伐鍏?
                      Row(
                        children: [
                          _buildInfoChip(
                            context,
                            Icons.brush_outlined,
                            work.style.label,
                          ),
                          const SizedBox(width: AppSizes.s),
                          _buildInfoChip(
                            context,
                            Icons.construction_outlined,
                            work.tool.label,
                          ),
                        ],
                      ),
                      const SizedBox(height: AppSizes.xs),

                      // 鍏冩暟鎹俊鎭瑙?- 璁剧疆涓哄彲婊氬姩涓旀湁鏈€澶ч珮搴?
                      Expanded(
                        child: _buildMetadataPreview(context),
                      ),

                      const Spacer(flex: 1),

                      // 搴曢儴鏃ユ湡淇℃伅
                      Row(
                        mainAxisAlignment: MainAxisAlignment.spaceBetween,
                        children: [
                          // 鍒涗綔鏃ユ湡
                          _buildInfoItem(
                            context,
                            Icons.palette_outlined,
                            '鍒涗綔浜?${DateFormatter.formatCompact(work.creationDate)}',
                          ),

                          // 瀵煎叆鏃ユ湡
                          _buildInfoItem(
                            context,
                            Icons.add_circle_outline,
                            '瀵煎叆浜?${DateFormatter.formatCompact(work.createTime)}',
                          ),
                        ],
                      ),
                    ],
                  ),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  // 鏋勫缓鍥剧墖鏁伴噺鎸囩ず鍣?
  Widget _buildImageCount(BuildContext context, int count) {
    final theme = Theme.of(context);
    return Container(
      padding: const EdgeInsets.symmetric(
        horizontal: AppSizes.xs,
        vertical: 2,
      ),
      decoration: BoxDecoration(
        color: theme.colorScheme.primaryContainer,
        borderRadius: BorderRadius.circular(AppSizes.radiusSmall),
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(Icons.photo_library_outlined,
              size: 16, color: theme.colorScheme.onPrimaryContainer),
          const SizedBox(width: 4),
          Text(
            count.toString(),
            style: theme.textTheme.labelMedium?.copyWith(
              color: theme.colorScheme.onPrimaryContainer,
            ),
          ),
        ],
      ),
    );
  }

  // 鏋勫缓甯﹀浘鏍囩殑淇℃伅灏忔爣绛?
  Widget _buildInfoChip(BuildContext context, IconData icon, String text) {
    final theme = Theme.of(context);
    return Container(
      padding: const EdgeInsets.symmetric(
        horizontal: AppSizes.xs,
        vertical: 2,
      ),
      decoration: BoxDecoration(
        color: theme.colorScheme.secondaryContainer.withOpacity(0.7),
        borderRadius: BorderRadius.circular(AppSizes.radiusSmall),
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(icon, size: 14, color: theme.colorScheme.onSecondaryContainer),
          const SizedBox(width: 4),
          Text(
            text,
            style: theme.textTheme.bodySmall?.copyWith(
              color: theme.colorScheme.onSecondaryContainer,
            ),
          ),
        ],
      ),
    );
  }

  // 鏋勫缓甯﹀浘鏍囩殑淇℃伅椤?
  Widget _buildInfoItem(BuildContext context, IconData icon, String text) {
    final theme = Theme.of(context);
    return Row(
      mainAxisSize: MainAxisSize.min,
      children: [
        Icon(icon, size: 14, color: theme.colorScheme.onSurfaceVariant),
        const SizedBox(width: 4),
        Text(
          text,
          style: theme.textTheme.bodySmall?.copyWith(
            color: theme.colorScheme.onSurfaceVariant,
          ),
        ),
      ],
    );
  }

  // 鏋勫缓鍏冩暟鎹瑙?
  Widget _buildMetadataPreview(BuildContext context) {
    final tags = work.tags;

    if (tags.isEmpty) {
      return const SizedBox.shrink();
    }

    // 鏄剧ず鏍囩
    return Container(
      constraints: const BoxConstraints(maxHeight: 48), // 闄愬埗鏈€澶ч珮搴?
      child: SingleChildScrollView(
        child: Wrap(
          spacing: 4,
          runSpacing: 4,
          children: tags.map((tag) => _buildTagChip(context, tag)).toList(),
        ),
      ),
    );
  }

  // 鏋勫缓缂╃暐鍥惧崰浣嶇
  Widget _buildPlaceholder(BuildContext context) {
    return Container(
      color: Theme.of(context).colorScheme.surfaceContainerHighest,
      child: Center(
        child: Icon(
          Icons.image_outlined,
          size: 48,
          color:
              Theme.of(context).colorScheme.onSurfaceVariant.withOpacity(0.5),
        ),
      ),
    );
  }

  // 鏋勫缓鏍囩
  Widget _buildTagChip(BuildContext context, String tag) {
    final theme = Theme.of(context);
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2),
      decoration: BoxDecoration(
        color: theme.colorScheme.primary.withOpacity(0.1),
        borderRadius: BorderRadius.circular(4),
      ),
      child: Text(
        '#$tag',
        style: theme.textTheme.bodySmall?.copyWith(
          color: theme.colorScheme.primary,
          fontSize: 12,
        ),
      ),
    );
  }

  // 鏋勫缓缂╃暐鍥?
  Widget _buildThumbnail(BuildContext context, WidgetRef ref) {
    final storage = ref.watch(initializedStorageProvider);
    final workStorage = ref.watch(workStorageProvider);
    final thumbnailPath = workStorage.getWorkCoverThumbnailPath(work.id);

    return FutureBuilder<bool>(
      future: storage.fileExists(thumbnailPath),
      builder: (context, existsSnapshot) {
        if (!existsSnapshot.hasData || !existsSnapshot.data!) {
          return _buildPlaceholder(context);
        }

        return Image.file(
          File(thumbnailPath),
          fit: BoxFit.cover,
          errorBuilder: (_, __, ___) => _buildPlaceholder(context),
        );
      },
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\pages\works\components\filter\date_range_filter_section.dart
-----------------------------------
import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'package:logging/logging.dart';

import '../../../../../domain/models/common/date_range_filter.dart';
import '../../../../../theme/app_sizes.dart';

class DateRangeFilterSection extends StatefulWidget {
  final DateRangeFilter? filter;
  final ValueChanged<DateRangeFilter?> onChanged;

  const DateRangeFilterSection({
    super.key,
    this.filter,
    required this.onChanged,
  });

  @override
  State<DateRangeFilterSection> createState() => _DateRangeFilterSectionState();
}

class _DateRangeFilterSectionState extends State<DateRangeFilterSection>
    with SingleTickerProviderStateMixin {
  late TabController _tabController;
  final _logger = Logger('DateRangeFilterSection');
  DateTime? _startDate;
  DateTime? _endDate;

  bool get _hasSelection => _startDate != null || _endDate != null;

  bool get _hasValidRange =>
      _startDate != null && _endDate != null && _startDate!.isBefore(_endDate!);

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    final filter = widget.filter;
    final bool showResetChip = filter != null &&
        ((filter.preset != null && filter.preset != DateRangePreset.all) ||
            filter.start != null ||
            filter.end != null);

    _logger.fine('build - filter: $filter, showResetChip: $showResetChip');

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        if (showResetChip)
          Padding(
            padding: const EdgeInsets.only(bottom: AppSizes.s),
            child: Row(
              children: [
                Expanded(
                  child: Chip(
                    label: Text(_formatFilterText()),
                    onDeleted: () {
                      _logger.info('鐐瑰嚮鍒犻櫎鎸夐挳');
                      widget.onChanged(null);
                    },
                  ),
                ),
              ],
            ),
          ),
        TabBar(
          controller: _tabController,
          tabs: const [
            Tab(text: '棰勮'),
            Tab(text: '鑷畾涔?),
          ],
        ),
        const SizedBox(height: AppSizes.m),
        SizedBox(
          height: 240,
          child: TabBarView(
            controller: _tabController,
            children: [
              _buildPresets(theme),
              _buildCustomRange(context),
            ],
          ),
        ),
      ],
    );
  }

  @override
  void dispose() {
    _tabController.dispose();
    super.dispose();
  }

  @override
  void initState() {
    super.initState();
    _tabController = TabController(length: 2, vsync: this);
    _tabController.index = 0;
    _startDate = widget.filter?.start;
    _endDate = widget.filter?.end;
  }

  void _applyDateRange() {
    if (_hasValidRange) {
      _logger.fine('搴旂敤鏃ユ湡鑼冨洿 - 寮€濮? $_startDate, 缁撴潫: $_endDate');
      widget.onChanged(DateRangeFilter(
        start: _startDate,
        end: _endDate,
      ));
    }
  }

  Widget _buildCustomRange(BuildContext context) {
    return Column(
      mainAxisSize: MainAxisSize.min,
      crossAxisAlignment: CrossAxisAlignment.stretch,
      children: [
        _buildDateField(
          context: context,
          label: '寮€濮嬫棩鏈?,
          value: _startDate,
          onPressed: () => _selectDate(context, true),
        ),
        const SizedBox(height: AppSizes.m),
        _buildDateField(
          context: context,
          label: '缁撴潫鏃ユ湡',
          value: _endDate,
          onPressed: () => _selectDate(context, false),
        ),
        if (_hasSelection) ...[
          const SizedBox(height: AppSizes.l),
          Row(
            children: [
              if (_hasValidRange)
                Expanded(
                  child: FilledButton(
                    onPressed: _applyDateRange,
                    child: const Text('搴旂敤'),
                  ),
                ),
              if (_hasValidRange) const SizedBox(width: AppSizes.s),
              Expanded(
                child: TextButton(
                  onPressed: _clearDateRange,
                  child: const Text('娓呴櫎'),
                ),
              ),
            ],
          ),
        ],
      ],
    );
  }

  Widget _buildDateField({
    required BuildContext context,
    required String label,
    required DateTime? value,
    required VoidCallback onPressed,
  }) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(label, style: Theme.of(context).textTheme.titleSmall),
        const SizedBox(height: AppSizes.xs),
        SizedBox(
          width: double.infinity,
          child: OutlinedButton.icon(
            icon: const Icon(Icons.calendar_today, size: 18),
            label: Text(value != null ? _formatDate(value) : '鐐瑰嚮閫夋嫨鏃ユ湡'),
            onPressed: onPressed,
          ),
        ),
      ],
    );
  }

  Widget _buildPresets(ThemeData theme) {
    return SingleChildScrollView(
      padding: const EdgeInsets.all(AppSizes.s),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.stretch,
        children: [
          Wrap(
            spacing: AppSizes.xs,
            runSpacing: AppSizes.xs,
            children: DateRangePreset.values
                .where((preset) => preset != DateRangePreset.all)
                .map((preset) {
              final selected = widget.filter?.preset == preset;
              return FilterChip(
                label: Text(preset.label),
                selected: selected,
                onSelected: (selected) {
                  _logger.fine('閫夋嫨棰勮: $preset, selected: $selected');
                  if (selected) {
                    widget.onChanged(DateRangeFilter.preset(preset));
                  } else {
                    widget.onChanged(null);
                  }
                },
                showCheckmark: false,
                selectedColor: theme.colorScheme.primaryContainer,
              );
            }).toList(),
          ),
          if (widget.filter?.preset != null) ...[
            const SizedBox(height: AppSizes.m),
            Text(
              _getPresetDateRange(widget.filter!.preset!),
              style: theme.textTheme.bodySmall,
            ),
          ],
        ],
      ),
    );
  }

  void _clearDateRange() {
    setState(() {
      _startDate = null;
      _endDate = null;
      widget.onChanged(null);
    });
  }

  String _formatDate(DateTime date) {
    return DateFormat('yyyy-MM-dd').format(date);
  }

  String _formatFilterText() {
    final filter = widget.filter;
    if (filter == null) return '';

    if (filter.preset != null && filter.preset != DateRangePreset.all) {
      return filter.preset!.label;
    }

    if (filter.start != null || filter.end != null) {
      final start = filter.start != null ? _formatDate(filter.start!) : '寮€濮嬫棩鏈?;
      final end = filter.end != null ? _formatDate(filter.end!) : '缁撴潫鏃ユ湡';
      return '$start - $end';
    }

    return '';
  }

  String _getPresetDateRange(DateRangePreset preset) {
    final range = preset.getRange();
    return '${_formatDate(range.start)} - ${_formatDate(range.end)}';
  }

  Future<void> _selectDate(BuildContext context, bool isStartDate) async {
    final initialDate = isStartDate ? _startDate : _endDate;

    final result = await showDatePicker(
      context: context,
      initialDate: initialDate ?? DateTime.now(),
      firstDate: DateTime(1900),
      lastDate: DateTime(2100),
    );

    if (result != null) {
      setState(() {
        if (isStartDate) {
          _startDate = result;
        } else {
          _endDate = result;
        }
      });
    }
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\pages\works\components\filter\date_section.dart
-----------------------------------
import 'package:flutter/material.dart';

import '../../../../../domain/models/common/date_range_filter.dart';
import '../../../../../domain/models/work/work_filter.dart';
import '../../../../../theme/app_sizes.dart';
import 'date_range_filter_section.dart';

class DateSection extends StatelessWidget {
  final WorkFilter filter;
  final ValueChanged<WorkFilter> onFilterChanged;

  const DateSection({
    super.key,
    required this.filter,
    required this.onFilterChanged,
  });

  @override
  Widget build(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text('鍒涗綔鏃堕棿', style: Theme.of(context).textTheme.titleMedium),
        const SizedBox(height: AppSizes.s),
        DateRangeFilterSection(
          filter: DateRangeFilter(
            preset: filter.datePreset,
            start: filter.dateRange?.start,
            end: filter.dateRange?.end,
          ),
          onChanged: (dateFilter) {
            if (dateFilter == null) {
              // 濡傛灉鏃ユ湡绛涢€夎娓呴櫎锛岄噸缃墍鏈夌浉鍏冲瓧娈?
              onFilterChanged(filter.copyWith(
                datePreset: DateRangePreset.all,
                dateRange: null,
              ));
            } else {
              onFilterChanged(filter.copyWith(
                datePreset: dateFilter.preset ?? DateRangePreset.all,
                dateRange: dateFilter.effectiveRange,
              ));
            }
          },
        ),
      ],
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\pages\works\components\filter\filter_chip_group.dart
-----------------------------------
import 'package:flutter/material.dart';

class FilterChipGroup extends StatelessWidget {
  final String label;
  final List<String> options;
  final String? selected;
  final ValueChanged<String?> onSelected;

  const FilterChipGroup({
    super.key,
    required this.label,
    required this.options,
    required this.onSelected,
    this.selected,
  });

  @override
  Widget build(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(label, style: Theme.of(context).textTheme.titleSmall),
        const SizedBox(height: 8),
        Wrap(
          spacing: 8,
          runSpacing: 8,
          children: options.map((option) {
            return FilterChip(
              label: Text(option),
              selected: option == selected,
              onSelected: (value) => onSelected(value ? option : null),
            );
          }).toList(),
        ),
      ],
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\pages\works\components\filter\sort_section.dart
-----------------------------------
import 'package:flutter/material.dart';

import '../../../../../domain/enums/sort_field.dart';
import '../../../../../domain/models/common/sort_option.dart';
import '../../../../../domain/models/work/work_filter.dart';
import '../../../../../theme/app_sizes.dart';

class SortSection extends StatelessWidget {
  // 榛樿鎺掑簭閫夐」
  static final defaultSortOption =
      const SortOption(field: SortField.createTime, descending: true);
  final WorkFilter filter;

  final ValueChanged<WorkFilter> onFilterChanged;

  const SortSection({
    super.key,
    required this.filter,
    required this.onFilterChanged,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Row(
          children: [
            Text('鎺掑簭', style: theme.textTheme.titleMedium),
            const SizedBox(width: AppSizes.s),
            Container(
              padding: const EdgeInsets.symmetric(
                horizontal: AppSizes.s,
                vertical: AppSizes.xs,
              ),
              decoration: BoxDecoration(
                color: theme.colorScheme.secondaryContainer,
                borderRadius: BorderRadius.circular(AppSizes.s),
              ),
              child: InkWell(
                onTap: () => onFilterChanged(filter.copyWith(
                    sortOption: filter.sortOption
                        .copyWith(descending: !filter.sortOption.descending))),
                child: Row(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    Text(
                      filter.sortOption.descending ? '闄嶅簭' : '鍗囧簭',
                      style: theme.textTheme.bodySmall?.copyWith(
                        color: theme.colorScheme.onSecondaryContainer,
                      ),
                    ),
                    const SizedBox(width: 4),
                    Icon(
                      Icons.sort,
                      size: 18,
                      textDirection: filter.sortOption.descending
                          ? TextDirection.rtl
                          : TextDirection.ltr,
                      color: theme.colorScheme.onSecondaryContainer,
                    ),
                  ],
                ),
              ),
            ),
          ],
        ),
        const SizedBox(height: AppSizes.s),
        ...SortField.values
            .where((field) => field != SortField.none)
            .map((field) => _buildSortItem(field, field.label, theme)),
      ],
    );
  }

  Widget _buildSortItem(
    SortField field,
    String label,
    ThemeData theme,
  ) {
    final bool selected = filter.sortOption.field == field;

    return Material(
      color:
          selected ? theme.colorScheme.secondaryContainer : Colors.transparent,
      borderRadius: BorderRadius.circular(AppSizes.s),
      child: InkWell(
        borderRadius: BorderRadius.circular(AppSizes.s),
        onTap: () {
          // 濡傛灉鐐瑰嚮褰撳墠閫変腑鐨勯」锛岄噸缃负榛樿鎺掑簭
          if (selected) {
            onFilterChanged(filter.copyWith(
              sortOption: defaultSortOption,
            ));
          } else {
            // 閫夋嫨鏂扮殑鎺掑簭瀛楁
            onFilterChanged(filter.copyWith(
              sortOption: filter.sortOption.copyWith(field: field),
            ));
          }
        },
        child: Container(
          width: double.infinity,
          padding: const EdgeInsets.symmetric(
            horizontal: AppSizes.m,
            vertical: AppSizes.s,
          ),
          child: Row(
            children: [
              SizedBox(
                width: 18,
                height: 18,
                child: Radio<SortField>(
                  value: field,
                  groupValue: selected ? field : null,
                  onChanged: (_) {
                    // 濡傛灉鐐瑰嚮褰撳墠閫変腑鐨勯」锛岄噸缃负榛樿鎺掑簭
                    if (selected) {
                      onFilterChanged(filter.copyWith(
                        sortOption: defaultSortOption,
                      ));
                    } else {
                      onFilterChanged(filter.copyWith(
                        sortOption: filter.sortOption.copyWith(field: field),
                      ));
                    }
                  },
                  visualDensity: VisualDensity.compact,
                ),
              ),
              const SizedBox(width: AppSizes.s),
              Expanded(
                child: Text(
                  label,
                  style: theme.textTheme.bodyMedium?.copyWith(
                    color: selected
                        ? theme.colorScheme.onSecondaryContainer
                        : theme.colorScheme.onSurface,
                  ),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\pages\works\components\filter\style_section.dart
-----------------------------------
import 'package:flutter/material.dart';

import '../../../../../domain/enums/work_style.dart';
import '../../../../../domain/models/work/work_filter.dart';
import 'work_filter_section.dart';

class StyleSection extends StatelessWidget {
  final WorkFilter filter;
  final ValueChanged<WorkFilter> onFilterChanged;

  const StyleSection({
    super.key,
    required this.filter,
    required this.onFilterChanged,
  });

  @override
  Widget build(BuildContext context) {
    return WorkFilterSection(
      title: '涔︽硶椋庢牸',
      child: _buildStyleChips(context),
    );
  }

  Widget _buildStyleChips(BuildContext context) {
    return Wrap(
      spacing: 8,
      runSpacing: 8,
      children: WorkStyle.values.map((style) {
        final selected = filter.style?.value == style.value;
        return FilterChip(
          label: Text(style.label),
          selected: selected,
          onSelected: (value) {
            // 濡傛灉鏄彇娑堥€夋嫨鎴栬€呯偣鍑诲綋鍓嶅凡閫変腑鐨勯」锛屽垯娓呴櫎閫夋嫨
            final newStyle = selected ? null : WorkStyle.fromValue(style.value);
            onFilterChanged(
              filter.copyWith(style: newStyle),
            );
          },
        );
      }).toList(),
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\pages\works\components\filter\tool_section.dart
-----------------------------------
import 'package:flutter/material.dart';

import '../../../../../domain/enums/work_tool.dart';
import '../../../../../domain/models/work/work_filter.dart';
import 'work_filter_section.dart';

class ToolSection extends StatelessWidget {
  final WorkFilter filter;
  final ValueChanged<WorkFilter> onFilterChanged;

  const ToolSection({
    super.key,
    required this.filter,
    required this.onFilterChanged,
  });

  @override
  Widget build(BuildContext context) {
    return WorkFilterSection(
      title: '涔﹀啓宸ュ叿',
      child: _buildToolChips(context),
    );
  }

  Widget _buildToolChips(BuildContext context) {
    return Wrap(
      spacing: 8,
      runSpacing: 8,
      children: WorkTool.values.map((tool) {
        final selected = filter.tool?.value == tool.value;
        return FilterChip(
          label: Text(tool.label),
          selected: selected,
          onSelected: (value) {
            // 濡傛灉鏄彇娑堥€夋嫨鎴栬€呯偣鍑诲綋鍓嶅凡閫変腑鐨勯」锛屽垯娓呴櫎閫夋嫨
            final newTool = selected ? null : WorkTool.fromValue(tool.value);
            onFilterChanged(
              filter.copyWith(tool: newTool),
            );
          },
        );
      }).toList(),
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\pages\works\components\filter\work_filter_panel.dart
-----------------------------------
import 'package:flutter/material.dart';

import '../../../../../domain/models/work/work_filter.dart';
import '../../../../../theme/app_sizes.dart';
import 'date_section.dart';
import 'sort_section.dart';
import 'style_section.dart';
import 'tool_section.dart';

class WorkFilterPanel extends StatelessWidget {
  final WorkFilter filter;
  final ValueChanged<WorkFilter> onFilterChanged;

  const WorkFilterPanel({
    super.key,
    required this.filter,
    required this.onFilterChanged,
  });

  @override
  Widget build(BuildContext context) {
    return Material(
      color: Theme.of(context).colorScheme.surface,
      child: Container(
        width: 280,
        padding: const EdgeInsets.all(AppSizes.m),
        // 绉婚櫎鎵€鏈夎竟妗嗙嚎
        // decoration: BoxDecoration(
        //   border: Border(
        //     right: BorderSide(
        //       color: Theme.of(context).dividerColor,
        //     ),
        //   ),
        // ),
        child: CustomScrollView(
          slivers: [
            SliverToBoxAdapter(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  SortSection(
                    filter: filter,
                    onFilterChanged: onFilterChanged,
                  ),
                  const Divider(height: AppSizes.l),
                  StyleSection(
                    filter: filter,
                    onFilterChanged: onFilterChanged,
                  ),
                  const Divider(height: AppSizes.l),
                  ToolSection(
                    filter: filter,
                    onFilterChanged: onFilterChanged,
                  ),
                  const Divider(height: AppSizes.l),
                  DateSection(
                    filter: filter,
                    onFilterChanged: onFilterChanged,
                  ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\pages\works\components\filter\work_filter_section.dart
-----------------------------------
import 'package:flutter/material.dart';

class WorkFilterSection extends StatelessWidget {
  final String title;
  final Widget child;
  final List<Widget>? actions;

  const WorkFilterSection({
    super.key,
    required this.title,
    required this.child,
    this.actions,
  });

  @override
  Widget build(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.stretch,
      children: [
        _buildHeader(context),
        const SizedBox(height: 8),
        child,
      ],
    );
  }

  Widget _buildHeader(BuildContext context) {
    return Row(
      children: [
        Text(
          title,
          style: Theme.of(context).textTheme.titleMedium,
        ),
        if (actions != null) ...[
          const Spacer(),
          ...actions!,
        ],
      ],
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\pages\works\components\layout\work_layout.dart
-----------------------------------
import 'package:flutter/material.dart';

class WorkLayout extends StatelessWidget {
  final Widget child;
  final Widget filterPanel;

  const WorkLayout({
    super.key,
    required this.child,
    required this.filterPanel,
  });

  @override
  Widget build(BuildContext context) {
    return Row(
      crossAxisAlignment: CrossAxisAlignment.stretch,
      children: [
        Expanded(child: child),
        filterPanel,
      ],
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\pages\works\components\toolbar\batch_mode.dart
-----------------------------------
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../providers/work_browse_provider.dart';

class BatchModeSection extends ConsumerWidget {
  const BatchModeSection({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final viewModel = ref.read(workBrowseProvider.notifier);
    final state = ref.watch(workBrowseProvider);
    
    return Row(
      children: [
        TextButton.icon(
          icon: Icon(state.batchMode ? Icons.close : Icons.checklist),
          label: Text(state.batchMode ? '瀹屾垚' : '鎵归噺澶勭悊'),
          onPressed: () => viewModel.toggleBatchMode(),
        ),
        if (state.batchMode && state.selectedWorks.isNotEmpty) ...[
          Text('宸查€夋嫨 ${state.selectedWorks.length} 椤?),
          FilledButton.tonalIcon(
            icon: const Icon(Icons.delete),
            label: Text('鍒犻櫎${state.selectedWorks.length}椤?),
            onPressed: () => viewModel.deleteSelected(),
          ),
        ],
      ],
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\pages\works\components\toolbar\batch_mode_button.dart
-----------------------------------
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../providers/work_browse_provider.dart';

class BatchModeButton extends ConsumerWidget {
  const BatchModeButton({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final viewModel = ref.read(workBrowseProvider.notifier);
    final state = ref.watch(workBrowseProvider);

    return TextButton.icon(
      icon: Icon(state.batchMode ? Icons.close : Icons.checklist),
      label: Text(state.batchMode ? '瀹屾垚' : '鎵归噺澶勭悊'),
      onPressed: () {
        viewModel.toggleBatchMode();
        // 閫€鍑烘壒閲忔ā寮忔椂娓呯┖閫夋嫨
        if (state.batchMode) {
          viewModel.clearSelection();
        }
      },
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\pages\works\components\toolbar\delete_button.dart
-----------------------------------
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../providers/work_browse_provider.dart';

class DeleteButton extends ConsumerWidget {
  const DeleteButton({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final state = ref.watch(workBrowseProvider);
    final viewModel = ref.read(workBrowseProvider.notifier);

    if (!state.batchMode || state.selectedWorks.isEmpty) {
      return const SizedBox.shrink();
    }

    return FilledButton.tonalIcon(
      icon: const Icon(Icons.delete),
      label: Text('鍒犻櫎${state.selectedWorks.length}椤?),
      onPressed: () async {
        final confirmed = await showDialog<bool>(
          context: context,
          builder: (context) => AlertDialog(
            title: const Text('纭鍒犻櫎'),
            content: Text('纭畾瑕佸垹闄ら€変腑鐨?${state.selectedWorks.length} 涓綔鍝佸悧锛?),
            actions: [
              TextButton(
                child: const Text('鍙栨秷'),
                onPressed: () => Navigator.pop(context, false),
              ),
              FilledButton(
                child: const Text('鍒犻櫎'),
                onPressed: () => Navigator.pop(context, true),
              ),
            ],
          ),
        );

        if (confirmed == true) {
          await viewModel.deleteSelected();
        }
      },
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\pages\works\components\toolbar\import_button.dart
-----------------------------------
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../dialogs/work_import/work_import_dialog.dart';
import '../../../../providers/work_browse_provider.dart';
import '../../../../viewmodels/work_browse_view_model.dart';

class ImportButton extends ConsumerWidget {
  const ImportButton({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final viewModel = ref.read(workBrowseProvider.notifier);

    return FilledButton.icon(
      icon: const Icon(Icons.add),
      label: const Text('瀵煎叆浣滃搧'),
      onPressed: () => _showImportDialog(context, viewModel),
    );
  }

  Future<void> _showImportDialog(
      BuildContext context, WorkBrowseViewModel viewModel) async {
    try {
      // 鏄剧ず瀵煎叆瀵硅瘽妗?
      final result = await showDialog<bool>(
        context: context,
        barrierDismissible: false,
        builder: (context) => const WorkImportDialog(),
      );

      if (result == true) {
        // 鏄剧ず鍔犺浇鎸囩ず鍣?
        if (context.mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(content: Text('姝ｅ湪鍒锋柊浣滃搧鍒楄〃...')),
          );
        }

        // 鍒锋柊鍒楄〃
        await viewModel.loadWorks();

        // 鏄剧ず鎴愬姛鎻愮ず
        if (context.mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(content: Text('浣滃搧瀵煎叆鎴愬姛')),
          );
        }
      }
    } catch (e) {
      if (context.mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('瀵煎叆澶辫触: ${e.toString()}')),
        );
      }
    }
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\pages\works\components\toolbar\search_field.dart
-----------------------------------
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../providers/work_browse_provider.dart';

class SearchField extends ConsumerWidget {
  const SearchField({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final viewModel = ref.read(workBrowseProvider.notifier);
    final state = ref.watch(workBrowseProvider);

    return SizedBox(
      width: 240,
      child: TextField(
        controller: state.searchController,
        decoration: InputDecoration(
          hintText: '鎼滅储浣滃搧...',
          prefixIcon: const Icon(Icons.search),
          border: OutlineInputBorder(
            borderRadius: BorderRadius.circular(8),
          ),
          // 鏀硅繘娓呯┖鎸夐挳閫昏緫
          suffixIcon: state.searchController.text.isNotEmpty
              ? IconButton(
                  icon: const Icon(Icons.clear),
                  onPressed: () {
                    state.searchController.clear();
                    viewModel.setSearchQuery('');
                    viewModel.loadWorks(); // 娓呯┖鍚庨噸鏂板姞杞?
                  },
                )
              : null,
        ),
        // 浣跨敤 ViewModel 涓殑闃叉姈鏂规硶
        onChanged: viewModel.setSearchQuery,
      ),
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\pages\works\components\toolbar\view_mode_toggle.dart
-----------------------------------
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../../providers/work_browse_provider.dart';
import '../../../../viewmodels/states/work_browse_state.dart';

class ViewModeToggle extends ConsumerWidget {
  const ViewModeToggle({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final state = ref.watch(workBrowseProvider);
    final viewModel = ref.read(workBrowseProvider.notifier);

    return Tooltip(
      message: state.viewMode == ViewMode.grid ? '鍒囨崲鍒板垪琛ㄨ鍥? : '鍒囨崲鍒扮綉鏍艰鍥?,
      child: IconButton(
        icon: AnimatedSwitcher(
          duration: const Duration(milliseconds: 200),
          child: Icon(
            state.viewMode == ViewMode.grid ? Icons.view_list : Icons.grid_view,
            key: ValueKey(state.viewMode),
          ),
        ),
        onPressed: viewModel.toggleViewMode,
      ),
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\providers\character_detail_provider.dart
-----------------------------------
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../application/providers/repository_providers.dart';
import '../../domain/models/character/character_entity.dart';

/// 瑙掕壊璇︽儏鎻愪緵鑰?
final characterDetailProvider =
    FutureProvider.family<CharacterEntity?, String>((ref, id) async {
  final repository = ref.watch(characterRepositoryProvider);
  return repository.get(id);
});

/// 瑙掕壊鏈嶅姟鎻愪緵鑰?
// final characterServiceProvider = Provider<CharacterService>((ref) {
//   return CharacterService(
//     repository: ref.watch(characterRepositoryProvider),
//   );
// });



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\providers\error_boundary_provider.dart
-----------------------------------
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

final errorBoundaryProvider = Provider<ErrorBoundary>((ref) {
  return ErrorBoundary();
});

class ErrorBoundary {
  Future<T> runWithBoundary<T>(
    BuildContext context,
    Future<T> Function() operation,
  ) async {
    try {
      return await operation();
    } catch (e) {
      // 閿欒杈圭晫澶勭悊
      _showErrorDialog(context, e.toString());
      rethrow;
    }
  }

  void _showErrorDialog(BuildContext context, String message) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('鎿嶄綔澶辫触'),
        content: Text(message),
        actions: [
          TextButton(
            child: const Text('纭畾'),
            onPressed: () => Navigator.pop(context),
          ),
        ],
      ),
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\providers\error_handler_provider.dart
-----------------------------------
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

final errorHandlerProvider = Provider<ErrorHandler>((ref) {
  return ErrorHandler();
});

class ErrorHandler {
  String getErrorMessage(Object error) {
    // 娣诲姞閿欒娑堟伅杞崲閫昏緫
    if (error is Exception) {
      return error.toString().replaceAll('Exception:', '');
    }
    return error.toString();
  }

  void handleError(Object error, StackTrace? stackTrace) {
    // 閿欒澶勭悊閫昏緫
  }

  Future<void> recoverFromError() async {
    // 閿欒鎭㈠閫昏緫
  }

  void showErrorDialog(BuildContext context, String message) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('閿欒'),
        content: Text(message),
        actions: [
          TextButton(
            child: const Text('纭畾'),
            onPressed: () => Navigator.of(context).pop(),
          ),
        ],
      ),
    );
  }

  void showErrorSnackBar(BuildContext context, String message) {
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text(message),
        backgroundColor: Theme.of(context).colorScheme.error,
      ),
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\providers\error_provider.dart
-----------------------------------
import 'package:flutter_riverpod/flutter_riverpod.dart';

final errorProvider = StateNotifierProvider<ErrorNotifier, String?>((ref) {
  return ErrorNotifier();
});

class ErrorNotifier extends StateNotifier<String?> {
  ErrorNotifier() : super(null);

  void setError(String? error) => state = error;
  void clearError() => state = null;

  Future<T> handleError<T>(Future<T> Function() task) async {
    try {
      clearError();
      return await task();
    } catch (e) {
      setError(e.toString());
      rethrow;
    }
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\providers\loading_provider.dart
-----------------------------------
import 'package:flutter_riverpod/flutter_riverpod.dart';

final loadingProvider = StateProvider<bool>((ref) => false);
final loadingMessageProvider = StateProvider<String?>((ref) => null);

class LoadingNotifier extends StateNotifier<bool> {
  LoadingNotifier() : super(false);

  void startLoading() => state = true;
  void stopLoading() => state = false;
  
  Future<T> runWithLoading<T>(Future<T> Function() task) async {
    try {
      startLoading();
      return await task();
    } finally {
      stopLoading();
    }
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\providers\practice_detail_provider.dart
-----------------------------------
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../application/providers/repository_providers.dart';
import '../../application/services/practice/practice_service.dart';
import '../../domain/models/practice/practice_entity.dart';
import '../../domain/models/practice/practice_layer.dart';
import '../../domain/models/practice/practice_page.dart';

/// 缁冧範璇︽儏Provider
final practiceDetailProvider = StateNotifierProvider.family<
    PracticeDetailNotifier, PracticeDetailState, String>(
  (ref, id) {
    final service =
        PracticeService(repository: ref.watch(practiceRepositoryProvider));
    return PracticeDetailNotifier(service: service)..loadPractice(id);
  },
);

/// 缁冧範璇︽儏Notifier
class PracticeDetailNotifier extends StateNotifier<PracticeDetailState> {
  final PracticeService _service;
  String? _currentId;

  PracticeDetailNotifier({
    required PracticeService service,
  })  : _service = service,
        super(const PracticeDetailState());

  /// 娣诲姞鍥惧眰
  Future<void> addLayer(int pageIndex, PracticeLayer layer) async {
    if (state.practice == null) return;
    try {
      final page =
          state.practice!.pages.firstWhere((p) => p.index == pageIndex);
      final updatedPage = page.addLayer(layer);
      final updated = state.practice!.updatePage(updatedPage);
      await _service.updatePractice(updated);
      state = state.copyWith(practice: updated);
    } catch (e) {
      state = state.copyWith(error: '娣诲姞鍥惧眰澶辫触: $e');
    }
  }

  /// 娣诲姞椤甸潰
  Future<void> addPage(PracticePage page) async {
    if (state.practice == null) return;

    try {
      final updated = state.practice!.addPage(page);
      await _service.updatePractice(updated);
      state = state.copyWith(practice: updated);
    } catch (e) {
      state = state.copyWith(error: '娣诲姞椤甸潰澶辫触: $e');
    }
  }

  Future<void> deletePractice(String id) async {
    try {
      state = state.copyWith(isLoading: true);
      await _service.deletePractice(id);
      state = state.copyWith(isLoading: false);
    } catch (e) {
      state = state.copyWith(isLoading: false, error: e.toString());
      rethrow;
    }
  }

  /// 鍔犺浇缁冧範
  Future<void> loadPractice(String id) async {
    if (id == _currentId && state.practice != null) return;

    state = state.copyWith(isLoading: true, error: null);
    _currentId = id;

    try {
      final practice = await _service.getPractice(id);
      if (practice == null) {
        state = state.copyWith(
          isLoading: false,
          error: '缁冧範涓嶅瓨鍦?,
        );
        return;
      }

      state = state.copyWith(
        practice: practice,
        isLoading: false,
      );
    } catch (e) {
      state = state.copyWith(
        isLoading: false,
        error: '鍔犺浇缁冧範澶辫触: $e',
      );
    }
  }

  /// 鍒犻櫎鍥惧眰
  Future<void> removeLayer(int pageIndex, String layerId) async {
    if (state.practice == null) return;
    try {
      final page =
          state.practice!.pages.firstWhere((p) => p.index == pageIndex);
      final updatedPage = page.removeLayer(layerId);
      final updated = state.practice!.updatePage(updatedPage);
      await _service.updatePractice(updated);
      state = state.copyWith(practice: updated);
    } catch (e) {
      state = state.copyWith(error: '鍒犻櫎鍥惧眰澶辫触: $e');
    }
  }

  /// 鍒犻櫎椤甸潰
  Future<void> removePage(int index) async {
    if (state.practice == null) return;

    try {
      final updated = state.practice!.removePage(index);
      await _service.updatePractice(updated);
      state = state.copyWith(practice: updated);
    } catch (e) {
      state = state.copyWith(error: '鍒犻櫎椤甸潰澶辫触: $e');
    }
  }

  /// 鏇存柊鍥惧眰
  Future<void> updateLayer(int pageIndex, PracticeLayer layer) async {
    if (state.practice == null) return;
    try {
      final page =
          state.practice!.pages.firstWhere((p) => p.index == pageIndex);
      final updatedPage = page.updateLayer(layer);
      final updated = state.practice!.updatePage(updatedPage);
      await _service.updatePractice(updated);
      state = state.copyWith(practice: updated);
    } catch (e) {
      state = state.copyWith(error: '鏇存柊鍥惧眰澶辫触: $e');
    }
  }

  /// 鏇存柊椤甸潰
  Future<void> updatePage(PracticePage page) async {
    if (state.practice == null) return;

    try {
      final updated = state.practice!.updatePage(page);
      await _service.updatePractice(updated);
      state = state.copyWith(practice: updated);
    } catch (e) {
      state = state.copyWith(error: '鏇存柊椤甸潰澶辫触: $e');
    }
  }
}

/// 缁冧範璇︽儏鐘舵€?
class PracticeDetailState {
  final PracticeEntity? practice;
  final bool isLoading;
  final String? error;

  const PracticeDetailState({
    this.practice,
    this.isLoading = false,
    this.error,
  });

  PracticeDetailState copyWith({
    PracticeEntity? practice,
    bool? isLoading,
    String? error,
  }) {
    return PracticeDetailState(
      practice: practice ?? this.practice,
      isLoading: isLoading ?? this.isLoading,
      error: error,
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\providers\providers.dart
-----------------------------------
export 'character_detail_provider.dart';
export 'work_browse_provider.dart';
export 'work_detail_provider.dart';
export 'work_import_provider.dart';



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\providers\settings_provider.dart
-----------------------------------
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../domain/enums/app_theme_mode.dart';
import '../../infrastructure/providers/shared_preferences_provider.dart';

/// Provider for application settings
final settingsProvider =
    StateNotifierProvider<SettingsNotifier, SettingsState>((ref) {
  return SettingsNotifier(ref);
});

class SettingsNotifier extends StateNotifier<SettingsState> {
  final Ref ref;

  SettingsNotifier(this.ref) : super(const SettingsState()) {
    _loadSettings();
  }

  Future<void> setCustomFont(String? fontFamily) async {
    final prefs = ref.read(sharedPreferencesProvider);

    if (fontFamily == null) {
      await prefs.remove('custom_font_family');
      state = state.copyWith(clearCustomFont: true);
    } else {
      await prefs.setString('custom_font_family', fontFamily);
      state = state.copyWith(customFontFamily: fontFamily);
    }
  }

  Future<void> setScaleFactor(double factor) async {
    final prefs = ref.read(sharedPreferencesProvider);
    await prefs.setDouble('scale_factor', factor);

    state = state.copyWith(scaleFactor: factor);
  }

  Future<void> setThemeMode(AppThemeMode mode) async {
    final prefs = ref.read(sharedPreferencesProvider);
    await prefs.setString('theme_mode', mode.toStorageValue());

    state = state.copyWith(themeMode: mode);
  }

  Future<void> setUseSystemFont(bool value) async {
    final prefs = ref.read(sharedPreferencesProvider);
    await prefs.setBool('use_system_font', value);

    state = state.copyWith(useSystemFont: value);
  }

  Future<void> _loadSettings() async {
    final prefs = ref.read(sharedPreferencesProvider);

    final themeMode = AppThemeMode.fromString(
      prefs.getString('theme_mode'),
    );

    final useSystemFont = prefs.getBool('use_system_font') ?? true;
    final customFontFamily = prefs.getString('custom_font_family');
    final scaleFactor = prefs.getDouble('scale_factor') ?? 1.0;

    state = SettingsState(
      themeMode: themeMode,
      useSystemFont: useSystemFont,
      customFontFamily: customFontFamily,
      scaleFactor: scaleFactor,
    );
  }
}

/// Settings state model
class SettingsState {
  final AppThemeMode themeMode;
  final bool useSystemFont;
  final String? customFontFamily;
  final double scaleFactor;

  const SettingsState({
    this.themeMode = AppThemeMode.system,
    this.useSystemFont = true,
    this.customFontFamily,
    this.scaleFactor = 1.0,
  });

  SettingsState copyWith({
    AppThemeMode? themeMode,
    bool? useSystemFont,
    String? customFontFamily,
    double? scaleFactor,
    bool clearCustomFont = false,
  }) {
    return SettingsState(
      themeMode: themeMode ?? this.themeMode,
      useSystemFont: useSystemFont ?? this.useSystemFont,
      customFontFamily:
          clearCustomFont ? null : (customFontFamily ?? this.customFontFamily),
      scaleFactor: scaleFactor ?? this.scaleFactor,
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\providers\storage_info_provider.dart
-----------------------------------
import 'dart:io';

import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../application/providers/service_providers.dart';
import '../../infrastructure/providers/storage_providers.dart';

/// 瀛樺偍淇℃伅鎻愪緵鑰?
final storageInfoProvider = FutureProvider<StorageInfo>((ref) async {
  final storage = ref.watch(initializedStorageProvider);
  final workService = ref.watch(workServiceProvider);

  // 鑾峰彇搴旂敤鏁版嵁鐩綍
  final basePath = storage.getAppDataPath();
  final baseDir = Directory(basePath);

  // 鑾峰彇浣滃搧鏁伴噺
  final works = await workService.getAllWorks();
  final workCount = works.length;

  // 璁＄畻瀛樺偍浣跨敤鎯呭喌
  int totalSize = 0;
  int fileCount = 0;
  int cacheSize = 0;
  final subdirectories = <DirectoryInfo>[];

  if (await baseDir.exists()) {
    await for (final entity in baseDir.list()) {
      if (entity is Directory) {
        // 鐗瑰埆澶勭悊缂撳瓨鐩綍
        if (entity.path.contains('temp') || entity.path.contains('cache')) {
          cacheSize += await _calculateDirectorySize(entity.path);
          continue;
        }

        final size = await _calculateDirectorySize(entity.path);
        totalSize += size;

        subdirectories.add(DirectoryInfo(
          name: entity.path.split(Platform.pathSeparator).last,
          path: entity.path,
          size: size,
        ));
      } else if (entity is File) {
        totalSize += await entity.length();
        fileCount++;
      }
    }
  }

  // 鑾峰彇鐩爣瀛樺偍绌洪棿锛?00GB锛?
  const targetSize = 100 * 1024 * 1024 * 1024;
  final usagePercentage = (totalSize / targetSize) * 100;

  return StorageInfo(
    path: basePath,
    totalSize: targetSize,
    usedSize: totalSize,
    usagePercentage: usagePercentage,
    workCount: workCount,
    fileCount: fileCount,
    cacheSize: cacheSize,
    subdirectories: subdirectories,
  );
});

Future<int> _calculateDirectorySize(String dirPath) async {
  int size = 0;
  final dir = Directory(dirPath);

  try {
    if (await dir.exists()) {
      await for (final entity in dir.list(recursive: true)) {
        if (entity is File) {
          size += await entity.length();
        }
      }
    }
  } catch (e) {
    // 蹇界暐鏉冮檺绛夐敊璇?
  }

  return size;
}

class DirectoryInfo {
  final String name;
  final String path;
  final int size;

  DirectoryInfo({
    required this.name,
    required this.path,
    required this.size,
  });
}

class StorageInfo {
  final String path;
  final int totalSize;
  final int usedSize;
  final double usagePercentage;
  final int workCount;
  final int fileCount;
  final int cacheSize;
  final List<DirectoryInfo> subdirectories;

  StorageInfo({
    required this.path,
    required this.totalSize,
    required this.usedSize,
    required this.usagePercentage,
    required this.workCount,
    required this.fileCount,
    required this.cacheSize,
    required this.subdirectories,
  });
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\providers\works_providers.dart
-----------------------------------
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../application/providers/service_providers.dart';
import '../../domain/models/work/work_entity.dart';
import '../../infrastructure/logging/logger.dart';

// 淇敼涓哄埛鏂颁俊鎭彁渚涘櫒
final worksNeedsRefreshProvider = StateProvider<RefreshInfo?>((ref) => null);

// 浣滃搧鍒楄〃鎻愪緵鍣?
final worksProvider = FutureProvider.autoDispose<List<WorkEntity>>((ref) async {
  AppLogger.debug('鍔犺浇浣滃搧鍒楄〃', tag: 'WorksProvider');

  // 璁剧疆缂撳瓨绛栫暐锛屼娇鍒楄〃鑳藉鍦ㄨ繑鍥炴椂淇濈暀
  ref.keepAlive();

  final workService = ref.watch(workServiceProvider);
  return await workService.getAllWorks();
});

// 澧炲己鍒锋柊鏍囧織锛屾坊鍔犲埛鏂板師鍥犲拰浼樺厛绾т俊鎭?
class RefreshInfo {
  final String reason;
  final int priority;
  final bool force;

  const RefreshInfo({
    required this.reason,
    this.priority = 0,
    this.force = false,
  });

  // 娣诲姞甯哥敤鍒锋柊鍘熷洜浣滀负宸ュ巶鏋勯€犲嚱鏁?
  factory RefreshInfo.appResume() =>
      const RefreshInfo(reason: '搴旂敤鎭㈠', priority: 1);

  factory RefreshInfo.dataChanged() =>
      const RefreshInfo(reason: '鏁版嵁鍙樻洿', priority: 10, force: true);

  factory RefreshInfo.importCompleted() =>
      const RefreshInfo(reason: '瀵煎叆瀹屾垚', priority: 9, force: true);

  factory RefreshInfo.userInitiated() =>
      const RefreshInfo(reason: '鐢ㄦ埛璇锋眰', priority: 8, force: true);

  // 鐢ㄤ簬鍒涘缓鏇撮珮浼樺厛绾х殑璇锋眰
  RefreshInfo asHighPriority() =>
      RefreshInfo(reason: reason, priority: priority + 5, force: true);

  // 姣旇緝浼樺厛绾ф柟娉?
  bool hasHigherPriorityThan(RefreshInfo other) => priority > other.priority;
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\providers\works_state_providers.dart
-----------------------------------
import 'package:flutter_riverpod/flutter_riverpod.dart';

import 'work_browse_provider.dart';

// 琛嶇敓鐘舵€?providers锛屼緷璧栦簬 workBrowseProvider 浣嗘彁渚涙洿鍏蜂綋鐨勬暟鎹鍥?

/// 浣滃搧鍒楄〃鍔犺浇鏄惁鏈夐敊璇?
final hasErrorProvider = Provider<bool>((ref) {
  final state = ref.watch(workBrowseProvider);
  return !state.isLoading && state.error != null;
});

/// 鏄惁鏈夋椿鍔ㄧ瓫閫夊櫒鎴栨悳绱?
final hasFilterProvider = Provider<bool>((ref) {
  final state = ref.watch(workBrowseProvider);
  return !state.filter.isEmpty || state.searchQuery.isNotEmpty;
});

/// 浣滃搧鍒楄〃鏄惁鍦ㄥ姞杞戒腑
final isLoadingWorksProvider = Provider<bool>((ref) {
  return ref.watch(workBrowseProvider).isLoading;
});

/// 宸查€夋嫨浣滃搧鏁伴噺
final selectedWorksCountProvider = Provider<int>((ref) {
  return ref.watch(workBrowseProvider).selectedWorks.length;
});

/// 鏄惁鏄剧ず鎵归噺鎿嶄綔宸ュ叿鏍?
final showBatchActionsProvider = Provider<bool>((ref) {
  final state = ref.watch(workBrowseProvider);
  return state.batchMode && state.selectedWorks.isNotEmpty;
});

/// 浣滃搧鍒楄〃鏄惁涓虹┖
final worksEmptyProvider = Provider<bool>((ref) {
  final state = ref.watch(workBrowseProvider);
  return !state.isLoading && state.works.isEmpty;
});



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\providers\work_browse_provider.dart
-----------------------------------
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../application/providers/service_providers.dart';
import '../../application/services/restoration/state_restoration_service.dart';
import '../viewmodels/states/work_browse_state.dart';
import '../viewmodels/work_browse_view_model.dart';

final workBrowseProvider =
    StateNotifierProvider<WorkBrowseViewModel, WorkBrowseState>((ref) {
  final workService = ref.watch(workServiceProvider);
  final stateRestorationService = ref.watch(stateRestorationServiceProvider);

  return WorkBrowseViewModel(workService, stateRestorationService);
});



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\providers\work_detail_provider.dart
-----------------------------------
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../application/providers/service_providers.dart';
import '../../application/services/work/work_service.dart';
import '../../domain/enums/work_style.dart';
import '../../domain/enums/work_tool.dart';
import '../../domain/models/work/work_entity.dart';
import '../../domain/models/work/work_image.dart';
import '../../infrastructure/logging/logger.dart';

/// 浣滃搧璇︽儏鎻愪緵鍣?
final workDetailProvider =
    StateNotifierProvider<WorkDetailNotifier, WorkDetailState>((ref) {
  final workService = ref.watch(workServiceProvider);
  return WorkDetailNotifier(workService);
});

/// 浣滃搧璇︽儏閫氱煡鍣?
class WorkDetailNotifier extends StateNotifier<WorkDetailState> {
  final WorkService _workService;

  WorkDetailNotifier(this._workService) : super(const WorkDetailState());

  /// 鍙栨秷缂栬緫
  void cancelEditing() {
    state = state.copyWith(
      editingWork: state.work,
      isEditing: false,
      hasChanges: false,
    );
  }

  /// 瀹屾垚缂栬緫锛堜粠缂栬緫妯″紡鍒囨崲鍥炴煡鐪嬫ā寮忥級
  void completeEditing() {
    // 纭繚宸茬紪杈戠殑鍐呭淇濇寔涓嶅彉锛屽彧鏀瑰彉缂栬緫鐘舵€?
    // 淇敼姝ゆ柟娉曪紝纭繚work鍊间篃琚洿鏂颁负鏈€鏂扮殑editingWork鍊?
    state = state.copyWith(
      work: state.editingWork, // 鏇存柊涓昏宸ヤ綔鐘舵€佷负缂栬緫鍚庣殑鐘舵€?
      isEditing: false,
      hasChanges: false,
    );

    AppLogger.debug('缂栬緫瀹屾垚', tag: 'WorkDetailProvider', data: {
      'workId': state.work?.id,
      'title': state.work?.title,
      'tagCount': state.work?.tags.length,
      'isEditing': state.isEditing,
    });
  }

  /// 鍒犻櫎浣滃搧
  Future<bool> deleteWork(String workId) async {
    if (state.isSaving) return false;

    try {
      state = state.copyWith(isSaving: true, error: null);

      await _workService.deleteWork(workId);

      state = state.copyWith(isSaving: false);
      return true;
    } catch (e) {
      state = state.copyWith(
        isSaving: false,
        error: '鍒犻櫎澶辫触: $e',
      );
      return false;
    }
  }

  /// 杩涘叆缂栬緫妯″紡
  void enterEditMode() {
    if (state.work == null) return;
    startEditing();
  }

  /// 鍔犺浇浣滃搧
  Future<void> loadWork(String workId) async {
    if (state.isLoading) return;

    try {
      state = state.copyWith(isLoading: true, error: null);

      final work = await _workService.getWork(workId);
      state = state.copyWith(
        work: work,
        editingWork: work,
        isLoading: false,
      );
    } catch (e) {
      state = state.copyWith(
        isLoading: false,
        error: '鍔犺浇澶辫触: $e',
      );
    }
  }

  /// 鍔犺浇浣滃搧璇︽儏
  Future<void> loadWorkDetails(String workId) async {
    await loadWork(workId);
  }

  /// 鏍囪鏈夋洿鏀?
  void markAsChanged() {
    state = state.copyWith(hasChanges: true);
  }

  /// 淇濆瓨浣滃搧
  Future<bool> saveChanges() async {
    if (state.isSaving || state.editingWork == null) return false;

    try {
      state = state.copyWith(isSaving: true, error: null);

      AppLogger.debug('淇濆瓨浣滃搧鍓嶇姸鎬?, tag: 'WorkDetailProvider', data: {
        'workId': state.editingWork!.id,
        'title': state.editingWork!.title,
        'tagCount': state.editingWork!.tags.length,
      });

      final updatedWork =
          await _workService.updateWorkEntity(state.editingWork!);

      AppLogger.debug('淇濆瓨浣滃搧鍚庣姸鎬?, tag: 'WorkDetailProvider', data: {
        'workId': updatedWork.id,
        'title': updatedWork.title,
        'tagCount': updatedWork.tags.length,
      });

      state = state.copyWith(
        work: updatedWork,
        editingWork: updatedWork,
        isSaving: false,
        hasChanges: false,
      );

      loadWorkDetails(updatedWork.id);

      return true;
    } catch (e) {
      AppLogger.error('淇濆瓨浣滃搧澶辫触', tag: 'WorkDetailProvider', error: e);
      state = state.copyWith(
        isSaving: false,
        error: '淇濆瓨澶辫触: $e',
      );
      return false;
    }
  }

  /// 閫夋嫨鍥剧墖
  void selectImage(int index) {
    if (index < 0 || index >= (state.work?.images.length ?? 0)) return;

    state = state.copyWith(
      selectedImageIndex: index,
    );
  }

  /// 寮€濮嬬紪杈?
  void startEditing() {
    if (state.work == null) return;
    state = state.copyWith(
      editingWork: state.work,
      isEditing: true,
      hasChanges: false,
    );
  }

  /// 灏濊瘯鎭㈠缂栬緫鐘舵€?
  Future<void> tryRestoreEditState(String workId) async {
    try {
      await loadWork(workId);
      startEditing();
    } catch (e) {
      // 鎭㈠澶辫触锛屼笉澶勭悊
    }
  }

  void updateWorkBasicInfo({
    String? title,
    String? author,
    String? remark,
    WorkStyle? style,
    WorkTool? tool,
    DateTime? creationDate,
  }) {
    if (state.editingWork == null) return;

    // 娣诲姞鏃ュ織甯姪璋冭瘯
    AppLogger.debug('鏇存柊浣滃搧鍩烘湰淇℃伅', tag: 'WorkDetailProvider', data: {
      'workId': state.editingWork!.id,
      'title': title ?? '[unchanged]',
      'author': author ?? '[unchanged]',
      'style': style?.value ?? '[unchanged]',
      'tool': tool?.value ?? '[unchanged]',
      'creationDate': creationDate?.toString() ?? '[unchanged]',
      'remark': remark?.toString() ?? '[unchanged]',
    });

    final updatedWork = WorkEntity(
      id: state.editingWork!.id,
      title: title ?? state.editingWork!.title,
      author: author ?? state.editingWork!.author,
      remark: remark ?? state.editingWork!.remark,
      style: style ?? state.editingWork!.style,
      tool: tool ?? state.editingWork!.tool,
      creationDate: creationDate ?? state.editingWork!.creationDate,
      createTime: state.editingWork!.createTime,
      updateTime: DateTime.now(),
      images: state.editingWork!.images,
      imageCount: state.editingWork!.imageCount,
      tags: state.editingWork!.tags,
      collectedChars: state.editingWork!.collectedChars,
    );

    state = state.copyWith(
      editingWork: updatedWork,
      hasChanges: true,
    );
  }

  /// 鏇存柊浣滃搧鍥剧墖鍒楄〃
  void updateWorkImages(List<WorkImage> images) {
    if (state.editingWork == null) return;

    final updatedWork = state.editingWork!.copyWith(
      images: images,
      imageCount: images.length,
      updateTime: DateTime.now(),
    );

    state = state.copyWith(
      editingWork: updatedWork,
      hasChanges: true,
    );
  }

  /// 鏇存柊浣滃搧鏍囩
  void updateWorkTags(List<String> tags) {
    if (state.editingWork == null) return;

    // 娣诲姞鏃ュ織甯姪璋冭瘯
    AppLogger.debug('鏇存柊浣滃搧鏍囩', tag: 'WorkDetailProvider', data: {
      'workId': state.editingWork!.id,
      'oldTagCount': state.editingWork!.tags.length,
      'newTagCount': tags.length,
      'oldTags': state.editingWork!.tags,
      'newTags': tags,
    });

    final updatedWork = state.editingWork!.copyWith(
      tags: tags,
      updateTime: DateTime.now(),
    );

    state = state.copyWith(
      editingWork: updatedWork,
      hasChanges: true,
    );
  }
}

/// 浣滃搧璇︽儏鐘舵€?
class WorkDetailState {
  final WorkEntity? work;
  final WorkEntity? editingWork;
  final bool isLoading;
  final bool isSaving;
  final bool isEditing;
  final bool hasChanges;
  final int historyIndex;
  final int selectedImageIndex;
  final String? error;

  const WorkDetailState({
    this.work,
    this.editingWork,
    this.isLoading = false,
    this.isSaving = false,
    this.isEditing = false,
    this.hasChanges = false,
    this.historyIndex = -1,
    this.selectedImageIndex = 0,
    this.error,
  });

  WorkDetailState copyWith({
    WorkEntity? work,
    WorkEntity? editingWork,
    bool? isLoading,
    bool? isSaving,
    bool? isEditing,
    bool? hasChanges,
    int? historyIndex,
    int? selectedImageIndex,
    String? error,
  }) {
    return WorkDetailState(
      work: work ?? this.work,
      editingWork: editingWork ?? this.editingWork,
      isLoading: isLoading ?? this.isLoading,
      isSaving: isSaving ?? this.isSaving,
      isEditing: isEditing ?? this.isEditing,
      hasChanges: hasChanges ?? this.hasChanges,
      historyIndex: historyIndex ?? this.historyIndex,
      selectedImageIndex: selectedImageIndex ?? this.selectedImageIndex,
      error: error,
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\providers\work_filter_provider.dart
-----------------------------------
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../domain/models/work/work_filter.dart';

final workFilterProvider =
    StateNotifierProvider<WorkFilterNotifier, WorkFilter>((ref) {
  return WorkFilterNotifier();
});

class WorkFilterNotifier extends StateNotifier<WorkFilter> {
  WorkFilterNotifier() : super(const WorkFilter());

  void resetFilter() {
    state = const WorkFilter();
  }

  void updateFilter(WorkFilter newFilter) {
    state = newFilter;
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\providers\work_image_editor_provider.dart
-----------------------------------
import 'dart:io';

import 'package:file_picker/file_picker.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../application/providers/service_providers.dart';
import '../../domain/models/work/work_image.dart';
import '../../infrastructure/logging/logger.dart';
import './work_detail_provider.dart';

final currentWorkImageIndexProvider = StateProvider<int>((ref) => 0);

final workImageEditorProvider = StateNotifierProvider.autoDispose<
    WorkImageEditorNotifier, WorkImageEditorState>((ref) {
  // Create the notifier
  final notifier = WorkImageEditorNotifier(ref);

  // Setup disposal callback
  ref.onDispose(() {
    AppLogger.debug('WorkImageEditorProvider disposed', tag: 'WorkImageEditor');
  });

  // Important: Don't call initialize methods that modify other providers here!

  return notifier;
});

/// Flag to indicate if initial synchronization is complete
final workImageInitializedProvider = StateProvider<bool>((ref) => false);

class WorkImageEditorNotifier extends StateNotifier<WorkImageEditorState> {
  final Ref _ref;

  WorkImageEditorNotifier(this._ref) : super(const WorkImageEditorState());

  // For backward compatibility - just calls addImages()
  Future<void> addImage() async {
    await addImages();
  }

  /// Add one or more images
  /// This is the consolidated method for adding images - always allows multiple selection
  Future<void> addImages() async {
    try {
      state = state.copyWith(isProcessing: true, error: null);

      AppLogger.debug('Starting image selection', tag: 'WorkImageEditor');

      // Always use multiple selection - users can still select just one if they want
      final result = await FilePicker.platform.pickFiles(
        type: FileType.image,
        allowMultiple: true, // Always allow multiple selection
        withData: false,
        lockParentWindow: true,
        dialogTitle: '閫夋嫨鍥剧墖 (鍙寜浣廋trl澶氶€?',
      );

      AppLogger.debug('File picker result', tag: 'WorkImageEditor', data: {
        'hasResult': result != null,
        'fileCount': result?.files.length ?? 0
      });

      // Handle no selection case
      if (result == null || result.files.isEmpty) {
        AppLogger.debug('User cancelled file selection',
            tag: 'WorkImageEditor');
        state = state.copyWith(isProcessing: false);
        return;
      }

      final workId = _ref.read(workDetailProvider).work!.id;
      final newImages = <WorkImage>[];
      int successCount = 0;
      int errorCount = 0;

      // Process each selected file - works for single or multiple selection
      for (final file in result.files) {
        if (file.path == null) {
          errorCount++;
          continue;
        }

        try {
          final filePath = file.path!;
          final imageFile = File(filePath);

          // Basic verification
          if (!await imageFile.exists()) {
            AppLogger.warning('Selected file does not exist',
                tag: 'WorkImageEditor', data: {'path': filePath});
            errorCount++;
            continue;
          }

          // Create a unique ID that includes timestamp and counter
          final imageId =
              '${DateTime.now().millisecondsSinceEpoch}_$successCount';

          final newImage = WorkImage(
            id: imageId,
            workId: workId,
            path: imageFile.path,
            originalPath: imageFile.path,
            thumbnailPath: imageFile.path,
            format: imageFile.path.split('.').last.toLowerCase(),
            size: await imageFile.length(),
            width: 0,
            height: 0,
            index: state.images.length + newImages.length,
            createTime: DateTime.now(),
            updateTime: DateTime.now(),
          );

          newImages.add(newImage);
          successCount++;
        } catch (e) {
          AppLogger.error('Error processing file',
              tag: 'WorkImageEditor', error: e, data: {'path': file.path});
          errorCount++;
        }
      }

      if (newImages.isNotEmpty) {
        // Update state with all new images
        final allImages = [...state.images, ...newImages];

        AppLogger.debug('Adding images to state',
            tag: 'WorkImageEditor',
            data: {
              'newImagesCount': newImages.length,
              'totalImagesCount': allImages.length,
              'successCount': successCount,
              'errorCount': errorCount,
            });

        state = state.copyWith(
          images: allImages,
          isProcessing: false,
          hasPendingAdditions: true,
        );

        // Update selected index to the first new image
        _ref.read(currentWorkImageIndexProvider.notifier).state =
            state.images.length - newImages.length;

        // Mark work as changed
        _ref.read(workDetailProvider.notifier).markAsChanged();

        // Show user feedback about partial failures if any
        if (errorCount > 0 && successCount > 0) {
          state = state.copyWith(
              error: '宸叉坊鍔?$successCount 寮犲浘鐗囷紝$errorCount 寮犲浘鐗囨棤娉曞鐞?);
        } else if (errorCount > 0 && successCount == 0) {
          state = state.copyWith(error: '鏃犳硶澶勭悊鎵€閫夊浘鐗?);
        }
      } else {
        state = state.copyWith(isProcessing: false, error: '鏃犳硶娣诲姞鎵€閫夊浘鐗?);
      }
    } catch (e, stackTrace) {
      AppLogger.error('Failed to add images',
          tag: 'WorkImageEditor', error: e, stackTrace: stackTrace);

      state = state.copyWith(
        isProcessing: false,
        error: '娣诲姞鍥剧墖澶辫触: ${e.toString()}',
      );
    }
  }

  Future<void> deleteImage(String imageId) async {
    try {
      AppLogger.debug('Starting image deletion', tag: 'WorkImageEditor', data: {
        'imageId': imageId,
        'currentImageCount': state.images.length,
      });

      state = state.copyWith(isProcessing: true, error: null);

      // Find the image in the current state
      final imageToDelete = state.images.firstWhere(
        (img) => img.id == imageId,
        orElse: () => throw Exception('Image not found: $imageId'),
      );

      AppLogger.debug('Found image to delete', tag: 'WorkImageEditor', data: {
        'imageId': imageId,
        'imagePath': imageToDelete.path,
      });

      final currentIndex = _ref.read(currentWorkImageIndexProvider);

      // Remove the image from the list and reindex
      final remainingImages =
          state.images.where((img) => img.id != imageId).toList();
      final reindexedImages = List<WorkImage>.generate(
        remainingImages.length,
        (index) => remainingImages[index].copyWith(
          index: index,
          updateTime: DateTime.now(),
        ),
      );

      // Add to deleted IDs list for tracking and future cleanup
      final updatedDeletedIds = [...state.deletedImageIds, imageId];

      // Update state with new image list and add deleted ID to tracking
      state = state.copyWith(
        images: reindexedImages,
        deletedImageIds: updatedDeletedIds,
        isProcessing: false,
      );

      // Log additional info about the deleted images tracking
      AppLogger.debug(
        'Updated deleted images tracking',
        tag: 'WorkImageEditor',
        data: {
          'deletedIds': updatedDeletedIds,
          'deletedCount': updatedDeletedIds.length,
        },
      );

      // Update selected index to prevent out-of-bounds access
      if (reindexedImages.isEmpty) {
        _ref.read(currentWorkImageIndexProvider.notifier).state = 0;
      } else if (currentIndex >= reindexedImages.length) {
        _ref.read(currentWorkImageIndexProvider.notifier).state =
            reindexedImages.length - 1;
      }

      // Mark the work as changed
      _ref.read(workDetailProvider.notifier).markAsChanged();

      AppLogger.debug('Image deleted successfully',
          tag: 'WorkImageEditor',
          data: {
            'remainingImageCount': reindexedImages.length,
            'deletedIdsCount': updatedDeletedIds.length,
          });
    } catch (e, stackTrace) {
      AppLogger.error('Failed to delete image',
          tag: 'WorkImageEditor', error: e, stackTrace: stackTrace);

      state = state.copyWith(
        isProcessing: false,
        error: '鍒犻櫎鍥剧墖澶辫触: ${e.toString()}',
      );
    }
  }

  /// Initialize the editor with images from a work
  /// This should only be called after provider creation, not during
  Future<void> initialize(List<WorkImage> images) async {
    // First check if still mounted before proceeding
    if (!mounted) {
      AppLogger.warning(
        'Attempted to initialize WorkImageEditor after disposal',
        tag: 'WorkImageEditor',
      );
      return;
    }

    // Reset initialized state to false at start of initialization
    _ref.read(workImageInitializedProvider.notifier).state = false;

    // Log the incoming images to verify they exist
    AppLogger.debug(
      'Initializing WorkImageEditor with images',
      tag: 'WorkImageEditor',
      data: {
        'imageCount': images.length,
        'imageIds': images.isNotEmpty
            ? images.map((img) => img.id).take(3).toList() +
                (images.length > 3 ? ['...'] : [])
            : [],
      },
    );

    if (images.isEmpty) {
      AppLogger.warning(
        'Attempted to initialize editor with empty images list',
        tag: 'WorkImageEditor',
      );
      return;
    }

    try {
      // Create a deep copy of images to prevent reference issues
      final imagesCopy = images.map((img) => img.copyWith()).toList();

      // Update our state with clean pending state
      state = WorkImageEditorState(
        images: imagesCopy,
        deletedImageIds: const [],
        isProcessing: false,
        error: null,
        hasPendingAdditions: false, // Reset pending state on initialization
      );

      // Verify images were properly loaded before marking as initialized
      if (state.images.isNotEmpty) {
        // Only mark as initialized if we actually have images
        _ref.read(workImageInitializedProvider.notifier).state = true;

        AppLogger.debug(
          'WorkImageEditor initialization successful',
          tag: 'WorkImageEditor',
          data: {
            'imageCount': state.images.length,
            'initialized': true,
          },
        );
      } else {
        AppLogger.error(
          'WorkImageEditor initialization failed - no images in state after update',
          tag: 'WorkImageEditor',
          data: {
            'providedImageCount': images.length,
          },
        );
      }
    } catch (e) {
      AppLogger.error(
        'Error during WorkImageEditor initialization',
        tag: 'WorkImageEditor',
        error: e,
      );
      // Ensure initialization flag is false on error
      _ref.read(workImageInitializedProvider.notifier).state = false;
    }
  }

  Future<void> reorderImages(int oldIndex, int newIndex) async {
    try {
      if (oldIndex < newIndex) {
        newIndex -= 1;
      }

      final items = List<WorkImage>.from(state.images);
      final item = items.removeAt(oldIndex);
      items.insert(newIndex, item);

      // 閲嶆柊璁＄畻鎵€鏈夊浘鐗囩殑绱㈠紩
      final reindexedImages = List<WorkImage>.generate(
        items.length,
        (index) => items[index].copyWith(
          index: index,
          updateTime: DateTime.now(),
        ),
      );

      AppLogger.debug('閲嶆帓搴忓浘鐗?, tag: 'WorkImageEditor', data: {
        'oldIndex': oldIndex,
        'newIndex': newIndex,
        'firstImageId':
            reindexedImages.isNotEmpty ? reindexedImages[0].id : null,
      });

      state = state.copyWith(images: reindexedImages);

      // 鏇存柊閫変腑绱㈠紩
      _ref.read(currentWorkImageIndexProvider.notifier).state = newIndex;

      // 鏍囪浣滃搧宸叉洿鏀?
      _ref.read(workDetailProvider.notifier).markAsChanged();
    } catch (e) {
      AppLogger.error('閲嶆帓搴忓浘鐗囧け璐?, tag: 'WorkImageEditor', error: e);
      state = state.copyWith(error: '閲嶆帓搴忓浘鐗囧け璐? $e');
      rethrow;
    }
  }

  /// Reset the state to initial empty state
  void reset() {
    // When resetting, make sure to clear the deleted images tracking
    state = const WorkImageEditorState();
    _ref.read(workImageInitializedProvider.notifier).state = false;
    AppLogger.debug(
      'Resetting WorkImageEditor state',
      tag: 'WorkImageEditor',
      data: {'deletedIdsCleared': true, 'pendingAdditionsCleared': true},
    );
  }

  Future<void> saveChanges() async {
    try {
      state = state.copyWith(isProcessing: true, error: null);

      final workId = _ref.read(workDetailProvider).work?.id;
      if (workId == null) return;

      AppLogger.debug('寮€濮嬩繚瀛樺浘鐗囨洿鏀?, tag: 'WorkImageEditor', data: {
        'workId': workId,
        'imageCount': state.images.length,
        'firstImageId': state.images.isNotEmpty ? state.images[0].id : null,
      });

      final workImageService = _ref.read(workImageServiceProvider);

      // 鍏堝垹闄ゆ爣璁颁负鍒犻櫎鐨勫浘鐗?
      for (final imageId in state.deletedImageIds) {
        try {
          await workImageService.deleteImage(workId, imageId);
        } catch (e) {
          AppLogger.warning('鍒犻櫎鍥剧墖鏂囦欢澶辫触',
              tag: 'WorkImageEditor',
              error: e,
              data: {
                'imageId': imageId,
                'workId': workId,
              });
        }
      }

      // 淇濆瓨鎵€鏈夊浘鐗?
      final savedImages = await workImageService.saveChanges(
        workId,
        state.images,
        onProgress: (progress, message) {
          AppLogger.debug('淇濆瓨杩涘害', tag: 'WorkImageEditor', data: {
            'progress': progress,
            'message': message,
          });
        },
      );

      state = state.copyWith(
        images: savedImages,
        deletedImageIds: [],
        isProcessing: false,
        hasPendingAdditions: false, // Clear pending flag after successful save
      );

      AppLogger.debug('鍥剧墖淇濆瓨瀹屾垚', tag: 'WorkImageEditor', data: {
        'savedCount': savedImages.length,
      });

      // 绉婚櫎姝よ - 涓嶈閲嶆柊鍔犺浇浣滃搧璇︽儏锛屼細瑕嗙洊宸茬紪杈戠殑鏇存敼
      // await _ref.read(workDetailProvider.notifier).loadWorkDetails(workId);
    } catch (e) {
      AppLogger.error('淇濆瓨鍥剧墖鏇存敼澶辫触', tag: 'WorkImageEditor', error: e);
      state = state.copyWith(
        isProcessing: false,
        error: '淇濆瓨鍥剧墖鏇存敼澶辫触: $e',
      );
      rethrow;
    }
  }

  // 鍥剧墖鎺掑簭
  Future<void> sortImages() async {
    try {
      if (state.images.isEmpty || state.images.length <= 1) return;

      state = state.copyWith(isProcessing: true, error: null);

      // 鏍规嵁鏂囦欢鍚嶆帓搴?
      final sortedImages = List<WorkImage>.from(state.images)
        ..sort((a, b) => a.path.compareTo(b.path));

      // 閲嶆柊璁＄畻绱㈠紩
      final reindexedImages = List<WorkImage>.generate(
        sortedImages.length,
        (index) => sortedImages[index].copyWith(
          index: index,
          updateTime: DateTime.now(),
        ),
      );

      // 鏇存柊鐘舵€?
      state = state.copyWith(
        images: reindexedImages,
        isProcessing: false,
      );

      // 濡傛灉褰撳墠閫夋嫨鐨勫浘鐗囬『搴忓彉浜嗭紝鏇存柊閫夋嫨鐨勭储寮曞埌绗竴寮?
      _ref.read(currentWorkImageIndexProvider.notifier).state = 0;

      // 鏍囪浣滃搧宸叉洿鏀?
      _ref.read(workDetailProvider.notifier).markAsChanged();
    } catch (e) {
      AppLogger.error('鍥剧墖鎺掑簭澶辫触', tag: 'WorkImageEditor', error: e);
      state = state.copyWith(
        isProcessing: false,
        error: '鍥剧墖鎺掑簭澶辫触: $e',
      );
    }
  }

  /// Update the selected index (to be called after initialization)
  void updateSelectedIndex(int index) {
    if (!mounted) return;

    final maxIndex = state.images.length - 1;
    final safeIndex = index.clamp(0, maxIndex < 0 ? 0 : maxIndex);

    // Now we can safely update the index provider
    _ref.read(currentWorkImageIndexProvider.notifier).state = safeIndex;

    AppLogger.debug(
      'Updated selected index',
      tag: 'WorkImageEditor',
      data: {
        'requestedIndex': index,
        'actualIndex': safeIndex,
        'maxIndex': maxIndex,
      },
    );
  }
}

class WorkImageEditorState {
  final List<WorkImage> images;
  final List<String> deletedImageIds;
  final bool isProcessing;
  final String? error;
  final bool hasPendingAdditions; // Track if we've added new images

  const WorkImageEditorState({
    this.images = const [],
    this.deletedImageIds = const [],
    this.isProcessing = false,
    this.error,
    this.hasPendingAdditions = false,
  });

  WorkImageEditorState copyWith({
    List<WorkImage>? images,
    List<String>? deletedImageIds,
    bool? isProcessing,
    String? error,
    bool? hasPendingAdditions,
  }) {
    return WorkImageEditorState(
      images: images ?? this.images,
      deletedImageIds: deletedImageIds ?? this.deletedImageIds,
      isProcessing: isProcessing ?? this.isProcessing,
      error: error,
      hasPendingAdditions: hasPendingAdditions ?? this.hasPendingAdditions,
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\providers\work_import_provider.dart
-----------------------------------
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../application/providers/service_providers.dart';
import '../viewmodels/states/work_import_state.dart';
import '../viewmodels/work_import_view_model.dart';

final workImportProvider =
    StateNotifierProvider<WorkImportViewModel, WorkImportState>((ref) {
  final workService = ref.watch(workServiceProvider);
  final imageProcessor = ref.watch(imageProcessorProvider);
  return WorkImportViewModel(workService, imageProcessor);
});



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\providers\character\auto_save_provider.dart
-----------------------------------
import 'package:flutter_riverpod/flutter_riverpod.dart';

/// 榛樿鐨勮嚜鍔ㄤ繚瀛樻椂闂撮棿闅斿垪琛?
final autoSaveIntervals = [
  const Duration(seconds: 30),
  const Duration(minutes: 1),
  const Duration(minutes: 5),
  const Duration(minutes: 10),
];

/// 鑷姩淇濆瓨鐩戝惉鍣ㄦ彁渚涜€?
final autoSaveListenerProvider = Provider((ref) {
  final autoSaveState = ref.watch(autoSaveProvider);

  if (autoSaveState.shouldSave) {
    // 褰撴弧瓒宠嚜鍔ㄤ繚瀛樻潯浠舵椂锛岃繑鍥瀟rue
    return true;
  }
  return false;
});

/// 鑷姩淇濆瓨鎻愪緵鑰?
final autoSaveProvider =
    StateNotifierProvider<AutoSaveNotifier, AutoSaveState>((ref) {
  return AutoSaveNotifier();
});

/// 鑷姩淇濆瓨鐘舵€佺鐞嗗櫒
class AutoSaveNotifier extends StateNotifier<AutoSaveState> {
  AutoSaveNotifier() : super(const AutoSaveState());

  void markClean() {
    state = state.copyWith(
      isDirty: false,
      lastSaveTime: DateTime.now(),
    );
  }

  void markDirty() {
    state = state.copyWith(isDirty: true);
  }

  void reset() {
    state = const AutoSaveState();
  }

  void resetLastSaveTime() {
    state = state.copyWith(lastSaveTime: DateTime.now());
  }

  void setEnabled(bool enabled) {
    state = state.copyWith(enabled: enabled);
  }

  void setInterval(Duration interval) {
    state = state.copyWith(interval: interval);
  }
}

class AutoSaveState {
  final Duration interval;
  final DateTime? lastSaveTime;
  final bool enabled;
  final bool isDirty;

  const AutoSaveState({
    this.interval = const Duration(minutes: 1),
    this.lastSaveTime,
    this.enabled = true,
    this.isDirty = false,
  });

  bool get shouldSave {
    if (!enabled || !isDirty) return false;
    if (lastSaveTime == null) return true;

    final now = DateTime.now();
    return now.difference(lastSaveTime!) >= interval;
  }

  AutoSaveState copyWith({
    Duration? interval,
    DateTime? lastSaveTime,
    bool? enabled,
    bool? isDirty,
  }) {
    return AutoSaveState(
      interval: interval ?? this.interval,
      lastSaveTime: lastSaveTime ?? this.lastSaveTime,
      enabled: enabled ?? this.enabled,
      isDirty: isDirty ?? this.isDirty,
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\providers\character\character_collection_provider.dart
-----------------------------------
import 'dart:typed_data';

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:image/image.dart' as img;

import '../../../application/services/character/character_service.dart';
import '../../../domain/models/character/character_region.dart';
import '../../../domain/models/character/character_region_state.dart';
import '../../../domain/models/character/processing_options.dart';
import '../../../domain/models/character/undo_action.dart';
import '../../../infrastructure/logging/logger.dart';
import '../../viewmodels/states/character_collection_state.dart';
import 'selected_region_provider.dart';
import 'tool_mode_provider.dart';

final characterCollectionProvider = StateNotifierProvider<
    CharacterCollectionNotifier, CharacterCollectionState>((ref) {
  final characterService = ref.watch(characterServiceProvider);
  final toolModeNotifier = ref.watch(toolModeProvider.notifier);
  final selectedRegionNotifier = ref.watch(selectedRegionProvider.notifier);

  return CharacterCollectionNotifier(
    characterService: characterService,
    toolModeNotifier: toolModeNotifier,
    selectedRegionNotifier: selectedRegionNotifier,
  );
});

class CharacterCollectionNotifier
    extends StateNotifier<CharacterCollectionState> {
  final CharacterService _characterService;
  final ToolModeNotifier _toolModeNotifier;
  final SelectedRegionNotifier _selectedRegionNotifier;

  Uint8List? _currentPageImage;
  String? _currentWorkId;
  String? _currentPageId;

  CharacterCollectionNotifier({
    required CharacterService characterService,
    required ToolModeNotifier toolModeNotifier,
    required SelectedRegionNotifier selectedRegionNotifier,
  })  : _characterService = characterService,
        _toolModeNotifier = toolModeNotifier,
        _selectedRegionNotifier = selectedRegionNotifier,
        super(CharacterCollectionState.initial());

  // 娣诲姞鍖哄煙鍒板閫夐泦鍚堜腑
  void addToSelection(String id) {
    if (state.regions.any((r) => r.id == id)) {
      final updatedSelectedIds = {...state.selectedIds, id};

      state = state.copyWith(
        selectedIds: updatedSelectedIds,
      );
    }
  }

  // 鍙栨秷缂栬緫
  void cancelEdit() {
    _selectedRegionNotifier.clearRegion();
    state =
        state.copyWith(currentId: null, selectedIds: {}, isAdjusting: false);
  }

  // 娓呴櫎閿欒娑堟伅
  void clearError() {
    state = state.copyWith(error: null);
  }

// 娓呯悊宸查€夋嫨鐨勫尯鍩?  void clearSelectedRegions() {
    _selectedRegionNotifier.clearRegion();
    state = state.copyWith(
      currentId: null,
      selectedIds: {},
    );
  }

// 澶氶€夊姛鑳斤細娓呴櫎鎵€鏈夐€夋嫨
  void clearSelections() {
    state = state.copyWith(selectedIds: {});
  }

  // 娓呯悊鎵€鏈夌姸鎬?  void clearState() {
    _currentPageImage = null;
    _currentWorkId = null;
    _currentPageId = null;
    _selectedRegionNotifier.clearRegion();
    state = CharacterCollectionState.initial();
  }

  /// 鍒涘缓鏂扮殑妗嗛€夊尯鍩?  /// 1. 楠岃瘉蹇呰鏉′欢
  /// 2. 鍒涘缓鏂板尯鍩熷苟澶勭悊閫夊尯鐘舵€?  /// 3. 璁板綍鎿嶄綔浠ユ敮鎸佹挙閿€
  CharacterRegion? createRegion(Rect rect) {
    try {
      // 1. 楠岃瘉鏉′欢
      if (_currentPageId == null) {
        throw Exception('褰撳墠椤甸潰ID鏈缃紝鏃犳硶鍒涘缓閫夊尯');
      }
      if (_currentPageImage == null) {
        throw Exception('褰撳墠椤甸潰鍥惧儚鏈缃紝鏃犳硶鍒涘缓閫夊尯');
      }
      if (rect.width < 20 || rect.height < 20) {
        throw Exception('閫夊尯灏哄杩囧皬锛屾渶灏忓昂瀵镐负20x20');
      }

      AppLogger.debug('寮€濮嬪垱寤烘柊閫夊尯', data: {
        'rect': '${rect.left.toStringAsFixed(1)},'
            '${rect.top.toStringAsFixed(1)},'
            '${rect.width.toStringAsFixed(1)}x'
            '${rect.height.toStringAsFixed(1)}',
        'pageId': _currentPageId,
      });

      // 2. 鍒涘缓鏂板尯鍩?      final region = CharacterRegion.create(
        pageId: _currentPageId!,
        rect: rect,
        options: const ProcessingOptions(),
      );

      // 娓呯悊鐜版湁閫夋嫨鐘舵€?      _selectedRegionNotifier.clearRegion();

      // 璁剧疆鏂扮殑閫変腑鍖哄煙骞剁珛鍗宠繘鍏ュ彲璋冭妭鐘舵€?      _selectedRegionNotifier.setRegion(region);

      // 鏇存柊鍖哄煙鍒楄〃鍜岀姸鎬?      final updatedRegions = [...state.regions, region];

      // 灏嗘柊鍒涘缓鐨勫尯鍩熸爣璁颁负鏈繚瀛?      final modifiedIds = {...state.modifiedIds, region.id};
      AppLogger.debug('鍒涘缓鏂伴€夊尯 - modifiedIds鏇存柊', data: {
        'regionId': region.id,
        'previousModifiedIds': state.modifiedIds.toList(),
        'newModifiedIds': modifiedIds.toList(),
        'isSaved': !modifiedIds.contains(region.id),
      });

      state = state.copyWith(
        regions: updatedRegions,
        currentId: region.id,
        selectedIds: {region.id}, // 鏇存柊澶氶€夌姸鎬?        modifiedIds: modifiedIds, // 鏇存柊淇敼鐘舵€?        isAdjusting: true, // 绔嬪嵆杩涘叆鍙皟鑺傜姸鎬?      );

      AppLogger.debug('鍒涘缓鏂伴€夊尯 - 鐘舵€佹洿鏂板畬鎴?, data: {
        'regionId': region.id,
        'currentModifiedIds': state.modifiedIds.toList(),
        'isSaved': !state.modifiedIds.contains(region.id),
      });

      return region;
    } catch (e, stack) {
      AppLogger.error('鍒涘缓閫夊尯澶辫触',
          error: e, stackTrace: stack, data: {'rect': rect.toString()});

      state = state.copyWith(
        error: '鍒涘缓閫夊尯澶辫触: ${e.toString()}',
      );
      return null;
    }
  }

  // 鎵归噺鍒犻櫎鍖哄煙
  Future<void> deleteBatchRegions(List<String> ids) async {
    if (ids.isEmpty) return;

    try {
      state = state.copyWith(processing: true);

      // 淇濆瓨琚垹闄ょ殑鍖哄煙浠ヤ究鎾ら攢
      final deletedRegions =
          state.regions.where((r) => ids.contains(r.id)).toList();

      // 鍒犻櫎鍖哄煙
      await _characterService.deleteBatchCharacters(ids);

      // 鏇存柊鍖哄煙鍒楄〃
      final updatedRegions =
          state.regions.where((r) => !ids.contains(r.id)).toList();

      // 鎵归噺鎾ら攢鎿嶄綔
      final batchActions =
          deletedRegions.map((r) => UndoAction.delete(r.id, r)).toList();
      final undoAction = UndoAction.batch(batchActions);
      final undoStack = [...state.undoStack, undoAction];

      // 濡傛灉鍒犻櫎浜嗗綋鍓嶉€変腑鐨勫尯鍩燂紝鍒欐竻闄ら€変腑鐘舵€?      final newCurrentId =
          ids.contains(state.currentId) ? null : state.currentId;
      if (newCurrentId == null) {
        _selectedRegionNotifier.clearRegion();
      }

      state = state.copyWith(
        regions: updatedRegions,
        currentId: newCurrentId,
        undoStack: undoStack,
        processing: false,
        selectedIds: {},
      );
    } catch (e) {
      state = state.copyWith(
        processing: false,
        error: e.toString(),
      );
    }
  }

  // 鍒犻櫎鍖哄煙
  Future<void> deleteRegion(String id) async {
    try {
      state = state.copyWith(processing: true);

      // 淇濆瓨琚垹闄ょ殑鍖哄煙浠ヤ究鎾ら攢
      final deletedRegion = state.regions.firstWhere((r) => r.id == id);

      // 鍒犻櫎鍖哄煙
      await _characterService.deleteCharacter(id);

      // 鏇存柊鍖哄煙鍒楄〃
      final updatedRegions = state.regions.where((r) => r.id != id).toList();

      // 娣诲姞鎾ら攢鎿嶄綔
      final undoAction = UndoAction.delete(id, deletedRegion);
      final undoStack = [...state.undoStack, undoAction];

      // 濡傛灉鍒犻櫎鐨勬槸褰撳墠閫変腑鐨勫尯鍩燂紝鍒欐竻闄ら€変腑鐘舵€?      final newCurrentId = state.currentId == id ? null : state.currentId;
      if (newCurrentId == null) {
        _selectedRegionNotifier.clearRegion();
      }

      state = state.copyWith(
        regions: updatedRegions,
        currentId: newCurrentId,
        undoStack: undoStack,
        processing: false,
      );
    } catch (e) {
      state = state.copyWith(
        processing: false,
        error: e.toString(),
      );
    }
  }

  /// 瀹屾垚褰撳墠鐨勮皟鏁存搷浣?  void finishCurrentAdjustment() {
    if (!state.isAdjusting || state.currentId == null) return;

    final currentRegionId = state.currentId!;
    AppLogger.debug('瀹屾垚璋冩暣 - 寮€濮?, data: {
      'currentId': currentRegionId,
      'isAdjusting': state.isAdjusting,
      'modifiedIds': state.modifiedIds.toList(),
    });

    // 鏌ユ壘褰撳墠璋冩暣鐨勫尯鍩?    final region = state.regions.firstWhere(
      (r) => r.id == currentRegionId,
      orElse: () => null as CharacterRegion,
    );

    if (region == null) {
      AppLogger.warning('瀹屾垚璋冩暣澶辫触锛氭湭鎵惧埌鍖哄煙', data: {'regionId': currentRegionId});
      _selectedRegionNotifier.clearRegion();
      state = state.copyWith(
        isAdjusting: false,
        currentId: null,
        selectedIds: {},
      );
      return;
    }

    // 妫€鏌ユ槸鍚︽槸鏂板缓閫夊尯锛堟病鏈塩haracterId锛?    final isNewRegion = region.characterId == null || !region.isSaved;

    // 妫€鏌ユ槸鍚︽湁瀹為檯淇敼
    final originalRegion = _findOriginalRegion(currentRegionId);

    // 鍒ゆ柇鏄惁鏈夊疄闄呬慨鏀癸紙浼樺寲妫€娴嬮€昏緫锛?    bool hasActualChanges = false;
    if (originalRegion != null) {
      // 鏄庣‘妫€鏌ユ瘡绉嶅彲鑳界殑淇敼
      bool positionChanged = originalRegion.rect.left != region.rect.left ||
          originalRegion.rect.top != region.rect.top;
      bool sizeChanged = originalRegion.rect.width != region.rect.width ||
          originalRegion.rect.height != region.rect.height;
      bool rotationChanged = originalRegion.rotation != region.rotation;
      bool characterChanged = originalRegion.character != region.character;
      bool optionsChanged = originalRegion.options != region.options;
      bool erasePointsChanged = _hasErasePointsChanged(
          originalRegion.erasePoints, region.erasePoints);

      hasActualChanges = positionChanged ||
          sizeChanged ||
          rotationChanged ||
          characterChanged ||
          optionsChanged ||
          erasePointsChanged;

      AppLogger.debug('淇敼妫€娴嬭鎯?, data: {
        'regionId': currentRegionId,
        'positionChanged': positionChanged,
        'sizeChanged': sizeChanged,
        'rotationChanged': rotationChanged,
        'characterChanged': characterChanged,
        'optionsChanged': optionsChanged,
        'erasePointsChanged': erasePointsChanged,
        'isNewRegion': isNewRegion,
      });
    }

    // 鍐冲畾鏄惁淇濈暀鍦╩odifiedIds涓?    Set<String> updatedModifiedIds = {...state.modifiedIds};
    if (isNewRegion) {
      // 鏂板缓閫夊尯鎬绘槸淇濈暀鍦╩odifiedIds涓紝鐩村埌淇濆瓨
      if (!updatedModifiedIds.contains(currentRegionId)) {
        updatedModifiedIds.add(currentRegionId);
      }
      AppLogger.debug('淇濈暀鏂板缓閫夊尯鍦╩odifiedIds涓?, data: {
        'regionId': currentRegionId,
      });
    } else if (!hasActualChanges && !isNewRegion) {
      // 濡傛灉涓嶆槸鏂板缓閫夊尯锛屼笖娌℃湁瀹為檯淇敼锛屼粠modifiedIds涓Щ闄?      updatedModifiedIds.remove(currentRegionId);
      AppLogger.debug('瀹屾垚璋冩暣 - 鏃犲疄闄呬慨鏀?, data: {
        'regionId': currentRegionId,
        'previousModifiedIds': state.modifiedIds.toList(),
        'newModifiedIds': updatedModifiedIds.toList(),
        'isNewRegion': isNewRegion,
      });
    } else if (hasActualChanges) {
      // 濡傛灉鏈夊疄闄呬慨鏀癸紝纭繚鍦╩odifiedIds涓?      if (!updatedModifiedIds.contains(currentRegionId)) {
        updatedModifiedIds.add(currentRegionId);
      }
      AppLogger.debug('瀹屾垚璋冩暣 - 鏈変慨鏀?, data: {
        'regionId': currentRegionId,
        'hasActualChanges': hasActualChanges,
        'modifiedIds': updatedModifiedIds.toList(),
      });
    }

    // 鏇存柊鐘舵€?    state = state.copyWith(
      isAdjusting: false,
      modifiedIds: updatedModifiedIds,
    );

    AppLogger.debug('瀹屾垚璋冩暣 - 缁撴潫', data: {
      'regionId': currentRegionId,
      'modifiedIdsCount': updatedModifiedIds.length,
      'isInModifiedIds': updatedModifiedIds.contains(currentRegionId),
    });
  }

  /// 鑾峰彇鍖哄煙鐨勮瑙夌姸鎬?  CharacterRegionState getRegionState(String id) {
    final isSelected = state.selectedIds.contains(id);
    final isAdjusting = state.isAdjusting && state.currentId == id;

    if (isAdjusting) {
      return CharacterRegionState.adjusting;
    } else if (isSelected) {
      return CharacterRegionState.selected;
    } else {
      return CharacterRegionState.normal;
    }
  }

  // 鑾峰彇缂╃暐鍥捐矾寰?  Future<String?> getThumbnailPath(String regionId) async {
    try {
      return await _characterService.getCharacterThumbnailPath(regionId);
    } catch (e) {
      AppLogger.error('鑾峰彇缂╃暐鍥捐矾寰勫け璐?, error: e);
      return null;
    }
  }

  // 鍔犺浇浣滃搧鏁版嵁
  Future<void> loadWorkData(String workId,
      {String? pageId, String? defaultSelectedRegionId}) async {
    AppLogger.debug('寮€濮嬪姞杞介€夊尯鏁版嵁', data: {
      'workId': workId,
      'pageId': pageId,
      'hasCurrentImage': _currentPageImage != null,
      'defaultSelectedRegionId': defaultSelectedRegionId,
    });

    // 鏇存柊鐘舵€侊紝浣嗕笉绔嬪嵆娓呴櫎閫変腑鐘舵€侊紝绛夊尯鍩熸暟鎹姞杞藉悗鍐嶅鐞?    state = state.copyWith(
      loading: true,
      error: null,
    );

    try {
      // 鏇存柊褰撳墠涓婁笅鏂?      _currentWorkId = workId;
      _currentPageId = pageId;

      if (_currentPageImage == null) {
        throw Exception('椤甸潰鍥惧儚鏈缃紝鏃犳硶鍔犺浇閫夊尯鏁版嵁');
      }

      // 鍔犺浇鍖哄煙鏁版嵁
      AppLogger.debug('浠庢暟鎹簱鍔犺浇閫夊尯鏁版嵁', data: {
        'pageId': pageId ?? 'null',
      });

      final regions = await _characterService.getPageRegions(pageId ?? '');

      AppLogger.debug('閫夊尯鏁版嵁鍔犺浇瀹屾垚', data: {
        'regionsCount': regions.length,
        'workId': workId,
        'pageId': pageId,
      });

      // 淇濆瓨褰撳墠閫変腑鐘舵€?      final currentSelectedIds = {...state.selectedIds};
      final currentId = state.currentId;

      // 鏍规嵁姣忎釜鍖哄煙鐨?characterId 鐘舵€佸垵濮嬪寲 modifiedIds
      final modifiedIds = <String>{};
      for (final region in regions) {
        // 涓ょ鎯呭喌闇€瑕佹坊鍔犲埌modifiedIds锛?        // 1. 鏈繚瀛樼殑鍖哄煙锛坈haracterId涓簄ull锛?        // 2. 宸叉湁characterId浣唅sSaved=false鐨勫尯鍩燂紙宸蹭慨鏀逛絾鏈繚瀛橈級
        if (region.characterId == null || !region.isSaved) {
          modifiedIds.add(region.id);
          AppLogger.debug('娣诲姞鏈繚瀛樺尯鍩熷埌 modifiedIds', data: {
            'regionId': region.id,
            'characterId': region.characterId,
            'isSaved': region.isSaved,
          });
        }
      }

      AppLogger.debug('鍒濆鍖?modifiedIds', data: {
        'modifiedIds': modifiedIds.toList(),
        'totalRegions': regions.length,
        'unsavedCount': modifiedIds.length,
      });

      // 鏇存柊鐘舵€侊紝浣嗕繚鐣欓€変腑鐘舵€?      state = state.copyWith(
        workId: workId,
        pageId: pageId,
        regions: regions,
        selectedIds: currentSelectedIds,
        currentId: currentId,
        modifiedIds: modifiedIds,
        loading: false,
      );

      // 濡傛灉鏈夐粯璁ら€変腑鐨勯€夊尯ID锛屽苟涓旇閫夊尯瀛樺湪浜庡姞杞界殑鍖哄煙涓紝鍒欓€変腑瀹?      if (defaultSelectedRegionId != null) {
        final targetRegion = regions.firstWhere(
          (r) => r.id == defaultSelectedRegionId,
          orElse: () => null as CharacterRegion,
        );

        if (targetRegion != null) {
          // 鐩存帴鏇存柊鐘舵€侊紝涓嶉渶瑕佽皟鐢╤andleRegionClick
          state = state.copyWith(
            currentId: defaultSelectedRegionId,
            selectedIds: {defaultSelectedRegionId},
          );
          _selectedRegionNotifier.setRegion(targetRegion);
          AppLogger.debug('宸查€変腑榛樿閫夊尯', data: {
            'regionId': defaultSelectedRegionId,
          });
        }
      }
    } catch (e, stack) {
      AppLogger.error('鍔犺浇閫夊尯鏁版嵁澶辫触', error: e, stackTrace: stack, data: {
        'workId': workId,
        'pageId': pageId,
      });

      // 鏇存柊閿欒鐘舵€?      state = state.copyWith(
        loading: false,
        error: '鍔犺浇閫夊尯鏁版嵁澶辫触: ${e.toString()}',
        regions: [], // 纭繚娓呯┖鍖哄煙鍒楄〃
      );
    }
  }

  /// 鏍囪鍖哄煙涓哄凡淇敼
  void markAsModified(String id) {
    if (!state.regions.any((r) => r.id == id)) return;

    state = state.copyWith(
      modifiedIds: {...state.modifiedIds, id},
    );
  }

  /// 鏍囪鍖哄煙涓哄凡淇濆瓨
  void markAsSaved(String id) {
    AppLogger.debug('灏濊瘯鏍囪鍖哄煙涓哄凡淇濆瓨', data: {
      'regionId': id,
      'currentlyModified': state.modifiedIds.contains(id),
    });

    if (!state.modifiedIds.contains(id)) return;

    final updatedModifiedIds = {...state.modifiedIds}..remove(id);

    // 鏇存柊鍖哄煙鐨勪繚瀛樼姸鎬?    final index = state.regions.indexWhere((r) => r.id == id);
    List<CharacterRegion> updatedRegions = [...state.regions];
    if (index >= 0) {
      final oldRegion = updatedRegions[index];
      updatedRegions[index] = updatedRegions[index].copyWith(isSaved: true);
      AppLogger.debug('鏇存柊鍖哄煙鍒楄〃涓殑isSaved鐘舵€?, data: {
        'regionId': id,
        'oldIsSaved': oldRegion.isSaved,
        'newIsSaved': updatedRegions[index].isSaved,
      });
    } else {
      AppLogger.warning('鍦╮egions鍒楄〃涓湭鎵惧埌瑕佹爣璁颁负宸蹭繚瀛樼殑鍖哄煙', data: {'regionId': id});
    }

    final oldModifiedIds = state.modifiedIds;
    state = state.copyWith(
      modifiedIds: updatedModifiedIds,
      regions: updatedRegions, // 纭繚鏇存柊鍖哄煙鍒楄〃
    );
    AppLogger.debug('markAsSaved 瀹屾垚鐘舵€佹洿鏂?, data: {
      'regionId': id,
      'previousModifiedIds': oldModifiedIds,
      'currentModifiedIds': state.modifiedIds,
    });
  }

  // 閲嶅仛鎿嶄綔
  Future<void> redo() async {
    if (state.redoStack.isEmpty) return;

    try {
      state = state.copyWith(processing: true);

      // 鑾峰彇鏈€鍚庝竴涓噸鍋氭搷浣?      final action = state.redoStack.last;
      final redoStack = state.redoStack.sublist(0, state.redoStack.length - 1);
      final undoStack = [...state.undoStack, action];

      switch (action.type) {
        case UndoActionType.create:
          // 閲嶅仛鍒涘缓鎿嶄綔 - 鎭㈠鍒涘缓鐨勫尯鍩?          final region = action.data as CharacterRegion;

          if (_currentPageImage == null) {
            throw Exception('褰撳墠椤甸潰鍥惧儚涓虹┖');
          }
          AppLogger.debug('浣跨敤褰撳墠椤甸潰鍥惧儚杩涜閲嶅仛鎿嶄綔',
              data: {'imageDataLength': _currentPageImage!.length});

          await _characterService.extractCharacter(
            _currentWorkId ?? '',
            region.pageId,
            region.rect,
            region.options,
            _currentPageImage!,
          );
          final updatedRegions = [...state.regions, region];

          state = state.copyWith(
            regions: updatedRegions,
            redoStack: redoStack,
            undoStack: undoStack,
            processing: false,
          );
          break;

        case UndoActionType.delete:
          // 閲嶅仛鍒犻櫎鎿嶄綔 - 鍒犻櫎鍖哄煙
          final data = action.data as Map<String, dynamic>;
          final id = data['id'] as String;
          await _characterService.deleteCharacter(id);
          final updatedRegions =
              state.regions.where((r) => r.id != id).toList();

          state = state.copyWith(
            regions: updatedRegions,
            currentId: state.currentId == id ? null : state.currentId,
            redoStack: redoStack,
            undoStack: undoStack,
            processing: false,
          );

          if (state.currentId == null) {
            _selectedRegionNotifier.clearRegion();
          }
          break;

        case UndoActionType.update:
          // 閲嶅仛鏇存柊鎿嶄綔
          // TODO: 瀹炵幇閲嶅仛鏇存柊鐨勯€昏緫
          state = state.copyWith(
            redoStack: redoStack,
            undoStack: undoStack,
            processing: false,
          );
          break;

        case UndoActionType.erase:
          // 閲嶅仛鎿﹂櫎鎿嶄綔
          // TODO: 瀹炵幇閲嶅仛鎿﹂櫎鐨勯€昏緫
          state = state.copyWith(
            redoStack: redoStack,
            undoStack: undoStack,
            processing: false,
          );
          break;

        case UndoActionType.batch:
          // 閲嶅仛鎵归噺鎿嶄綔
          // TODO: 瀹炵幇閲嶅仛鎵归噺鎿嶄綔鐨勯€昏緫
          state = state.copyWith(
            redoStack: redoStack,
            undoStack: undoStack,
            processing: false,
          );
          break;
      }
    } catch (e) {
      state = state.copyWith(
        processing: false,
        error: e.toString(),
      );
    }
  }

  /// 璇锋眰鍒犻櫎鍗曚釜鍖哄煙
  /// 杩斿洖涓€涓狥uture<bool>琛ㄧず鐢ㄦ埛鏄惁纭鍒犻櫎
  Future<bool> requestDeleteRegion(String id) async {
    // 杩欓噷瀹為檯涓婂彧鏄彁渚涗竴涓帴鍙ｏ紝瀹為檯鐨勭‘璁ゅ璇濇閫昏緫鍦║I灞傚疄鐜?    // 杩斿洖true琛ㄧず鍙互缁х画鍒犻櫎鎿嶄綔
    return true;
  }

  /// 璇锋眰鍒犻櫎閫変腑鐨勫尯鍩?  /// 杩斿洖涓€涓狥uture<bool>琛ㄧず鐢ㄦ埛鏄惁纭鍒犻櫎
  /// 娉ㄦ剰锛氭鏂规硶涓嶆墽琛屽疄闄呭垹闄わ紝鍙槸鎻愪緵涓€涓粺涓€鐨勬帴鍙ｆ潵璇锋眰鍒犻櫎
  Future<bool> requestDeleteRegions() async {
    if (state.selectedIds.isEmpty) return false;

    // 杩欓噷瀹為檯涓婂彧鏄彁渚涗竴涓帴鍙ｏ紝瀹為檯鐨勭‘璁ゅ璇濇閫昏緫鍦║I灞傚疄鐜?    // 杩斿洖true琛ㄧず鍙互缁х画鍒犻櫎鎿嶄綔
    return true;
  }

  // 淇濆瓨褰撳墠缂栬緫鐨勫尯鍩?  Future<void> saveCurrentRegion() async {
    AppLogger.debug('saveCurrentRegion 璋冪敤',
        data: {'currentId': state.currentId});
    if (state.currentId == null) return;

    try {
      state = state.copyWith(processing: true);

      final region = _selectedRegionNotifier.getCurrentRegion();
      if (region == null) {
        throw Exception('No region selected');
      }

      // 妫€鏌ュ尯鍩熸槸鍚﹀瓨鍦ㄤ簬鍒楄〃涓?      final exists = state.regions.any((r) => r.id == region.id);

      if (exists) {
        // 鏇存柊鐜版湁鍖哄煙
        AppLogger.debug('淇濆瓨鐜版湁鍖哄煙', data: {'regionId': region.id});
        await _characterService.updateCharacter(
          region.id,
          region.copyWith(isSaved: true), // 鏄庣‘鏍囪涓哄凡淇濆瓨
          region.character,
        );

        // 鏇存柊鍖哄煙鍒楄〃
        final updatedRegions = [...state.regions];
        final index = updatedRegions.indexWhere((r) => r.id == region.id);
        updatedRegions[index] = region.copyWith(isSaved: true); // 鏍囪涓哄凡淇濆瓨

        // 浠庡凡淇敼闆嗗悎涓Щ闄わ紝琛ㄧず宸蹭繚瀛?        final Set<String> originalModifiedIds = {...state.modifiedIds};
        final modifiedIds = {...state.modifiedIds}..remove(region.id);
        AppLogger.debug('鏇存柊modifiedIds (鐜版湁鍖哄煙)', data: {
          'regionId': region.id,
          'beforeRemove': originalModifiedIds.toList(),
          'afterRemove': modifiedIds.toList(),
          'hasBeenRemoved': !modifiedIds.contains(region.id),
        });

        state = state.copyWith(
          regions: updatedRegions,
          processing: false,
          modifiedIds: modifiedIds, // 鏇存柊淇敼鐘舵€?          isAdjusting: false, // 閫€鍑鸿皟鏁寸姸鎬?        );
        AppLogger.debug('鐘舵€佹洿鏂板畬鎴?(鐜版湁鍖哄煙)', data: {
          'modifiedIdsCount': state.modifiedIds.length,
          'modifiedIds': state.modifiedIds.toList(),
          'hasUnsavedChanges': state.hasUnsavedChanges,
        });

        // 寮哄埗鍒涘缓涓€涓叏鏂扮殑鐘舵€佸璞?        final newState = CharacterCollectionState(
          workId: state.workId,
          pageId: state.pageId,
          regions: List.from(state.regions), // 纭繚鏄柊鍒楄〃瀹炰緥
          selectedIds: Set.from(state.selectedIds),
          modifiedIds: Set.from(state.modifiedIds), // 纭繚鏄柊 Set 瀹炰緥
          currentId: state.currentId,
          currentTool: state.currentTool,
          defaultOptions: state.defaultOptions,
          undoStack: List.from(state.undoStack),
          redoStack: List.from(state.redoStack),
          loading: state.loading,
          processing: state.processing,
          error: state.error,
          isAdjusting: state.isAdjusting,
        );
        state = newState;
        AppLogger.debug('寮哄埗搴旂敤浜嗗叏鏂扮殑 State 瀵硅薄 (鐜版湁鍖哄煙)', data: {
          'modifiedIdsCount': state.modifiedIds.length,
          'modifiedIds': state.modifiedIds.toList(),
          'hasUnsavedChanges': state.hasUnsavedChanges,
        });
      } else {
        // 鍒涘缓鏂板尯鍩?        AppLogger.debug('鍒涘缓骞朵繚瀛樻柊鍖哄煙', data: {'tempRegionId': region.id});
        if (_currentPageImage == null || _currentPageId == null) {
          throw Exception('Page image or ID not available');
        }

        AppLogger.debug('浣跨敤褰撳墠椤甸潰鍥惧儚鍒涘缓鏂板尯鍩?,
            data: {'imageDataLength': _currentPageImage!.length});

        // 鎻愬彇骞跺鐞嗗瓧绗︼紝鏄庣‘璁剧疆isSaved涓簍rue
        final characterEntity = await _characterService.extractCharacter(
          _currentWorkId ?? '',
          _currentPageId!,
          region.rect,
          region.options,
          _currentPageImage!,
          isSaved: true, // 娣诲姞鍙傛暟锛岀‘淇濇暟鎹簱涓篃鏍囪涓哄凡淇濆瓨
        );
        AppLogger.debug('鏁版嵁搴撴搷浣滃畬鎴愶紝鑾峰彇鍒?CharacterEntity',
            data: {'entityId': characterEntity.id});

        // 鏇存柊涓烘纭殑ID骞舵爣璁颁负宸蹭繚瀛?        final newRegion = region.copyWith(
          id: characterEntity.id,
          isSaved: true,
          characterId: characterEntity.id, // 璁剧疆鍏宠仈鐨凜haracter ID
        );
        AppLogger.debug('鍒涘缓浜嗘柊鐨?Region 瀵硅薄', data: {
          'newRegionId': newRegion.id,
          'isSaved': newRegion.isSaved,
          'characterId': newRegion.characterId,
        });

        // 鏇存柊鍖哄煙鍒楄〃
        final updatedRegions = [...state.regions];
        final index =
            updatedRegions.indexWhere((r) => r.id == region.id); // 鏌ユ壘涓存椂 ID
        if (index >= 0) {
          // 鏇挎崲宸插瓨鍦ㄧ殑涓存椂鍖哄煙
          AppLogger.debug('鏇挎崲涓存椂鍖哄煙',
              data: {'tempId': region.id, 'newId': newRegion.id});
          updatedRegions[index] = newRegion;
        } else {
          // 娣诲姞鏂板尯鍩?(鐞嗚涓婂垱寤烘柊鍖哄煙鏃讹紝鏃х殑涓存椂ID搴旇瀛樺湪)
          AppLogger.warning('鏈壘鍒拌鏇挎崲鐨勪复鏃跺尯鍩燂紝鐩存帴娣诲姞',
              data: {'tempId': region.id, 'newId': newRegion.id});
          updatedRegions.add(newRegion);
        }

        // 浠庡凡淇敼闆嗗悎涓Щ闄わ紝琛ㄧず宸蹭繚瀛?        final Set<String> originalModifiedIds = {...state.modifiedIds};
        final modifiedIds = {...state.modifiedIds}
          ..remove(region.id) // 绉婚櫎鏃х殑涓存椂ID
          ..remove(newRegion.id); // 绉婚櫎鏂扮殑銆佸凡淇濆瓨鐨処D
        AppLogger.debug('鏇存柊modifiedIds (鏂板尯鍩?', data: {
          'tempRegionId': region.id,
          'newRegionId': newRegion.id,
          'beforeRemove': originalModifiedIds.toList(),
          'afterRemove': modifiedIds.toList(),
          'hasBeenRemovedTemp': !modifiedIds.contains(region.id),
          'hasBeenRemovedNew': !modifiedIds.contains(newRegion.id),
        });

        state = state.copyWith(
          regions: updatedRegions,
          currentId: newRegion.id, // 纭繚褰撳墠ID鏇存柊涓烘柊鐨処D
          processing: false,
          modifiedIds: modifiedIds, // 鏇存柊淇敼鐘舵€?          isAdjusting: false, // 閫€鍑鸿皟鏁寸姸鎬?        );
        AppLogger.debug('鐘舵€佹洿鏂板畬鎴?(鏂板尯鍩?', data: {
          'modifiedIdsCount': state.modifiedIds.length,
          'modifiedIds': state.modifiedIds.toList(),
          'hasUnsavedChanges': state.hasUnsavedChanges,
        });
        _selectedRegionNotifier.setRegion(newRegion);
        AppLogger.debug('SelectedRegionProvider 鏇存柊瀹屾垚...');

        // 寮哄埗鍒涘缓涓€涓叏鏂扮殑鐘舵€佸璞?        final newState = CharacterCollectionState(
          workId: state.workId,
          pageId: state.pageId,
          regions: List.from(state.regions), // 纭繚鏄柊鍒楄〃瀹炰緥
          selectedIds: Set.from(state.selectedIds),
          modifiedIds: Set.from(state.modifiedIds), // 纭繚鏄柊 Set 瀹炰緥
          currentId: state.currentId,
          currentTool: state.currentTool,
          defaultOptions: state.defaultOptions,
          undoStack: List.from(state.undoStack),
          redoStack: List.from(state.redoStack),
          loading: state.loading,
          processing: state.processing,
          error: state.error,
          isAdjusting: state.isAdjusting,
        );
        state = newState;
        AppLogger.debug('寮哄埗搴旂敤浜嗗叏鏂扮殑 State 瀵硅薄 (鏂板尯鍩?', data: {
          'modifiedIdsCount': state.modifiedIds.length,
          'modifiedIds': state.modifiedIds.toList(),
          'hasUnsavedChanges': state.hasUnsavedChanges,
        });
      }
    } catch (e) {
      AppLogger.error('淇濆瓨鍖哄煙澶辫触', error: e);
      state = state.copyWith(
        processing: false,
        error: e.toString(),
      );
    }
  }

  // 澶氶€夊姛鑳斤細閫夋嫨鎵€鏈夊尯鍩?  void selectAll() {
    final selectedIds = state.regions.map((r) => r.id).toSet();
    state = state.copyWith(selectedIds: selectedIds);
  }

  /// 閫夋嫨鎸囧畾鐨勫尯鍩?  void selectRegion(String? id) {
    AppLogger.debug('閫夋嫨鍖哄煙', data: {
      'regionId': id,
      'currentId': state.currentId,
      'isAdjusting': state.isAdjusting,
    });

    // 濡傛灉褰撳墠姝ｅ湪璋冩暣锛屽厛瀹屾垚璋冩暣
    if (state.isAdjusting) {
      finishCurrentAdjustment();
    }

    // 濡傛灉鏄竻闄ら€夋嫨
    if (id == null) {
      _selectedRegionNotifier.clearRegion();
      state = state.copyWith(
        currentId: null,
        selectedIds: {},
      );
      AppLogger.debug('娓呴櫎閫夊尯');
      return;
    }

    // 鏌ユ壘鐩爣鍖哄煙
    final region = state.regions.firstWhere(
      (r) => r.id == id,
      orElse: () => null as CharacterRegion,
    );

    if (region == null) {
      AppLogger.warning('閫夋嫨鍖哄煙澶辫触锛氭湭鎵惧埌鐩爣鍖哄煙', data: {'regionId': id});
      state = state.copyWith(error: '鎵句笉鍒板尯鍩燂細$id');
      return;
    }

    // 鏇存柊閫変腑鐘舵€?    _selectedRegionNotifier.setRegion(region);
    state = state.copyWith(
      currentId: id,
      selectedIds: {id},
      error: null,
    );

    AppLogger.debug('閫夊尯鏇存柊瀹屾垚', data: {
      'regionId': id,
      'currentId': state.currentId,
      'selectedIds': state.selectedIds,
    });
  }

  // 璁剧疆璋冩暣鐘舵€?  void setAdjusting(bool isAdjusting) {
    if (state.isAdjusting != isAdjusting) {
      // 濡傛灉姝ｅ湪閫€鍑鸿皟鏁寸姸鎬侊紝鍏堝畬鎴愬綋鍓嶈皟鏁?      if (state.isAdjusting && !isAdjusting) {
        finishCurrentAdjustment();
      }

      state = state.copyWith(isAdjusting: isAdjusting);
      AppLogger.debug('Set Adjusting State',
          data: {'isAdjusting': isAdjusting});
    }
  }

  /// 璁剧疆褰撳墠椤甸潰鍥惧儚
  /// 1. 瑙ｇ爜骞堕獙璇佸浘鍍忔暟鎹?  /// 2. 鏇存柊鍥惧儚鏁版嵁锛屼絾淇濈暀鐜版湁鐘舵€?  void setCurrentPageImage(Uint8List imageData) {
    AppLogger.debug('鍑嗗璁剧疆褰撳墠椤甸潰鍥惧儚', data: {
      'imageDataLength': imageData.length,
      'hasExistingImage': _currentPageImage != null,
    });

    try {
      // 1. 瑙ｇ爜骞堕獙璇佸浘鍍忔暟鎹?      final decodedImage = img.decodeImage(imageData);
      if (decodedImage == null) {
        AppLogger.error('鍥惧儚鏁版嵁瑙ｇ爜澶辫触锛氳В鐮佺粨鏋滀负null');
        throw Exception('Invalid image data: decoded result is null');
      }

      // 2. 鏇存柊鍥惧儚鏁版嵁锛屼絾淇濈暀鐜版湁鐘舵€?      _currentPageImage = imageData;

      AppLogger.debug('鍥惧儚鏁版嵁璁剧疆瀹屾垚', data: {
        'width': decodedImage.width,
        'height': decodedImage.height,
        'channels': decodedImage.numChannels,
      });
    } catch (e, stack) {
      AppLogger.error('璁剧疆椤甸潰鍥惧儚澶辫触',
          error: e,
          stackTrace: stack,
          data: {'imageDataLength': imageData.length});
      rethrow;
    }
  }

  // 澶氶€夊姛鑳斤細鍒囨崲閫夋嫨鐘舵€?  void toggleSelection(String id) {
    final selectedIds = <String>{...state.selectedIds};

    if (selectedIds.contains(id)) {
      selectedIds.remove(id);
    } else {
      selectedIds.add(id);
    }

    state = state.copyWith(selectedIds: selectedIds);
  }

  // 鎾ら攢鎿嶄綔
  Future<void> undo() async {
    if (state.undoStack.isEmpty) return;

    try {
      state = state.copyWith(processing: true);

      // 鑾峰彇鏈€鍚庝竴涓挙閿€鎿嶄綔
      final action = state.undoStack.last;
      final undoStack = state.undoStack.sublist(0, state.undoStack.length - 1);
      final redoStack = [...state.redoStack, action];

      switch (action.type) {
        case UndoActionType.create:
          // 鎾ら攢鍒涘缓鎿嶄綔 - 鍒犻櫎鍖哄煙
          final id = action.data as String;
          await _characterService.deleteCharacter(id);
          final updatedRegions =
              state.regions.where((r) => r.id != id).toList();

          state = state.copyWith(
            regions: updatedRegions,
            currentId: state.currentId == id ? null : state.currentId,
            undoStack: undoStack,
            redoStack: redoStack,
            processing: false,
          );

          if (state.currentId == null) {
            _selectedRegionNotifier.clearRegion();
          }
          break;

        case UndoActionType.delete:
          // 鎾ら攢鍒犻櫎鎿嶄綔 - 鎭㈠鍖哄煙
          final data = action.data as Map<String, dynamic>;
          final id = data['id'] as String;
          final deletedRegion = data['deletedState'] as CharacterRegion;

          if (_currentPageImage == null) {
            throw Exception('褰撳墠椤甸潰鍥惧儚涓虹┖');
          }

          AppLogger.debug('浣跨敤褰撳墠椤甸潰鍥惧儚杩涜鎾ら攢鎿嶄綔',
              data: {'imageDataLength': _currentPageImage!.length});

          await _characterService.extractCharacter(
            _currentWorkId ?? '',
            deletedRegion.pageId,
            deletedRegion.rect,
            deletedRegion.options,
            _currentPageImage!,
          );

          final updatedRegions = [...state.regions, deletedRegion];

          state = state.copyWith(
            regions: updatedRegions,
            undoStack: undoStack,
            redoStack: redoStack,
            processing: false,
          );
          break;

        case UndoActionType.update:
          // 鎾ら攢鏇存柊鎿嶄綔 - 鎭㈠鍘熷鐘舵€?          // TODO: 瀹炵幇鎾ら攢鏇存柊鐨勯€昏緫
          state = state.copyWith(
            undoStack: undoStack,
            redoStack: redoStack,
            processing: false,
          );
          break;

        case UndoActionType.erase:
          // 鎾ら攢鎿﹂櫎鎿嶄綔
          // TODO: 瀹炵幇鎾ら攢鎿﹂櫎鐨勯€昏緫
          state = state.copyWith(
            undoStack: undoStack,
            redoStack: redoStack,
            processing: false,
          );
          break;

        case UndoActionType.batch:
          // 鎾ら攢鎵归噺鎿嶄綔
          // TODO: 瀹炵幇鎾ら攢鎵归噺鎿嶄綔鐨勯€昏緫
          state = state.copyWith(
            undoStack: undoStack,
            redoStack: redoStack,
            processing: false,
          );
          break;
      }
    } catch (e) {
      state = state.copyWith(
        processing: false,
        error: e.toString(),
      );
    }
  }

  // 浠庡閫夐泦鍚堜腑绉婚櫎鍖哄煙
  void unselectRegion(String id) {
    final updatedSelectedIds = {...state.selectedIds}..remove(id);

    // 濡傛灉褰撳墠姝ｅ湪缂栬緫鐨勫尯鍩熻鍙栨秷閫夋嫨锛屽垯涔熸竻闄urrentId
    final newCurrentId = (state.currentId == id) ? null : state.currentId;

    if (newCurrentId == null) {
      _selectedRegionNotifier.clearRegion();
    }

    state = state.copyWith(
      selectedIds: updatedSelectedIds,
      currentId: newCurrentId,
    );
  }

  // 鏇存柊閫変腑鍖哄煙
  void updateSelectedRegion(CharacterRegion region) {
    if (state.currentId == null) return;

    // 鎵惧埌褰撳墠鍖哄煙鐨勭储寮?    final index = state.regions.indexWhere((r) => r.id == state.currentId);

    if (index >= 0) {
      // 鑾峰彇鏃у尯鍩熶互渚挎瘮杈冩槸鍚︽湁瀹為檯鍐呭鍙樺寲
      final oldRegion = state.regions[index];

      // 妫€鏌ユ摝闄ょ偣鏄惁鏈夊彉鍖?      bool hasErasePointsChanges =
          _hasErasePointsChanged(oldRegion.erasePoints, region.erasePoints);

      // 妫€鏌ユ槸鍚︽湁瀹為檯鍐呭鍙樺寲锛堜緥濡備綅缃€佸ぇ灏忋€佹棆杞瓑锛?      bool hasContentChanges = oldRegion.rect != region.rect ||
          oldRegion.rotation != region.rotation ||
          oldRegion.character != region.character ||
          hasErasePointsChanges ||
          oldRegion.options != region.options;

      AppLogger.debug('妫€鏌ュ尯鍩熷唴瀹瑰彉鍖?, data: {
        'regionId': region.id,
        'hasContentChanges': hasContentChanges,
        'hasErasePointsChanges': hasErasePointsChanges,
        'oldRect': oldRegion.rect.toString(),
        'newRect': region.rect.toString(),
        'oldRotation': oldRegion.rotation,
        'newRotation': region.rotation,
        'rotationChanged': oldRegion.rotation != region.rotation,
        'oldCharacter': oldRegion.character,
        'newCharacter': region.character,
        'characterChanged': oldRegion.character != region.character,
        'optionsChanged': oldRegion.options != region.options,
        'isInModifiedIds': state.modifiedIds.contains(region.id),
      });

      // 鏇存柊鍖哄煙鍒楄〃
      final updatedRegions = [...state.regions];
      updatedRegions[index] = region;

      // 浠呭綋鏈夊疄闄呭唴瀹瑰彉鍖栨椂锛屾墠灏嗘洿鏂扮殑鍖哄煙娣诲姞鍒板凡淇敼闆嗗悎涓?      final modifiedIds = hasContentChanges
          ? {...state.modifiedIds, region.id}
          : state.modifiedIds;

      // 鏇存柊鐘舵€?      state = state.copyWith(
        regions: updatedRegions,
        modifiedIds: modifiedIds, // 鍙湪鍐呭鍙樺寲鏃舵洿鏂颁慨鏀圭姸鎬?      );

      AppLogger.debug('鍖哄煙鏇存柊瀹屾垚', data: {
        'regionId': region.id,
        'hasContentChanges': hasContentChanges,
        'isInModifiedIds': modifiedIds.contains(region.id),
        'modifiedIdsCount': modifiedIds.length,
      });

      // 鏇存柊閫変腑鍖哄煙
      _selectedRegionNotifier.setRegion(region);
    }
  }

  /// [Internal] Finds the region and updates the SelectedRegionNotifier.
  /// Does NOT update the main collection state. Returns null if not found or error.
  CharacterRegion? _findAndSetSelectedRegion(String? id) {
    try {
      AppLogger.debug('[Internal] Finding region', data: {'targetId': id});
      if (id == null) {
        _selectedRegionNotifier.clearRegion();
        AppLogger.debug('[Internal] Cleared selected region notifier');
        return null;
      }

      // Find region using where + firstOrNull pattern (emulated)
      final matchingRegions = state.regions.where((r) => r.id == id).toList();
      final CharacterRegion? region =
          matchingRegions.isNotEmpty ? matchingRegions.first : null;

      if (region == null) {
        // Update error state if region not found
        state = state.copyWith(error: '鏌ユ壘鍖哄煙澶辫触: ID $id 鏈壘鍒?);
        _selectedRegionNotifier.clearRegion(); // Ensure notifier is cleared
        return null;
      }

      _selectedRegionNotifier.setRegion(region);
      AppLogger.debug('[Internal] Set selected region notifier',
          data: {'regionId': id});
      return region;
    } catch (e, stack) {
      AppLogger.error('[Internal] Finding region failed',
          error: e, stackTrace: stack, data: {'targetId': id});
      _selectedRegionNotifier.clearRegion();
      state = state.copyWith(error: '鏌ユ壘鍖哄煙鏃跺彂鐢熼敊璇? ${e.toString()}');
      return null;
    }
  }

  // 鏂板: 鏌ユ壘鍘熷鍖哄煙鏁版嵁 (鐢ㄤ簬姣旇緝鏄惁鏈夊疄闄呬慨鏀?
  CharacterRegion? _findOriginalRegion(String id) {
    try {
      // 杩欓噷搴旇鏄粠鏁版嵁搴撴垨缂撳瓨涓幏鍙栧師濮嬪尯鍩熸暟鎹?      // 鐩墠绠€鍗曞疄鐜帮紝浠呰繑鍥炲綋鍓峴tate涓殑region
      final regions = state.regions.where((r) => r.id == id).toList();
      return regions.isNotEmpty ? regions.first : null;
    } catch (e) {
      AppLogger.error('鏌ユ壘鍘熷鍖哄煙鏁版嵁澶辫触', error: e, data: {'id': id});
      return null;
    }
  }

  // 妫€鏌ユ摝闄ょ偣鏄惁鏈夊彉鍖?  bool _hasErasePointsChanged(
      List<Offset>? oldPoints, List<Offset>? newPoints) {
    // 濡傛灉涓€涓负null鑰屽彟涓€涓笉涓簄ull锛屽垯瑙嗕负鏈夊彉鍖?    if ((oldPoints == null && newPoints != null) ||
        (oldPoints != null && newPoints == null)) {
      return true;
    }

    // 濡傛灉涓よ€呴兘涓簄ull锛屽垯娌℃湁鍙樺寲
    if (oldPoints == null && newPoints == null) {
      return false;
    }

    // 濡傛灉鐐圭殑鏁伴噺涓嶅悓锛屽垯鏈夊彉鍖?    if (oldPoints!.length != newPoints!.length) {
      return true;
    }

    // 绠€鍖栧垽鏂細濡傛灉鏈夋摝闄ょ偣锛岃涓烘湁鍙樺寲
    // 瀹為檯搴旂敤涓彲鑳介渶瑕佹洿绮剧‘鐨勬瘮杈?    if (oldPoints.isNotEmpty || newPoints.isNotEmpty) {
      return true;
    }
    return false;
  }

  // 鏂板: 妫€鏌ヤ袱涓尯鍩熸槸鍚﹀疄闄呭唴瀹圭浉鍚?(娌℃湁瀹炶川鎬т慨鏀?
  bool _isRegionUnchanged(CharacterRegion original, CharacterRegion current) {
    // 姣旇緝rect
    if (original.rect != current.rect) {
      AppLogger.debug('Region changed: rect', data: {
        'original': original.rect.toString(),
        'current': current.rect.toString()
      });
      return false;
    }

    // 姣旇緝rotation
    if (original.rotation != current.rotation) {
      AppLogger.debug('Region changed: rotation',
          data: {'original': original.rotation, 'current': current.rotation});
      return false;
    }

    // 姣旇緝character
    if (original.character != current.character) {
      AppLogger.debug('Region changed: character',
          data: {'original': original.character, 'current': current.character});
      return false;
    }

    // 姣旇緝erasePoints
    if (!_areErasePointsEqual(
        original.erasePoints ?? [], current.erasePoints ?? [])) {
      AppLogger.debug('Region changed: erasePoints', data: {
        'original': original.erasePoints?.length ?? 0,
        'current': current.erasePoints?.length ?? 0
      });
      return false;
    }

    return true;
  }

  bool _areErasePointsEqual(List<Offset> points1, List<Offset> points2) {
    if (points1.length != points2.length) return false;

    for (int i = 0; i < points1.length; i++) {
      if (points1[i].dx != points2[i].dx || points1[i].dy != points2[i].dy) {
        return false;
      }
    }

    return true;
  }
}

// 娣诲姞鐘舵€佺鐞嗘墿灞曟柟娉?extension StateManagement on CharacterCollectionNotifier {
  /// 澶勭悊鍖哄煙鐐瑰嚮閫昏緫
  /// 鏍规嵁褰撳墠宸ュ叿妯″紡杞崲鍖哄煙鐘舵€?  void handleRegionClick(String id) {
    final currentTool = _toolModeNotifier.currentMode;
    // Find the region first to ensure it exists before proceeding
    final matchingRegions = state.regions.where((r) => r.id == id).toList();
    final CharacterRegion? region =
        matchingRegions.isNotEmpty ? matchingRegions.first : null;

    if (region == null) {
      AppLogger.warning('Region clicked but not found in state',
          data: {'regionId': id});
      state = state.copyWith(error: 'Clicked region $id not found');
      return;
    }

    AppLogger.debug('澶勭悊鍖哄煙鐐瑰嚮', data: {
      'regionId': id,
      'currentTool': currentTool.toString(),
      'isAdjusting': state.isAdjusting,
      'isSelected': state.selectedIds.contains(id),
    });

    // 濡傛灉褰撳墠姝ｅ湪璋冩暣锛屽厛瀹屾垚璋冩暣
    if (state.isAdjusting) {
      finishCurrentAdjustment();
    }

    // 鏍规嵁宸ュ叿妯″紡澶勭悊鐐瑰嚮
    switch (currentTool) {
      case Tool.pan:
        _handlePanModeClick(id);
        break;
      case Tool.select:
        _handleSelectModeClick(id);
        break;
      case Tool.multiSelect:
        // 澶氶€夋ā寮忓凡搴熷純锛岄檷绾т负Pan妯″紡澶勭悊
        _handlePanModeClick(id);
        break;
      default:
        // 鍏朵粬宸ュ叿妯″紡榛樿澶勭悊涓篜an妯″紡
        _handlePanModeClick(id);
        break;
    }
  }

  /// 澶勭悊Pan妯″紡涓嬬殑鐐瑰嚮 (Add logging and ensure adjusting is false)
  void _handlePanModeClick(String id) {
    AppLogger.debug('Handling Pan Mode Click', data: {'regionId': id});

    // 濡傛灉褰撳墠鍖哄煙宸茶閫変腑锛屽垯鍙栨秷閫夋嫨
    if (state.selectedIds.contains(id)) {
      unselectRegion(id);
      AppLogger.debug('Pan Mode Click: Deselected region',
          data: {'regionId': id});
    } else {
      // 濡傛灉鏈€変腑锛屽垯閫変腑璇ュ尯鍩?      selectRegion(id);
      AppLogger.debug('Pan Mode Click: Selected region',
          data: {'regionId': id});
    }
  }

  /// 澶勭悊Select妯″紡涓嬬殑鐐瑰嚮
  /// Select妯″紡涓嬬偣鍑荤洿鎺ヨ繘鍏ヨ皟鏁存ā寮?(Atomic Update)
  void _handleSelectModeClick(String id) {
    AppLogger.debug('Handling Select Mode Click', data: {
      'regionId': id,
      'currentStateIsAdjusting': state.isAdjusting,
      'currentStateCurrentId': state.currentId
    });

    // 1. 濡傛灉褰撳墠姝ｅ湪璋冩暣鍏朵粬閫夊尯锛屽厛淇濆瓨鐘舵€?    if (state.isAdjusting && state.currentId != id) {
      finishCurrentAdjustment(); // 淇濆瓨褰撳墠璋冩暣涓殑閫夊尯
    }

    // 2. 鏌ユ壘鐩爣閫夊尯
    final regionToSelect = _findAndSetSelectedRegion(id);
    if (regionToSelect == null) {
      AppLogger.warning(
          'Select mode click failed: Region not found or error occurred.',
          data: {'regionId': id});
      return;
    }

    // 3. 鏇存柊鐘舵€?- 濡傛灉宸茬粡鍦ㄨ皟鏁磋閫夊尯锛屽垯涓嶉噸鏂拌繘鍏ヨ皟鏁寸姸鎬?    bool shouldEnterAdjusting = !state.isAdjusting || state.currentId != id;

    // 閲嶈锛氶€夋嫨鍖哄煙锛屼絾涓嶆坊鍔犲埌modifiedIds涓?    state = state.copyWith(
      currentId: id,
      selectedIds: {id},
      isAdjusting: shouldEnterAdjusting, // 鍙湁鍦ㄩ渶瑕佹椂鎵嶈繘鍏ヨ皟鏁寸姸鎬?      error: null,
      // 涓嶅啀鑷姩娣诲姞鍒癿odifiedIds涓?    );

    AppLogger.debug('Select Mode Click - State Update Complete', data: {
      'newStateRegionId': state.currentId,
      'newStateSelectedIds': state.selectedIds,
      'newStateIsAdjusting': state.isAdjusting,
      'wasAlreadyAdjusting': !shouldEnterAdjusting,
      'modifiedIds': state.modifiedIds.toList(),
    });
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\providers\character\character_edit_providers.dart
-----------------------------------
import 'dart:ui' as ui;

import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../domain/models/character/path_info.dart';

/// 澶勭悊鍚庣殑鍥惧儚鏁版嵁鎻愪緵鑰?
final processedImageProvider =
    StateNotifierProvider<ProcessedImageNotifier, ProcessedImageData>((ref) {
  return ProcessedImageNotifier();
});

/// 璺緞娓叉煋鏁版嵁
class PathRenderData {
  final List<PathInfo> completedPaths;
  final PathInfo? currentPath;
  final ui.Rect? dirtyBounds;

  const PathRenderData({
    this.completedPaths = const [],
    this.currentPath,
    this.dirtyBounds,
  });

  PathRenderData copyWith({
    List<PathInfo>? completedPaths,
    PathInfo? currentPath,
    ui.Rect? dirtyBounds,
  }) {
    return PathRenderData(
      completedPaths: completedPaths ?? this.completedPaths,
      currentPath: currentPath,
      dirtyBounds: dirtyBounds,
    );
  }
}

/// 澶勭悊鍚庣殑鍥惧儚鏁版嵁
class ProcessedImageData {
  final ui.Image? image;
  final bool isProcessing;
  final String? error;

  const ProcessedImageData({
    this.image,
    this.isProcessing = false,
    this.error,
  });

  bool get hasError => error != null;

  bool get hasImage => image != null;
  ProcessedImageData copyWith({
    ui.Image? image,
    bool? isProcessing,
    String? error,
  }) {
    return ProcessedImageData(
      image: image ?? this.image,
      isProcessing: isProcessing ?? this.isProcessing,
      error: error,
    );
  }
}

class ProcessedImageNotifier extends StateNotifier<ProcessedImageData> {
  bool _disposed = false;

  ProcessedImageNotifier() : super(const ProcessedImageData());

  void clear() {
    if (_disposed) return;
    try {
      if (state.image != null) {
        state.image!.dispose();
      }
      state = const ProcessedImageData();
    } catch (e) {
      // 蹇界暐娓呯悊杩囩▼涓殑閿欒
    }
  }

  @override
  void dispose() {
    if (_disposed) return;
    _disposed = true;

    try {
      clear();
    } finally {
      super.dispose();
    }
  }

  void setError(String error) {
    if (_disposed) return;
    try {
      state = state.copyWith(
        error: error,
        isProcessing: false,
      );
    } catch (e) {
      // 蹇界暐鍦ㄨ缃敊璇姸鎬佹椂鍙兘鍙戠敓鐨勫紓甯?
    }
  }

  void setImage(ui.Image image) {
    if (_disposed) return;
    try {
      final oldImage = state.image;
      state = state.copyWith(
        image: image,
        isProcessing: false,
        error: null,
      );
      // 娓呯悊鏃у浘鍍?
      if (oldImage != null) {
        oldImage.dispose();
      }
    } catch (e) {
      // 蹇界暐鍦ㄨ缃浘鍍忔椂鍙兘鍙戠敓鐨勫紓甯?
    }
  }

  void setProcessing(bool isProcessing) {
    if (_disposed) return;
    try {
      state = state.copyWith(
        isProcessing: isProcessing,
        error: null,
      );
    } catch (e) {
      // 蹇界暐鍦ㄨ缃鐞嗙姸鎬佹椂鍙兘鍙戠敓鐨勫紓甯?
    }
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\providers\character\character_grid_provider.dart
-----------------------------------
import 'package:demo/application/services/character/character_persistence_service.dart';
import 'package:demo/presentation/providers/work_detail_provider.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../application/providers/repository_providers.dart';
import '../../../domain/repositories/character_repository.dart';
import '../../viewmodels/states/character_grid_state.dart';
import '../../widgets/character_collection/filter_type.dart';

final characterGridProvider =
    StateNotifierProvider<CharacterGridNotifier, CharacterGridState>((ref) {
  final repository = ref.watch(characterRepositoryProvider);
  final workId = ref.watch(workDetailProvider).work?.id;
  final persistenceService = ref.watch(characterPersistenceServiceProvider);
  return CharacterGridNotifier(repository, workId!, persistenceService);
});

class CharacterGridNotifier extends StateNotifier<CharacterGridState> {
  final CharacterRepository _repository;
  final CharacterPersistenceService _persistenceService;
  final String workId;

  CharacterGridNotifier(this._repository, this.workId, this._persistenceService)
      : super(const CharacterGridState()) {
    // 鍒濆鍖栨椂鍔犺浇鏁版嵁
    loadCharacters();
  }

  void clearSelection() {
    state = state.copyWith(selectedIds: {});
  }

  Future<void> deleteSelected() async {
    try {
      state = state.copyWith(loading: true, error: null);

      // 鍒犻櫎鎵€閫夊瓧绗?
      await _repository.deleteBatch(state.selectedIds.toList());

      // 閲嶆柊鍔犺浇鏁版嵁
      await loadCharacters();

      // 娓呴櫎閫夋嫨
      clearSelection();
    } catch (e) {
      state = state.copyWith(
        loading: false,
        error: e.toString(),
      );
    }
  }

  Future<void> exportSelected() async {
    // 瀵煎嚭鍔熻兘瀹炵幇
    // 杩欓噷闇€瑕佽皟鐢ㄥ鍑烘湇鍔?
  }

  Future<void> loadCharacters() async {
    try {
      state = state.copyWith(loading: true, error: null);

      // 浠庝粨搴撳姞杞戒綔鍝佺浉鍏崇殑瀛楃
      final characters = await _repository.findByWorkId(workId);

      // 杞崲涓鸿鍥炬ā鍨?
      final viewModels = characters
          .map((char) => CharacterViewModel(
                id: char.id,
                pageId: char.pageId,
                character: char.character,
                thumbnailPath: '', // 闇€閫氳繃浠撳簱鑾峰彇缂╃暐鍥捐矾寰?
                createdAt: char.createTime,
                updatedAt: char.updateTime,
                isFavorite: char.isFavorite,
              ))
          .toList();

      // 鑾峰彇缂╃暐鍥捐矾寰?
      for (int i = 0; i < viewModels.length; i++) {
        final vm = viewModels[i];
        final path = await _persistenceService.getThumbnailPath(vm.id);
        viewModels[i] = vm.copyWith(thumbnailPath: path);
      }

      // 璁＄畻鍒嗛〉淇℃伅锛堝亣璁炬瘡椤?6椤癸級
      const itemsPerPage = 16;
      final totalPages = (viewModels.length / itemsPerPage).ceil();

      state = state.copyWith(
        characters: viewModels,
        filteredCharacters: viewModels,
        totalPages: totalPages > 0 ? totalPages : 1,
        currentPage: 1,
        loading: false,
      );

      _applyFilters();
    } catch (e) {
      state = state.copyWith(
        loading: false,
        error: e.toString(),
      );
    }
  }

  void setPage(int page) {
    if (page < 1 || page > state.totalPages) return;

    state = state.copyWith(currentPage: page);
    _applyFilters();
  }

  void toggleSelection(String id) {
    final selectedIds = Set<String>.from(state.selectedIds);
    if (selectedIds.contains(id)) {
      selectedIds.remove(id);
    } else {
      selectedIds.add(id);
    }

    state = state.copyWith(selectedIds: selectedIds);
  }

  void updateFilter(FilterType type) {
    state = state.copyWith(filterType: type);
    _applyFilters();
  }

  void updateSearch(String term) {
    state = state.copyWith(searchTerm: term);
    _applyFilters();
  }

  void _applyFilters() {
    var filtered = List<CharacterViewModel>.from(state.characters);

    // 搴旂敤鎼滅储鏉′欢
    if (state.searchTerm.isNotEmpty) {
      filtered = filtered
          .where((char) => char.character.contains(state.searchTerm))
          .toList();
    }

    // 搴旂敤绛涢€夌被鍨?
    switch (state.filterType) {
      case FilterType.recent:
        filtered.sort((a, b) => b.createdAt.compareTo(a.createdAt));
        break;
      case FilterType.modified:
        filtered.sort((a, b) => b.updatedAt.compareTo(a.updatedAt));
        break;
      case FilterType.favorite:
        filtered = filtered.where((char) => char.isFavorite).toList();
        break;
      case FilterType.byStroke:
        // 杩欓噷闇€瑕佽皟鐢ㄧ瑪鐢绘帓搴忔湇鍔?
        break;
      case FilterType.custom:
        // 鑷畾涔夋帓搴?
        break;
      case FilterType.all:
      default:
        // 榛樿鎺掑簭
        break;
    }

    // 璁＄畻鍒嗛〉
    const itemsPerPage = 16;
    final totalPages = (filtered.length / itemsPerPage).ceil();

    // 搴旂敤鍒嗛〉
    final startIndex = (state.currentPage - 1) * itemsPerPage;
    if (startIndex < filtered.length) {
      final endIndex = startIndex + itemsPerPage < filtered.length
          ? startIndex + itemsPerPage
          : filtered.length;
      filtered = filtered.sublist(startIndex, endIndex);
    } else {
      filtered = [];
    }

    state = state.copyWith(
      filteredCharacters: filtered,
      totalPages: totalPages > 0 ? totalPages : 1,
      currentPage: state.currentPage > totalPages ? 1 : state.currentPage,
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\providers\character\character_region_sync_fix.dart
-----------------------------------




C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\providers\character\character_region_sync_service.dart
-----------------------------------
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../domain/models/character/character_region.dart';
import '../../../infrastructure/logging/logger.dart';
import '../../viewmodels/states/character_collection_state.dart';
import 'character_collection_provider.dart';
import 'character_grid_provider.dart';
import 'character_save_notifier.dart';

/// 鎻愪緵Character涓嶳egion鍚屾鏈嶅姟
final characterRegionSyncServiceProvider =
    Provider<CharacterRegionSyncService>((ref) {
  return CharacterRegionSyncService(ref);
});

/// Character涓嶳egion鍚屾鏈嶅姟
/// 澶勭悊Character淇濆瓨鐘舵€佷笌Region淇濆瓨鐘舵€佺殑鍚屾
class CharacterRegionSyncService {
  final Ref _ref;

  CharacterRegionSyncService(this._ref) {
    // 鐩戝惉Character鐨勪繚瀛樼姸鎬?    _ref.listen(characterSaveNotifierProvider, (previous, next) {
      _handleCharacterSaveStateChange(previous, next);
    });

    // 鐩戝惉Region鐨勪慨鏀圭姸鎬?    _ref.listen(characterCollectionProvider, (previous, next) {
      _handleRegionModificationStateChange(
          previous as CharacterCollectionState?, next);
    });

    AppLogger.debug('CharacterRegionSyncService initialized');
  }

  /// 澶勭悊Character淇濆瓨鐘舵€佸彉鍖?  void _handleCharacterSaveStateChange(SaveState? previous, SaveState next) {
    if (previous?.isSaving == true &&
        next.isSaving == false &&
        next.error == null) {
      // 淇濆瓨鎴愬姛锛屾洿鏂板搴旂殑Region鐘舵€?      final characterId =
          _ref.read(characterSaveNotifierProvider).lastSavedCharacterId;

      AppLogger.debug('Character淇濆瓨鐘舵€佸彉鍖?, data: {
        'previousIsSaving': previous?.isSaving,
        'nextIsSaving': next.isSaving,
        'lastSavedCharacterId': characterId,
      });

      if (characterId == null) return;

      // 鎵惧埌瀵瑰簲鐨凴egion
      final regionWithCharacter = _findRegionByCharacterId(characterId);
      if (regionWithCharacter != null) {
        AppLogger.debug('鎵惧埌鍏宠仈鐨凴egion锛屾爣璁颁负宸蹭繚瀛?, data: {
          'regionId': regionWithCharacter.id,
          'characterId': characterId,
          'previousIsSaved': regionWithCharacter.isSaved,
        });

        // 鏍囪涓哄凡淇濆瓨
        _ref
            .read(characterCollectionProvider.notifier)
            .markAsSaved(regionWithCharacter.id);

        // 寮哄埗鍒锋柊UI
        Future.microtask(() {
          // 浣跨敤寰换鍔＄‘淇濆湪褰撳墠鏋勫缓鍛ㄦ湡鍚庡埛鏂?          final notifier = _ref.read(characterCollectionProvider.notifier);
          // 閫氳繃閲嶆柊搴旂敤褰撳墠鐘舵€佸己鍒惰Е鍙戝埛鏂?          final currentState = _ref.read(characterCollectionProvider);
          notifier.state = currentState.copyWith();

          // 鍒锋柊瀛楃缃戞牸鏁版嵁
          try {
            _ref.read(characterGridProvider.notifier).loadCharacters();
            AppLogger.debug('宸茶Е鍙戝瓧绗︾綉鏍煎埛鏂?, data: {
              'regionId': regionWithCharacter.id,
            });
          } catch (e) {
            AppLogger.error('鍒锋柊瀛楃缃戞牸澶辫触', error: e);
          }

          AppLogger.debug('宸茶Е鍙慤I鍒锋柊浠ユ洿鏂颁繚瀛樼姸鎬?, data: {
            'regionId': regionWithCharacter.id,
          });
        });
      } else {
        AppLogger.warning('鏃犳硶鎵惧埌鍏宠仈鐨凴egion', data: {
          'characterId': characterId,
        });
      }
    }
  }

  /// 澶勭悊Region淇敼鐘舵€佸彉鍖?  void _handleRegionModificationStateChange(
      CharacterCollectionState? previous, CharacterCollectionState next) {
    // 妫€娴嬫柊澧炵殑淇敼椤?    final previousModifiedIds = previous?.modifiedIds ?? {};
    final currentModifiedIds = next.modifiedIds;

    final newlyModifiedIds = {...currentModifiedIds}
      ..removeAll(previousModifiedIds);

    AppLogger.debug('Region淇敼鐘舵€佸彉鍖?, data: {
      'previousModifiedCount': previousModifiedIds.length,
      'currentModifiedCount': currentModifiedIds.length,
      'newlyModifiedCount': newlyModifiedIds.length,
    });

    if (newlyModifiedIds.isNotEmpty) {
      // 鏈夋柊鐨勪慨鏀瑰尯鍩燂紝闇€瑕佸悓姝ュ埌Character鐘舵€?      for (final regionId in newlyModifiedIds) {
        final region = _findRegionById(regionId, next.regions);
        if (region?.characterId != null) {
          AppLogger.debug('Region琚慨鏀癸紝闇€瑕佹洿鏂癈haracter鐘舵€?, data: {
            'regionId': regionId,
            'characterId': region!.characterId,
          });

          // 閫氱煡Character闇€瑕侀噸鏂颁繚瀛?          _markCharacterAsModified(region.characterId!);
        }
      }
    }
  }

  /// 鏍规嵁ID鏌ユ壘Region
  CharacterRegion? _findRegionById(
      String regionId, List<CharacterRegion> regions) {
    try {
      return regions.firstWhere((r) => r.id == regionId);
    } catch (e) {
      return null;
    }
  }

  /// 鏍规嵁CharacterId鏌ユ壘Region
  CharacterRegion? _findRegionByCharacterId(String characterId) {
    final regions = _ref.read(characterCollectionProvider).regions;
    try {
      return regions.firstWhere((r) => r.characterId == characterId);
    } catch (e) {
      return null;
    }
  }

  /// 灏咰haracter鏍囪涓哄凡淇敼闇€瑕佷繚瀛?  void _markCharacterAsModified(String characterId) {
    // 杩欓噷闇€瑕佸疄闄呰皟鐢–haracter鐩稿叧鐨凱rovider
    // 绀轰緥锛歳ef.read(characterEditProvider.notifier).markAsModified(characterId);
    AppLogger.debug('Character琚爣璁颁负宸蹭慨鏀?, data: {
      'characterId': characterId,
    });
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\providers\character\character_save_notifier.dart
-----------------------------------
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../application/services/character/character_persistence_service.dart';
import '../../../domain/models/character/character_region.dart';
import '../../../domain/models/character/processing_result.dart';
import '../../../domain/models/common/result.dart';

final characterSaveNotifierProvider =
    StateNotifierProvider<CharacterSaveNotifier, SaveState>((ref) {
  final persistenceService = ref.watch(characterPersistenceServiceProvider);
  return CharacterSaveNotifier(persistenceService);
});

class CharacterSaveNotifier extends StateNotifier<SaveState> {
  final CharacterPersistenceService _persistenceService;

  CharacterSaveNotifier(this._persistenceService) : super(const SaveState());

  Future<Result<String>> save(
      CharacterRegion region, ProcessingResult result, String workId) async {
    try {
      // 寮€濮嬩繚瀛橈紝鏇存柊鐘舵€?
      state = state.copyWith(isSaving: true, error: null);

      // 璋冪敤鎸佷箙鍖栨湇鍔′繚瀛?
      // 璁剧疆workId
      final savedEntity = await _persistenceService.saveCharacter(
        region,
        result,
        workId,
      );

      // 淇濆瓨鎴愬姛锛屾洿鏂扮姸鎬侊紝璁板綍鏈€鍚庝繚瀛樼殑characterId
      state = state.copyWith(
        isSaving: false,
        lastSavedCharacterId: savedEntity.id,
      );
      return Result.success(savedEntity.id);
    } catch (e) {
      // 淇濆瓨澶辫触锛屾洿鏂伴敊璇姸鎬?
      state = state.copyWith(
        isSaving: false,
        error: _getErrorMessage(e),
      );
      return Result.failure(e);
    }
  }

  String _getErrorMessage(Object error) {
    if (error is ValidationError) {
      return '杈撳叆楠岃瘉澶辫触锛?{error.message}';
    } else if (error is StorageError) {
      return '淇濆瓨澶辫触锛?{error.message}';
    } else {
      return '淇濆瓨澶辫触锛岃閲嶈瘯';
    }
  }
}

class SaveState {
  final bool isSaving;
  final String? error;
  final String? lastSavedCharacterId;

  const SaveState({
    this.isSaving = false,
    this.error,
    this.lastSavedCharacterId,
  });

  SaveState copyWith({
    bool? isSaving,
    String? error,
    String? lastSavedCharacterId,
  }) {
    return SaveState(
      isSaving: isSaving ?? this.isSaving,
      error: error ?? this.error,
      lastSavedCharacterId: lastSavedCharacterId ?? this.lastSavedCharacterId,
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\providers\character\edit_panel_provider.dart
-----------------------------------
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../viewmodels/states/edit_panel_state.dart';

final editPanelProvider =
    StateNotifierProvider<EditPanelNotifier, EditPanelState>((ref) {
  return EditPanelNotifier();
});

class EditPanelNotifier extends StateNotifier<EditPanelState> {
  EditPanelNotifier() : super(EditPanelState.initial());

  // 鍑忓皯缂╂斁绾у埆
  void decrementZoom() {
    final newZoom = state.zoomLevel - 0.1;
    setZoom(newZoom);
  }

  // 澧炲姞缂╂斁绾у埆
  void incrementZoom() {
    final newZoom = state.zoomLevel + 0.1;
    setZoom(newZoom);
  }

  // 閲嶇疆缂栬緫鐘舵€?
  void reset() {
    state = EditPanelState.initial();
  }

  // 閲嶇疆缂╂斁绾у埆
  void resetZoom() {
    state = state.copyWith(zoomLevel: 1.0, panOffset: Offset.zero);
  }

  // 璁剧疆鐢荤瑪澶у皬
  void setBrushSize(double size) {
    // 闄愬埗鐢荤瑪澶у皬鑼冨洿
    final clampedSize = size.clamp(1.0, 50.0);
    state = state.copyWith(brushSize: clampedSize);
  }

  // 鏇存柊闄嶅櫔绾у埆
  void setNoiseReduction(double noiseReduction) {
    // 闄愬埗闄嶅櫔鑼冨洿
    final clampedNoiseReduction = noiseReduction.clamp(0.0, 1.0);
    state = state.copyWith(noiseReduction: clampedNoiseReduction);
  }

  // 璁剧疆骞崇Щ鍋忕Щ
  void setPan(Offset offset) {
    state = state.copyWith(panOffset: offset);
  }

  // 鏇存柊闃堝€?
  void setThreshold(double threshold) {
    // 闄愬埗闃堝€艰寖鍥?
    final clampedThreshold = threshold.clamp(0.0, 255.0);
    state = state.copyWith(threshold: clampedThreshold);
  }

  // 璁剧疆缂╂斁绾у埆
  void setZoom(double zoom) {
    // 闄愬埗缂╂斁鑼冨洿
    final clampedZoom = zoom.clamp(0.5, 3.0);
    state = state.copyWith(zoomLevel: clampedZoom);
  }

  // 鍒囨崲鎿﹂櫎妯″紡
  void toggleErase() {
    state = state.copyWith(isErasing: !state.isErasing);
  }

  // 鍒囨崲鍙嶈浆鐘舵€?
  void toggleInvert() {
    state = state.copyWith(isInverted: !state.isInverted);
  }

  // 鍒囨崲杞粨鏄剧ず
  void toggleOutline() {
    state = state.copyWith(showOutline: !state.showOutline);
  }

  // 鏇存柊骞崇Щ鍋忕Щ
  void updatePan(Offset delta) {
    final newOffset = state.panOffset + delta;
    state = state.copyWith(panOffset: newOffset);
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\providers\character\erase_providers.dart
-----------------------------------
import 'dart:ui';

import 'package:flutter_riverpod/flutter_riverpod.dart';

import 'erase_state.dart';
import 'erase_state_notifier.dart';
import 'path_manager.dart';

// 绗斿埛閰嶇疆鐨刾rovider
final brushConfigProvider = Provider<double>((ref) {
  return ref.watch(eraseStateProvider.select((state) => state.brushSize));
});

// 杞粨鏄剧ず鐘舵€佺殑provider
final contourVisibilityProvider = Provider<bool>((ref) {
  return ref.watch(eraseStateProvider.select((state) => state.showContour));
});

// 娣诲姞鍏夋爣浣嶇疆鐨刾rovider - add name to allow filtering in logs
final cursorPositionProvider = StateProvider<Offset?>(
  (ref) => null,
  name: 'cursorPosition', // Adding name helps identify in logs for filtering
);

// 妯″紡鐘舵€佺殑provider
final eraseModeProvider = Provider<EraseMode>((ref) {
  return ref.watch(eraseStateProvider.select((state) => state.mode));
});

// EraseStateNotifier鐨刾rovider
final eraseStateProvider =
    StateNotifierProvider<EraseStateNotifier, EraseState>((ref) {
  final pathManager = ref.watch(pathManagerProvider);
  return EraseStateNotifier(pathManager);
});

// PathManager鐨刾rovider
final pathManagerProvider = Provider<PathManager>((ref) {
  return PathManager();
});

// 璺緞娓叉煋鏁版嵁鐨刾rovider
final pathRenderDataProvider = Provider((ref) {
  final state = ref.watch(eraseStateProvider);

  // Explicitly handle current path to ensure its color is correctly set
  final currentPath = state.currentPath;

  return (
    completedPaths: state.completedPaths,
    currentPath: currentPath, // This ensures color updates are reflected
    dirtyBounds: state.dirtyBounds,
    brushSize: state.brushSize,
    isReversed: state.isReversed,
  );
});

// 澶勭悊閫夐」鐨刾rovider
final processingOptionsProvider = Provider((ref) {
  return ref
      .watch(eraseStateProvider.select((state) => state.processingOptions));
});



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\providers\character\erase_state.dart
-----------------------------------
import 'package:flutter/material.dart';

import '../../../domain/models/character/path_info.dart';
import '../../../domain/models/character/processing_options.dart';

/// 鎿﹂櫎妯″紡鏋氫妇
enum EraseMode {
  draw, // 缁樺埗妯″紡
  pan, // 骞崇Щ妯″紡
}

/// 鎿﹂櫎宸ュ叿鐘舵€?
class EraseState {
  // 宸插畬鎴愮殑璺緞
  final List<PathInfo> completedPaths;

  // 褰撳墠娲诲姩璺緞
  final PathInfo? currentPath;

  // 鑴忓尯鍩燂紙闇€瑕侀噸缁樼殑鍖哄煙锛?
  final Rect? dirtyBounds;

  // 鐢荤瑪澶у皬
  final double brushSize;

  // 绗斿埛棰滆壊鍙嶈浆锛堟摝鐧藉彉鎴愭摝榛戯級
  final bool isReversed;

  // 鏄惁鏄剧ず杞粨
  final bool showContour;

  // 鍥惧儚鍙嶈浆妯″紡
  final bool imageInvertMode;

  // 澶勭悊閫夐」
  final ProcessingOptions processingOptions;

  // 褰撳墠娲诲姩妯″紡
  final EraseMode mode;

  // 閲嶅仛璺緞鍒楄〃(閫氳繃PathManager璁块棶)
  final List<PathInfo>? _redoPaths;

  // 鏋勯€犲嚱鏁?
  const EraseState({
    this.completedPaths = const [],
    this.currentPath,
    this.dirtyBounds,
    this.brushSize = 10.0,
    this.isReversed = false,
    this.showContour = false,
    this.imageInvertMode = false,
    this.processingOptions = const ProcessingOptions(),
    this.mode = EraseMode.draw,
    List<PathInfo>? redoPaths,
  }) : _redoPaths = redoPaths;

  // 鍒涘缓鍒濆鐘舵€?
  factory EraseState.initial() {
    return const EraseState(
      processingOptions: ProcessingOptions(
        inverted: false,
        threshold: 128.0,
        noiseReduction: 0.5,
        showContour: false,
      ),
    );
  }

  // 鑾峰彇褰撳墠鐢荤瑪棰滆壊 - 鍩轰簬绗斿埛鍙嶈浆鐘舵€侊紝涓嶅彈鍥惧儚鍙嶈浆褰卞搷
  Color get brushColor {
    // 绗斿埛棰滆壊鍙彇鍐充簬绗斿埛鍙嶈浆鐘舵€侊紝涓庡浘鍍忓弽杞棤鍏?
    // 姝ｅ父妯″紡(isReversed=false): 鐧借壊 - 鎿﹂櫎鏁堟灉
    // 鍙嶈浆妯″紡(isReversed=true): 榛戣壊 - 濉厖鏁堟灉
    final brushColor = isReversed ? Colors.black : Colors.white;

    // if (kDebugMode) {
    //   print(
    //       '鑾峰彇绗斿埛棰滆壊 - isReversed=$isReversed => ${brushColor == Colors.black ? "榛戣壊" : "鐧借壊"}');
    // }

    return brushColor;
  }

  // 鏄惁鍙互閲嶅仛
  bool get canRedo => (_redoPaths?.isNotEmpty ?? false);

  // 鏄惁鍙互鎾ら攢
  bool get canUndo => completedPaths.isNotEmpty;

  // 鏄惁澶勪簬骞崇Щ妯″紡
  bool get isPanMode => mode == EraseMode.pan;

  // 澶嶅埗骞朵慨鏀归儴鍒嗗睘鎬?
  EraseState copyWith({
    List<PathInfo>? completedPaths,
    PathInfo? currentPath,
    Rect? dirtyBounds,
    double? brushSize,
    bool? isReversed,
    bool? showContour,
    bool? imageInvertMode,
    ProcessingOptions? processingOptions,
    EraseMode? mode,
    List<PathInfo>? redoPaths,
  }) {
    return EraseState(
      completedPaths: completedPaths ?? this.completedPaths,
      currentPath: currentPath, // 鍏佽璁剧疆涓簄ull
      dirtyBounds: dirtyBounds, // 鍏佽璁剧疆涓簄ull
      brushSize: brushSize ?? this.brushSize,
      isReversed: isReversed ?? this.isReversed,
      showContour: showContour ?? this.showContour,
      imageInvertMode: imageInvertMode ?? this.imageInvertMode,
      processingOptions: processingOptions ?? this.processingOptions,
      mode: mode ?? this.mode,
      redoPaths: redoPaths ?? _redoPaths, // 娣诲姞redoPaths鍙傛暟
    );
  }

  // Get the default brush color for the current mode
  Color getDefaultBrushColor(bool forImageInvert) {
    if (forImageInvert) {
      return isReversed ? Colors.white : Colors.black;
    } else {
      return isReversed ? Colors.black : Colors.white;
    }
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\providers\character\erase_state_notifier.dart
-----------------------------------
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../domain/models/character/path_info.dart';
import 'erase_state.dart';
import 'path_manager.dart';

/// 鎿﹂櫎鐘舵€佺鐞嗗櫒
class EraseStateNotifier extends StateNotifier<EraseState> {
  final PathManager _pathManager;

  EraseStateNotifier(this._pathManager) : super(EraseState.initial());

  /// 娓呴櫎鎵€鏈夎矾寰?
  void clear() {
    _pathManager.clear();
    _updateState();
  }

  /// 鍗曞嚮鎿﹂櫎鎿嶄綔
  void clickErase(Offset position) {
    if (state.mode != EraseMode.draw) return;

    // 鍏堝垱寤鸿矾寰勶紝浼犲叆褰撳墠绗斿埛棰滆壊
    _pathManager.startPath(
      position,
      brushSize: state.brushSize,
      brushColor: state.brushColor,
    );
    // 绔嬪嵆瀹屾垚璺緞
    _pathManager.completePath();
    // 鏇存柊鐘舵€?
    _updateState();
  }

  /// 瀹屾垚褰撳墠璺緞
  void completePath() {
    if (state.mode != EraseMode.draw) return;

    // 纭繚淇濆瓨棰滆壊淇℃伅
    if (_pathManager.currentPath != null) {
      // Always update the color before completing the path
      _pathManager.updateCurrentColor(state.brushColor);
      print('瀹屾垚璺緞鍓嶈缃鑹? ${state.brushColor}');
    }

    _pathManager.completePath();
    _updateState();
  }

  /// 閲嶅仛涓婁竴涓挙閿€鐨勬搷浣?
  void redo() {
    if (!state.canRedo) return;

    _pathManager.redoPath();
    _updateState();
  }

  /// 璁剧疆绗斿埛澶у皬
  void setBrushSize(double size) {
    if (size <= 0) return;
    state = state.copyWith(brushSize: size);
  }

  /// 寮€濮嬩竴涓柊鐨勮矾寰?
  void startPath(Offset position) {
    if (state.mode != EraseMode.draw) return;

    // 浼犲叆褰撳墠绗斿埛棰滆壊
    _pathManager.startPath(
      position,
      brushSize: state.brushSize,
      brushColor: state.brushColor,
    );
    _updateState();
  }

  /// 鍒囨崲杞粨鏄剧ず
  void toggleContour() {
    final newValue = !state.showContour;
    print('鍒囨崲杞粨鏄剧ず鐘舵€? $newValue');

    // 鏇存柊鐘舵€佸苟绔嬪嵆閫氱煡鐩戝惉鑰?
    state = state.copyWith(showContour: newValue);

    // 娣诲姞寤惰繜锛岀‘淇濈姸鎬佸凡鏇存柊
    Future.delayed(Duration.zero, () {
      // 纭繚鐘舵€佹洿鏂拌骞挎挱
      _updateState();
    });
  }

  /// 鍒囨崲鍥惧儚鍙嶈浆妯″紡
  void toggleImageInvert() {
    final wasImageInverted = state.imageInvertMode;
    final newImageInverted = !wasImageInverted;

    print('鍒囨崲鍥惧儚鍙嶈浆: $wasImageInverted 鈫?$newImageInverted');

    // 鏇存柊鐘舵€?- 鍙洿鏂板綋鍓嶇殑璁剧疆锛屼笉浼氬奖鍝嶅凡鏈夎矾寰?
    state = state.copyWith(imageInvertMode: newImageInverted);

    // 鏇存柊鎵€鏈夎矾寰勭殑棰滆壊锛屼互鍖归厤鏂扮殑鍥惧儚鍙嶈浆鐘舵€?
    _pathManager.updateAllPathsForImageInversion(newImageInverted);

    // 濡傛灉鏈夋椿鍔ㄨ矾寰勶紝淇濇寔鍏堕鑹蹭笉鍙?
    if (_pathManager.currentPath != null) {
      _pathManager.updateCurrentColor(state.brushColor);
    }

    // 鏃ュ織璁板綍棰滆壊鍙樺寲
    print(
        '鍥惧儚鍙嶈浆鍒囨崲鍚庣瑪鍒烽鑹? ${state.brushColor}, 鍙嶈浆鐘舵€? ${state.isReversed}, 鍥惧儚鍙嶈浆: ${state.imageInvertMode}');

    // 濡傛灉杞粨鏄剧ず寮€鍚紝闇€瑕佸己鍒跺埛鏂拌疆寤?
    if (state.showContour) {
      // 涓存椂鍏抽棴杞粨鏄剧ず鐒跺悗绔嬪嵆閲嶆柊鎵撳紑锛岃Е鍙戣疆寤撻噸鏂拌绠?
      state = state.copyWith(showContour: false);
      _updateState();

      // 寤惰繜閲嶆柊寮€鍚疆寤撴樉绀?
      Future.delayed(const Duration(milliseconds: 50), () {
        state = state.copyWith(showContour: true);
        _updateState();
        print('鍥惧儚鍙嶈浆鍚庡己鍒跺埛鏂拌疆寤?);
      });
    } else {
      // 纭繚鐘舵€佹洿鏂拌閫氱煡
      _updateState();
    }
  }

  /// 鍒囨崲缁樺埗/骞崇Щ妯″紡
  void togglePanMode() {
    state = state.copyWith(
      mode: state.isPanMode ? EraseMode.draw : EraseMode.pan,
    );
  }

  /// 鍒囨崲棰滆壊鍙嶈浆
  void toggleReverse() {
    final wasReversed = state.isReversed;
    final newReversed = !wasReversed;

    print('鍒囨崲绗斿埛鍙嶈浆: $wasReversed 鈫?$newReversed');

    // 鏇存柊鐘舵€?- 鍙奖鍝嶆湭鏉ョ殑璺緞
    state = state.copyWith(isReversed: newReversed);

    // 濡傛灉鏈夋椿鍔ㄨ矾寰勶紝绔嬪嵆鏇存柊鍏堕鑹?
    if (_pathManager.currentPath != null) {
      _pathManager.updateCurrentColor(state.brushColor);
      print('鏇存柊褰撳墠璺緞棰滆壊: ${state.brushColor}');
    }

    // 鏃ュ織璁板綍棰滆壊鍙樺寲
    print(
        '绗斿埛鍙嶈浆鍒囨崲鍚庨鑹? ${state.brushColor}, 鍙嶈浆鐘舵€? ${state.isReversed}, 鍥惧儚鍙嶈浆: ${state.imageInvertMode}');

    // 纭繚鐘舵€佹洿鏂拌閫氱煡
    _updateState();
  }

  /// 鎾ら攢鏈€鍚庝竴涓搷浣?
  void undo() {
    if (!state.canUndo) return;

    _pathManager.undo();
    _updateState();
  }

  /// 鏇存柊褰撳墠璺緞
  void updatePath(Offset position) {
    if (state.mode != EraseMode.draw) return;

    _pathManager.updatePath(position);
    _updateState();
  }

  void _updateState() {
    // 灏嗗凡瀹屾垚鐨勮矾寰勮浆鎹负PathInfo鍒楄〃锛屼繚鐣欐瘡鏉¤矾寰勭殑鍘熷棰滆壊
    final paths = _pathManager.completedPaths.map((pathEntry) {
      return PathInfo(
        path: pathEntry.path,
        brushSize: pathEntry.brushSize,
        brushColor: pathEntry.brushColor,
      );
    }).toList();

    // 灏嗛噸鍋氳矾寰勮浆鎹负PathInfo鍒楄〃锛屽悓鏍蜂繚鐣欏師濮嬮鑹?
    final redoPaths = _pathManager.redoPaths.map((pathEntry) {
      return PathInfo(
        path: pathEntry.path,
        brushSize: pathEntry.brushSize,
        brushColor: pathEntry.brushColor,
      );
    }).toList();

    // 杞崲褰撳墠璺緞锛堝鏋滃瓨鍦級锛屼娇鐢ㄥ綋鍓嶇殑绗斿埛棰滆壊
    PathInfo? currentPath;
    if (_pathManager.currentPath != null) {
      currentPath = PathInfo(
        path: _pathManager.currentPath!,
        brushSize: state.brushSize,
        brushColor: _pathManager.currentColor ?? state.brushColor,
      );
    }

    // 鏇存柊鐘舵€?
    state = state.copyWith(
      completedPaths: paths,
      currentPath: currentPath,
      dirtyBounds: _pathManager.dirtyBounds,
      redoPaths: redoPaths,
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\providers\character\path_manager.dart
-----------------------------------
import 'package:flutter/material.dart';

import '../../../utils/path/path_utils.dart';

/// 瀛樺偍璺緞鍙婂叾灞炴€х殑绫?
class PathEntry {
  final Path path;
  final double brushSize;
  final Color brushColor;
  final bool
      wasReversed; // Track whether this path was created with reversed brush

  const PathEntry({
    required this.path,
    required this.brushSize,
    required this.brushColor,
    required this.wasReversed, // Add this parameter
  });
}

/// 璺緞绠＄悊鍣紝璐熻矗绠＄悊缁樺埗璺緞鐨勭姸鎬?
class PathManager {
  // 瀹屾垚鐨勮矾寰勫垪琛?- 淇敼涓哄瓨鍌≒athEntry鑰屼笉浠呬粎鏄疨ath
  final List<PathEntry> _completedPaths = [];

  // 褰撳墠姝ｅ湪缁樺埗鐨勮矾寰?
  Path? _currentPath;

  // 褰撳墠璺緞鐨勯鑹插拰澶у皬
  Color? _currentColor;
  double _currentBrushSize = 10.0;

  // 閲嶅仛璺緞鍒楄〃
  final List<PathEntry> _redoPaths = [];

  // 鑴忓尯鍩燂紙闇€瑕侀噸缁樼殑鍖哄煙锛?
  Rect? _dirtyBounds;

  // 褰撳墠鐐瑰垪琛紙鐢ㄤ簬鏋勫缓褰撳墠璺緞锛?
  final List<Offset> _currentPoints = [];

  // 鏄惁鍙互閲嶅仛
  bool get canRedo => _redoPaths.isNotEmpty;

  // 宸插畬鎴愮殑璺緞鐨勫彧璇昏闂?
  List<PathEntry> get completedPaths => List.unmodifiable(_completedPaths);

  // 褰撳墠璺緞鐨勯鑹?
  Color? get currentColor => _currentColor;

  // 褰撳墠璺緞鐨勫彧璇昏闂?
  Path? get currentPath => _currentPath;

  // 鑴忓尯鍩熺殑鍙璁块棶
  Rect? get dirtyBounds => _dirtyBounds;

  // 閲嶅仛璺緞鍒楄〃鐨勫彧璇昏闂?
  List<PathEntry> get redoPaths => List.unmodifiable(_redoPaths);

  /// 娓呴櫎鎵€鏈夎矾寰?
  void clear() {
    _completedPaths.clear();
    _currentPath = null;
    _currentColor = null;
    _currentPoints.clear();
    _dirtyBounds = null;
    _redoPaths.clear();
  }

  /// 瀹屾垚褰撳墠璺緞
  void completePath() {
    if (_currentPath != null) {
      // 纭繚鍗充娇 _currentColor 涓?null 涔熻兘浣跨敤榛樿鐨勯鑹?
      final color = _currentColor ?? Colors.white;

      // isReversed now represents the visual intention (black vs white brush)
      // rather than the technical color value
      final isReversed = color == Colors.black;

      _completedPaths.add(PathEntry(
        path: _currentPath!,
        brushSize: _currentBrushSize,
        brushColor: color,
        wasReversed: isReversed, // Save the reversal intent for later updates
      ));

      print('瀹屾垚璺緞锛岄鑹? $color, 鍙嶈浆鐘舵€? $isReversed');

      _currentPath = null;
      _currentColor = null;
      _currentPoints.clear();
      _redoPaths.clear(); // 瀹屾垚鏂拌矾寰勬椂娓呴櫎閲嶅仛鍒楄〃
    }
  }

  // 鑾峰彇鎸囧畾璺緞鐨勯鑹蹭俊鎭紝鐢ㄤ簬璋冭瘯鍜岃疆寤撴娴?
  Map<String, dynamic> getPathColorInfo() {
    int blackPaths = 0;
    int whitePaths = 0;

    for (final path in _completedPaths) {
      if (path.brushColor == Colors.black) {
        blackPaths++;
      } else if (path.brushColor == Colors.white) {
        whitePaths++;
      }
    }

    return {
      'blackPaths': blackPaths,
      'whitePaths': whitePaths,
      'hasMixedColors': blackPaths > 0 && whitePaths > 0,
      'currentColor': _currentColor?.toString(),
    };
  }

  /// 閲嶅仛涓婁竴涓挙閿€鐨勮矾寰?
  void redoPath() {
    if (_redoPaths.isNotEmpty) {
      final pathEntry = _redoPaths.removeLast();
      _completedPaths.add(pathEntry);
    }
  }

  /// 寮€濮嬫柊鐨勮矾寰?
  void startPath(Offset position, {double? brushSize, Color? brushColor}) {
    _currentPoints.clear();
    _currentPath = Path();
    _currentPoints.add(position);

    if (brushSize != null) {
      _currentBrushSize = brushSize;
    }

    if (brushColor != null) {
      _currentColor = brushColor;
      print('寮€濮嬭矾寰勶紝璁剧疆棰滆壊: $brushColor');
    }

    _updateCurrentPath();
    _updateDirtyBounds(position);
  }

  /// 鎾ら攢涓婁竴涓矾寰?
  void undo() {
    if (_completedPaths.isNotEmpty) {
      final pathEntry = _completedPaths.removeLast();
      _redoPaths.add(pathEntry); // 淇濆瓨鍒伴噸鍋氬垪琛?
    }
  }

  /// 鏇存柊鎵€鏈夊凡瀹屾垚璺緞鐨勯鑹?(鐢ㄤ簬鍥惧儚鍙嶈浆鎴栫瑪鍒峰弽杞椂鍚屾鏇存柊)
  void updateAllPathColors(bool imageInverted, bool brushReversed) {
    if (_completedPaths.isEmpty) return;

    // 鍩轰簬绗斿埛鍙嶈浆鐘舵€侊紝纭畾搴旇浣跨敤鐨勯鑹?
    // 鍥惧儚鍙嶈浆涓嶅簲褰卞搷绗斿埛棰滆壊鐨勭‘瀹?
    final targetColor = brushReversed ? Colors.black : Colors.white;

    print(
        '鏇存柊褰撳墠绗斿埛棰滆壊: 绗斿埛鍙嶈浆=$brushReversed, 鐩爣棰滆壊=${targetColor == Colors.black ? "榛戣壊" : "鐧借壊"}');

    // 涓嶈淇敼宸插畬鎴愮殑璺緞棰滆壊锛屽彧鏇存柊褰撳墠璺緞鐨勯鑹?
    if (_currentPath != null && _currentColor != null) {
      _currentColor = targetColor;
    }

    print('鍙洿鏂板綋鍓嶈矾寰勯鑹诧紝淇濇寔宸插畬鎴愯矾寰勯鑹蹭笉鍙?);
  }

  /// 鏇存柊鎵€鏈夎矾寰勪互閫傚簲鍥惧儚鍙嶈浆鐘舵€佸彉鍖?
  void updateAllPathsForImageInversion(bool imageInverted) {
    if (_completedPaths.isEmpty) return;

    print('鍥惧儚鍙嶈浆鐘舵€佹洿鏀逛负: $imageInverted, 鏇存柊鎵€鏈夊凡瀛樺湪鐨勮矾寰?);

    // 澶嶅埗璺緞浣嗗弽杞鑹诧紝浠ラ€傚簲鏂扮殑鍥惧儚鍙嶈浆鐘舵€?
    final updatedPaths = <PathEntry>[];

    for (final entry in _completedPaths) {
      // 鑾峰彇鏂伴鑹?- 鍦ㄥ浘鍍忓弽杞椂锛屽弽杞矾寰勯鑹诧紝浣垮叾鍦ㄨ瑙変笂淇濇寔涓€鑷?
      final newColor = _invertColor(entry.brushColor);

      updatedPaths.add(PathEntry(
        path: entry.path,
        brushSize: entry.brushSize,
        brushColor: newColor,
        wasReversed: entry.wasReversed,
      ));
    }

    // 鏇挎崲璺緞鍒楄〃
    _completedPaths.clear();
    _completedPaths.addAll(updatedPaths);

    print('宸叉洿鏂?${updatedPaths.length} 鏉¤矾寰勭殑棰滆壊浠ラ€傚簲鍥惧儚鍙嶈浆');
  }

  /// 鏇存柊褰撳墠璺緞鐨勯鑹?
  void updateCurrentColor(Color color) {
    if (_currentPath != null) {
      _currentColor = color;
      print('鏇存柊褰撳墠璺緞棰滆壊: $color');
    }
  }

  /// 鏇存柊褰撳墠璺緞
  void updatePath(Offset position) {
    if (_currentPath == null) return;

    _currentPoints.add(position);
    _updateCurrentPath();
    _updateDirtyBounds(position);
  }

  // Helper method to determine color based on brush reversed state and image inverted state
  Color _getColorForInversionState(bool brushReversed, bool imageInverted) {
    // If both inversions are active or both are inactive, visual effect is the same
    // If only one is active, we need to invert the color
    if (brushReversed == imageInverted) {
      return Colors.white;
    } else {
      return Colors.black;
    }
  }

  /// 鍙嶈浆棰滆壊 (榛戝彉鐧斤紝鐧藉彉榛?
  Color _invertColor(Color color) {
    return color == Colors.black ? Colors.white : Colors.black;
  }

  // 鏇存柊褰撳墠璺緞鐨勫疄闄呭舰鐘?
  void _updateCurrentPath() {
    if (_currentPoints.isEmpty) return;

    Path path = Path();

    if (_currentPoints.length == 1) {
      // 鍗曠偣鎯呭喌锛屽垱寤哄渾褰㈣矾寰?
      final point = _currentPoints.first;
      // 浣跨敤褰撳墠绗斿埛澶у皬鐨勪竴鍗婁綔涓哄崐寰勶紝涓嶈繘琛屽洓鑸嶄簲鍏?
      path.addOval(
          Rect.fromCircle(center: point, radius: _currentBrushSize / 2));
    } else {
      // 澶氱偣鎯呭喌 - 浣跨敤PathUtils鍒涘缓瀹炲績璺緞
      if (_currentPoints.length == 2) {
        // 浠呮湁涓や釜鐐癸紝鐩存帴鍒涘缓涓€涓狦ap
        path = PathUtils.createSolidGap(
          _currentPoints.first,
          _currentPoints.last,
          _currentBrushSize,
        );
      } else {
        // 澶氫釜鐐癸紝閫愭鍒涘缓骞跺悎骞?
        path = Path(); // 鍒涘缓绌鸿矾寰?

        // 棣栧厛娣诲姞绗竴涓偣鐨勫渾褰?
        path.addOval(Rect.fromCircle(
          center: _currentPoints.first,
          radius: _currentBrushSize / 2,
        ));

        // 鐒跺悗閫愭杩炴帴
        for (int i = 1; i < _currentPoints.length; i++) {
          final gap = PathUtils.createSolidGap(
            _currentPoints[i - 1],
            _currentPoints[i],
            _currentBrushSize,
          );
          path.addPath(gap, Offset.zero);
        }
      }
    }

    _currentPath = path;
  }

  // 鏇存柊鑴忓尯鍩?
  void _updateDirtyBounds(Offset position) {
    final pointBounds =
        Rect.fromCircle(center: position, radius: _currentBrushSize / 2);
    _dirtyBounds = _dirtyBounds?.expandToInclude(pointBounds) ?? pointBounds;
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\providers\character\selected_region_provider.dart
-----------------------------------
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../domain/models/character/character_region.dart';
import '../../../domain/models/character/processing_options.dart';

final selectedRegionProvider =
    StateNotifierProvider<SelectedRegionNotifier, CharacterRegion?>((ref) {
  return SelectedRegionNotifier();
});

class SelectedRegionNotifier extends StateNotifier<CharacterRegion?> {
  SelectedRegionNotifier() : super(null);

  // 娣诲姞鎿﹂櫎鐐?
  void addErasePoints(List<Offset> points) {
    if (state == null) return;

    final currentPoints = state!.erasePoints ?? [];
    final updatedPoints = [...currentPoints, ...points];

    state = state!.copyWith(erasePoints: updatedPoints);
  }

  // 娓呴櫎鎵€鏈夋摝闄ょ偣
  void clearErasePoints() {
    if (state == null) return;
    state = state!.copyWith(erasePoints: null);
  }

  void clearRegion() {
    state = null;
  }

  CharacterRegion? getCurrentRegion() {
    return state;
  }

  // 鏍规嵁ID鑾峰彇鍖哄煙
  bool isSelected(String id) {
    return state?.id == id;
  }

  void setRegion(CharacterRegion region) {
    state = region;
  }

  // 鏇存柊鏃嬭浆瑙掑害
  void updateAngle(double angle) {
    if (state == null) return;
    state = state!.copyWith(rotation: angle);
  }

  // 鏇存柊瀛楃
  void updateCharacter(String character) {
    if (state == null) return;
    state = state!.copyWith(character: character);
  }

  // 鏇存柊澶勭悊閫夐」
  void updateOptions(ProcessingOptions options) {
    if (state == null) return;
    state = state!.copyWith(options: options);
  }

  // 鏇存柊鍖哄煙灏哄鍜屼綅缃?
  void updateRect(Rect rect) {
    if (state == null) return;
    state = state!.copyWith(rect: rect);
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\providers\character\tool_mode_provider.dart
-----------------------------------
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../infrastructure/logging/logger.dart';

/// 宸ュ叿妯″紡Provider
final toolModeProvider = StateNotifierProvider<ToolModeNotifier, Tool>((ref) {
  return ToolModeNotifier();
});

/// 宸ュ叿妯″紡鏋氫妇
enum Tool {
  /// 骞崇Щ鍜岀缉鏀炬ā寮忥紙榛樿锛?
  pan,

  /// 妗嗛€夊伐鍏锋ā寮?
  select,

  /// 澶氶€夊伐鍏锋ā寮?
  multiSelect,

  /// 鎿﹂櫎妯″紡
  erase;

  IconData get icon {
    switch (this) {
      case Tool.pan:
        return Icons.pan_tool;
      case Tool.select:
        return Icons.crop_square;
      case Tool.multiSelect:
        return Icons.select_all;
      case Tool.erase:
        return Icons.auto_fix_normal;
    }
  }

  String get tooltip {
    switch (this) {
      case Tool.pan:
        return '鎷栨嫿宸ュ叿 (V)';
      case Tool.select:
        return '妗嗛€夊伐鍏?(R)';
      case Tool.multiSelect:
        return '澶氶€夊伐鍏?(M)';
      case Tool.erase:
        return '鎿﹂櫎宸ュ叿 (E)';
    }
  }
}

/// 宸ュ叿妯″紡鐘舵€佺鐞嗗櫒
class ToolModeNotifier extends StateNotifier<Tool> {
  Tool _previousMode = Tool.pan;

  ToolModeNotifier() : super(Tool.pan);

  /// 鑾峰彇褰撳墠妯″紡
  Tool get currentMode => state;

  /// 鑾峰彇鍓嶄竴涓ā寮?
  Tool get previousMode => _previousMode;

  /// 鍒囨崲鍒版摝闄ゆā寮?
  void eraseMode() {
    _previousMode = state;
    state = Tool.erase;
  }

  /// 鍒囨崲鍒板钩绉绘ā寮?
  void panMode() {
    _previousMode = state;
    state = Tool.pan;
  }

  /// 鍒囨崲鍒伴€夋嫨妯″紡
  void selectMode() {
    _previousMode = state;
    state = Tool.select;
  }

  /// 璁剧疆宸ュ叿妯″紡
  void setMode(Tool mode) {
    if (state != mode) {
      final oldMode = state;
      _previousMode = oldMode;
      state = mode;

      // 璁板綍宸ュ叿妯″紡鍙樺寲
      AppLogger.debug('宸ュ叿妯″紡鍙樻洿', data: {
        'from': _previousMode.toString(),
        'to': state.toString(),
      });
    }
  }

  /// 鍒囨崲鍥炲墠涓€涓ā寮?
  void toggleMode() {
    final currentState = state;
    state = _previousMode;
    _previousMode = currentState;
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\providers\character\work_image_provider.dart
-----------------------------------
import 'dart:typed_data';

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:image/image.dart' as img;

import '../../../application/providers/service_providers.dart';
import '../../../application/services/work/work_image_service.dart';
import '../../../infrastructure/logging/logger.dart';

final workImageProvider =
    StateNotifierProvider<WorkImageNotifier, WorkImageState>((ref) {
  final workImageService = ref.watch(workImageServiceProvider);
  AppLogger.debug('鍒濆鍖朩orkImageProvider');
  return WorkImageNotifier(workImageService);
});

class WorkImageNotifier extends StateNotifier<WorkImageState> {
  final WorkImageService _workImageService;
  final Map<String, String?> _thumbnailCache = {};

  WorkImageNotifier(this._workImageService) : super(WorkImageState.initial());

  // 鍒囨崲椤甸潰
  Future<void> changePage(String pageId) async {
    if (pageId == state.currentPageId) return;

    state = state.copyWith(
      loading: true,
      error: null,
    );

    try {
      // 鑾峰彇椤甸潰鍥惧儚
      final imageData =
          await _workImageService.getWorkPageImage(state.workId, pageId);
      if (imageData == null) {
        throw Exception('Image not found');
      }

      // 瑙ｆ瀽鍥惧儚灏哄
      final imageSize = await _parseImageSize(imageData);
      AppLogger.debug('WorkImageProvider鑾峰彇鍒板浘鍍忓昂瀵?, data: {
        'width': imageSize.width,
        'height': imageSize.height,
        'dataLength': imageData.length,
      });

      // 鏇存柊鐘舵€?
      state = state.copyWith(
        currentPageId: pageId,
        imageData: imageData,
        imageWidth: imageSize.width,
        imageHeight: imageSize.height,
        loading: false,
      );
    } catch (e, stack) {
      AppLogger.error('WorkImageProvider鍒囨崲椤甸潰澶辫触', error: e, stackTrace: stack);
      state = state.copyWith(
        loading: false,
        error: e.toString(),
      );
    }
  }

  @override
  void dispose() {
    _thumbnailCache.clear();
    super.dispose();
  }

  // 鑾峰彇椤甸潰缂╃暐鍥捐矾寰?
  Future<String?> getThumbnailPath(String pageId) async {
    try {
      // 妫€鏌ョ紦瀛?
      if (_thumbnailCache.containsKey(pageId)) {
        return _thumbnailCache[pageId];
      }

      // 浠庢湇鍔¤幏鍙栫缉鐣ュ浘璺緞
      final path = await _workImageService.getPageThumbnailPath(pageId);

      // 鏇存柊缂撳瓨
      _thumbnailCache[pageId] = path;

      return path;
    } catch (e) {
      AppLogger.error('鑾峰彇缂╃暐鍥捐矾寰勫け璐?, error: e, data: {'pageId': pageId});
      return null;
    }
  }

  // 鍔犺浇浣滃搧鍥惧儚
  Future<void> loadWorkImage(String workId, String pageId) async {
    state = state.copyWith(
      loading: true,
      error: null,
    );

    try {
      // 鑾峰彇浣滃搧鍥惧儚
      final imageData =
          await _workImageService.getWorkPageImage(workId, pageId);
      if (imageData == null) {
        throw Exception('Image not found');
      }

      // 瑙ｆ瀽鍥惧儚灏哄
      final imageSize = await _parseImageSize(imageData);
      AppLogger.debug('WorkImageProvider鍔犺浇鍥惧儚鎴愬姛', data: {
        'width': imageSize.width,
        'height': imageSize.height,
        'dataLength': imageData.length,
      });

      // 鑾峰彇鎵€鏈夐〉闈D
      final pageIds = await _workImageService.getWorkPageIds(workId);

      // 鏇存柊鐘舵€?
      state = state.copyWith(
        workId: workId,
        currentPageId: pageId,
        pageIds: pageIds,
        imageData: imageData,
        imageWidth: imageSize.width,
        imageHeight: imageSize.height,
        loading: false,
      );
    } catch (e, stack) {
      AppLogger.error('WorkImageProvider鍔犺浇鍥惧儚澶辫触', error: e, stackTrace: stack);
      state = state.copyWith(
        loading: false,
        error: e.toString(),
      );
    }
  }

  // 鍒囨崲鍒颁笅涓€椤?
  Future<void> nextPage() async {
    if (state.pageIds.isEmpty) return;

    final currentIndex = state.pageIds.indexOf(state.currentPageId);
    if (currentIndex < 0 || currentIndex >= state.pageIds.length - 1) return;

    final nextPageId = state.pageIds[currentIndex + 1];
    await changePage(nextPageId);
  }

  // 鍒囨崲鍒颁笂涓€椤?
  Future<void> previousPage() async {
    if (state.pageIds.isEmpty) return;

    final currentIndex = state.pageIds.indexOf(state.currentPageId);
    if (currentIndex <= 0) return;

    final previousPageId = state.pageIds[currentIndex - 1];
    await changePage(previousPageId);
  }

  // 閲嶆柊鍔犺浇褰撳墠椤甸潰
  Future<void> reload() async {
    await loadWorkImage(state.workId, state.currentPageId);
  }

  // 瑙ｆ瀽鍥惧儚灏哄
  Future<Size> _parseImageSize(Uint8List imageData) async {
    final decodedImage = img.decodeImage(imageData);
    if (decodedImage == null) {
      throw Exception('Failed to decode image data');
    }
    return Size(decodedImage.width.toDouble(), decodedImage.height.toDouble());
  }
}

class WorkImageState {
  final String workId;
  final String currentPageId;
  final List<String> pageIds;
  final Uint8List? imageData;
  final double imageWidth;
  final double imageHeight;
  final bool loading;
  final String? error;

  WorkImageState({
    required this.workId,
    required this.currentPageId,
    required this.pageIds,
    this.imageData,
    required this.imageWidth,
    required this.imageHeight,
    required this.loading,
    this.error,
  });

  factory WorkImageState.initial() {
    return WorkImageState(
      workId: '',
      currentPageId: '',
      pageIds: [],
      imageData: null,
      imageWidth: 0,
      imageHeight: 0,
      loading: false,
    );
  }

  // 鏄惁鏈変笅涓€椤?
  bool get hasNext {
    final currentIndex = pageIds.indexOf(currentPageId);
    return currentIndex >= 0 && currentIndex < pageIds.length - 1;
  }

  // 鏄惁鏈変笂涓€椤?
  bool get hasPrevious {
    final currentIndex = pageIds.indexOf(currentPageId);
    return currentIndex > 0;
  }

  // 妫€鏌ュ浘鍍忔槸鍚︽湁鏁?
  bool get hasValidImage =>
      imageData != null && imageWidth > 0 && imageHeight > 0;

  // 鑾峰彇鍥惧儚灏哄
  Size get imageSize => Size(imageWidth, imageHeight);

  WorkImageState copyWith({
    String? workId,
    String? currentPageId,
    List<String>? pageIds,
    Uint8List? imageData,
    double? imageWidth,
    double? imageHeight,
    bool? loading,
    String? error,
  }) {
    return WorkImageState(
      workId: workId ?? this.workId,
      currentPageId: currentPageId ?? this.currentPageId,
      pageIds: pageIds ?? this.pageIds,
      imageData: imageData ?? this.imageData,
      imageWidth: imageWidth ?? this.imageWidth,
      imageHeight: imageHeight ?? this.imageHeight,
      loading: loading ?? this.loading,
      error: error ?? this.error,
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\providers\debug\debug_options_provider.dart
-----------------------------------
import 'package:flutter_riverpod/flutter_riverpod.dart';

/// 璋冭瘯閫夐」Provider
final debugOptionsProvider =
    StateNotifierProvider<DebugOptionsNotifier, DebugOptions>((ref) {
  return DebugOptionsNotifier();
});

/// 璋冭瘯閫夐」
class DebugOptions {
  /// 鏄惁鍚敤璋冭瘯妯″紡
  final bool enabled;

  /// 鏄惁鏄剧ず缃戞牸
  final bool showGrid;

  /// 鏄惁鏄剧ず鍧愭爣
  final bool showCoordinates;

  /// 鏄惁鏄剧ず璇︾粏淇℃伅
  final bool showDetails;

  /// 鏄惁鏄剧ず鍥惧儚淇℃伅
  final bool showImageInfo;

  /// 鏄惁鏄剧ず鍖哄煙涓績鐐?
  final bool showRegionCenter;

  /// 缃戞牸澶у皬锛堝浘鍍忓潗鏍囩郴锛?
  final double gridSize;

  /// 鏂囨湰澶у皬缂╂斁
  final double textScale;

  /// 鏄惁鍚敤鏃ュ織璁板綍
  final bool enableLogging;

  /// 璋冭瘯鍥惧眰鐨勪笉閫忔槑搴?
  final double opacity;

  const DebugOptions({
    this.enabled = false,
    this.showGrid = true,
    this.showCoordinates = true,
    this.showDetails = true,
    this.showImageInfo = true,
    this.showRegionCenter = true,
    this.gridSize = 50.0,
    this.textScale = 1.0,
    this.enableLogging = false,
    this.opacity = 0.5,
  });

  /// 鍒涘缓鏂扮殑閫夐」瀹炰緥
  DebugOptions copyWith({
    bool? enabled,
    bool? showGrid,
    bool? showCoordinates,
    bool? showDetails,
    bool? showImageInfo,
    bool? showRegionCenter,
    double? gridSize,
    double? textScale,
    bool? enableLogging,
    double? opacity,
  }) {
    return DebugOptions(
      enabled: enabled ?? this.enabled,
      showGrid: showGrid ?? this.showGrid,
      showCoordinates: showCoordinates ?? this.showCoordinates,
      showDetails: showDetails ?? this.showDetails,
      showImageInfo: showImageInfo ?? this.showImageInfo,
      showRegionCenter: showRegionCenter ?? this.showRegionCenter,
      gridSize: gridSize ?? this.gridSize,
      textScale: textScale ?? this.textScale,
      enableLogging: enableLogging ?? this.enableLogging,
      opacity: opacity ?? this.opacity,
    );
  }
}

/// 璋冭瘯閫夐」绠＄悊
class DebugOptionsNotifier extends StateNotifier<DebugOptions> {
  DebugOptionsNotifier() : super(const DebugOptions());

  /// 閲嶇疆鎵€鏈夐€夐」鍒伴粯璁ゅ€?
  void resetToDefaults() {
    state = const DebugOptions();
  }

  /// 璁剧疆缃戞牸澶у皬
  void setGridSize(double size) {
    if (state.enabled) {
      // 闄愬埗缃戞牸澶у皬鍦?0-100涔嬮棿
      final newSize = size.clamp(20.0, 100.0);
      state = state.copyWith(gridSize: newSize);
    }
  }

  /// 璁剧疆涓嶉€忔槑搴?
  void setOpacity(double value) {
    if (state.enabled) {
      // 闄愬埗涓嶉€忔槑搴﹀湪0.1-1.0涔嬮棿
      final newValue = value.clamp(0.1, 1.0);
      state = state.copyWith(opacity: newValue);
    }
  }

  /// 璁剧疆鏂囨湰缂╂斁
  void setTextScale(double scale) {
    if (state.enabled) {
      // 闄愬埗鏂囨湰缂╂斁鍦?.5-2.0涔嬮棿
      final newScale = scale.clamp(0.5, 2.0);
      state = state.copyWith(textScale: newScale);
    }
  }

  /// 鍒囨崲鍧愭爣鏄剧ず
  void toggleCoordinates() {
    if (state.enabled) {
      state = state.copyWith(showCoordinates: !state.showCoordinates);
    }
  }

  /// 鍒囨崲璋冭瘯妯″紡
  void toggleDebugMode() {
    state = state.copyWith(enabled: !state.enabled);
  }

  /// 鍒囨崲璇︾粏淇℃伅鏄剧ず
  void toggleDetails() {
    if (state.enabled) {
      state = state.copyWith(showDetails: !state.showDetails);
    }
  }

  /// 鍒囨崲缃戞牸鏄剧ず
  void toggleGrid() {
    if (state.enabled) {
      state = state.copyWith(showGrid: !state.showGrid);
    }
  }

  /// 鍒囨崲鍥惧儚淇℃伅鏄剧ず
  void toggleImageInfo() {
    if (state.enabled) {
      state = state.copyWith(showImageInfo: !state.showImageInfo);
    }
  }

  /// 鍒囨崲鏃ュ織璁板綍
  void toggleLogging() {
    if (state.enabled) {
      state = state.copyWith(enableLogging: !state.enableLogging);
    }
  }

  /// 鍒囨崲鍖哄煙涓績鐐规樉绀?
  void toggleRegionCenter() {
    if (state.enabled) {
      state = state.copyWith(showRegionCenter: !state.showRegionCenter);
    }
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\viewmodels\character_collection_viewmodel.dart
-----------------------------------
import 'package:flutter/material.dart';

class CharacterViewModel {
  final String id;
  final String pageId;
  final String character;
  final Rect rect;
  final String thumbnailPath;
  final DateTime createdAt;
  final DateTime updatedAt;
  final bool isFavorite;

  const CharacterViewModel({
    required this.id,
    required this.pageId,
    required this.character,
    required this.rect,
    required this.thumbnailPath,
    required this.createdAt,
    required this.updatedAt,
    this.isFavorite = false,
  });

  // 浠庢暟鎹簱瀹炰綋鍒涘缓
  factory CharacterViewModel.fromEntity(Map<String, dynamic> entity) {
    return CharacterViewModel(
      id: entity['id'] as String,
      pageId: entity['page_id'] as String,
      character: entity['character'] as String,
      rect: Rect.fromLTWH(
        entity['rect_x'] as double,
        entity['rect_y'] as double,
        entity['rect_width'] as double,
        entity['rect_height'] as double,
      ),
      thumbnailPath: entity['thumbnail_path'] as String,
      createdAt: DateTime.parse(entity['created_at'] as String),
      updatedAt: DateTime.parse(entity['updated_at'] as String),
      isFavorite: (entity['is_favorite'] as int?) == 1,
    );
  }

  // 鍒涘缓鍓湰骞舵洿鏂伴儴鍒嗗睘鎬?
  CharacterViewModel copyWith({
    String? id,
    String? pageId,
    String? character,
    Rect? rect,
    String? thumbnailPath,
    DateTime? createdAt,
    DateTime? updatedAt,
    bool? isFavorite,
  }) {
    return CharacterViewModel(
      id: id ?? this.id,
      pageId: pageId ?? this.pageId,
      character: character ?? this.character,
      rect: rect ?? this.rect,
      thumbnailPath: thumbnailPath ?? this.thumbnailPath,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      isFavorite: isFavorite ?? this.isFavorite,
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\viewmodels\work_browse_view_model.dart
-----------------------------------
import 'dart:async';

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../application/services/restoration/state_restoration_service.dart';
import '../../application/services/services.dart';
import '../../domain/models/common/date_range_filter.dart';
import '../../domain/models/work/work_filter.dart';
import '../../infrastructure/logging/logger.dart';
import '../../utils/throttle_helper.dart';
import 'states/work_browse_state.dart';

/// 浣滃搧娴忚瑙嗗浘妯″瀷
class WorkBrowseViewModel extends StateNotifier<WorkBrowseState> {
  final WorkService _workService;
  final StateRestorationService _stateRestorationService;
  Timer? _searchDebounce;
  final ThrottleHelper _loadThrottler = ThrottleHelper(
    minInterval: const Duration(milliseconds: 500),
  );

  WorkBrowseViewModel(this._workService, this._stateRestorationService)
      : super(WorkBrowseState(
          isLoading: false,
          filter: const WorkFilter(),
          works: const [],
          requestStatus: LoadRequestStatus.idle,
          searchQuery: '',
        )) {
    Future.microtask(() => _initializeData());
  }

  void clearSelection() {
    state = state.copyWith(selectedWorks: {});
  }

  Future<void> deleteSelected() async {
    if (state.selectedWorks.isEmpty) return;

    AppLogger.debug('寮€濮嬫壒閲忓垹闄?,
        tag: 'WorkBrowseViewModel',
        data: {'selectedCount': state.selectedWorks.length});

    try {
      state = state.copyWith(isLoading: true);

      // 1. 鎵ц鍒犻櫎鎿嶄綔
      await Future.wait(
          state.selectedWorks.map((id) => _workService.deleteWork(id)));

      AppLogger.debug('鍒犻櫎瀹屾垚锛屽噯澶囧埛鏂板垪琛?, tag: 'WorkBrowseViewModel');

      // 2. 閲嶆柊鍔犺浇浣滃搧鍒楄〃
      final works = await _workService.queryWorks(state.filter);

      // 3. 鏇存柊鐘舵€?
      state = state.copyWith(
        isLoading: false,
        works: works,
        batchMode: false, // 鍒犻櫎鍚庨€€鍑烘壒閲忔ā寮?
        selectedWorks: {}, // 娓呯┖閫夋嫨
      );
    } catch (e, stack) {
      AppLogger.error('鎵归噺鍒犻櫎澶辫触',
          tag: 'WorkBrowseViewModel', error: e, stackTrace: stack);

      state = state.copyWith(
        isLoading: false,
        error: e.toString(),
      );
    }
  }

  @override
  void dispose() {
    _searchDebounce?.cancel();
    _loadThrottler.cancel();
    _saveState();
    super.dispose();
  }

  // 鍔犺浇鐩稿叧鏂规硶
  Future<void> loadWorks({bool forceRefresh = false}) async {
    if (state.isLoading && !forceRefresh) return;

    AppLogger.debug('瑙﹀彂鍔犺浇娴佺▼',
        tag: 'WorkBrowseViewModel', data: {'forceRefresh': forceRefresh});

    state = state.copyWith(
      isLoading: true,
      error: null,
      requestStatus: LoadRequestStatus.loading,
    );

    try {
      final works = await _workService.queryWorks(state.filter);

      state = state.copyWith(
        works: works,
        isLoading: false,
        error: null,
        requestStatus: LoadRequestStatus.idle,
      );

      AppLogger.debug('鍔犺浇瀹屾垚',
          tag: 'WorkBrowseViewModel', data: {'worksCount': works.length});
    } catch (e, stack) {
      _handleLoadError(e, stack);
    }
  }

  // 鎼滅储鐩稿叧鏂规硶
  void setSearchQuery(String query) {
    AppLogger.debug('璁剧疆鎼滅储鍏抽敭璇?,
        tag: 'WorkBrowseViewModel', data: {'query': query});

    if (_searchDebounce?.isActive ?? false) {
      _searchDebounce?.cancel();
    }

    _searchDebounce = Timer(const Duration(milliseconds: 500), () {
      final newFilter = state.filter.copyWith(keyword: query.trim());
      updateFilter(newFilter);
    });
  }

  void setViewMode(ViewMode mode) {
    state = state.copyWith(viewMode: mode);
    _saveState();
  }

  // 鎵归噺鎿嶄綔鐩稿叧鏂规硶
  void toggleBatchMode() {
    AppLogger.debug('鍒囨崲鎵归噺妯″紡',
        tag: 'WorkBrowseViewModel', data: {'currentMode': state.batchMode});

    state = state.copyWith(
      batchMode: !state.batchMode,
      selectedWorks: {}, // 閫€鍑烘壒閲忔ā寮忔椂娓呯┖閫夋嫨
    );
  }

  void toggleSelection(String workId) {
    final newSelection = Set<String>.from(state.selectedWorks);
    if (newSelection.contains(workId)) {
      newSelection.remove(workId);
    } else {
      newSelection.add(workId);
    }

    AppLogger.debug('鍒囨崲閫夋嫨鐘舵€?,
        tag: 'WorkBrowseViewModel',
        data: {'workId': workId, 'selected': newSelection.contains(workId)});

    state = state.copyWith(selectedWorks: newSelection);
  }

  void toggleSidebar() {
    state = state.copyWith(isSidebarOpen: !state.isSidebarOpen);
    _saveState();
  }

  // 瑙嗗浘鐩稿叧鏂规硶
  void toggleViewMode() {
    state = state.copyWith(
      viewMode: state.viewMode == ViewMode.grid ? ViewMode.list : ViewMode.grid,
    );
    _saveState();
  }

  void updateDatePreset(DateRangePreset? preset) {
    if (preset == null || preset == DateRangePreset.all) {
      // 娓呴櫎鎵€鏈夋棩鏈熺浉鍏崇殑绛涢€夋潯浠?
      final newFilter = state.filter.copyWith(
        datePreset: DateRangePreset.all,
        dateRange: null,
      );
      updateFilter(newFilter);
      return;
    }

    final newFilter = state.filter.copyWith(
      datePreset: preset,
      dateRange: null,
    );
    updateFilter(newFilter);
  }

  void updateDateRange(DateTimeRange? range) {
    if (range == null) {
      // 娓呴櫎鎵€鏈夋棩鏈熺浉鍏崇殑绛涢€夋潯浠?
      final newFilter = state.filter.copyWith(
        datePreset: DateRangePreset.all,
        dateRange: null,
      );
      updateFilter(newFilter);
      return;
    }

    final newFilter = state.filter.copyWith(
      dateRange: range,
      datePreset: DateRangePreset.all, // 浣跨敤鑷畾涔夋椂闇€瑕佹竻闄ら璁?
    );
    updateFilter(newFilter);
  }

  // 绛涢€夌浉鍏虫柟娉?
  void updateFilter(WorkFilter? filter) {
    AppLogger.debug(
      '鏇存柊绛涢€夋潯浠?,
      tag: 'WorkBrowseViewModel',
      data: {
        'oldFilter': state.filter.toString(),
        'newFilter': filter?.toString() ?? 'null',
      },
    );

    if (filter == null) {
      // 娓呴櫎鎵€鏈夌瓫閫夋潯浠?
      final newFilter = state.filter.copyWith(
        datePreset: DateRangePreset.all,
        dateRange: null,
        keyword: null, // 纭繚娓呴櫎鎼滅储鍏抽敭璇?
      );

      state = state.copyWith(
        works: [],
        filter: newFilter,
        page: 1,
        hasMore: true,
        error: null,
      );
    } else {
      state = state.copyWith(
        works: [],
        filter: filter,
        page: 1,
        hasMore: true,
        error: null,
      );
    }

    loadWorks(forceRefresh: true);
  }

  void _handleLoadError(dynamic error, StackTrace stack) {
    AppLogger.error('鍔犺浇浣滃搧鍒楄〃澶辫触',
        tag: 'WorkBrowseViewModel', error: error, stackTrace: stack);

    state = state.copyWith(
      isLoading: false,
      error: error.toString(),
      requestStatus: LoadRequestStatus.idle,
    );
  }

  Future<void> _initializeData() async {
    try {
      AppLogger.info('鍒濆鍖栦綔鍝佹祻瑙堥〉鏁版嵁',
          tag: 'WorkBrowseViewModel',
          data: {'initialFilter': state.filter.toString()});

      state = state.copyWith(
        isLoading: true,
        error: null,
        filter: const WorkFilter(),
        works: const [],
      );

      await loadWorks(forceRefresh: true);
    } catch (e, stack) {
      _handleLoadError(e, stack);
    }
  }

  void _saveState() {
    try {
      _stateRestorationService.saveWorkBrowseState(state);
    } catch (e, stack) {
      AppLogger.error(
        'Failed to save work browse state',
        tag: 'WorkBrowseViewModel',
        error: e,
        stackTrace: stack,
      );
    }
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\viewmodels\work_import_view_model.dart
-----------------------------------
import 'dart:io';

import 'package:file_picker/file_picker.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:uuid/uuid.dart';

import '../../application/services/work/work_service.dart';
import '../../domain/enums/work_style.dart';
import '../../domain/enums/work_tool.dart';
import '../../domain/models/work/work_entity.dart';
import '../../infrastructure/image/image_processor.dart';
import 'states/work_import_state.dart';

/// 浣滃搧瀵煎叆瑙嗗浘妯″瀷
class WorkImportViewModel extends StateNotifier<WorkImportState> {
  final WorkService _workService;
  final ImageProcessor _imageProcessor;

  WorkImportViewModel(this._workService, this._imageProcessor)
      : super(WorkImportState.initial());

  /// 鍒ゆ柇鏄惁鍙互淇濆瓨
  bool get canSubmit {
    return state.hasImages &&
        state.title.trim().isNotEmpty &&
        !state.isProcessing;
  }

  /// 娣诲姞鍥剧墖
  Future<void> addImages([List<File>? files]) async {
    try {
      state = state.copyWith(error: null);

      // 濡傛灉娌℃湁浼犲叆鏂囦欢锛屽垯鎵撳紑鏂囦欢閫夋嫨鍣?
      if (files == null || files.isEmpty) {
        final result = await FilePicker.platform.pickFiles(
          type: FileType.image,
          allowMultiple: true,
        );

        if (result == null || result.files.isEmpty) {
          return;
        }

        files = result.files
            .where((file) => file.path != null)
            .map((file) => File(file.path!))
            .toList();

        if (files.isEmpty) return;
      }

      state = state.copyWith(
        isProcessing: true,
        error: null,
      );

      state = state.copyWith(
        images: [...state.images, ...files],
        isProcessing: false,
      );
    } catch (e) {
      state = state.copyWith(
        isProcessing: false,
        error: '娣诲姞鍥剧墖澶辫触: $e',
      );
    }
  }

  /// 娓呯悊鐘舵€侊紙鍏抽棴瀵硅瘽妗嗘椂璋冪敤锛?
  void cleanup() {
    reset();
  }

  /// 瀵煎叆浣滃搧
  Future<bool> importWork() async {
    if (!canSubmit) return false;

    try {
      state = state.copyWith(isProcessing: true, error: null);

      // 鍒涘缓鏂扮殑浣滃搧瀹炰綋
      final work = WorkEntity(
        id: const Uuid().v4(),
        title: state.title.trim(),
        author: state.author?.trim() ?? '',
        style: state.style ?? WorkStyle.other,
        tool: state.tool ?? WorkTool.other,
        creationDate: state.creationDate ?? DateTime.now(),
        remark: state.remark?.trim(),
        createTime: DateTime.now(),
        updateTime: DateTime.now(),
      );

      // 鎵ц瀵煎叆鎿嶄綔
      await _workService.importWork(state.images, work);

      // 瀵煎叆鎴愬姛鍚庨噸缃姸鎬?
      reset();
      return true;
    } catch (e) {
      state = state.copyWith(
        isProcessing: false,
        error: '瀵煎叆澶辫触: $e',
      );
      return false;
    }
  }

  /// 鍒濆鍖栫幇鏈変綔鍝佺殑鍥剧墖
  Future<void> initialize(List<File> images) async {
    if (images.isEmpty) return;

    try {
      state = state.copyWith(
        images: images,
        isProcessing: true,
        error: null,
      );

      state = state.copyWith(
        selectedImageIndex: 0,
        isProcessing: false,
      );
    } catch (e) {
      state = state.copyWith(
        isProcessing: false,
        error: '鍒濆鍖栧浘鐗囧け璐? $e',
      );
    }
  }

  /// 鍒犻櫎鍥剧墖
  void removeImage(int index) {
    if (index < 0 || index >= state.images.length) return;

    final newImages = List<File>.from(state.images);
    newImages.removeAt(index);

    // 濡傛灉鍒犻櫎鐨勬槸褰撳墠閫変腑椤癸紝闇€瑕佹洿鏂伴€変腑绱㈠紩
    final newSelectedIndex = _calculateNewSelectedIndex(
      oldIndex: index,
      maxIndex: newImages.length - 1,
    );

    state = state.copyWith(
      images: newImages,
      selectedImageIndex: newSelectedIndex,
    );
  }

  /// 閲嶆柊鎺掑簭鍥剧墖
  void reorderImages(int oldIndex, int newIndex) {
    if (oldIndex < 0 ||
        oldIndex >= state.images.length ||
        newIndex < 0 ||
        newIndex > state.images.length) return;

    final images = List<File>.from(state.images);
    final item = images.removeAt(oldIndex);
    final adjustedNewIndex = newIndex > oldIndex ? newIndex - 1 : newIndex;
    images.insert(adjustedNewIndex, item);

    state = state.copyWith(
      images: images,
      selectedImageIndex: _calculateNewSelectedIndex(
        oldIndex: oldIndex,
        newIndex: adjustedNewIndex,
        maxIndex: images.length - 1,
      ),
    );
  }

  /// 閲嶇疆鐘舵€?
  void reset() {
    state = WorkImportState.clean();
  }

  /// 閫夋嫨鍥剧墖
  void selectImage(int index) {
    if (index < 0 || index >= state.images.length) return;
    state = state.copyWith(selectedImageIndex: index);
  }

  /// 璁剧疆浣滆€?
  void setAuthor(String? author) {
    state = state.copyWith(author: author?.trim() ?? '');
  }

  /// 璁剧疆鍒涗綔鏃ユ湡
  void setCreationDate(DateTime? date) {
    state = state.copyWith(creationDate: date);
  }

  /// 璁剧疆澶囨敞
  void setRemark(String? remark) {
    state = state.copyWith(remark: remark?.trim() ?? '');
  }

  /// 璁剧疆鐢婚
  void setStyle(WorkStyle? style) {
    if (style == null) return;
    state = state.copyWith(style: style);
  }

  /// 璁剧疆鐢婚 (string version for compatibility)
  void setStyleByString(String? styleStr) {
    if (styleStr == null) return;

    final style = WorkStyle.values.firstWhere(
      (s) => s.value == styleStr,
      orElse: () => WorkStyle.other,
    );
    state = state.copyWith(style: style);
  }

  /// 璁剧疆鏍囬
  void setTitle(String? title) {
    state = state.copyWith(title: title?.trim() ?? '');
  }

  /// 璁剧疆鍒涗綔宸ュ叿
  void setTool(WorkTool? tool) {
    if (tool == null) return;
    state = state.copyWith(tool: tool);
  }

  /// 璁剧疆鍒涗綔宸ュ叿 (string version for compatibility)
  void setToolByString(String? toolStr) {
    if (toolStr == null) return;

    final tool = WorkTool.values.firstWhere(
      (t) => t.value == toolStr,
      orElse: () => WorkTool.other,
    );
    state = state.copyWith(tool: tool);
  }

  /// 璁＄畻鏂扮殑閫変腑绱㈠紩
  int _calculateNewSelectedIndex({
    required int oldIndex,
    int? newIndex,
    required int maxIndex,
  }) {
    int selectedIndex = state.selectedImageIndex;

    // 閲嶆柊鎺掑簭鏃剁殑绱㈠紩璁＄畻
    if (newIndex != null) {
      if (selectedIndex == oldIndex) {
        return newIndex;
      }
      if (selectedIndex > oldIndex && selectedIndex <= newIndex) {
        return selectedIndex - 1;
      }
      if (selectedIndex < oldIndex && selectedIndex >= newIndex) {
        return selectedIndex + 1;
      }
      return selectedIndex;
    }

    // 鍒犻櫎鏃剁殑绱㈠紩璁＄畻
    if (selectedIndex == oldIndex) {
      return maxIndex >= 0 ? maxIndex : 0;
    }
    if (selectedIndex > oldIndex) {
      return selectedIndex - 1;
    }
    return selectedIndex;
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\viewmodels\states\character_collection_state.dart
-----------------------------------
import 'package:equatable/equatable.dart';

import '../../../domain/models/character/character_region.dart';
import '../../../domain/models/character/processing_options.dart';
import '../../../domain/models/character/undo_action.dart';
import '../../providers/character/tool_mode_provider.dart';

// 闆嗗瓧鍔熻兘鐘舵€?class CharacterCollectionState extends Equatable {
  final String? workId;
  final String? pageId;
  final List<CharacterRegion> regions;
  final Set<String> selectedIds;
  final Set<String> modifiedIds;
  final String? currentId;
  final Tool currentTool;
  final ProcessingOptions defaultOptions;
  final List<UndoAction> undoStack;
  final List<UndoAction> redoStack;
  final bool loading;
  final bool processing;
  final String? error;
  final bool isAdjusting;

  const CharacterCollectionState({
    this.workId,
    this.pageId,
    required this.regions,
    required this.selectedIds,
    required this.modifiedIds,
    this.currentId,
    required this.currentTool,
    required this.defaultOptions,
    required this.undoStack,
    required this.redoStack,
    required this.loading,
    required this.processing,
    this.error,
    this.isAdjusting = false,
  });

  // 鍒濆鐘舵€?  factory CharacterCollectionState.initial() {
    return const CharacterCollectionState(
      regions: [],
      selectedIds: {},
      modifiedIds: {},
      currentTool: Tool.pan,
      defaultOptions: ProcessingOptions(),
      undoStack: [],
      redoStack: [],
      loading: false,
      processing: false,
      isAdjusting: false,
    );
  }

  // 鏄惁鏈夐噸鍋氭搷浣?  bool get canRedo => redoStack.isNotEmpty;

  // 鏄惁鏈夋挙閿€鎿嶄綔
  bool get canUndo => undoStack.isNotEmpty;

  // 鏄惁鏈夊閫夊尯鍩?  bool get hasMultiSelection => selectedIds.isNotEmpty;

  // 鏄惁鏈夐€変腑鐨勫尯鍩?  bool get hasSelection => currentId != null;

  // Ensure hasUnsavedChanges uses modifiedIds directly and doesn't rely on other state
  bool get hasUnsavedChanges => modifiedIds.isNotEmpty;

  @override
  List<Object?> get props => [
        workId,
        pageId,
        regions,
        selectedIds,
        modifiedIds,
        currentId,
        currentTool,
        defaultOptions,
        undoStack,
        redoStack,
        loading,
        processing,
        error,
        isAdjusting,
      ];

  // 褰撳墠閫変腑鐨勫尯鍩?  CharacterRegion? get selectedRegion {
    if (currentId == null) return null;
    try {
      return regions.firstWhere((r) => r.id == currentId);
    } catch (e) {
      return null;
    }
  }

  // 鍒涘缓鍓湰骞舵洿鏂伴儴鍒嗗睘鎬?  CharacterCollectionState copyWith({
    String? workId,
    String? pageId,
    List<CharacterRegion>? regions,
    Set<String>? selectedIds,
    Set<String>? modifiedIds,
    String? currentId,
    Tool? currentTool,
    ProcessingOptions? defaultOptions,
    List<UndoAction>? undoStack,
    List<UndoAction>? redoStack,
    bool? loading,
    bool? processing,
    String? error,
    bool? isAdjusting,
  }) {
    return CharacterCollectionState(
      workId: workId ?? this.workId,
      pageId: pageId ?? this.pageId,
      regions: regions ?? this.regions,
      selectedIds: selectedIds ?? this.selectedIds,
      modifiedIds: modifiedIds ?? this.modifiedIds,
      currentId: currentId ?? this.currentId,
      currentTool: currentTool ?? this.currentTool,
      defaultOptions: defaultOptions ?? this.defaultOptions,
      undoStack: undoStack ?? this.undoStack,
      redoStack: redoStack ?? this.redoStack,
      loading: loading ?? this.loading,
      processing: processing ?? this.processing,
      error: error,
      isAdjusting: isAdjusting ?? this.isAdjusting,
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\viewmodels\states\character_grid_state.dart
-----------------------------------
import 'package:freezed_annotation/freezed_annotation.dart';

import '../../widgets/character_collection/filter_type.dart';

part 'character_grid_state.freezed.dart';
part 'character_grid_state.g.dart';

@freezed
class CharacterGridState with _$CharacterGridState {
  const factory CharacterGridState({
    @Default([]) List<CharacterViewModel> characters,
    @Default([]) List<CharacterViewModel> filteredCharacters,
    @Default('') String searchTerm,
    @Default(FilterType.all) FilterType filterType,
    @Default({}) Set<String> selectedIds,
    @Default(1) int currentPage,
    @Default(1) int totalPages,
    @Default(false) bool loading,
    String? error,
  }) = _CharacterGridState;

  factory CharacterGridState.fromJson(Map<String, dynamic> json) =>
      _$CharacterGridStateFromJson(json);
}

@freezed
class CharacterViewModel with _$CharacterViewModel {
  const factory CharacterViewModel({
    required String id,
    required String pageId,
    required String character,
    required String thumbnailPath,
    required DateTime createdAt,
    required DateTime updatedAt,
    @Default(false) bool isFavorite,
  }) = _CharacterViewModel;

  factory CharacterViewModel.fromJson(Map<String, dynamic> json) =>
      _$CharacterViewModelFromJson(json);
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\viewmodels\states\character_grid_state.freezed.dart
-----------------------------------
// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'character_grid_state.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

CharacterGridState _$CharacterGridStateFromJson(Map<String, dynamic> json) {
  return _CharacterGridState.fromJson(json);
}

/// @nodoc
mixin _$CharacterGridState {
  List<CharacterViewModel> get characters => throw _privateConstructorUsedError;
  List<CharacterViewModel> get filteredCharacters =>
      throw _privateConstructorUsedError;
  String get searchTerm => throw _privateConstructorUsedError;
  FilterType get filterType => throw _privateConstructorUsedError;
  Set<String> get selectedIds => throw _privateConstructorUsedError;
  int get currentPage => throw _privateConstructorUsedError;
  int get totalPages => throw _privateConstructorUsedError;
  bool get loading => throw _privateConstructorUsedError;
  String? get error => throw _privateConstructorUsedError;

  /// Serializes this CharacterGridState to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of CharacterGridState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $CharacterGridStateCopyWith<CharacterGridState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CharacterGridStateCopyWith<$Res> {
  factory $CharacterGridStateCopyWith(
          CharacterGridState value, $Res Function(CharacterGridState) then) =
      _$CharacterGridStateCopyWithImpl<$Res, CharacterGridState>;
  @useResult
  $Res call(
      {List<CharacterViewModel> characters,
      List<CharacterViewModel> filteredCharacters,
      String searchTerm,
      FilterType filterType,
      Set<String> selectedIds,
      int currentPage,
      int totalPages,
      bool loading,
      String? error});
}

/// @nodoc
class _$CharacterGridStateCopyWithImpl<$Res, $Val extends CharacterGridState>
    implements $CharacterGridStateCopyWith<$Res> {
  _$CharacterGridStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of CharacterGridState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? characters = null,
    Object? filteredCharacters = null,
    Object? searchTerm = null,
    Object? filterType = null,
    Object? selectedIds = null,
    Object? currentPage = null,
    Object? totalPages = null,
    Object? loading = null,
    Object? error = freezed,
  }) {
    return _then(_value.copyWith(
      characters: null == characters
          ? _value.characters
          : characters // ignore: cast_nullable_to_non_nullable
              as List<CharacterViewModel>,
      filteredCharacters: null == filteredCharacters
          ? _value.filteredCharacters
          : filteredCharacters // ignore: cast_nullable_to_non_nullable
              as List<CharacterViewModel>,
      searchTerm: null == searchTerm
          ? _value.searchTerm
          : searchTerm // ignore: cast_nullable_to_non_nullable
              as String,
      filterType: null == filterType
          ? _value.filterType
          : filterType // ignore: cast_nullable_to_non_nullable
              as FilterType,
      selectedIds: null == selectedIds
          ? _value.selectedIds
          : selectedIds // ignore: cast_nullable_to_non_nullable
              as Set<String>,
      currentPage: null == currentPage
          ? _value.currentPage
          : currentPage // ignore: cast_nullable_to_non_nullable
              as int,
      totalPages: null == totalPages
          ? _value.totalPages
          : totalPages // ignore: cast_nullable_to_non_nullable
              as int,
      loading: null == loading
          ? _value.loading
          : loading // ignore: cast_nullable_to_non_nullable
              as bool,
      error: freezed == error
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$CharacterGridStateImplCopyWith<$Res>
    implements $CharacterGridStateCopyWith<$Res> {
  factory _$$CharacterGridStateImplCopyWith(_$CharacterGridStateImpl value,
          $Res Function(_$CharacterGridStateImpl) then) =
      __$$CharacterGridStateImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {List<CharacterViewModel> characters,
      List<CharacterViewModel> filteredCharacters,
      String searchTerm,
      FilterType filterType,
      Set<String> selectedIds,
      int currentPage,
      int totalPages,
      bool loading,
      String? error});
}

/// @nodoc
class __$$CharacterGridStateImplCopyWithImpl<$Res>
    extends _$CharacterGridStateCopyWithImpl<$Res, _$CharacterGridStateImpl>
    implements _$$CharacterGridStateImplCopyWith<$Res> {
  __$$CharacterGridStateImplCopyWithImpl(_$CharacterGridStateImpl _value,
      $Res Function(_$CharacterGridStateImpl) _then)
      : super(_value, _then);

  /// Create a copy of CharacterGridState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? characters = null,
    Object? filteredCharacters = null,
    Object? searchTerm = null,
    Object? filterType = null,
    Object? selectedIds = null,
    Object? currentPage = null,
    Object? totalPages = null,
    Object? loading = null,
    Object? error = freezed,
  }) {
    return _then(_$CharacterGridStateImpl(
      characters: null == characters
          ? _value._characters
          : characters // ignore: cast_nullable_to_non_nullable
              as List<CharacterViewModel>,
      filteredCharacters: null == filteredCharacters
          ? _value._filteredCharacters
          : filteredCharacters // ignore: cast_nullable_to_non_nullable
              as List<CharacterViewModel>,
      searchTerm: null == searchTerm
          ? _value.searchTerm
          : searchTerm // ignore: cast_nullable_to_non_nullable
              as String,
      filterType: null == filterType
          ? _value.filterType
          : filterType // ignore: cast_nullable_to_non_nullable
              as FilterType,
      selectedIds: null == selectedIds
          ? _value._selectedIds
          : selectedIds // ignore: cast_nullable_to_non_nullable
              as Set<String>,
      currentPage: null == currentPage
          ? _value.currentPage
          : currentPage // ignore: cast_nullable_to_non_nullable
              as int,
      totalPages: null == totalPages
          ? _value.totalPages
          : totalPages // ignore: cast_nullable_to_non_nullable
              as int,
      loading: null == loading
          ? _value.loading
          : loading // ignore: cast_nullable_to_non_nullable
              as bool,
      error: freezed == error
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CharacterGridStateImpl implements _CharacterGridState {
  const _$CharacterGridStateImpl(
      {final List<CharacterViewModel> characters = const [],
      final List<CharacterViewModel> filteredCharacters = const [],
      this.searchTerm = '',
      this.filterType = FilterType.all,
      final Set<String> selectedIds = const {},
      this.currentPage = 1,
      this.totalPages = 1,
      this.loading = false,
      this.error})
      : _characters = characters,
        _filteredCharacters = filteredCharacters,
        _selectedIds = selectedIds;

  factory _$CharacterGridStateImpl.fromJson(Map<String, dynamic> json) =>
      _$$CharacterGridStateImplFromJson(json);

  final List<CharacterViewModel> _characters;
  @override
  @JsonKey()
  List<CharacterViewModel> get characters {
    if (_characters is EqualUnmodifiableListView) return _characters;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_characters);
  }

  final List<CharacterViewModel> _filteredCharacters;
  @override
  @JsonKey()
  List<CharacterViewModel> get filteredCharacters {
    if (_filteredCharacters is EqualUnmodifiableListView)
      return _filteredCharacters;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_filteredCharacters);
  }

  @override
  @JsonKey()
  final String searchTerm;
  @override
  @JsonKey()
  final FilterType filterType;
  final Set<String> _selectedIds;
  @override
  @JsonKey()
  Set<String> get selectedIds {
    if (_selectedIds is EqualUnmodifiableSetView) return _selectedIds;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableSetView(_selectedIds);
  }

  @override
  @JsonKey()
  final int currentPage;
  @override
  @JsonKey()
  final int totalPages;
  @override
  @JsonKey()
  final bool loading;
  @override
  final String? error;

  @override
  String toString() {
    return 'CharacterGridState(characters: $characters, filteredCharacters: $filteredCharacters, searchTerm: $searchTerm, filterType: $filterType, selectedIds: $selectedIds, currentPage: $currentPage, totalPages: $totalPages, loading: $loading, error: $error)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CharacterGridStateImpl &&
            const DeepCollectionEquality()
                .equals(other._characters, _characters) &&
            const DeepCollectionEquality()
                .equals(other._filteredCharacters, _filteredCharacters) &&
            (identical(other.searchTerm, searchTerm) ||
                other.searchTerm == searchTerm) &&
            (identical(other.filterType, filterType) ||
                other.filterType == filterType) &&
            const DeepCollectionEquality()
                .equals(other._selectedIds, _selectedIds) &&
            (identical(other.currentPage, currentPage) ||
                other.currentPage == currentPage) &&
            (identical(other.totalPages, totalPages) ||
                other.totalPages == totalPages) &&
            (identical(other.loading, loading) || other.loading == loading) &&
            (identical(other.error, error) || other.error == error));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_characters),
      const DeepCollectionEquality().hash(_filteredCharacters),
      searchTerm,
      filterType,
      const DeepCollectionEquality().hash(_selectedIds),
      currentPage,
      totalPages,
      loading,
      error);

  /// Create a copy of CharacterGridState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$CharacterGridStateImplCopyWith<_$CharacterGridStateImpl> get copyWith =>
      __$$CharacterGridStateImplCopyWithImpl<_$CharacterGridStateImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$CharacterGridStateImplToJson(
      this,
    );
  }
}

abstract class _CharacterGridState implements CharacterGridState {
  const factory _CharacterGridState(
      {final List<CharacterViewModel> characters,
      final List<CharacterViewModel> filteredCharacters,
      final String searchTerm,
      final FilterType filterType,
      final Set<String> selectedIds,
      final int currentPage,
      final int totalPages,
      final bool loading,
      final String? error}) = _$CharacterGridStateImpl;

  factory _CharacterGridState.fromJson(Map<String, dynamic> json) =
      _$CharacterGridStateImpl.fromJson;

  @override
  List<CharacterViewModel> get characters;
  @override
  List<CharacterViewModel> get filteredCharacters;
  @override
  String get searchTerm;
  @override
  FilterType get filterType;
  @override
  Set<String> get selectedIds;
  @override
  int get currentPage;
  @override
  int get totalPages;
  @override
  bool get loading;
  @override
  String? get error;

  /// Create a copy of CharacterGridState
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$CharacterGridStateImplCopyWith<_$CharacterGridStateImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

CharacterViewModel _$CharacterViewModelFromJson(Map<String, dynamic> json) {
  return _CharacterViewModel.fromJson(json);
}

/// @nodoc
mixin _$CharacterViewModel {
  String get id => throw _privateConstructorUsedError;
  String get pageId => throw _privateConstructorUsedError;
  String get character => throw _privateConstructorUsedError;
  String get thumbnailPath => throw _privateConstructorUsedError;
  DateTime get createdAt => throw _privateConstructorUsedError;
  DateTime get updatedAt => throw _privateConstructorUsedError;
  bool get isFavorite => throw _privateConstructorUsedError;

  /// Serializes this CharacterViewModel to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of CharacterViewModel
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $CharacterViewModelCopyWith<CharacterViewModel> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CharacterViewModelCopyWith<$Res> {
  factory $CharacterViewModelCopyWith(
          CharacterViewModel value, $Res Function(CharacterViewModel) then) =
      _$CharacterViewModelCopyWithImpl<$Res, CharacterViewModel>;
  @useResult
  $Res call(
      {String id,
      String pageId,
      String character,
      String thumbnailPath,
      DateTime createdAt,
      DateTime updatedAt,
      bool isFavorite});
}

/// @nodoc
class _$CharacterViewModelCopyWithImpl<$Res, $Val extends CharacterViewModel>
    implements $CharacterViewModelCopyWith<$Res> {
  _$CharacterViewModelCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of CharacterViewModel
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? pageId = null,
    Object? character = null,
    Object? thumbnailPath = null,
    Object? createdAt = null,
    Object? updatedAt = null,
    Object? isFavorite = null,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      pageId: null == pageId
          ? _value.pageId
          : pageId // ignore: cast_nullable_to_non_nullable
              as String,
      character: null == character
          ? _value.character
          : character // ignore: cast_nullable_to_non_nullable
              as String,
      thumbnailPath: null == thumbnailPath
          ? _value.thumbnailPath
          : thumbnailPath // ignore: cast_nullable_to_non_nullable
              as String,
      createdAt: null == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as DateTime,
      updatedAt: null == updatedAt
          ? _value.updatedAt
          : updatedAt // ignore: cast_nullable_to_non_nullable
              as DateTime,
      isFavorite: null == isFavorite
          ? _value.isFavorite
          : isFavorite // ignore: cast_nullable_to_non_nullable
              as bool,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$CharacterViewModelImplCopyWith<$Res>
    implements $CharacterViewModelCopyWith<$Res> {
  factory _$$CharacterViewModelImplCopyWith(_$CharacterViewModelImpl value,
          $Res Function(_$CharacterViewModelImpl) then) =
      __$$CharacterViewModelImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      String pageId,
      String character,
      String thumbnailPath,
      DateTime createdAt,
      DateTime updatedAt,
      bool isFavorite});
}

/// @nodoc
class __$$CharacterViewModelImplCopyWithImpl<$Res>
    extends _$CharacterViewModelCopyWithImpl<$Res, _$CharacterViewModelImpl>
    implements _$$CharacterViewModelImplCopyWith<$Res> {
  __$$CharacterViewModelImplCopyWithImpl(_$CharacterViewModelImpl _value,
      $Res Function(_$CharacterViewModelImpl) _then)
      : super(_value, _then);

  /// Create a copy of CharacterViewModel
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? pageId = null,
    Object? character = null,
    Object? thumbnailPath = null,
    Object? createdAt = null,
    Object? updatedAt = null,
    Object? isFavorite = null,
  }) {
    return _then(_$CharacterViewModelImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      pageId: null == pageId
          ? _value.pageId
          : pageId // ignore: cast_nullable_to_non_nullable
              as String,
      character: null == character
          ? _value.character
          : character // ignore: cast_nullable_to_non_nullable
              as String,
      thumbnailPath: null == thumbnailPath
          ? _value.thumbnailPath
          : thumbnailPath // ignore: cast_nullable_to_non_nullable
              as String,
      createdAt: null == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as DateTime,
      updatedAt: null == updatedAt
          ? _value.updatedAt
          : updatedAt // ignore: cast_nullable_to_non_nullable
              as DateTime,
      isFavorite: null == isFavorite
          ? _value.isFavorite
          : isFavorite // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$CharacterViewModelImpl implements _CharacterViewModel {
  const _$CharacterViewModelImpl(
      {required this.id,
      required this.pageId,
      required this.character,
      required this.thumbnailPath,
      required this.createdAt,
      required this.updatedAt,
      this.isFavorite = false});

  factory _$CharacterViewModelImpl.fromJson(Map<String, dynamic> json) =>
      _$$CharacterViewModelImplFromJson(json);

  @override
  final String id;
  @override
  final String pageId;
  @override
  final String character;
  @override
  final String thumbnailPath;
  @override
  final DateTime createdAt;
  @override
  final DateTime updatedAt;
  @override
  @JsonKey()
  final bool isFavorite;

  @override
  String toString() {
    return 'CharacterViewModel(id: $id, pageId: $pageId, character: $character, thumbnailPath: $thumbnailPath, createdAt: $createdAt, updatedAt: $updatedAt, isFavorite: $isFavorite)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CharacterViewModelImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.pageId, pageId) || other.pageId == pageId) &&
            (identical(other.character, character) ||
                other.character == character) &&
            (identical(other.thumbnailPath, thumbnailPath) ||
                other.thumbnailPath == thumbnailPath) &&
            (identical(other.createdAt, createdAt) ||
                other.createdAt == createdAt) &&
            (identical(other.updatedAt, updatedAt) ||
                other.updatedAt == updatedAt) &&
            (identical(other.isFavorite, isFavorite) ||
                other.isFavorite == isFavorite));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(runtimeType, id, pageId, character,
      thumbnailPath, createdAt, updatedAt, isFavorite);

  /// Create a copy of CharacterViewModel
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$CharacterViewModelImplCopyWith<_$CharacterViewModelImpl> get copyWith =>
      __$$CharacterViewModelImplCopyWithImpl<_$CharacterViewModelImpl>(
          this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$CharacterViewModelImplToJson(
      this,
    );
  }
}

abstract class _CharacterViewModel implements CharacterViewModel {
  const factory _CharacterViewModel(
      {required final String id,
      required final String pageId,
      required final String character,
      required final String thumbnailPath,
      required final DateTime createdAt,
      required final DateTime updatedAt,
      final bool isFavorite}) = _$CharacterViewModelImpl;

  factory _CharacterViewModel.fromJson(Map<String, dynamic> json) =
      _$CharacterViewModelImpl.fromJson;

  @override
  String get id;
  @override
  String get pageId;
  @override
  String get character;
  @override
  String get thumbnailPath;
  @override
  DateTime get createdAt;
  @override
  DateTime get updatedAt;
  @override
  bool get isFavorite;

  /// Create a copy of CharacterViewModel
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$CharacterViewModelImplCopyWith<_$CharacterViewModelImpl> get copyWith =>
      throw _privateConstructorUsedError;
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\viewmodels\states\character_grid_state.g.dart
-----------------------------------
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'character_grid_state.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

_$CharacterGridStateImpl _$$CharacterGridStateImplFromJson(
        Map<String, dynamic> json) =>
    _$CharacterGridStateImpl(
      characters: (json['characters'] as List<dynamic>?)
              ?.map(
                  (e) => CharacterViewModel.fromJson(e as Map<String, dynamic>))
              .toList() ??
          const [],
      filteredCharacters: (json['filteredCharacters'] as List<dynamic>?)
              ?.map(
                  (e) => CharacterViewModel.fromJson(e as Map<String, dynamic>))
              .toList() ??
          const [],
      searchTerm: json['searchTerm'] as String? ?? '',
      filterType:
          $enumDecodeNullable(_$FilterTypeEnumMap, json['filterType']) ??
              FilterType.all,
      selectedIds: (json['selectedIds'] as List<dynamic>?)
              ?.map((e) => e as String)
              .toSet() ??
          const {},
      currentPage: (json['currentPage'] as num?)?.toInt() ?? 1,
      totalPages: (json['totalPages'] as num?)?.toInt() ?? 1,
      loading: json['loading'] as bool? ?? false,
      error: json['error'] as String?,
    );

Map<String, dynamic> _$$CharacterGridStateImplToJson(
        _$CharacterGridStateImpl instance) =>
    <String, dynamic>{
      'characters': instance.characters,
      'filteredCharacters': instance.filteredCharacters,
      'searchTerm': instance.searchTerm,
      'filterType': _$FilterTypeEnumMap[instance.filterType]!,
      'selectedIds': instance.selectedIds.toList(),
      'currentPage': instance.currentPage,
      'totalPages': instance.totalPages,
      'loading': instance.loading,
      'error': instance.error,
    };

const _$FilterTypeEnumMap = {
  FilterType.all: 'all',
  FilterType.recent: 'recent',
  FilterType.modified: 'modified',
  FilterType.favorite: 'favorite',
  FilterType.byStroke: 'byStroke',
  FilterType.custom: 'custom',
};

_$CharacterViewModelImpl _$$CharacterViewModelImplFromJson(
        Map<String, dynamic> json) =>
    _$CharacterViewModelImpl(
      id: json['id'] as String,
      pageId: json['pageId'] as String,
      character: json['character'] as String,
      thumbnailPath: json['thumbnailPath'] as String,
      createdAt: DateTime.parse(json['createdAt'] as String),
      updatedAt: DateTime.parse(json['updatedAt'] as String),
      isFavorite: json['isFavorite'] as bool? ?? false,
    );

Map<String, dynamic> _$$CharacterViewModelImplToJson(
        _$CharacterViewModelImpl instance) =>
    <String, dynamic>{
      'id': instance.id,
      'pageId': instance.pageId,
      'character': instance.character,
      'thumbnailPath': instance.thumbnailPath,
      'createdAt': instance.createdAt.toIso8601String(),
      'updatedAt': instance.updatedAt.toIso8601String(),
      'isFavorite': instance.isFavorite,
    };



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\viewmodels\states\edit_panel_state.dart
-----------------------------------
import 'package:equatable/equatable.dart';
import 'package:flutter/material.dart';

// 缂栬緫闈㈡澘鐘舵€?
class EditPanelState extends Equatable {
  final bool isInverted;
  final bool showOutline;
  final bool isErasing;
  final double zoomLevel;
  final Offset panOffset;
  final double threshold;
  final double noiseReduction;
  final double brushSize;

  const EditPanelState({
    required this.isInverted,
    required this.showOutline,
    required this.isErasing,
    required this.zoomLevel,
    required this.panOffset,
    required this.threshold,
    required this.noiseReduction,
    required this.brushSize,
  });

  // 鍒濆鐘舵€?
  factory EditPanelState.initial() {
    return const EditPanelState(
      isInverted: false,
      showOutline: false,
      isErasing: false,
      zoomLevel: 1.0,
      panOffset: Offset.zero,
      threshold: 128.0,
      noiseReduction: 0.5,
      brushSize: 10.0,
    );
  }

  @override
  List<Object?> get props => [
        isInverted,
        showOutline,
        isErasing,
        zoomLevel,
        panOffset,
        threshold,
        noiseReduction,
        brushSize,
      ];

  // 瑙嗗浘鍙樻崲鐭╅樀
  Matrix4 get transform {
    final matrix = Matrix4.identity()
      ..translate(panOffset.dx, panOffset.dy)
      ..scale(zoomLevel);
    return matrix;
  }

  // 鍒涘缓鍓湰骞舵洿鏂伴儴鍒嗗睘鎬?
  EditPanelState copyWith({
    bool? isInverted,
    bool? showOutline,
    bool? isErasing,
    double? zoomLevel,
    Offset? panOffset,
    double? threshold,
    double? noiseReduction,
    double? brushSize,
  }) {
    return EditPanelState(
      isInverted: isInverted ?? this.isInverted,
      showOutline: showOutline ?? this.showOutline,
      isErasing: isErasing ?? this.isErasing,
      zoomLevel: zoomLevel ?? this.zoomLevel,
      panOffset: panOffset ?? this.panOffset,
      threshold: threshold ?? this.threshold,
      noiseReduction: noiseReduction ?? this.noiseReduction,
      brushSize: brushSize ?? this.brushSize,
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\viewmodels\states\work_browse_state.dart
-----------------------------------
import 'dart:convert';

import 'package:demo/domain/models/work/work_entity.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:shared_preferences/shared_preferences.dart';

import '../../../domain/models/common/sort_option.dart';
import '../../../domain/models/work/work_filter.dart';
import '../../../infrastructure/logging/logger.dart'; // 娣诲姞鏃ュ織瀵煎叆

enum LoadRequestStatus {
  idle, // 绌洪棽
  throttled, // 鑺傛祦涓紙宸茶姹備絾绛夊緟鎵ц锛?
  loading, // 鍔犺浇涓?
}

enum ViewMode { grid, list }

class WorkBrowseState {
  // 瑙嗗浘鐘舵€?
  final ViewMode viewMode;
  final bool isSidebarOpen;

  // 閫夋嫨鐘舵€?
  final bool batchMode;
  final Set<String> selectedWorks;

  // 鎼滅储鍜岃繃婊ょ姸鎬?
  final String searchQuery;
  final WorkFilter filter;
  final SortOption sortOption;

  // 鏁版嵁鐘舵€?
  final bool isLoading;
  final List<WorkEntity> works;
  final String? error;
  final TextEditingController searchController;

  // 娣诲姞鍒嗛〉鐩稿叧鐘舵€?
  final int page;
  final int pageSize;
  final bool hasMore;
  final bool isLoadingMore;

  // 娣诲姞涓€涓瓧娈佃〃绀鸿姹傜姸鎬?
  final LoadRequestStatus requestStatus;

  WorkBrowseState({
    this.isLoading = false,
    this.error,
    this.works = const [],
    this.searchQuery = '',
    this.viewMode = ViewMode.grid,
    this.sortOption = const SortOption(),
    this.filter = const WorkFilter(),
    this.isSidebarOpen = true, // 榛樿灞曞紑
    this.batchMode = false,
    this.selectedWorks = const {},
    TextEditingController? searchController,
    this.page = 1,
    this.pageSize = 20,
    this.hasMore = true,
    this.isLoadingMore = false,
    this.requestStatus = LoadRequestStatus.idle,
  }) : searchController = searchController ?? TextEditingController();

  @override
  int get hashCode => Object.hash(
        Object.hashAll(works),
        filter,
        viewMode,
        isLoading,
        error,
        batchMode,
        Object.hashAll(selectedWorks),
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    return other is WorkBrowseState &&
        listEquals(works, other.works) && // 浣跨敤 listEquals 姣旇緝鍒楄〃
        filter == other.filter &&
        viewMode == other.viewMode &&
        isLoading == other.isLoading &&
        error == other.error &&
        batchMode == other.batchMode &&
        setEquals(selectedWorks, other.selectedWorks); // 浣跨敤 setEquals 姣旇緝闆嗗悎
  }

  WorkBrowseState copyWith({
    bool? isLoading,
    String? error,
    List<WorkEntity>? works,
    String? searchQuery, // 娣诲姞 searchQuery
    ViewMode? viewMode,
    SortOption? sortOption,
    WorkFilter? filter,
    bool? isSidebarOpen, // 鏂板瀛楁
    bool? batchMode,
    Set<String>? selectedWorks,
    TextEditingController? searchController,
    int? page,
    int? pageSize,
    bool? hasMore,
    bool? isLoadingMore,
    int? totalCount,
    LoadRequestStatus? requestStatus,
  }) {
    // Add debug print to verify state updates
    debugPrint(
        'WorkBrowseState.copyWith - new works count: ${works?.length ?? this.works.length}');

    return WorkBrowseState(
      isLoading: isLoading ?? this.isLoading,
      error: error ?? this.error,
      works: works ?? this.works,
      searchQuery: searchQuery ?? this.searchQuery, // 淇濇寔鎼滅储鏉′欢
      viewMode: viewMode ?? this.viewMode,
      sortOption: sortOption ?? this.sortOption,
      filter: filter ?? this.filter,
      isSidebarOpen: isSidebarOpen ?? this.isSidebarOpen, // 澶嶅埗 isSidebarOpen
      batchMode: batchMode ?? this.batchMode,
      selectedWorks: selectedWorks ?? this.selectedWorks,
      searchController: searchController ?? this.searchController,
      page: page ?? this.page,
      pageSize: pageSize ?? this.pageSize,
      hasMore: hasMore ?? this.hasMore,
      isLoadingMore: isLoadingMore ?? this.isLoadingMore,
      requestStatus: requestStatus ?? this.requestStatus,
    );
  }

  void dispose() {
    searchController.dispose();
  }

  // 娣诲姞 toJson 鏂规硶锛岀敤浜庡簭鍒楀寲
  Map<String, dynamic> toJson() {
    AppLogger.debug('Serializing WorkBrowseState', tag: 'State');

    final result = {
      'viewMode': viewMode.index,
      'isSidebarOpen': isSidebarOpen,
      'searchQuery': searchQuery,
      'filter': filter.toJson(),
      'sortOption': sortOption.toJson(),
      'page': page,
      'pageSize': pageSize,
      'hasMore': hasMore,
      // 涓嶅簭鍒楀寲鐘舵€佹暟鎹 isLoading銆亀orks銆乪rror 绛?
      // 涓嶅簭鍒楀寲 TextEditingController
      // 涓嶅簭鍒楀寲 batchMode 鍜?selectedWorks锛屽洜涓鸿繖浜涙槸涓存椂閫夋嫨鐘舵€?
    };

    AppLogger.debug('WorkBrowseState serialized successfully', tag: 'State');
    return result;
  }

  // 娣诲姞 fromJson 闈欐€佹柟娉曪紝鐢ㄤ簬鍙嶅簭鍒楀寲
  static WorkBrowseState fromJson(Map<String, dynamic> json) {
    try {
      AppLogger.debug('Deserializing WorkBrowseState',
          tag: 'State', data: {'json': json});

      final result = WorkBrowseState(
        viewMode: json['viewMode'] != null
            ? ViewMode.values[json['viewMode'] as int]
            : ViewMode.grid,
        isSidebarOpen: json['isSidebarOpen'] as bool? ?? true,
        searchQuery: json['searchQuery'] as String? ?? '',
        filter: json['filter'] != null
            ? WorkFilter.fromJson(json['filter'] as Map<String, dynamic>)
            : const WorkFilter(),
        sortOption: json['sortOption'] != null
            ? SortOption.fromJson(json['sortOption'] as Map<String, dynamic>)
            : const SortOption(),
        page: json['page'] as int? ?? 1,
        pageSize: json['pageSize'] as int? ?? 20,
        hasMore: json['hasMore'] as bool? ?? true,
        // 榛樿鍊?
        isLoading: false,
        works: const [],
        selectedWorks: const {},
      );

      AppLogger.debug('WorkBrowseState deserialized successfully',
          tag: 'State',
          data: {
            'viewMode': result.viewMode.toString(),
            'isSidebarOpen': result.isSidebarOpen,
          });

      return result;
    } catch (e, stack) {
      AppLogger.error(
        'Error deserializing WorkBrowseState',
        tag: 'State',
        error: e,
        stackTrace: stack,
        data: {'json': json},
      );

      // 鍑洪敊鏃惰繑鍥為粯璁ょ姸鎬?
      return WorkBrowseState();
    }
  }
}

extension WorkBrowseStatePersistence on WorkBrowseState {
  static const String _keyWorkBrowseState = 'work_browse_state';

  Future<void> persist() async {
    try {
      AppLogger.debug('Persisting WorkBrowseState', tag: 'State');

      final prefs = await SharedPreferences.getInstance();
      final jsonData = toJson();
      final jsonString = jsonEncode(jsonData);
      await prefs.setString(_keyWorkBrowseState, jsonString);

      AppLogger.debug('WorkBrowseState persisted successfully', tag: 'State');
    } catch (e, stack) {
      AppLogger.error('Failed to persist WorkBrowseState',
          tag: 'State', error: e, stackTrace: stack);
    }
  }

  static Future<WorkBrowseState> restore() async {
    try {
      AppLogger.debug('Restoring WorkBrowseState', tag: 'State');

      final prefs = await SharedPreferences.getInstance();
      final jsonString = prefs.getString(_keyWorkBrowseState);

      if (jsonString == null) {
        AppLogger.debug('No saved WorkBrowseState found, using defaults',
            tag: 'State');
        return WorkBrowseState();
      }

      final jsonData = jsonDecode(jsonString) as Map<String, dynamic>;
      final state = WorkBrowseState.fromJson(jsonData);

      AppLogger.debug('WorkBrowseState restored successfully',
          tag: 'State', data: {'viewMode': state.viewMode.toString()});

      return state;
    } catch (e, stack) {
      AppLogger.error('Failed to restore WorkBrowseState',
          tag: 'State', error: e, stackTrace: stack);
      return WorkBrowseState();
    }
  }

  // 鍒犻櫎鏃ф柟娉曪紝鎴戜滑鐜板湪浣跨敤鏇村己澶х殑JSON搴忓垪鍖栨柟娉?
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\viewmodels\states\work_import_state.dart
-----------------------------------
import 'dart:io';

import '../../../domain/enums/work_style.dart';
import '../../../domain/enums/work_tool.dart';

/// 浣滃搧瀵煎叆鐘舵€?
class WorkImportState {
  final List<File> images;
  final File? selectedImage;
  final String title;
  final String? author;
  final WorkStyle? style;
  final WorkTool? tool;
  final DateTime? creationDate;
  final String? remark;
  final bool isProcessing;
  final String? error;
  final bool optimizeImages;
  final bool keepOriginals;
  final Map<String, double> imageRotations;
  final double scale;
  final double rotation;
  final int selectedImageIndex;

  const WorkImportState({
    this.images = const [],
    this.selectedImage,
    this.title = '',
    this.author = '',
    this.style,
    this.tool,
    this.creationDate,
    this.remark = '',
    this.isProcessing = false,
    this.error,
    this.optimizeImages = true,
    this.keepOriginals = false,
    this.imageRotations = const {},
    this.scale = 1.0,
    this.rotation = 0.0,
    this.selectedImageIndex = 0,
  });

  /// 鑾峰彇骞插噣鐨勫垵濮嬬姸鎬?
  factory WorkImportState.clean() {
    return WorkImportState.initial().copyWith(
      images: const [],
      selectedImage: null,
      title: '',
      error: null,
      imageRotations: const {},
    );
  }

  factory WorkImportState.initial() {
    return WorkImportState(
      // 璁剧疆榛樿鍊?
      style: WorkStyle.regular,
      tool: WorkTool.brush,
      creationDate: DateTime.now(), // 鐩存帴璁剧疆褰撳墠鏃ユ湡浣滀负榛樿鍊?
      author: '', // 鎻愪緵绌哄瓧绗︿覆鑰屼笉鏄?null
      remark: '', // 鎻愪緵绌哄瓧绗︿覆鑰屼笉鏄?null
      optimizeImages: true,
      keepOriginals: false,
      scale: 1.0,
      rotation: 0.0,
      selectedImageIndex: 0,
    );
  }
  bool get canSubmit => hasImages && !isProcessing;
  bool get hasError => error != null;
  bool get hasImages => images.isNotEmpty;

  bool get isDirty =>
      hasImages || title.isNotEmpty || author?.isNotEmpty == true;

  WorkImportState copyWith({
    List<File>? images,
    File? selectedImage,
    String? title,
    String? author,
    WorkStyle? style,
    WorkTool? tool,
    DateTime? creationDate,
    String? remark,
    bool? isProcessing,
    String? error,
    bool? optimizeImages,
    bool? keepOriginals,
    Map<String, double>? imageRotations,
    double? scale,
    double? rotation,
    int? selectedImageIndex,
  }) {
    return WorkImportState(
      images: images ?? this.images,
      selectedImage: selectedImage ?? this.selectedImage,
      title: title ?? this.title,
      author: author ?? this.author,
      style: style ?? this.style,
      tool: tool ?? this.tool,
      creationDate: creationDate ?? this.creationDate,
      remark: remark ?? this.remark,
      isProcessing: isProcessing ?? this.isProcessing,
      error: error,
      optimizeImages: optimizeImages ?? this.optimizeImages,
      keepOriginals: keepOriginals ?? this.keepOriginals,
      imageRotations: imageRotations ?? this.imageRotations,
      scale: scale ?? this.scale,
      rotation: rotation ?? this.rotation,
      selectedImageIndex: selectedImageIndex ?? this.selectedImageIndex,
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\base_page.dart
-----------------------------------
import 'package:flutter/material.dart';

import '../../theme/app_sizes.dart';

class BasePage extends StatelessWidget {
  final String title;
  final List<Widget>? actions;
  final Widget? toolbar;
  final Widget body;
  final Widget? sidebar;
  final Widget? footer;

  const BasePage({
    super.key,
    required this.title,
    this.actions,
    this.toolbar,
    required this.body,
    this.sidebar,
    this.footer,
  });

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text(title),
        actions: actions,
        toolbarHeight: AppSizes.appBarHeight,
      ),
      body: Row(
        children: [
          if (sidebar != null)
            SizedBox(
              width: AppSizes.sidebarWidth,
              child: sidebar!,
            ),
          Expanded(
            child: Column(
              children: [
                if (toolbar != null)
                  SizedBox(
                    height: AppSizes.appBarHeight,
                    child: toolbar!,
                  ),
                Expanded(child: body),
                if (footer != null)
                  SizedBox(
                    height: AppSizes.tableHeaderHeight,
                    child: footer!,
                  ),
              ],
            ),
          ),
        ],
      ),
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\date_range_picker.dart
-----------------------------------
import 'package:flutter/material.dart';

import '../../domain/models/common/date_range_filter.dart';
import '../../theme/app_sizes.dart';

class DateRangePicker extends StatefulWidget {
  final DateTimeRange? initialDateRange;
  final DateTime firstDate;
  final DateTime lastDate;
  final ValueChanged<DateTimeRange> onDateRangeChanged;

  const DateRangePicker({
    super.key,
    this.initialDateRange,
    required this.firstDate,
    required this.lastDate,
    required this.onDateRangeChanged,
  });

  @override
  State<DateRangePicker> createState() => _DateRangePickerState();
}

class _DateRangePickerState extends State<DateRangePicker> {
  late DateTime _startDate;
  late DateTime _endDate;
  DateTime? _selectedDate;

  bool get _isSelectingStart => _selectedDate == null;

  @override
  Widget build(BuildContext context) {
    return Row(
      children: [
        Expanded(
          child: Column(
            children: [
              _buildDateHeader(),
              Expanded(
                child: CalendarDatePicker(
                  initialDate: _selectedDate ?? _startDate,
                  firstDate: widget.firstDate,
                  lastDate: widget.lastDate,
                  onDateChanged: _handleDateSelected,
                ),
              ),
            ],
          ),
        ),
        const VerticalDivider(width: 1),
        SizedBox(
          width: 200,
          child: _buildQuickSelections(),
        ),
      ],
    );
  }

  @override
  void initState() {
    super.initState();
    _startDate = widget.initialDateRange?.start ?? widget.lastDate;
    _endDate = widget.initialDateRange?.end ?? widget.lastDate;
  }

  Widget _buildDateButton({
    required String label,
    required DateTime date,
    required bool isSelected,
    required VoidCallback onPressed,
  }) {
    final theme = Theme.of(context);

    return InkWell(
      onTap: onPressed,
      borderRadius: BorderRadius.circular(4),
      child: Container(
        padding: const EdgeInsets.all(AppSizes.s),
        decoration: BoxDecoration(
          border: Border.all(
            color: isSelected ? theme.colorScheme.primary : theme.dividerColor,
          ),
          borderRadius: BorderRadius.circular(4),
        ),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              label,
              style: theme.textTheme.bodySmall,
            ),
            const SizedBox(height: AppSizes.xs),
            Text(
              _formatDate(date),
              style: theme.textTheme.bodyMedium,
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildDateHeader() {
    final theme = Theme.of(context);

    return Padding(
      padding: const EdgeInsets.all(AppSizes.m),
      child: Row(
        children: [
          _buildDateButton(
            label: '寮€濮嬫棩鏈?,
            date: _startDate,
            isSelected: _selectedDate == null || _isSelectingStart,
            onPressed: () => _handleModeChange(true),
          ),
          const SizedBox(width: AppSizes.m),
          Text('鑷?, style: theme.textTheme.bodyMedium),
          const SizedBox(width: AppSizes.m),
          _buildDateButton(
            label: '缁撴潫鏃ユ湡',
            date: _endDate,
            isSelected: _selectedDate != null && !_isSelectingStart,
            onPressed: () => _handleModeChange(false),
          ),
        ],
      ),
    );
  }

  Widget _buildDateTypeSection() {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        ListTile(
          dense: true,
          title: const Text('鏌愪釜鏃ユ湡涔嬪墠'),
          onTap: () => _showSingleDatePicker(
            title: '閫夋嫨鏃ユ湡',
            initialDate: _endDate,
            onDateSelected: (date) {
              setState(() {
                _endDate = date;
                _startDate = widget.firstDate;
                widget.onDateRangeChanged(DateTimeRange(
                  start: _startDate,
                  end: _endDate,
                ));
              });
            },
          ),
        ),
        ListTile(
          dense: true,
          title: const Text('鏌愪釜鏃ユ湡涔嬪悗'),
          onTap: () => _showSingleDatePicker(
            title: '閫夋嫨鏃ユ湡',
            initialDate: _startDate,
            onDateSelected: (date) {
              setState(() {
                _startDate = date;
                _endDate = widget.lastDate;
                widget.onDateRangeChanged(DateTimeRange(
                  start: _startDate,
                  end: _endDate,
                ));
              });
            },
          ),
        ),
      ],
    );
  }

  Widget _buildQuickSelections() {
    return ListView(
      padding: const EdgeInsets.all(AppSizes.m),
      children: [
        Text(
          '蹇嵎閫夋嫨',
          style: Theme.of(context).textTheme.titleSmall,
        ),
        const SizedBox(height: AppSizes.m),
        _buildDateTypeSection(),
        const Divider(),
        ...DateRangePreset.values.map(
          (preset) => ListTile(
            dense: true,
            title: Text(_getPresetLabel(preset)),
            onTap: () => _handlePresetSelected(preset),
          ),
        ),
      ],
    );
  }

  String _formatDate(DateTime date) {
    return '${date.year}-${date.month.toString().padLeft(2, '0')}-${date.day.toString().padLeft(2, '0')}';
  }

  String _getPresetLabel(DateRangePreset preset) {
    // Convert the preset enum value to a readable label.
    return preset.toString().split('.').last;
  }

  void _handleDateSelected(DateTime date) {
    if (_isSelectingStart) {
      setState(() {
        _startDate = date;
        _selectedDate = date;
      });
    } else {
      setState(() {
        _endDate = date;
        _selectedDate = null;
        widget.onDateRangeChanged(DateTimeRange(
          start: _startDate,
          end: _endDate,
        ));
      });
    }
  }

  void _handleModeChange(bool selectingStart) {
    setState(() {
      _selectedDate = selectingStart ? null : _startDate;
    });
  }

  void _handlePresetSelected(DateRangePreset preset) {
    final range = preset.getRange();
    setState(() {
      _startDate = range.start;
      _endDate = range.end;
      _selectedDate = null;
      widget.onDateRangeChanged(range);
    });
  }

  Future<void> _showSingleDatePicker({
    required String title,
    required DateTime initialDate,
    required ValueChanged<DateTime> onDateSelected,
  }) async {
    final date = await showDialog<DateTime>(
      context: context,
      builder: (context) => Dialog(
        child: ConstrainedBox(
          constraints: const BoxConstraints(
            maxWidth: 400,
            maxHeight: 480,
          ),
          child: Padding(
            padding: const EdgeInsets.all(AppSizes.m),
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                Row(
                  children: [
                    Text(
                      title,
                      style: Theme.of(context).textTheme.titleMedium,
                    ),
                    const Spacer(),
                    IconButton(
                      icon: const Icon(Icons.close),
                      onPressed: () => Navigator.of(context).pop(),
                    ),
                  ],
                ),
                Expanded(
                  child: CalendarDatePicker(
                    initialDate: initialDate,
                    firstDate: widget.firstDate,
                    lastDate: widget.lastDate,
                    onDateChanged: (date) => Navigator.of(context).pop(date),
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );

    if (date != null) {
      onDateSelected(date);
    }
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\dialog_container.dart
-----------------------------------
import 'package:flutter/material.dart';

import '../../theme/app_sizes.dart';

class DialogContainer extends StatelessWidget {
  final String title;
  final Widget child;
  final List<Widget>? actions;
  final EdgeInsets? padding;
  final double? width;
  final double? height;
  final VoidCallback? onClose;

  const DialogContainer({
    super.key,
    required this.title,
    required this.child,
    this.actions,
    this.padding,
    this.width,
    this.height,
    this.onClose,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Dialog(
      child: Container(
        width: width,
        height: height,
        padding: padding ?? const EdgeInsets.all(AppSizes.spacingLarge),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Row(
              children: [
                Text(
                  title,
                  style: theme.textTheme.titleLarge,
                ),
                const Spacer(),
                if (onClose != null)
                  IconButton(
                    icon: const Icon(Icons.close),
                    onPressed: onClose,
                  ),
              ],
            ),
            if (onClose != null) const Divider(height: 24),
            Expanded(child: child),
            if (actions != null) ...[
              const SizedBox(height: AppSizes.spacingMedium),
              Row(
                mainAxisAlignment: MainAxisAlignment.end,
                children: actions!,
              ),
            ],
          ],
        ),
      ),
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\error_boundary.dart
-----------------------------------
import 'package:flutter/material.dart';

class ErrorBoundary extends StatefulWidget {
  final Widget child;
  final Widget Function(FlutterErrorDetails)? errorBuilder;

  const ErrorBoundary({
    super.key,
    required this.child,
    this.errorBuilder,
  });

  @override
  State<ErrorBoundary> createState() => _ErrorBoundaryState();
}

class _ErrorBoundaryState extends State<ErrorBoundary> {
  FlutterErrorDetails? _error;

  @override
  Widget build(BuildContext context) {
    if (_error != null) {
      return widget.errorBuilder?.call(_error!) ??
          Center(
            child: Padding(
              padding: const EdgeInsets.all(16.0),
              child: Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  const Icon(Icons.error_outline, size: 48, color: Colors.red),
                  const SizedBox(height: 16),
                  const Text('鍙戠敓浜嗘剰澶栭敊璇?),
                  const SizedBox(height: 8),
                  Text(
                    _error!.exception.toString(),
                    style: const TextStyle(fontSize: 12),
                  ),
                  const SizedBox(height: 16),
                  ElevatedButton(
                    onPressed: () {
                      setState(() {
                        _error = null;
                      });
                    },
                    child: const Text('閲嶈瘯'),
                  ),
                ],
              ),
            ),
          );
    }

    ErrorWidget.builder = (FlutterErrorDetails details) {
      setState(() {
        _error = details;
      });
      return const SizedBox.shrink();
    };
    return widget.child;
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\info_card.dart
-----------------------------------
import 'package:flutter/material.dart';

import '../../theme/app_sizes.dart';

class InfoCard extends StatelessWidget {
  final String title;
  final IconData? icon;
  final Widget content;
  final bool initiallyExpanded;
  final EdgeInsetsGeometry? padding;

  const InfoCard({
    super.key,
    required this.title,
    this.icon,
    required this.content,
    this.initiallyExpanded = true,
    this.padding,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Card(
      margin: EdgeInsets.zero,
      elevation: 0,
      color: theme.colorScheme.surface,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(AppSizes.radiusMedium),
        side: BorderSide(
          color: theme.colorScheme.outlineVariant,
          width: 1.0,
        ),
      ),
      child: ExpansionTile(
        title: Row(
          children: [
            if (icon != null) ...[
              Icon(
                icon,
                size: 18,
                color: theme.colorScheme.primary,
              ),
              const SizedBox(width: 8),
            ],
            Text(
              title,
              style: theme.textTheme.titleMedium?.copyWith(
                fontWeight: FontWeight.w500,
              ),
            ),
          ],
        ),
        initiallyExpanded: initiallyExpanded,
        childrenPadding:
            padding ?? const EdgeInsets.all(AppSizes.spacingMedium),
        expandedAlignment: Alignment.topLeft,
        expandedCrossAxisAlignment: CrossAxisAlignment.start,
        children: [content],
      ),
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\loading_overlay.dart
-----------------------------------
import 'package:flutter/material.dart';

class LoadingOverlay extends StatelessWidget {
  const LoadingOverlay({super.key});

  @override
  Widget build(BuildContext context) {
    return Container(
      color: Colors.black26,
      child: const Center(
        child: CircularProgressIndicator(),
      ),
    );
  }
}


C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\message_bar.dart
-----------------------------------
import 'package:flutter/material.dart';

import '../../theme/app_sizes.dart';

class MessageBar extends StatelessWidget {
  final String message;
  final Color? backgroundColor;
  final Color? textColor;
  final IconData? icon;
  final VoidCallback? onDismiss;

  const MessageBar({
    super.key,
    required this.message,
    this.backgroundColor,
    this.textColor,
    this.icon,
    this.onDismiss,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Material(
      color: backgroundColor ?? theme.colorScheme.secondary,
      child: Padding(
        padding: const EdgeInsets.all(AppSizes.spacingMedium),
        child: Row(
          children: [
            if (icon != null) ...[
              Icon(
                icon,
                color: textColor ?? Colors.white,
                size: AppSizes.iconMedium,
              ),
              const SizedBox(width: AppSizes.spacingSmall),
            ],
            Expanded(
              child: Text(
                message,
                style: theme.textTheme.bodyMedium?.copyWith(
                  color: textColor ?? Colors.white,
                ),
              ),
            ),
            if (onDismiss != null)
              IconButton(
                icon: Icon(
                  Icons.close,
                  color: textColor ?? Colors.white,
                  size: AppSizes.iconSmall,
                ),
                onPressed: onDismiss,
              ),
          ],
        ),
      ),
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\page_bar.dart
-----------------------------------
import 'package:flutter/material.dart';

import '../../theme/app_sizes.dart';

class PageBar extends StatelessWidget implements PreferredSizeWidget {
  final Widget? title;
  final List<Widget>? actions;
  final double? toolbarHeight;
  final Color? backgroundColor;
  final Color? foregroundColor;

  const PageBar({
    super.key,
    this.title,
    this.actions,
    this.toolbarHeight,
    this.backgroundColor,
    this.foregroundColor,
  });

  @override
  Size get preferredSize =>
      Size.fromHeight(toolbarHeight ?? AppSizes.pageToolbarHeight);

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Container(
      height: preferredSize.height,
      padding: const EdgeInsets.symmetric(horizontal: AppSizes.spacingMedium),
      decoration: BoxDecoration(
        color: backgroundColor ?? theme.primaryColor,
        border: Border(
          bottom: BorderSide(
            color: theme.dividerColor,
            width: 1,
          ),
        ),
      ),
      child: Row(
        children: [
          if (title != null)
            DefaultTextStyle(
              style: theme.textTheme.titleLarge!.copyWith(
                color: foregroundColor ?? Colors.white,
              ),
              child: title!,
            ),
          const Spacer(),
          if (actions != null) Row(children: actions!),
        ],
      ),
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\page_layout.dart
-----------------------------------
import 'package:flutter/material.dart';

/// A simplified standard page layout with consistent structure.
/// Only includes toolbar and body areas - the toolbar should include
/// all title/navigation/action elements combined.
class PageLayout extends StatelessWidget {
  /// The toolbar widget that appears at the top of the page
  /// This should contain all title elements and action buttons
  final Widget? toolbar;

  /// The main content of the page
  final Widget body;

  /// Optional floating action button
  final Widget? floatingActionButton;

  /// Height of the toolbar. If null, toolbar will size to its content.
  final double? toolbarHeight;

  const PageLayout({
    super.key,
    this.toolbar,
    required this.body,
    this.floatingActionButton,
    this.toolbarHeight,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Scaffold(
      // No AppBar, using our own toolbar
      body: SafeArea(
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            // Toolbar with bottom border (if provided)
            if (toolbar != null)
              Container(
                height: toolbarHeight ??
                    kToolbarHeight, // Use standard toolbar height if not specified
                decoration: BoxDecoration(
                  border: Border(
                    bottom: BorderSide(
                      color: theme.dividerColor.withOpacity(0.5),
                      width: 1,
                    ),
                  ),
                ),
                child: toolbar!,
              ),

            // Main content
            Expanded(child: body),
          ],
        ),
      ),
      floatingActionButton: floatingActionButton,
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\page_toolbar.dart
-----------------------------------
import 'package:flutter/material.dart';
import '../../theme/app_sizes.dart';

class PageToolbar extends StatelessWidget {
  final List<Widget>? leading;
  final List<Widget>? trailing;
  final double? height;

  const PageToolbar({
    super.key,
    this.leading,
    this.trailing,
    this.height,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Container(
      height: height ?? AppSizes.pageToolbarHeight,
      padding: const EdgeInsets.symmetric(
        horizontal: AppSizes.spacingMedium,
        vertical: AppSizes.spacingSmall,
      ),
      decoration: BoxDecoration(
        color: theme.scaffoldBackgroundColor,
        border: Border(
          bottom: BorderSide(color: theme.dividerColor),
        ),
      ),
      child: Row(
        children: [
          if (leading != null) ...[
            ...leading!,
            const Spacer(),
          ],
          if (trailing != null) ...trailing!,
        ],
      ),
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\responsive_builder.dart
-----------------------------------
import 'package:flutter/material.dart';

import '../../theme/app_sizes.dart';

enum ResponsiveBreakpoint { xs, sm, md, lg }

class ResponsiveBuilder extends StatelessWidget {
  final Widget Function(BuildContext, ResponsiveBreakpoint) builder;

  const ResponsiveBuilder({
    super.key,
    required this.builder,
  });

  @override
  Widget build(BuildContext context) {
    return LayoutBuilder(
      builder: (context, constraints) {
        final breakpoint = _getBreakpoint(constraints.maxWidth);
        return builder(context, breakpoint);
      },
    );
  }

  ResponsiveBreakpoint _getBreakpoint(double width) {
    if (width < AppSizes.breakpointXs) return ResponsiveBreakpoint.xs;
    if (width < AppSizes.breakpointMd) return ResponsiveBreakpoint.sm;
    if (width < AppSizes.breakpointLg) return ResponsiveBreakpoint.md;
    return ResponsiveBreakpoint.lg;
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\section_header.dart
-----------------------------------
import 'package:flutter/material.dart';
import '../../theme/app_sizes.dart';

class SectionHeader extends StatelessWidget {
  final String title;
  final List<Widget>? actions;
  final EdgeInsets? padding;

  const SectionHeader({
    super.key,
    required this.title,
    this.actions,
    this.padding,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    
    return Padding(
      padding: padding ?? const EdgeInsets.all(AppSizes.spacingMedium),
      child: Row(
        children: [
          Text(
            title,
            style: theme.textTheme.titleMedium?.copyWith(
              fontWeight: FontWeight.bold,
            ),
          ),
          if (actions != null) ...[
            const Spacer(),
            ...actions!,
          ],
        ],
      ),
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\skeleton_loader.dart
-----------------------------------
import 'package:flutter/material.dart';

class SkeletonLoader extends StatefulWidget {
  final double width;
  final double height;
  final BorderRadius? borderRadius;

  const SkeletonLoader({
    super.key,
    required this.width,
    required this.height,
    this.borderRadius,
  });

  @override
  State<SkeletonLoader> createState() => _SkeletonLoaderState();
}

class _SkeletonLoaderState extends State<SkeletonLoader>
    with SingleTickerProviderStateMixin {
  late AnimationController _controller;
  late Animation<double> _animation;

  @override
  Widget build(BuildContext context) {
    return AnimatedBuilder(
      animation: _animation,
      builder: (context, child) {
        return Container(
          width: widget.width,
          height: widget.height,
          decoration: BoxDecoration(
            borderRadius: widget.borderRadius ?? BorderRadius.circular(8),
            color: Colors.grey[300]?.withOpacity(_animation.value),
          ),
        );
      },
    );
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  @override
  void initState() {
    super.initState();
    _controller = AnimationController(
      duration: const Duration(seconds: 1),
      vsync: this,
    )..repeat(reverse: true);

    _animation = Tween<double>(begin: 0.5, end: 1.0).animate(_controller);
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\tag_editor.dart
-----------------------------------
import 'package:flutter/material.dart';

class TagEditor extends StatefulWidget {
  final List<String> tags;
  final List<String> suggestedTags;
  final Function(List<String>) onTagsChanged;
  final Color? chipColor;
  final Color? textColor;
  final bool readOnly;

  const TagEditor({
    super.key,
    required this.tags,
    required this.onTagsChanged,
    this.suggestedTags = const [],
    this.chipColor,
    this.textColor,
    this.readOnly = false,
  });

  @override
  State<TagEditor> createState() => _TagEditorState();
}

class _TagEditorState extends State<TagEditor> {
  final TextEditingController _controller = TextEditingController();
  final FocusNode _focusNode = FocusNode();
  List<String> _tags = [];

  @override
  Widget build(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        // Only show tag input when not in read-only mode
        if (!widget.readOnly) ...[
          // 鏍囩杈撳叆
          Row(
            children: [
              Expanded(
                child: TextField(
                  controller: _controller,
                  focusNode: _focusNode,
                  decoration: InputDecoration(
                    hintText: '杈撳叆鏍囩鍚庢寜Enter娣诲姞',
                    isDense: true,
                    border: OutlineInputBorder(
                      borderRadius: BorderRadius.circular(4),
                    ),
                    suffixIcon: IconButton(
                      icon: const Icon(Icons.add),
                      onPressed: () {
                        if (_controller.text.isNotEmpty) {
                          _addTag(_controller.text);
                        }
                      },
                    ),
                  ),
                  onSubmitted: (value) {
                    _addTag(value);
                    _focusNode.requestFocus(); // 淇濇寔鐒︾偣
                  },
                ),
              ),
            ],
          ),

          const SizedBox(height: 8),
        ],

        // Current tags display - always shown
        if (_tags.isEmpty && widget.readOnly)
          Text(
            '鏆傛棤鏍囩',
            style: TextStyle(
              color: Theme.of(context).hintColor,
              fontStyle: FontStyle.italic,
            ),
          )
        else
          Wrap(
            spacing: 8,
            runSpacing: 8,
            children: _tags.map((tag) {
              return Chip(
                label: Text(
                  tag,
                  style: TextStyle(color: widget.textColor),
                ),
                backgroundColor: widget.chipColor,
                // Only show delete icon when not in read-only mode
                deleteIcon:
                    widget.readOnly ? null : const Icon(Icons.close, size: 16),
                onDeleted: widget.readOnly ? null : () => _removeTag(tag),
              );
            }).toList(),
          ),

        // Only show suggested tags when not in read-only mode and there are suggestions
        if (!widget.readOnly && widget.suggestedTags.isNotEmpty) ...[
          const SizedBox(height: 16),
          const Text('寤鸿鏍囩:', style: TextStyle(fontWeight: FontWeight.bold)),
          const SizedBox(height: 8),

          // 寤鸿鏍囩
          Wrap(
            spacing: 8,
            runSpacing: 8,
            children: widget.suggestedTags
                .where((tag) => !_tags.contains(tag))
                .map((tag) {
              return ActionChip(
                label: Text(tag),
                onPressed: () => _addTag(tag),
              );
            }).toList(),
          ),
        ],
      ],
    );
  }

  @override
  void didUpdateWidget(covariant TagEditor oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (oldWidget.tags != widget.tags) {
      setState(() {
        _tags = List.from(widget.tags);
      });
    }
  }

  @override
  void dispose() {
    _controller.dispose();
    _focusNode.dispose();
    super.dispose();
  }

  @override
  void initState() {
    super.initState();
    _tags = List.from(widget.tags);
  }

  void _addTag(String tag) {
    if (widget.readOnly)
      return; // Safety check - don't add tags in readonly mode

    tag = tag.trim();
    if (tag.isNotEmpty && !_tags.contains(tag)) {
      setState(() {
        _tags.add(tag);
        _controller.clear();
      });
      widget.onTagsChanged(_tags);
    }
  }

  void _removeTag(String tag) {
    if (widget.readOnly)
      return; // Safety check - don't remove tags in readonly mode

    setState(() {
      _tags.remove(tag);
    });
    widget.onTagsChanged(_tags);
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\tag_list.dart
-----------------------------------
import 'package:flutter/material.dart';

import '../../theme/app_colors.dart';
import '../../theme/app_sizes.dart';
import '../../theme/app_text_styles.dart';

class TagList extends StatelessWidget {
  final List<String> tags;
  final int? maxLines;
  final void Function(String)? onTagTap;

  const TagList({
    super.key,
    required this.tags,
    this.maxLines,
    this.onTagTap,
  });

  @override
  Widget build(BuildContext context) {
    if (maxLines == 1) {
      return SingleChildScrollView(
        scrollDirection: Axis.horizontal,
        child: _buildTagRow(),
      );
    }

    return Wrap(
      spacing: AppSizes.p4,
      runSpacing: AppSizes.p4,
      children: tags.map(_buildTag).toList(),
    );
  }

  Widget _buildTag(String tag) {
    return InkWell(
      onTap: onTagTap != null ? () => onTagTap!(tag) : null,
      child: Container(
        padding: const EdgeInsets.symmetric(
          horizontal: AppSizes.p8,
          vertical: AppSizes.p4,
        ),
        decoration: BoxDecoration(
          color: AppColors.background,
          borderRadius: BorderRadius.circular(AppSizes.r4),
        ),
        child: Text(
          '#$tag',
          style: AppTextStyles.bodySmall,
          maxLines: 1,
          overflow: TextOverflow.ellipsis,
        ),
      ),
    );
  }

  Widget _buildTagRow() {
    return Row(
      children: [
        for (var i = 0; i < tags.length; i++) ...[
          if (i > 0) const SizedBox(width: AppSizes.p4),
          _buildTag(tags[i]),
        ],
      ],
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\character\character_detail_view.dart
-----------------------------------
import 'package:flutter/material.dart';

class CharacterDetailView extends StatelessWidget {
  final String charId;
  final bool showCloseButton;
  final VoidCallback? onClose;

  const CharacterDetailView({
    super.key,
    required this.charId,
    this.showCloseButton = false,
    this.onClose,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Container(
      color: theme.scaffoldBackgroundColor,
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          if (!showCloseButton) ...[
            Padding(
              padding: const EdgeInsets.all(16.0),
              child: Row(
                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                children: [
                  Text(
                    '瀛楃璇︽儏',
                    style: theme.textTheme.titleLarge,
                  ),
                  ElevatedButton.icon(
                    onPressed: () {},
                    icon: const Icon(Icons.edit),
                    label: const Text('缂栬緫'),
                  ),
                ],
              ),
            ),
            const Divider(height: 1),
          ],
          Expanded(
            child: ListView(
              padding: const EdgeInsets.all(16.0),
              children: [
                Card(
                  child: Padding(
                    padding: const EdgeInsets.all(16.0),
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text('鍩烘湰淇℃伅', style: theme.textTheme.titleMedium),
                        const SizedBox(height: 16),
                        _buildInfoRow('Unicode', 'U+4E00', theme),
                        _buildInfoRow('鎷奸煶', 'y墨', theme),
                        _buildInfoRow('绗旂敾', '1', theme),
                      ],
                    ),
                  ),
                ),
                const SizedBox(height: 16),
                Card(
                  child: Padding(
                    padding: const EdgeInsets.all(16.0),
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Text('鍑哄淇℃伅', style: theme.textTheme.titleMedium),
                        const SizedBox(height: 16),
                        _buildInfoRow('浣滃搧', '鍏颁涵闆嗗簭', theme),
                        _buildInfoRow('浣滆€?, '鐜嬬静涔?, theme),
                        _buildInfoRow('鏈濅唬', '鏅?, theme),
                      ],
                    ),
                  ),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildInfoRow(String label, String value, ThemeData theme) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 8.0),
      child: Row(
        children: [
          SizedBox(
            width: 80,
            child: Text(
              label,
              style: theme.textTheme.bodyMedium?.copyWith(
                color: theme.textTheme.bodySmall?.color,
              ),
            ),
          ),
          Expanded(
            child: Text(
              value,
              style: theme.textTheme.bodyMedium,
            ),
          ),
        ],
      ),
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\character\character_extraction_panel.dart
-----------------------------------
import 'package:flutter/material.dart';

class CharacterExtractionPanel extends StatefulWidget {
  final String workId;
  final int imageIndex;
  
  const CharacterExtractionPanel({
    super.key,
    required this.workId,
    required this.imageIndex,
  });

  @override
  State<CharacterExtractionPanel> createState() => _CharacterExtractionPanelState();
}

class _CharacterExtractionPanelState extends State<CharacterExtractionPanel> {
  bool _autoRecognitionEnabled = true;
  double _noiseReduction = 0.5;
  double _binarization = 0.5;
  double _grayScale = 0.5;
  String _selectedTool = 'select'; // select, rect, lasso
  final List<Rect> _selectedRegions = [];
  final PageController _pageController = PageController();
  int _currentPage = 0;
  List<String> _pages = []; // 瀛樺偍鎵€鏈夐〉闈㈢殑鍥剧墖璺緞

  @override
  void initState() {
    super.initState();
    // TODO: 鍔犺浇瀹為檯鐨勯〉闈㈡暟鎹?
    _pages = List.generate(5, (index) => 'Page ${index + 1}');
  }

  @override
  void dispose() {
    _pageController.dispose();
    super.dispose();
  }
  
  @override
  Widget build(BuildContext context) {
    return Material(
      child: Column(
        children: [
          _buildTopToolbar(),
          Expanded(
            child: Row(
              children: [
                _buildLeftToolbar(),
                Expanded(
                  child: _buildPreviewArea(),
                ),
                _buildRightPanel(),
              ],
            ),
          ),
          _buildStatusBar(),
        ],
      ),
    );
  }

  Widget _buildTopToolbar() {
    return Container(
      height: 48,
      padding: const EdgeInsets.symmetric(horizontal: 16),
      decoration: BoxDecoration(
        border: Border(bottom: BorderSide(color: Colors.grey[300]!)),
      ),
      child: Row(
        children: [
          IconButton(
            icon: const Icon(Icons.close),
            onPressed: () => Navigator.pop(context),
            tooltip: '閫€鍑?,
          ),
          const VerticalDivider(),
          // 棰勫鐞嗗伐鍏风粍
          Row(
            children: [
              Switch(
                value: _autoRecognitionEnabled,
                onChanged: (value) => setState(() => _autoRecognitionEnabled = value),
              ),
              const Text('鑷姩璇嗗埆绗旂敾'),
              const SizedBox(width: 16),
              _buildSlider('闄嶅櫔', _noiseReduction),
              _buildSlider('浜屽€煎寲', _binarization),
              _buildSlider('鐏板害鑼冨洿', _grayScale),
              TextButton(
                onPressed: _resetPreprocess,
                child: const Text('閲嶇疆'),
              ),
            ],
          ),
          const Spacer(),
          // 鎿嶄綔宸ュ叿缁?
          IconButton(
            icon: const Icon(Icons.clear),
            onPressed: _clearSelection,
            tooltip: '娓呯┖閫夋嫨',
          ),
          IconButton(
            icon: const Icon(Icons.undo),
            onPressed: _undo,
            tooltip: '鎾ら攢',
          ),
          IconButton(
            icon: const Icon(Icons.redo),
            onPressed: _redo,
            tooltip: '閲嶅仛',
          ),
        ],
      ),
    );
  }

  Widget _buildLeftToolbar() {
    return Container(
      width: 48,
      decoration: BoxDecoration(
        border: Border(right: BorderSide(color: Colors.grey[300]!)),
      ),
      child: Column(
        children: [
          // 閫夋嫨宸ュ叿
          IconButton(
            icon: const Icon(Icons.touch_app),
            onPressed: () => setState(() => _selectedTool = 'select'),
            isSelected: _selectedTool == 'select',
            tooltip: '鐐瑰嚮閫夋嫨',
          ),
          IconButton(
            icon: const Icon(Icons.crop_square),
            onPressed: () => setState(() => _selectedTool = 'rect'),
            isSelected: _selectedTool == 'rect',
            tooltip: '鐭╁舰妗嗛€?,
          ),
          IconButton(
            icon: const Icon(Icons.gesture),
            onPressed: () => setState(() => _selectedTool = 'lasso'),
            isSelected: _selectedTool == 'lasso',
            tooltip: '濂楃储閫夋嫨',
          ),
          const Divider(),
          // 瑙嗗浘宸ュ叿
          IconButton(
            icon: const Icon(Icons.zoom_in),
            onPressed: _zoomIn,
            tooltip: '鏀惧ぇ',
          ),
          IconButton(
            icon: const Icon(Icons.zoom_out),
            onPressed: _zoomOut,
            tooltip: '缂╁皬',
          ),
        ],
      ),
    );
  }

  Widget _buildPreviewArea() {
    return Column(
      children: [
        // 宸ュ叿鏍?
        // ...existing code...

        // 涓婚瑙堝尯锛堟敮鎸佸乏鍙虫粦鍔級
        Expanded(
          child: Row(
            children: [
              // 宸︾炕椤垫寜閽?
              IconButton(
                icon: const Icon(Icons.chevron_left),
                onPressed: _currentPage > 0
                    ? () {
                        _pageController.previousPage(
                          duration: const Duration(milliseconds: 300),
                          curve: Curves.easeInOut,
                        );
                      }
                    : null,
              ),
              // 涓ぎ棰勮鍖?
              Expanded(
                child: Stack(
                  children: [
                    PageView.builder(
                      controller: _pageController,
                      onPageChanged: (index) {
                        setState(() => _currentPage = index);
                      },
                      itemCount: _pages.length,
                      itemBuilder: (context, index) {
                        return Container(
                          color: Colors.grey[100],
                          child: Center(
                            child: Text('${_pages[index]} 棰勮鍖哄煙'),
                          ),
                        );
                      },
                    ),
                    // 椤电爜鎸囩ず鍣?
                    Positioned(
                      bottom: 16,
                      left: 0,
                      right: 0,
                      child: Row(
                        mainAxisAlignment: MainAxisAlignment.center,
                        children: [
                          Container(
                            padding: const EdgeInsets.symmetric(
                              horizontal: 12,
                              vertical: 4,
                            ),
                            decoration: BoxDecoration(
                              color: Colors.black54,
                              borderRadius: BorderRadius.circular(12),
                            ),
                            child: Text(
                              '${_currentPage + 1} / ${_pages.length}',
                              style: const TextStyle(
                                color: Colors.white,
                                fontSize: 12,
                              ),
                            ),
                          ),
                        ],
                      ),
                    ),
                  ],
                ),
              ),
              // 鍙崇炕椤垫寜閽?
              IconButton(
                icon: const Icon(Icons.chevron_right),
                onPressed: _currentPage < _pages.length - 1
                    ? () {
                        _pageController.nextPage(
                          duration: const Duration(milliseconds: 300),
                          curve: Curves.easeInOut,
                        );
                      }
                    : null,
              ),
            ],
          ),
        ),
        // 搴曢儴缂╃暐鍥惧鑸爮
        SizedBox(
          height: 80,
          child: ListView.builder(
            scrollDirection: Axis.horizontal,
            itemCount: _pages.length,
            itemBuilder: (context, index) {
              final isSelected = index == _currentPage;
              return GestureDetector(
                onTap: () {
                  _pageController.animateToPage(
                    index,
                    duration: const Duration(milliseconds: 300),
                    curve: Curves.easeInOut,
                  );
                },
                child: Container(
                  width: 60,
                  margin: const EdgeInsets.all(4),
                  decoration: BoxDecoration(
                    border: Border.all(
                      color: isSelected
                          ? Theme.of(context).primaryColor
                          : Colors.transparent,
                      width: 2,
                    ),
                  ),
                  child: Center(
                    child: Text('${index + 1}'),
                  ),
                ),
              );
            },
          ),
        ),
      ],
    );
  }

  Widget _buildRightPanel() {
    return Container(
      width: 300,
      decoration: BoxDecoration(
        border: Border(left: BorderSide(color: Colors.grey[300]!)),
      ),
      child: Column(
        children: [
          // 缁撴灉棰勮
          Expanded(
            child: Container(
              padding: const EdgeInsets.all(16),
              child: Column(
                children: [
                  const Text('闆嗗瓧棰勮'),
                  Expanded(
                    child: Container(
                      margin: const EdgeInsets.all(16),
                      decoration: BoxDecoration(
                        color: Colors.white,
                        border: Border.all(color: Colors.grey[300]!),
                      ),
                      child: const Center(
                        child: Text('棰勮缁撴灉'),
                      ),
                    ),
                  ),
                ],
              ),
            ),
          ),
          const Divider(height: 1),
          // 鐧昏淇℃伅
          Container(
            padding: const EdgeInsets.all(16),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.stretch,
              children: [
                const TextField(
                  decoration: InputDecoration(
                    labelText: '绠€浣撳瓧 *',
                    border: OutlineInputBorder(),
                  ),
                  maxLength: 1,
                ),
                const SizedBox(height: 16),
                DropdownButtonFormField<String>(
                  decoration: const InputDecoration(
                    labelText: '椋庢牸',
                    border: OutlineInputBorder(),
                  ),
                  items: const [
                    DropdownMenuItem(value: 'kai', child: Text('妤蜂功')),
                    DropdownMenuItem(value: 'xing', child: Text('琛屼功')),
                  ],
                  onChanged: (value) {},
                ),
                const SizedBox(height: 16),
                DropdownButtonFormField<String>(
                  decoration: const InputDecoration(
                    labelText: '宸ュ叿',
                    border: OutlineInputBorder(),
                  ),
                  items: const [
                    DropdownMenuItem(value: 'brush', child: Text('姣涚瑪')),
                    DropdownMenuItem(value: 'pen', child: Text('纭瑪')),
                  ],
                  onChanged: (value) {},
                ),
                const SizedBox(height: 24),
                ElevatedButton(
                  onPressed: _saveCharacter,
                  child: const Text('淇濆瓨闆嗗瓧'),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildStatusBar() {
    return Container(
      height: 24,
      padding: const EdgeInsets.symmetric(horizontal: 16),
      decoration: BoxDecoration(
        border: Border(top: BorderSide(color: Colors.grey[300]!)),
      ),
      child: Row(
        children: [
          Text('褰撳墠宸ュ叿: $_selectedTool'),
          const Spacer(),
          Text('宸查€夋嫨鍖哄煙: ${_selectedRegions.length}'),
        ],
      ),
    );
  }

  Widget _buildSlider(String label, double value) {
    return Row(
      mainAxisSize: MainAxisSize.min,
      children: [
        Text(label),
        SizedBox(
          width: 100,
          child: Slider(
            value: value,
            onChanged: (v) => setState(() {
              switch (label) {
                case '闄嶅櫔':
                  _noiseReduction = v;
                  break;
                case '浜屽€煎寲':
                  _binarization = v;
                  break;
                case '鐏板害鑼冨洿':
                  _grayScale = v;
                  break;
              }
            }),
          ),
        ),
      ],
    );
  }

  void _resetPreprocess() {
    setState(() {
      _noiseReduction = 0.5;
      _binarization = 0.5;
      _grayScale = 0.5;
    });
  }

  void _clearSelection() {
    setState(() => _selectedRegions.clear());
  }

  void _undo() {
    // TODO: 瀹炵幇鎾ら攢鍔熻兘
  }

  void _redo() {
    // TODO: 瀹炵幇閲嶅仛鍔熻兘
  }

  void _zoomIn() {
    // TODO: 瀹炵幇鏀惧ぇ鍔熻兘
  }

  void _zoomOut() {
    // TODO: 瀹炵幇缂╁皬鍔熻兘
  }

  void _handleTap(TapDownDetails details) {
    // TODO: 瀹炵幇鐐瑰嚮閫夋嫨鍔熻兘
  }

  void _handlePanStart(DragStartDetails details) {
    // TODO: 瀹炵幇鎷栧姩寮€濮?
  }

  void _handlePanUpdate(DragUpdateDetails details) {
    // TODO: 瀹炵幇鎷栧姩鏇存柊
  }

  void _handlePanEnd(DragEndDetails details) {
    // TODO: 瀹炵幇鎷栧姩缁撴潫
  }

  void _saveCharacter() {
    // TODO: 瀹炵幇淇濆瓨闆嗗瓧鍔熻兘
  }
}

class CharacterExtractionPainter extends CustomPainter {
  final List<Rect> regions;
  final String currentTool;

  CharacterExtractionPainter({
    required this.regions,
    required this.currentTool,
  });

  @override
  void paint(Canvas canvas, Size size) {
    // TODO: 瀹炵幇缁樺埗鍔熻兘
  }

  @override
  bool shouldRepaint(covariant CustomPainter oldDelegate) => true;
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\character_collection\action_buttons.dart
-----------------------------------
import 'package:flutter/material.dart';

class ActionButtons extends StatelessWidget {
  final VoidCallback onSave;
  final VoidCallback onCancel;

  const ActionButtons({
    Key? key,
    required this.onSave,
    required this.onCancel,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Row(
      mainAxisAlignment: MainAxisAlignment.end,
      children: [
        // 鍙栨秷鎸夐挳
        OutlinedButton(
          onPressed: onCancel,
          style: OutlinedButton.styleFrom(
            padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 12),
          ),
          child: const Text('鍙栨秷'),
        ),

        const SizedBox(width: 16),

        // 淇濆瓨鎸夐挳
        ElevatedButton(
          onPressed: onSave,
          style: ElevatedButton.styleFrom(
            backgroundColor: Theme.of(context).colorScheme.primary,
            foregroundColor: Theme.of(context).colorScheme.onPrimary,
            padding: const EdgeInsets.symmetric(horizontal: 24, vertical: 12),
          ),
          child: const Text('淇濆瓨'),
        ),
      ],
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\character_collection\adjustable_region_painter.dart
-----------------------------------
import 'package:flutter/material.dart';

import '../../../domain/models/character/character_region.dart';
import '../../../utils/coordinate_transformer.dart';

/// 鍙皟鏁村尯鍩熺粯鍒跺櫒
class AdjustableRegionPainter extends CustomPainter {
  final CharacterRegion region;
  final CoordinateTransformer transformer;
  final bool isActive;
  final bool isAdjusting;
  final int? activeHandleIndex;
  final double currentRotation;
  final List<Offset>? guideLines;
  final Rect? viewportRect;

  AdjustableRegionPainter({
    required this.region,
    required this.transformer,
    this.isActive = false,
    this.isAdjusting = false,
    this.activeHandleIndex,
    this.currentRotation = 0.0,
    this.guideLines,
    this.viewportRect,
  });

  @override
  void paint(Canvas canvas, Size size) {
    if (!isActive || viewportRect == null) return;

    final center = viewportRect!.center;

    // 缁樺埗閫夊尯濉厖
    final fillPaint = Paint()
      ..color = Colors.blue.withOpacity(0.1)
      ..style = PaintingStyle.fill;

    // 淇濆瓨鐢诲竷鐘舵€佺敤浜庢棆杞?
    canvas.save();

    // 搴旂敤鏃嬭浆鍙樻崲
    if (currentRotation != 0) {
      canvas.translate(center.dx, center.dy);
      canvas.rotate(currentRotation);
      canvas.translate(-center.dx, -center.dy);
    }

    // 缁樺埗閫夊尯濉厖
    canvas.drawRect(viewportRect!, fillPaint);

    // 缁樺埗閫夊尯杈规
    final borderPaint = Paint()
      ..color = Colors.blue
      ..style = PaintingStyle.stroke
      ..strokeWidth = isAdjusting ? 2.0 : 1.5;
    canvas.drawRect(viewportRect!, borderPaint);

    // 缁樺埗璋冩暣鎵嬫焺 (draw with rotation applied)
    _drawHandles(canvas, viewportRect!);

    // 缁樺埗鏃嬭浆鎺т欢 (draw with rotation applied)
    _drawRotationControl(canvas, viewportRect!);

    // 鎭㈠鐢诲竷鐘舵€侊紝鍚庣画缁樺埗涓嶄細鍙楀埌鏃嬭浆褰卞搷
    canvas.restore();

    // 缁樺埗涓嶉殢鏃嬭浆鐨勫厓绱?
    // 缁樺埗杈呭姪绾?
    if (guideLines != null) {
      _drawGuideLines(canvas);
    }
  }

  @override
  bool shouldRepaint(AdjustableRegionPainter oldDelegate) {
    return region != oldDelegate.region ||
        isActive != oldDelegate.isActive ||
        isAdjusting != oldDelegate.isAdjusting ||
        activeHandleIndex != oldDelegate.activeHandleIndex ||
        currentRotation != oldDelegate.currentRotation ||
        guideLines != oldDelegate.guideLines ||
        viewportRect != oldDelegate.viewportRect;
  }

  void _drawGuideLines(Canvas canvas) {
    if (guideLines == null || guideLines!.length < 2) return;

    final guidePaint = Paint()
      ..color = Colors.red.withOpacity(0.5)
      ..style = PaintingStyle.stroke
      ..strokeWidth = 1.0;

    for (var i = 0; i < guideLines!.length - 1; i += 2) {
      canvas.drawLine(guideLines![i], guideLines![i + 1], guidePaint);
    }
  }

  void _drawHandles(Canvas canvas, Rect rect) {
    final handles = [
      rect.topLeft,
      rect.topCenter,
      rect.topRight,
      rect.centerRight,
      rect.bottomRight,
      rect.bottomCenter,
      rect.bottomLeft,
      rect.centerLeft,
    ];

    final handlePaint = Paint()
      ..color = Colors.white
      ..style = PaintingStyle.fill;

    final handleBorderPaint = Paint()
      ..color = Colors.blue
      ..style = PaintingStyle.stroke
      ..strokeWidth = 1.0;

    final activeHandlePaint = Paint()
      ..color = Colors.blue.shade100
      ..style = PaintingStyle.fill;

    for (var i = 0; i < handles.length; i++) {
      final isActive = i == activeHandleIndex;

      // // 淇濆瓨褰撳墠鐢诲竷鐘舵€?
      // canvas.save();

      // // 鍦ㄦ墜鏌勪綅缃簲鐢ㄦ棆杞?
      // canvas.translate(handles[i].dx, handles[i].dy);
      // canvas.rotate(currentRotation);

      // 缁樺埗鎵嬫焺
      final handleRect = Rect.fromCenter(
        // center: Offset.zero, // 鍥犱负宸茬粡骞崇Щ鍒版墜鏌勪綅缃紝鎵€浠ヤ娇鐢ㄥ師鐐?
        center: handles[i],
        width: isActive ? 12.0 : 10.0,
        height: isActive ? 12.0 : 10.0,
      );

      canvas.drawRect(handleRect, isActive ? activeHandlePaint : handlePaint);
      canvas.drawRect(handleRect, handleBorderPaint);

      // 鎭㈠鐢诲竷鐘舵€?
      // canvas.restore();
    }
  }

  void _drawRotationControl(Canvas canvas, Rect rect) {
    final rotationPoint = rect.topCenter.translate(0, -30);
    final center = rect.center;

    // 缁樺埗杩炴帴绾?
    final linePaint = Paint()
      ..color = Colors.blue
      ..style = PaintingStyle.stroke
      ..strokeWidth = 1.0
      ..strokeCap = StrokeCap.round;

    // 缁樺埗铏氱嚎
    const dashWidth = 5.0;
    const dashSpace = 5.0;
    final path = Path();
    var distance = 0.0;
    final totalDistance = (rotationPoint - center).distance;
    final direction = (rotationPoint - center) / totalDistance;

    while (distance < totalDistance) {
      path.moveTo(
        center.dx + direction.dx * distance,
        center.dy + direction.dy * distance,
      );
      path.lineTo(
        center.dx + direction.dx * (distance + dashWidth),
        center.dy + direction.dy * (distance + dashWidth),
      );
      distance += dashWidth + dashSpace;
    }

    canvas.drawPath(path, linePaint);

    // 缁樺埗鏃嬭浆鎺у埗鐐?
    final controlPaint = Paint()
      ..color = Colors.white
      ..style = PaintingStyle.fill;

    final controlBorderPaint = Paint()
      ..color = Colors.blue
      ..style = PaintingStyle.stroke
      ..strokeWidth = 1.0;

    canvas.drawCircle(rotationPoint, 8.0, controlPaint);
    canvas.drawCircle(rotationPoint, 8.0, controlBorderPaint);

    // 缁樺埗鏃嬭浆绠ご
    final arrowPaint = Paint()
      ..color = Colors.blue
      ..style = PaintingStyle.stroke
      ..strokeWidth = 2.0
      ..strokeCap = StrokeCap.round;

    final arrowPath = Path()
      ..moveTo(rotationPoint.dx - 4, rotationPoint.dy)
      ..lineTo(rotationPoint.dx + 4, rotationPoint.dy)
      ..moveTo(rotationPoint.dx + 2, rotationPoint.dy - 2)
      ..lineTo(rotationPoint.dx + 4, rotationPoint.dy)
      ..lineTo(rotationPoint.dx + 2, rotationPoint.dy + 2);

    canvas.drawPath(arrowPath, arrowPaint);
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\character_collection\batch_action_bar.dart
-----------------------------------
import 'package:flutter/material.dart';

class BatchActionBar extends StatelessWidget {
  final int selectedCount;
  final VoidCallback onExport;
  final VoidCallback onDelete;
  final VoidCallback onCancel;

  const BatchActionBar({
    Key? key,
    required this.selectedCount,
    required this.onExport,
    required this.onDelete,
    required this.onCancel,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 8.0),
      decoration: BoxDecoration(
        color: theme.colorScheme.surfaceContainerHighest,
        border: Border(
          bottom: BorderSide(color: theme.dividerColor),
        ),
      ),
      child: Row(
        children: [
          // 閫変腑璁℃暟
          Icon(
            Icons.check_circle,
            color: theme.colorScheme.primary,
            size: 20,
          ),
          const SizedBox(width: 8),
          Text(
            '宸查€夋嫨 $selectedCount 涓瓧绗?,
            style: theme.textTheme.bodyLarge?.copyWith(
              fontWeight: FontWeight.bold,
            ),
          ),

          const Spacer(),

          // 瀵煎嚭鎸夐挳
          _BatchActionButton(
            icon: Icons.download,
            label: '瀵煎嚭',
            onPressed: onExport,
          ),

          const SizedBox(width: 8),

          // 鍒犻櫎鎸夐挳
          _BatchActionButton(
            icon: Icons.delete,
            label: '鍒犻櫎',
            color: Colors.red,
            onPressed: () {
              _showDeleteConfirmation(context);
            },
          ),

          const SizedBox(width: 16),

          // 鍙栨秷閫夋嫨鎸夐挳
          OutlinedButton(
            onPressed: onCancel,
            style: OutlinedButton.styleFrom(
              padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
            ),
            child: const Text('鍙栨秷閫夋嫨'),
          ),
        ],
      ),
    );
  }

  void _showDeleteConfirmation(BuildContext context) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('鍒犻櫎纭'),
        content: Text('纭畾瑕佸垹闄よ繖 $selectedCount 涓瓧绗﹀悧锛熸鎿嶄綔涓嶅彲鎭㈠銆?),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(),
            child: const Text('鍙栨秷'),
          ),
          ElevatedButton(
            onPressed: () {
              Navigator.of(context).pop();
              onDelete();
            },
            style: ElevatedButton.styleFrom(
              backgroundColor: Colors.red,
              foregroundColor: Colors.white,
            ),
            child: const Text('鍒犻櫎'),
          ),
        ],
      ),
    );
  }
}

class _BatchActionButton extends StatelessWidget {
  final IconData icon;
  final String label;
  final Color? color;
  final VoidCallback onPressed;

  const _BatchActionButton({
    Key? key,
    required this.icon,
    required this.label,
    this.color,
    required this.onPressed,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return TextButton.icon(
      onPressed: onPressed,
      icon: Icon(
        icon,
        size: 18,
        color: color,
      ),
      label: Text(
        label,
        style: TextStyle(color: color),
      ),
      style: TextButton.styleFrom(
        padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
      ),
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\character_collection\character_grid_view.dart
-----------------------------------
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../providers/character/character_grid_provider.dart';
import 'batch_action_bar.dart';
import 'character_tile.dart';
import 'pagination_control.dart';
import 'search_filter_bar.dart';

class CharacterGridView extends ConsumerWidget {
  final String workId;
  final Function(String) onCharacterSelected;

  const CharacterGridView({
    Key? key,
    required this.workId,
    required this.onCharacterSelected,
  }) : super(key: key);

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final gridState = ref.watch(characterGridProvider);

    // 鏄剧ず绌虹姸鎬?
    if (gridState.characters.isEmpty) {
      return const EmptyState(
        icon: Icons.sentiment_satisfied_alt,
        title: '杩樻病鏈夋敹闆嗕换浣曞瓧绗?,
        message: '浣跨敤宸︿晶鐨勬閫夊伐鍏蜂粠鍥剧墖涓彁鍙栧瓧绗?,
      );
    }

    return Column(
      children: [
        // 鎼滅储绛涢€夋爮
        SearchFilterBar(
          searchTerm: gridState.searchTerm,
          filterType: gridState.filterType,
          onSearchChanged: (term) =>
              ref.read(characterGridProvider.notifier).updateSearch(term),
          onFilterChanged: (type) =>
              ref.read(characterGridProvider.notifier).updateFilter(type),
        ),

        // 鎵归噺鎿嶄綔鏍忥紙鏉′欢鏄剧ず锛?
        if (gridState.selectedIds.isNotEmpty)
          BatchActionBar(
            selectedCount: gridState.selectedIds.length,
            onExport: () =>
                ref.read(characterGridProvider.notifier).exportSelected(),
            onDelete: () =>
                ref.read(characterGridProvider.notifier).deleteSelected(),
            onCancel: () =>
                ref.read(characterGridProvider.notifier).clearSelection(),
          ),

        // 瀛楃缃戞牸
        Expanded(
          child: GridView.builder(
            padding: const EdgeInsets.all(16.0),
            gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
              crossAxisCount: 4,
              childAspectRatio: 1,
              crossAxisSpacing: 12,
              mainAxisSpacing: 12,
            ),
            itemCount: gridState.filteredCharacters.length,
            itemBuilder: (context, index) {
              final character = gridState.filteredCharacters[index];
              return CharacterTile(
                character: character,
                isSelected: gridState.selectedIds.contains(character.id),
                onTap: () => onCharacterSelected(character.id),
                onLongPress: () => ref
                    .read(characterGridProvider.notifier)
                    .toggleSelection(character.id),
              );
            },
          ),
        ),

        // 鍒嗛〉鎺у埗
        if (gridState.totalPages > 1)
          PaginationControl(
            currentPage: gridState.currentPage,
            totalPages: gridState.totalPages,
            onPageChanged: (page) =>
                ref.read(characterGridProvider.notifier).setPage(page),
          ),
      ],
    );
  }
}

// 绌虹姸鎬佺粍浠?
class EmptyState extends StatelessWidget {
  final IconData icon;
  final String title;
  final String message;
  final String? actionLabel;
  final VoidCallback? onAction;

  const EmptyState({
    Key? key,
    required this.icon,
    required this.title,
    required this.message,
    this.actionLabel,
    this.onAction,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Icon(
            icon,
            size: 64,
            color: Colors.grey[400],
          ),
          const SizedBox(height: 16),
          Text(
            title,
            style: Theme.of(context).textTheme.titleLarge,
          ),
          const SizedBox(height: 8),
          Text(
            message,
            style: Theme.of(context).textTheme.bodyMedium,
            textAlign: TextAlign.center,
          ),
          if (actionLabel != null && onAction != null) ...[
            const SizedBox(height: 24),
            ElevatedButton(
              onPressed: onAction,
              child: Text(actionLabel!),
            ),
          ],
        ],
      ),
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\character_collection\character_input.dart
-----------------------------------
import 'package:flutter/material.dart';

class CharacterInput extends StatefulWidget {
  final String value;
  final ValueChanged<String> onChanged;

  const CharacterInput({
    Key? key,
    required this.value,
    required this.onChanged,
  }) : super(key: key);

  @override
  _CharacterInputState createState() => _CharacterInputState();
}

class _CharacterInputState extends State<CharacterInput> {
  late TextEditingController _controller;

  @override
  void initState() {
    super.initState();
    _controller = TextEditingController(text: widget.value);
  }

  @override
  void didUpdateWidget(CharacterInput oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (widget.value != _controller.text) {
      _controller.text = widget.value;
      _controller.selection = TextSelection.fromPosition(
          TextPosition(offset: _controller.text.length));
    }
  }

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
      decoration: BoxDecoration(
        color: Theme.of(context).colorScheme.surface,
        borderRadius: BorderRadius.circular(8),
        border: Border.all(color: Theme.of(context).dividerColor),
      ),
      child: TextField(
        controller: _controller,
        decoration: const InputDecoration(
          border: InputBorder.none,
          hintText: '璇疯緭鍏ュ瓧绗?,
          isDense: true,
          contentPadding: EdgeInsets.zero,
        ),
        style: Theme.of(context).textTheme.bodyLarge,
        onChanged: widget.onChanged,
      ),
    );
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\character_collection\character_tile.dart
-----------------------------------
import 'dart:io';

import 'package:flutter/material.dart';

import '../../viewmodels/states/character_grid_state.dart';

class CharacterTile extends StatelessWidget {
  final CharacterViewModel character;
  final bool isSelected;
  final VoidCallback onTap;
  final VoidCallback onLongPress;

  const CharacterTile({
    Key? key,
    required this.character,
    required this.isSelected,
    required this.onTap,
    required this.onLongPress,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return InkWell(
      onTap: onTap,
      onLongPress: onLongPress,
      borderRadius: BorderRadius.circular(8.0),
      child: Container(
        decoration: BoxDecoration(
          border: Border.all(
            color: isSelected ? theme.colorScheme.primary : theme.dividerColor,
            width: isSelected ? 2.0 : 1.0,
          ),
          borderRadius: BorderRadius.circular(8.0),
          color: isSelected ? theme.colorScheme.primary.withOpacity(0.1) : null,
        ),
        child: Stack(
          fit: StackFit.expand,
          children: [
            Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                // 瀛楃鍥剧墖
                Expanded(
                  flex: 5,
                  child: Padding(
                    padding: const EdgeInsets.all(8.0),
                    child: _buildImage(context),
                  ),
                ),

                // 瀛楃淇℃伅
                Container(
                  width: double.infinity,
                  padding: const EdgeInsets.symmetric(vertical: 6.0),
                  decoration: BoxDecoration(
                    color: theme.colorScheme.surfaceContainerHighest,
                    borderRadius: const BorderRadius.only(
                      bottomLeft: Radius.circular(7.0),
                      bottomRight: Radius.circular(7.0),
                    ),
                  ),
                  child: Text(
                    character.character.isEmpty ? '鏃犲瓧绗? : character.character,
                    textAlign: TextAlign.center,
                    style: theme.textTheme.titleMedium?.copyWith(
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                ),
              ],
            ),

            // 閫変腑鎸囩ず鍣?
            if (isSelected)
              Positioned(
                top: 4,
                right: 4,
                child: Container(
                  padding: const EdgeInsets.all(2),
                  decoration: BoxDecoration(
                    color: theme.colorScheme.primary,
                    shape: BoxShape.circle,
                  ),
                  child: Icon(
                    Icons.check,
                    size: 16,
                    color: theme.colorScheme.onPrimary,
                  ),
                ),
              ),

            // 鏀惰棌鎸囩ず鍣?
            if (character.isFavorite)
              const Positioned(
                top: 4,
                left: 4,
                child: Icon(
                  Icons.favorite,
                  size: 16,
                  color: Colors.red,
                ),
              ),
          ],
        ),
      ),
    );
  }

  Widget _buildImage(BuildContext context) {
    // 灏濊瘯鍔犺浇缂╃暐鍥?
    try {
      return Image.file(
        File(character.thumbnailPath),
        fit: BoxFit.contain,
        errorBuilder: (context, error, stackTrace) {
          return _buildPlaceholder(context);
        },
      );
    } catch (e) {
      return _buildPlaceholder(context);
    }
  }

  Widget _buildPlaceholder(BuildContext context) {
    return Container(
      decoration: BoxDecoration(
        color: Colors.grey[200],
        borderRadius: BorderRadius.circular(4.0),
      ),
      child: Center(
        child: Icon(
          Icons.image_not_supported,
          size: 24,
          color: Colors.grey[400],
        ),
      ),
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\character_collection\debug_overlay.dart
-----------------------------------
import 'package:flutter/material.dart';

import '../../../domain/models/character/character_region.dart';
import '../../../utils/coordinate_transformer.dart';

/// 璋冭瘯瑕嗙洊灞?
/// 鐢ㄤ簬鍙鍖栨樉绀哄潗鏍囩郴缁熴€佺綉鏍煎拰璋冭瘯淇℃伅
class DebugOverlay extends CustomPainter {
  final CoordinateTransformer transformer;
  final bool showGrid;
  final bool showCoordinates;
  final bool showDetails;
  final bool showImageInfo;
  final bool showRegionCenter;
  final double gridSize;
  final double textScale;
  final List<CharacterRegion> regions;
  final Set<String> selectedIds;
  final double opacity;
  final Rect? lastCropRect;

  const DebugOverlay({
    required this.transformer,
    this.showGrid = true,
    this.showCoordinates = true,
    this.showDetails = true,
    this.showImageInfo = true,
    this.showRegionCenter = true,
    this.gridSize = 50.0,
    this.textScale = 1.0,
    this.regions = const [],
    this.selectedIds = const {},
    this.opacity = 0.5,
    this.lastCropRect,
  });

  @override
  void paint(Canvas canvas, Size size) {
    try {
      _drawImageBounds(canvas);
      if (showGrid) _drawGrid(canvas);
      if (showCoordinates) _drawAxis(canvas, size);
      if (showDetails) {
        _drawCoordinateSystems(canvas, size);
        for (final region in regions) {
          _drawRegionInfo(canvas, region);
        }
      }
      if (lastCropRect != null) _drawLastCropRect(canvas);
      if (showImageInfo) _drawViewInfo(canvas, size);
    } catch (e) {
      _drawError(canvas, e.toString());
    }
  }

  @override
  bool shouldRepaint(covariant DebugOverlay oldDelegate) {
    return transformer != oldDelegate.transformer ||
        showGrid != oldDelegate.showGrid ||
        showCoordinates != oldDelegate.showCoordinates ||
        showDetails != oldDelegate.showDetails ||
        showImageInfo != oldDelegate.showImageInfo ||
        showRegionCenter != oldDelegate.showRegionCenter ||
        gridSize != oldDelegate.gridSize ||
        textScale != oldDelegate.textScale ||
        regions != oldDelegate.regions ||
        selectedIds != oldDelegate.selectedIds ||
        opacity != oldDelegate.opacity ||
        lastCropRect != oldDelegate.lastCropRect;
  }

  void _drawAxis(Canvas canvas, Size size) {
    final displayRect = transformer.displayRect;
    final axisColor = Colors.red.withOpacity(opacity);

    // X杞达紙浠庡師鐐瑰悜鍙筹級
    canvas.drawLine(
      Offset(displayRect.left, displayRect.top),
      Offset(displayRect.right, displayRect.top),
      Paint()
        ..color = axisColor
        ..strokeWidth = 1.0,
    );

    // Y杞达紙浠庡師鐐瑰悜涓嬶級
    canvas.drawLine(
      Offset(displayRect.left, displayRect.top),
      Offset(displayRect.left, displayRect.bottom),
      Paint()
        ..color = axisColor
        ..strokeWidth = 1.0,
    );

    // 鍘熺偣鎸囩ず
    canvas.drawCircle(
      Offset(displayRect.left, displayRect.top),
      4,
      Paint()..color = axisColor,
    );

    if (showCoordinates) {
      _drawText(
        canvas,
        'O',
        Offset(displayRect.left - 15, displayRect.top - 15),
        color: axisColor,
        fontSize: 12 * textScale,
      );

      _drawText(
        canvas,
        'X 鈫?,
        Offset(displayRect.right + 5, displayRect.top),
        color: axisColor,
        fontSize: 12 * textScale,
      );

      _drawText(
        canvas,
        'Y 鈫?,
        Offset(displayRect.left - 20, displayRect.bottom),
        color: axisColor,
        fontSize: 12 * textScale,
      );
    }
  }

  void _drawCoordinateSystems(Canvas canvas, Size size) {
    final rectWidth = 160.0 * textScale;
    final rectHeight = 180.0 * textScale;
    final rect = Rect.fromLTWH(size.width - rectWidth - 10,
        size.height - rectHeight - 10, rectWidth, rectHeight);

    // 鑳屾櫙
    canvas.drawRect(
      rect,
      Paint()..color = Colors.white.withOpacity(0.85),
    );

    // 杈规
    canvas.drawRect(
      rect,
      Paint()
        ..color = Colors.black.withOpacity(0.5)
        ..style = PaintingStyle.stroke
        ..strokeWidth = 1.0,
    );

    final padding = 8.0 * textScale;
    _drawText(
      canvas,
      '鍧愭爣绯荤粺璇存槑 (宸︿笂瑙掍负鍘熺偣)锛歕n'
      '1. 瑙嗗彛鍧愭爣锛氱浉瀵逛簬缁勪欢宸︿笂瑙抃n'
      '2. 瑙嗗浘鍧愭爣锛氱浉瀵逛簬鍥惧儚宸︿笂瑙抃n'
      '\n'
      '鍧愭爣杞崲锛歕n'
      '瑙嗗彛 鈫?瑙嗗浘: (p - o) / s\n'
      '瑙嗗浘 鈫?瑙嗗彛: p * s + o\n'
      '鍏朵腑: p=鐐? o=鍋忕Щ, s=缂╂斁',
      Offset(rect.left + padding, rect.top + padding),
      color: Colors.black.withOpacity(0.8),
      fontSize: 11 * textScale,
      bgColor: Colors.white.withOpacity(0.8),
      padding: EdgeInsets.all(padding),
    );
  }

  void _drawError(Canvas canvas, String error) {
    _drawText(
      canvas,
      '缁樺埗閿欒: $error',
      const Offset(10, 10),
      color: Colors.red,
      fontSize: 14 * textScale,
      bgColor: Colors.white.withOpacity(0.8),
      padding: const EdgeInsets.all(4),
    );
  }

  void _drawGrid(Canvas canvas) {
    final paint = Paint()
      ..color = Colors.grey.withOpacity(opacity * 0.4)
      ..style = PaintingStyle.stroke
      ..strokeWidth = 0.5;

    final lines = transformer.calculateGridLines(gridSize);
    for (int i = 0; i < lines.length; i += 2) {
      canvas.drawLine(lines[i], lines[i + 1], paint);
    }
  }

  void _drawImageBounds(Canvas canvas) {
    final paint = Paint()
      ..color = Colors.blue.withOpacity(opacity)
      ..style = PaintingStyle.stroke
      ..strokeWidth = 1.0;

    final displayRect = transformer.displayRect;
    canvas.drawRect(displayRect, paint);
  }

  void _drawLastCropRect(Canvas canvas) {
    if (lastCropRect == null) return;
    final viewportRect = transformer.imageRectToViewportRect(lastCropRect!);
    canvas.drawRect(
      viewportRect,
      Paint()
        ..color = Colors.red.withOpacity(opacity * 0.7)
        ..style = PaintingStyle.stroke
        ..strokeWidth = 2.0,
    );
  }

  void _drawRegionInfo(Canvas canvas, CharacterRegion region) {
    final isSelected = selectedIds.contains(region.id);
    final viewportRect = transformer.imageRectToViewportRect(region.rect);
    canvas.drawRect(
      viewportRect,
      Paint()
        ..color = (isSelected ? Colors.blue : Colors.green).withOpacity(opacity)
        ..style = PaintingStyle.stroke
        ..strokeWidth = 1.0,
    );
  }

  void _drawText(
    Canvas canvas,
    String text,
    Offset position, {
    Color color = Colors.black,
    double fontSize = 12,
    TextAlign alignment = TextAlign.left,
    Color? bgColor,
    EdgeInsets? padding,
  }) {
    final textPainter = TextPainter(
      text: TextSpan(
        text: text,
        style: TextStyle(
          color: color,
          fontSize: fontSize,
          shadows: bgColor == null
              ? [
                  Shadow(
                    offset: const Offset(1, 1),
                    blurRadius: 2,
                    color: Colors.white.withOpacity(opacity * 0.8),
                  ),
                ]
              : null,
        ),
      ),
      textDirection: TextDirection.ltr,
      textAlign: alignment,
    );

    textPainter.layout();

    switch (alignment) {
      case TextAlign.right:
        position = position.translate(-textPainter.width, -textPainter.height);
        break;
      case TextAlign.center:
        position = position.translate(-textPainter.width / 2, 0);
        break;
      default:
        break;
    }

    if (bgColor != null && padding != null) {
      final rect = Rect.fromLTWH(
        position.dx - padding.left,
        position.dy - padding.top,
        textPainter.width + padding.horizontal,
        textPainter.height + padding.vertical,
      );
      canvas.drawRect(
        rect,
        Paint()..color = bgColor,
      );
    }

    textPainter.paint(canvas, position);
  }

  void _drawViewInfo(Canvas canvas, Size size) {
    final scale = transformer.currentScale;
    final baseScale = transformer.baseScale;
    final offset = transformer.currentOffset;
    final imageSize = transformer.imageSize;
    final viewportSize = transformer.viewportSize;
    final displayRect = transformer.displayRect;

    final info = [
      '鍥惧儚淇℃伅',
      ' - 鍘熷灏哄: ${imageSize.width.toInt()}x${imageSize.height.toInt()}px',
      ' - 瑙嗗彛灏哄: ${viewportSize.width.toInt()}x${viewportSize.height.toInt()}px',
      ' - 鏄剧ず浣嶇疆: (${displayRect.left.toInt()},${displayRect.top.toInt()})',
      ' - 鏄剧ず灏哄: ${displayRect.width.toInt()}x${displayRect.height.toInt()}px',
      '缂╂斁姣斾緥',
      ' - 鍩虹姣斾緥: ${(baseScale * 100).toInt()}%',
      ' - 褰撳墠姣斾緥: ${(scale * 100).toInt()}%',
      ' - 瀹為檯鍋忕Щ: (${offset.dx.toStringAsFixed(2)}, ${offset.dy.toStringAsFixed(2)})',
      '閫変腑鍖哄煙',
      ' - 鍖哄煙鎬绘暟: ${regions.length}',
      ' - 閫変腑鏁伴噺: ${selectedIds.length}',
    ].join('\n');

    _drawText(
      canvas,
      info,
      const Offset(10, 10),
      color: Colors.black.withOpacity(opacity),
      fontSize: 10 * textScale,
      bgColor: Colors.white.withOpacity(0.8),
      padding: const EdgeInsets.all(4),
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\character_collection\debug_toolbar.dart
-----------------------------------
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../providers/debug/debug_options_provider.dart';

/// 璋冭瘯宸ュ叿鏍忕粍浠?
class DebugToolbar extends ConsumerWidget {
  const DebugToolbar({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final debugOptions = ref.watch(debugOptionsProvider);
    final theme = Theme.of(context);

    return Card(
      margin: EdgeInsets.zero,
      color: Colors.black87,
      child: SingleChildScrollView(
        child: Padding(
          padding: const EdgeInsets.all(8.0),
          child: IntrinsicWidth(
            child: Column(
              mainAxisSize: MainAxisSize.min,
              crossAxisAlignment: CrossAxisAlignment.stretch,
              children: [
                _buildHeader(theme),
                const Divider(color: Colors.white24),
                _buildToggles(debugOptions, ref),
                const Divider(color: Colors.white24),
                _buildAdjustments(debugOptions, ref),
                const Divider(color: Colors.white24),
                _buildFooter(ref),
              ],
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildAdjustments(DebugOptions options, WidgetRef ref) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.stretch,
      children: [
        _buildSlider(
          label: '缃戞牸澶у皬',
          value: options.gridSize,
          min: 20,
          max: 100,
          divisions: 8,
          onChanged: (value) =>
              ref.read(debugOptionsProvider.notifier).setGridSize(value),
        ),
        _buildSlider(
          label: '鏂囨湰缂╂斁',
          value: options.textScale,
          min: 0.5,
          max: 2.0,
          divisions: 6,
          onChanged: (value) =>
              ref.read(debugOptionsProvider.notifier).setTextScale(value),
        ),
        _buildSlider(
          label: '涓嶉€忔槑搴?,
          value: options.opacity,
          min: 0.1,
          max: 1.0,
          divisions: 9,
          onChanged: (value) =>
              ref.read(debugOptionsProvider.notifier).setOpacity(value),
        ),
      ],
    );
  }

  Widget _buildFooter(WidgetRef ref) {
    return Padding(
      padding: const EdgeInsets.only(top: 8),
      child: TextButton.icon(
        icon: const Icon(Icons.refresh, size: 16),
        label: const Text('閲嶇疆'),
        onPressed: () =>
            ref.read(debugOptionsProvider.notifier).resetToDefaults(),
        style: TextButton.styleFrom(
          foregroundColor: Colors.white70,
          padding: const EdgeInsets.symmetric(vertical: 8),
        ),
      ),
    );
  }

  Widget _buildHeader(ThemeData theme) {
    return Padding(
      padding: const EdgeInsets.only(bottom: 8),
      child: Row(
        children: [
          const Icon(
            Icons.bug_report,
            color: Colors.white70,
            size: 16,
          ),
          const SizedBox(width: 8),
          Text(
            '璋冭瘯宸ュ叿',
            style: theme.textTheme.titleSmall?.copyWith(
              color: Colors.white70,
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildSlider({
    required String label,
    required double value,
    required double min,
    required double max,
    required int divisions,
    required ValueChanged<double> onChanged,
  }) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.stretch,
      children: [
        Row(
          mainAxisAlignment: MainAxisAlignment.spaceBetween,
          children: [
            Text(
              label,
              style: const TextStyle(
                color: Colors.white70,
                fontSize: 12,
              ),
            ),
            Text(
              value.toStringAsFixed(1),
              style: const TextStyle(
                color: Colors.white70,
                fontSize: 12,
              ),
            ),
          ],
        ),
        const SizedBox(height: 4),
        SizedBox(
          height: 20,
          child: SliderTheme(
            data: SliderThemeData(
              trackHeight: 2,
              thumbShape: const RoundSliderThumbShape(enabledThumbRadius: 6),
              overlayShape: const RoundSliderOverlayShape(overlayRadius: 12),
              activeTrackColor: Colors.blue,
              inactiveTrackColor: Colors.white24,
              thumbColor: Colors.blue,
              overlayColor: Colors.blue.withOpacity(0.2),
            ),
            child: Slider(
              value: value,
              min: min,
              max: max,
              divisions: divisions,
              onChanged: onChanged,
            ),
          ),
        ),
        const SizedBox(height: 8),
      ],
    );
  }

  Widget _buildToggle({
    required String label,
    String? tooltip,
    required bool value,
    required ValueChanged<bool> onChanged,
  }) {
    final toggle = Row(
      mainAxisSize: MainAxisSize.min,
      children: [
        Text(
          label,
          style: const TextStyle(
            color: Colors.white70,
            fontSize: 12,
          ),
        ),
        const Spacer(),
        Switch(
          value: value,
          onChanged: onChanged,
          activeColor: Colors.blue,
          activeTrackColor: Colors.blue.withOpacity(0.5),
          materialTapTargetSize: MaterialTapTargetSize.shrinkWrap,
        ),
        if (tooltip != null)
          Tooltip(
            message: tooltip,
            child: const Icon(
              Icons.keyboard,
              color: Colors.white38,
              size: 14,
            ),
          ),
      ],
    );

    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 2),
      child: toggle,
    );
  }

  Widget _buildToggles(DebugOptions options, WidgetRef ref) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.stretch,
      children: [
        _buildToggle(
          label: '缃戞牸',
          tooltip: 'Alt+G',
          value: options.showGrid,
          onChanged: (value) =>
              ref.read(debugOptionsProvider.notifier).toggleGrid(),
        ),
        _buildToggle(
          label: '鍧愭爣',
          tooltip: 'Alt+C',
          value: options.showCoordinates,
          onChanged: (value) =>
              ref.read(debugOptionsProvider.notifier).toggleCoordinates(),
        ),
        _buildToggle(
          label: '璇︾粏淇℃伅',
          value: options.showDetails,
          onChanged: (value) =>
              ref.read(debugOptionsProvider.notifier).toggleDetails(),
        ),
        _buildToggle(
          label: '鍥惧儚淇℃伅',
          value: options.showImageInfo,
          onChanged: (value) =>
              ref.read(debugOptionsProvider.notifier).toggleImageInfo(),
        ),
        _buildToggle(
          label: '鏃ュ織',
          tooltip: 'Alt+L',
          value: options.enableLogging,
          onChanged: (value) =>
              ref.read(debugOptionsProvider.notifier).toggleLogging(),
        ),
      ],
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\character_collection\delete_confirmation_dialog.dart
-----------------------------------
import 'package:flutter/material.dart';

/// 鍒犻櫎纭瀵硅瘽妗?
/// 鐢ㄤ簬鍦ㄥ垹闄ゅ尯鍩熷墠纭鐢ㄦ埛鎰忓浘
class DeleteConfirmationDialog extends StatelessWidget {
  final int count;
  final bool isBatch;

  const DeleteConfirmationDialog({
    Key? key,
    required this.count,
    this.isBatch = false,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    final title = isBatch ? '纭鍒犻櫎${count}涓凡淇濆瓨鐨勯€夊尯锛? : '纭鍒犻櫎宸蹭繚瀛樼殑閫夊尯锛?;

    final content =
        isBatch ? '鍗冲皢鍒犻櫎${count}涓凡淇濆瓨鐨勯€夊尯锛屾鎿嶄綔涓嶅彲鎾ら攢銆? : '鍗冲皢鍒犻櫎褰撳墠閫変腑鐨勫凡淇濆瓨閫夊尯锛屾鎿嶄綔涓嶅彲鎾ら攢銆?;

    return AlertDialog(
      title: Text(title),
      content: Text(content),
      actions: [
        TextButton(
          onPressed: () => Navigator.of(context).pop(false),
          child: const Text('鍙栨秷'),
        ),
        TextButton(
          onPressed: () => Navigator.of(context).pop(true),
          style: TextButton.styleFrom(
            foregroundColor: Colors.red,
          ),
          child: const Text('鍒犻櫎'),
        ),
      ],
    );
  }

  /// 鏄剧ず纭瀵硅瘽妗嗗苟杩斿洖鐢ㄦ埛閫夋嫨
  /// 杩斿洖true琛ㄧず鐢ㄦ埛纭鍒犻櫎锛宖alse琛ㄧず鍙栨秷
  static Future<bool> show(BuildContext context,
      {int count = 1, bool isBatch = false}) async {
    final result = await showDialog<bool>(
      context: context,
      builder: (context) => DeleteConfirmationDialog(
        count: count,
        isBatch: isBatch,
      ),
    );

    return result ?? false;
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\character_collection\edit_toolbar.dart
-----------------------------------
import 'package:flutter/material.dart';

class EditToolbar extends StatelessWidget {
  final bool isInverted;
  final bool showOutline;
  final bool isErasing;
  final bool canUndo;
  final bool canRedo;
  final ValueChanged<bool> onInvertToggled;
  final ValueChanged<bool> onOutlineToggled;
  final ValueChanged<bool> onEraseToggled;
  final VoidCallback onUndo;
  final VoidCallback onRedo;

  const EditToolbar({
    Key? key,
    required this.isInverted,
    required this.showOutline,
    required this.isErasing,
    required this.canUndo,
    required this.canRedo,
    required this.onInvertToggled,
    required this.onOutlineToggled,
    required this.onEraseToggled,
    required this.onUndo,
    required this.onRedo,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
      decoration: BoxDecoration(
        color: theme.colorScheme.surface,
        borderRadius: BorderRadius.circular(8),
        border: Border.all(color: theme.dividerColor),
      ),
      child: Row(
        children: [
          // 鍙嶈浆寮€鍏?
          _ToolbarToggleButton(
            icon: Icons.invert_colors,
            tooltip: '鍙嶈浆棰滆壊',
            isSelected: isInverted,
            onPressed: () => onInvertToggled(!isInverted),
          ),

          // 杞粨寮€鍏?
          _ToolbarToggleButton(
            icon: Icons.format_shapes,
            tooltip: '鏄剧ず杞粨',
            isSelected: showOutline,
            onPressed: () => onOutlineToggled(!showOutline),
          ),

          // 鎿﹂櫎寮€鍏?
          _ToolbarToggleButton(
            icon: Icons.auto_fix_high,
            tooltip: '鎿﹂櫎宸ュ叿',
            isSelected: isErasing,
            onPressed: () => onEraseToggled(!isErasing),
          ),

          const Spacer(),

          // 鎾ら攢鎸夐挳
          IconButton(
            icon: const Icon(Icons.undo),
            tooltip: '鎾ら攢',
            onPressed: canUndo ? onUndo : null,
          ),

          // 閲嶅仛鎸夐挳
          IconButton(
            icon: const Icon(Icons.redo),
            tooltip: '閲嶅仛',
            onPressed: canRedo ? onRedo : null,
          ),
        ],
      ),
    );
  }
}

class _ToolbarToggleButton extends StatelessWidget {
  final IconData icon;
  final String tooltip;
  final bool isSelected;
  final VoidCallback onPressed;

  const _ToolbarToggleButton({
    Key? key,
    required this.icon,
    required this.tooltip,
    required this.isSelected,
    required this.onPressed,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Tooltip(
      message: tooltip,
      child: Material(
        color: isSelected
            ? theme.colorScheme.primaryContainer
            : Colors.transparent,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(4),
        ),
        child: InkWell(
          onTap: onPressed,
          borderRadius: BorderRadius.circular(4),
          child: Container(
            padding: const EdgeInsets.all(8),
            child: Icon(
              icon,
              color: isSelected ? theme.colorScheme.primary : null,
            ),
          ),
        ),
      ),
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\character_collection\filter_type.dart
-----------------------------------
enum FilterType { all, recent, modified, favorite, byStroke, custom }



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\character_collection\image_preview_panel.dart
-----------------------------------
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../providers/character/tool_mode_provider.dart';
import '../../providers/character/work_image_provider.dart';
import 'image_view.dart';
import 'preview_toolbar.dart';
import 'thumbnail_list.dart';

class ImagePreviewPanel extends ConsumerWidget {
  const ImagePreviewPanel({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final imageState = ref.watch(workImageProvider);
    final toolMode = ref.watch(toolModeProvider);

    return Column(
      children: [
        // 宸ュ叿鏍?
        const PreviewToolbar(),
        // 涓诲浘鍍忓尯鍩?
        Expanded(
          child: Stack(
            fit: StackFit.expand,
            children: [
              // 鍥惧儚瑙嗗浘
              const ImageView(),

              // 鍔犺浇鎸囩ず鍣?
              if (imageState.loading)
                Center(
                  child: Container(
                    padding: const EdgeInsets.all(16),
                    decoration: BoxDecoration(
                      color: Colors.black54,
                      borderRadius: BorderRadius.circular(8),
                    ),
                    child: const Column(
                      mainAxisSize: MainAxisSize.min,
                      children: [
                        CircularProgressIndicator(color: Colors.white),
                        SizedBox(height: 16),
                        Text(
                          '鍔犺浇鍥惧儚涓?..',
                          style: TextStyle(color: Colors.white),
                        ),
                      ],
                    ),
                  ),
                ),

              // 閿欒鎻愮ず
              if (imageState.error != null)
                Center(
                  child: Container(
                    padding: const EdgeInsets.all(16),
                    decoration: BoxDecoration(
                      color: Colors.red.shade900.withOpacity(0.8),
                      borderRadius: BorderRadius.circular(8),
                    ),
                    child: Column(
                      mainAxisSize: MainAxisSize.min,
                      children: [
                        const Icon(Icons.error_outline,
                            color: Colors.white, size: 48),
                        const SizedBox(height: 16),
                        Text(
                          '鍔犺浇鍥惧儚澶辫触: ${imageState.error}',
                          style: const TextStyle(color: Colors.white),
                          textAlign: TextAlign.center,
                          overflow: TextOverflow.ellipsis,
                          maxLines: 3,
                        ),
                        const SizedBox(height: 16),
                        ElevatedButton(
                          onPressed: () =>
                              ref.read(workImageProvider.notifier).reload(),
                          child: const Text('閲嶈瘯'),
                        ),
                      ],
                    ),
                  ),
                ),
            ],
          ),
        ),

        // 缂╃暐鍥惧垪琛?
        if (imageState.pageIds.length > 1) const ThumbnailList(),
      ],
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\character_collection\image_view.dart
-----------------------------------
import 'dart:async';
import 'dart:math' as math;

import 'package:flutter/gestures.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:vector_math/vector_math_64.dart' show Vector3;

import '../../../domain/models/character/character_region.dart';
import '../../../infrastructure/logging/logger.dart';
import '../../../utils/coordinate_transformer.dart';
import '../../providers/character/character_collection_provider.dart';
import '../../providers/character/tool_mode_provider.dart';
import '../../providers/character/work_image_provider.dart';
import '../../providers/debug/debug_options_provider.dart';
import 'adjustable_region_painter.dart';
import 'debug_overlay.dart';
import 'delete_confirmation_dialog.dart';
import 'regions_painter.dart';
import 'selection_painters.dart';
import 'selection_toolbar.dart';

/// 鍥惧儚鏌ョ湅缁勪欢
class ImageView extends ConsumerStatefulWidget {
  const ImageView({Key? key}) : super(key: key);

  @override
  ConsumerState<ImageView> createState() => _ImageViewState();
}

class _DebugModeToggle extends ConsumerWidget {
  final bool enabled;

  const _DebugModeToggle({
    required this.enabled,
  });

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return FloatingActionButton.small(
      onPressed: () =>
          ref.read(debugOptionsProvider.notifier).toggleDebugMode(),
      tooltip: 'Alt+D',
      backgroundColor: enabled ? Colors.blue : Colors.black87,
      child: Icon(
        enabled ? Icons.bug_report : Icons.bug_report_outlined,
        color: Colors.white,
        size: 20,
      ),
    );
  }
}

class _ImageViewState extends ConsumerState<ImageView>
    with SingleTickerProviderStateMixin {
  final TransformationController _transformationController =
      TransformationController();
  final FocusNode _focusNode = FocusNode();
  CoordinateTransformer? _transformer;

  late final AnimationController _debugPanelController;
  late final Animation<double> _debugPanelAnimation;
  AnimationController? _animationController;
  Timer? _transformationDebouncer;
  String? _lastImageId;
  bool _isFirstLoad = true;

  bool _isInSelectionMode = false;

  bool _isPanning = false;
  bool _isZoomed = false;
  // 閫夊尯鐩稿叧
  Offset? _selectionStart;

  Offset? _selectionCurrent;
  Rect? _lastCompletedSelection;
  bool _hasCompletedSelection = false;
  // 璋冩暣鐩稿叧
  bool _isAdjusting = false;

  String? _adjustingRegionId;
  int? _activeHandleIndex;
  List<Offset>? _guideLines;
  CharacterRegion? _originalRegion;
  Rect? _adjustingRect;
  String? _hoveredRegionId;
  bool _isRotating = false;
  double _rotationStartAngle = 0.0;
  double _currentRotation = 0.0;
  Offset? _rotationCenter;
  bool _mounted = true;

  Offset? _lastPanPosition;

  // 鎮仠鐨勬帶鍒剁偣绱㈠紩
  int? _hoveredHandleIndex;

  @override
  Widget build(BuildContext context) {
    final imageState = ref.watch(workImageProvider);
    final toolMode = ref.watch(toolModeProvider);
    final characterCollection = ref.watch(characterCollectionProvider);
    final regions = characterCollection.regions;
    final selectedIds = characterCollection.selectedIds;
    final debugOptions = ref.watch(debugOptionsProvider);

    // 澶勭悊宸ュ叿妯″紡鍙樺寲
    final lastToolMode = _isInSelectionMode
        ? Tool.select
        : (_isPanning ? Tool.pan : Tool.multiSelect);
    _isInSelectionMode = toolMode == Tool.select;
    _isPanning = toolMode == Tool.pan;

    // 妯″紡鍙樺寲鏃堕噸缃姸鎬?
    if (lastToolMode != toolMode) {
      AppLogger.debug('宸ュ叿妯″紡鍙樺寲锛岄噸缃姸鎬?, data: {
        'from': lastToolMode.toString(),
        'to': toolMode.toString(),
      });
      // 浣跨敤Future寤惰繜鎵ц锛岄伩鍏嶅湪build杩囩▼涓慨鏀筽rovider鐘舵€?
      Future(() => _resetSelectionState());
    }

    if (!imageState.hasValidImage) {
      return const SizedBox.shrink();
    }

    final imageSize = Size(imageState.imageWidth, imageState.imageHeight);

    return Focus(
      focusNode: _focusNode,
      autofocus: true,
      onKeyEvent: _handleKeyEvent,
      child: LayoutBuilder(
        builder: (context, constraints) {
          final viewportSize =
              Size(constraints.maxWidth, constraints.maxHeight);

          // 妫€鏌ユ槸鍚﹂渶瑕佹洿鏂皌ransformer
          _updateTransformer(
            imageSize: imageSize,
            viewportSize: viewportSize,
            enableLogging: debugOptions.enableLogging,
          );

          // 棣栨鍔犺浇涓斿浘鍍忓拰transformer閮藉噯澶囧ソ鏃惰缃垵濮嬬缉鏀?
          if (_isFirstLoad &&
              imageState.hasValidImage &&
              imageSize.width > 0 &&
              imageSize.height > 0 &&
              _transformer != null) {
            // 纭繚鍦ㄥ竷灞€瀹屾垚鍚庢墽琛?
            WidgetsBinding.instance.addPostFrameCallback((_) {
              if (!_mounted || _transformer == null) return;

              final effectiveViewportSize = _transformer!.viewportSize;
              _setInitialScale(
                  imageSize: imageSize, viewportSize: effectiveViewportSize);

              setState(() {
                _isFirstLoad = false;
                _isZoomed = false;
              });

              AppLogger.debug('棣栨鍔犺浇瀹屾垚锛屽凡璁剧疆鍒濆缂╂斁', data: {
                'imageSize': '${imageSize.width}x${imageSize.height}',
                'viewportSize':
                    '${effectiveViewportSize.width}x${effectiveViewportSize.height}',
                'scale': _transformer!.currentScale
              });
            });
          }

          return Material(
            // 娣诲姞Material widget浠ユ敮鎸乪levation鏁堟灉
            color: Colors.transparent,
            child: Listener(
              onPointerHover: _handleMouseMove,
              child: Stack(
                fit: StackFit.expand,
                children: [
                  _buildImageLayer(
                    imageState,
                    regions,
                    selectedIds,
                    viewportSize,
                  ),
                  if (_transformer != null && debugOptions.enabled)
                    _buildDebugLayer(
                      debugOptions,
                      regions,
                      selectedIds,
                      viewportSize,
                    ),
                  _buildSelectionToolLayer(),
                  _buildUILayer(debugOptions),
                ],
              ),
            ),
          );
        },
      ),
    );
  }

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();

    // Check if there's a selected region and activate adjustment mode if needed
    final selectedIds = ref.read(characterCollectionProvider).selectedIds;
    if (selectedIds.length == 1 &&
        !_isAdjusting &&
        ref.read(toolModeProvider) == Tool.select) {
      final regions = ref.read(characterCollectionProvider).regions;
      final selectedRegion = regions.firstWhere(
        (r) => selectedIds.contains(r.id),
        orElse: () => throw Exception('No selected region found'),
      );

      WidgetsBinding.instance.addPostFrameCallback((_) {
        _activateAdjustmentMode(selectedRegion);
      });
    }
  }

  @override
  void didUpdateWidget(ImageView oldWidget) {
    super.didUpdateWidget(oldWidget);
    // 涓嶅湪杩欓噷瑙﹀彂鏁版嵁鍔犺浇锛屾敼涓鸿瀵熷浘鍍忕姸鎬佸彉鍖?
  }

  @override
  void dispose() {
    _mounted = false;
    _transformationDebouncer?.cancel();
    _animationController?.dispose();
    _transformationController.removeListener(_onTransformationChanged);
    _transformationController.dispose();
    _focusNode.dispose();
    _debugPanelController.dispose();
    super.dispose();
  }

  @override
  void initState() {
    super.initState();
    _debugPanelController = AnimationController(
      vsync: this,
      duration: const Duration(milliseconds: 300),
    );
    _debugPanelAnimation = CurvedAnimation(
      parent: _debugPanelController,
      curve: Curves.easeInOut,
    );

    // 娣诲姞鍙樻崲鐭╅樀鍙樺寲鐩戝惉
    _transformationController.addListener(_onTransformationChanged);

    _initializeView();

    // Listen for external region deletions affecting the adjusted region
    ref.listenManual(characterCollectionProvider, (previous, next) {
      // Check if we were adjusting a region
      if (_isAdjusting && _adjustingRegionId != null) {
        // Check if the adjusted region ID no longer exists in the new list
        final regionExists =
            next.regions.any((r) => r.id == _adjustingRegionId);
        if (!regionExists) {
          AppLogger.debug(
              'Adjusted region removed externally, resetting adjustment state.',
              data: {'removedRegionId': _adjustingRegionId});
          // Use WidgetsBinding to ensure state reset happens after build
          WidgetsBinding.instance.addPostFrameCallback((_) {
            if (_mounted) {
              // Check if still mounted
              _resetAdjustmentState();
            }
          });
        }
      }

      // 鐩戝惉Provider鐨刬sAdjusting鐘舵€佸彉鍖栦互鍚屾鏈湴鐘舵€?
      if (previous?.isAdjusting != next.isAdjusting) {
        AppLogger.debug('Provider isAdjusting state changed', data: {
          'previous': previous?.isAdjusting,
          'next': next.isAdjusting,
          'local_isAdjusting': _isAdjusting,
          'currentRegionId': next.currentId,
        });
        WidgetsBinding.instance.addPostFrameCallback((_) {
          if (!_mounted) return;

          if (next.isAdjusting && !_isAdjusting) {
            // Provider杩涘叆璋冩暣妯″紡锛屾湰鍦伴渶瑕佸悓姝?
            final regionToAdjust = next.selectedRegion;
            if (regionToAdjust != null) {
              AppLogger.debug('Activating adjustment mode from provider state');
              _activateAdjustmentMode(regionToAdjust);
            } else {
              AppLogger.warning(
                  'Provider isAdjusting is true, but no selected region found');
            }
          } else if (!next.isAdjusting && _isAdjusting) {
            // Provider閫€鍑鸿皟鏁存ā寮忥紝鏈湴闇€瑕佸悓姝ワ紙鍙噸缃甎I锛?
            AppLogger.debug(
                'Resetting local adjustment state from provider state');
            _resetAdjustmentState(); // 閲嶇疆鏈湴鐘舵€?
          }
        });
      }
    });

    // 鐩戝惉鍥惧儚鐘舵€佸彉鍖栨潵瑙﹀彂閫夊尯鏁版嵁鍔犺浇
    WidgetsBinding.instance.addPostFrameCallback((_) {
      final imageState = ref.read(workImageProvider);
      _lastImageId = '${imageState.workId}-${imageState.currentPageId}';
      if (imageState.hasValidImage) {
        _tryLoadCharacterData();
      }
    });
  }

  void _activateAdjustmentMode(CharacterRegion region) {
    if (_transformer == null) return;

    try {
      setState(() {
        _isAdjusting = true;
        _adjustingRegionId = region.id;
        _originalRegion = region;
        // 灏嗗浘鍍忓潗鏍囩郴涓殑鐭╁舰杞崲涓鸿鍙ｅ潗鏍囩郴
        _adjustingRect = _transformer!.imageRectToViewportRect(region.rect);
        _currentRotation = region.rotation;
        _selectionStart = null;
        _selectionCurrent = null;
        _hasCompletedSelection = false;
      });

      // 璁板綍婵€娲荤姸鎬?
      AppLogger.debug('閫夊尯杩涘叆璋冩暣妯″紡', data: {
        'regionId': region.id,
        'isAdjusting': _isAdjusting,
        'rect': '${_adjustingRect!.width}x${_adjustingRect!.height}',
        'position': '${_adjustingRect!.left},${_adjustingRect!.top}',
        'rotation': _currentRotation,
        'scale': _transformer!.currentScale.toStringAsFixed(2)
      });
    } catch (e) {
      AppLogger.error('婵€娲昏皟鏁存ā寮忓け璐?,
          error: e,
          data: {'regionId': region.id, 'rect': region.rect.toString()});
      _resetAdjustmentState();
    }
  }

  Rect _adjustRect(Rect rect, Offset position, int handleIndex) {
    final center = rect.center;

    // Transform the position to account for rotation
    Offset transformedPosition = position;
    if (_currentRotation != 0) {
      // Convert screen position to object space (un-rotate it)
      final dx = position.dx - center.dx;
      final dy = position.dy - center.dy;

      final cos = math.cos(-_currentRotation);
      final sin = math.sin(-_currentRotation);

      final rotatedX = dx * cos - dy * sin + center.dx;
      final rotatedY = dx * sin + dy * cos + center.dy;

      transformedPosition = Offset(rotatedX, rotatedY);
    }

    // Use the transformed position for standard rectangle adjustments
    Rect newRect;

    switch (handleIndex) {
      case 0: // 宸︿笂瑙?
        newRect = Rect.fromPoints(transformedPosition, rect.bottomRight);
        break;
      case 1: // 涓婅竟涓偣
        newRect = Rect.fromLTRB(
            rect.left, transformedPosition.dy, rect.right, rect.bottom);
        break;
      case 2: // 鍙充笂瑙?
        newRect = Rect.fromPoints(rect.bottomLeft, transformedPosition);
        break;
      case 3: // 鍙宠竟涓偣
        newRect = Rect.fromLTRB(
            rect.left, rect.top, transformedPosition.dx, rect.bottom);
        break;
      case 4: // 鍙充笅瑙?
        newRect = Rect.fromPoints(rect.topLeft, transformedPosition);
        break;
      case 5: // 涓嬭竟涓偣
        newRect = Rect.fromLTRB(
            rect.left, rect.top, rect.right, transformedPosition.dy);
        break;
      case 6: // 宸︿笅瑙?
        newRect = Rect.fromPoints(transformedPosition, rect.topRight);
        break;
      case 7: // 宸﹁竟涓偣
        newRect = Rect.fromLTRB(
            transformedPosition.dx, rect.top, rect.right, rect.bottom);
        break;
      case 8: // 绉诲姩鏁翠釜閫夊尯
        // For movement, use the original (non-transformed) position delta
        final dx = position.dx - center.dx;
        final dy = position.dy - center.dy;

        // If rotated, calculate the rotated delta
        if (_currentRotation != 0) {
          final cos = math.cos(-_currentRotation);
          final sin = math.sin(-_currentRotation);

          final rotatedDx = dx * cos - dy * sin;
          final rotatedDy = dx * sin + dy * cos;

          // Apply the rotated delta
          newRect = rect.translate(rotatedDx, rotatedDy);
        } else {
          newRect = rect.translate(dx, dy);
        }
        break;
      default:
        return rect;
    }

    // Ensure minimum size
    const minSize = 20.0;
    if (newRect.width < minSize || newRect.height < minSize) {
      // Keep at least minimum size but respect aspect ratio if possible
      if (newRect.width < minSize) {
        final aspectRatio = rect.height / rect.width;
        const newWidth = minSize;
        final newHeight = newWidth * aspectRatio;

        // Create rect with minimum width while preserving position
        newRect = Rect.fromLTWH(
            newRect.left, newRect.top, newWidth, math.max(newHeight, minSize));
      }

      if (newRect.height < minSize) {
        final aspectRatio = rect.width / rect.height;
        const newHeight = minSize;
        final newWidth = newHeight * aspectRatio;

        // Create rect with minimum height while preserving position
        newRect = Rect.fromLTWH(
            newRect.left, newRect.top, math.max(newWidth, minSize), newHeight);
      }
    }

    return newRect;
  }

  void _animateMatrix(Matrix4 targetMatrix) {
    _animationController?.dispose();
    _animationController = AnimationController(
      vsync: this,
      duration: const Duration(milliseconds: 300),
    );

    final animation = Matrix4Tween(
      begin: _transformationController.value,
      end: targetMatrix,
    ).animate(CurvedAnimation(
      parent: _animationController!,
      curve: Curves.easeInOut,
    ));

    animation.addListener(() {
      _transformationController.value = animation.value;
    });

    _animationController!.forward();
  }

  Widget _buildDebugLayer(
    DebugOptions debugOptions,
    List<CharacterRegion> regions,
    Set<String> selectedIds,
    Size viewportSize,
  ) {
    return Positioned.fill(
      child: IgnorePointer(
        child: CustomPaint(
          painter: DebugOverlay(
            transformer: _transformer!,
            showGrid: debugOptions.showGrid,
            showCoordinates: debugOptions.showCoordinates,
            showDetails: debugOptions.showDetails,
            showImageInfo: debugOptions.showImageInfo,
            showRegionCenter: debugOptions.showRegionCenter,
            gridSize: debugOptions.gridSize,
            textScale: debugOptions.textScale,
            opacity: debugOptions.opacity,
            regions: regions,
            selectedIds: selectedIds,
          ),
          size: viewportSize,
        ),
      ),
    );
  }

  /// 鏋勫缓閿欒鏄剧ず
  Widget _buildErrorWidget(
    BuildContext context,
    Object error,
    StackTrace? stackTrace,
  ) {
    AppLogger.error('鍥剧墖鍔犺浇澶辫触', error: error, stackTrace: stackTrace);

    return Center(
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          const Icon(Icons.broken_image, size: 64, color: Colors.red),
          const SizedBox(height: 16),
          Text(
            '鏃犳硶鍔犺浇鍥剧墖: ${error.toString()}',
            style: const TextStyle(color: Colors.red),
            textAlign: TextAlign.center,
          ),
        ],
      ),
    );
  }

  /// 鏋勫缓鍥惧儚甯?
  Widget _buildImageFrame(
    BuildContext context,
    Widget child,
    int? frame,
    bool wasSynchronouslyLoaded,
  ) {
    if (frame != null && !wasSynchronouslyLoaded) {
      // 鍙湪寮傛鍔犺浇瀹屾垚鏃惰Е鍙戜竴娆?
      WidgetsBinding.instance.addPostFrameCallback((_) {
        if (!_mounted) return;
        final imageState = ref.read(workImageProvider);
        final currentImageId =
            '${imageState.workId}-${imageState.currentPageId}';
        if (_lastImageId != currentImageId) {
          _handleImageLoaded(imageState);
        }
      });

      return AnimatedSwitcher(
        duration: const Duration(milliseconds: 200),
        child: child,
      );
    }

    return const Center(
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          CircularProgressIndicator(strokeWidth: 2),
          SizedBox(height: 16),
          Text('姝ｅ湪鍔犺浇鍥剧墖...', style: TextStyle(color: Colors.grey)),
        ],
      ),
    );
  }

  Widget _buildImageLayer(
    WorkImageState imageState,
    List<CharacterRegion> regions,
    Set<String> selectedIds,
    Size viewportSize,
  ) {
    final toolMode = ref.watch(toolModeProvider);
    final isPanMode = toolMode == Tool.pan;
    final isSelectMode = toolMode == Tool.select;
    final isMultiSelectMode = toolMode == Tool.multiSelect;
    final characterCollection = ref.watch(characterCollectionProvider);

    return MouseRegion(
      cursor: _getCursor(),
      onHover: (event) {
        // 鏇存柊鎮仠鐘舵€?
        if (_isAdjusting && _adjustingRect != null) {
          final handleIndex = _getHandleIndexFromPosition(event.localPosition);
          setState(() {
            _hoveredHandleIndex = handleIndex;
          });
        } else {
          final hitRegion = _hitTestRegion(event.localPosition, regions);
          setState(() {
            _hoveredRegionId = hitRegion?.id;
          });
        }
      },
      onExit: (_) {
        setState(() {
          _hoveredRegionId = null;
          _hoveredHandleIndex = null;
        });
      },
      child: GestureDetector(
        onTapUp: _onTapUp,
        onDoubleTap: () {
          // 鍙屽嚮涓嶅啀闇€瑕佺‘璁よ皟鏁?
        },
        // Always allow selection start, handle adjustment cancellation inside
        onPanStart: isPanMode ? _handlePanStart : _handleSelectionStart,
        onPanUpdate: isPanMode ? _handlePanUpdate : _handleSelectionUpdate,
        onPanEnd: isPanMode ? _handlePanEnd : _handleSelectionEnd,
        child: Listener(
          onPointerSignal: _handlePointerSignal,
          child: Stack(
            fit: StackFit.expand,
            children: [
              InteractiveViewer(
                transformationController: _transformationController,
                minScale: 0.1,
                maxScale: 10.0,
                scaleEnabled: true,
                panEnabled: isPanMode && !_isAdjusting,
                boundaryMargin: const EdgeInsets.all(double.infinity),
                onInteractionStart: _handleInteractionStart,
                onInteractionUpdate: _handleInteractionUpdate,
                onInteractionEnd: _handleInteractionEnd,
                alignment: Alignment.topLeft,
                child: Stack(
                  children: [
                    Image.memory(
                      imageState.imageData!,
                      fit: BoxFit.contain,
                      alignment: Alignment.topLeft,
                      filterQuality: FilterQuality.high,
                      gaplessPlayback: true,
                      frameBuilder: _buildImageFrame,
                      errorBuilder: _buildErrorWidget,
                    ),
                  ],
                ),
              ),

              // 缁樺埗鎵€鏈夊尯鍩?
              if (_transformer != null && regions.isNotEmpty)
                Positioned.fill(
                  child: IgnorePointer(
                    ignoring: _isAdjusting,
                    child: CustomPaint(
                      painter: RegionsPainter(
                        regions: regions,
                        selectedIds: selectedIds,
                        modifiedIds: characterCollection.modifiedIds,
                        transformer: _transformer!,
                        hoveredId: _hoveredRegionId,
                        adjustingRegionId: _adjustingRegionId,
                        currentTool: toolMode,
                        isAdjusting: characterCollection.isAdjusting,
                      ),
                    ),
                  ),
                ),

              // **Adjustment Layer GestureDetector**
              if (_isAdjusting && _adjustingRegionId != null)
                Positioned.fill(
                  child: GestureDetector(
                    behavior:
                        HitTestBehavior.opaque, // Capture hits within bounds
                    onPanStart:
                        _handleAdjustmentPanStart, // Use dedicated handler
                    onPanUpdate:
                        _handleAdjustmentPanUpdate, // Use dedicated handler
                    onPanEnd: _handleAdjustmentPanEnd, // Use dedicated handler
                    child: CustomPaint(
                      painter: AdjustableRegionPainter(
                        region: _originalRegion!,
                        transformer: _transformer!,
                        isActive: true,
                        isAdjusting: true,
                        activeHandleIndex: _activeHandleIndex,
                        currentRotation: _currentRotation,
                        guideLines: _guideLines,
                        viewportRect: _adjustingRect,
                      ),
                      size: viewportSize,
                    ),
                  ),
                ),

              // 娣诲姞妗嗛€夊眰
              if (isSelectMode && !_isAdjusting)
                Positioned.fill(
                  child: GestureDetector(
                    onPanStart: _handleSelectionStart,
                    onPanUpdate: _handleSelectionUpdate,
                    onPanEnd: _handleSelectionEnd,
                    child: CustomPaint(
                      painter: ActiveSelectionPainter(
                        startPoint: _selectionStart ?? Offset.zero,
                        endPoint: _selectionCurrent ?? Offset.zero,
                        viewportSize: _transformer?.viewportSize ?? Size.zero,
                        isActive: _selectionStart != null,
                      ),
                    ),
                  ),
                ),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildSelectionToolLayer() {
    if (!_isInSelectionMode || _selectionStart == null) {
      return const SizedBox.shrink();
    }

    return GestureDetector(
      onPanUpdate: (details) {
        setState(() {
          _selectionCurrent = details.localPosition;
        });
      },
      onPanEnd: (details) {
        if (_selectionStart != null && _selectionCurrent != null) {
          _handleSelectionEnd(details);
        }
      },
      child: CustomPaint(
        painter: ActiveSelectionPainter(
          startPoint: _selectionStart!,
          endPoint: _selectionCurrent ?? _selectionStart!,
          viewportSize: _transformer!.viewportSize,
        ),
      ),
    );
  }

  Widget _buildUILayer(DebugOptions debugOptions) {
    return Stack(
      children: [
        // 璋冭瘯妯″紡鍒囨崲鎸夐挳
        if (debugOptions.enabled)
          Positioned(
            right: 16,
            bottom: 16,
            child: _DebugModeToggle(enabled: debugOptions.enabled),
          ),

        // 閫夊尯宸ュ叿鏍?
        if (_hasCompletedSelection && _lastCompletedSelection != null)
          Positioned(
            left: _lastCompletedSelection!.left,
            top: _lastCompletedSelection!.top - 40,
            child: SelectionToolbar(
              onConfirm: () {
                _confirmSelection();
              },
              onCancel: () {
                _cancelSelection();
              },
              onDelete: () {
                // 鍒犻櫎閫夊尯鐨勯€昏緫
              },
            ),
          ),

        // 灏哄鎸囩ず鍣?- 鍙湪璋冩暣妯″紡涓嬫樉绀?
        if (_isAdjusting && _adjustingRect != null)
          Positioned(
            left: _calculateIndicatorPosition().dx,
            top: _calculateIndicatorPosition().dy,
            child: AnimatedOpacity(
              duration: const Duration(milliseconds: 150),
              opacity: _hoveredHandleIndex != null || _activeHandleIndex != null
                  ? 1.0
                  : 0.7,
              child: Container(
                padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 4),
                decoration: BoxDecoration(
                  color: Colors.white,
                  borderRadius: BorderRadius.circular(4),
                  boxShadow: [
                    BoxShadow(
                      color: Colors.black.withOpacity(0.1),
                      blurRadius: 4,
                      offset: const Offset(0, 2),
                    ),
                  ],
                  border: Border.all(
                    color: _hoveredHandleIndex != null ||
                            _activeHandleIndex != null
                        ? Colors.blue
                        : Colors.blue.withOpacity(0.7),
                    width: 1,
                  ),
                ),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Row(
                      mainAxisSize: MainAxisSize.min,
                      children: [
                        const Icon(
                          Icons.straighten,
                          size: 14,
                          color: Colors.blue,
                        ),
                        const SizedBox(width: 4),
                        Text(
                          '${_adjustingRect!.width.round()}脳${_adjustingRect!.height.round()}',
                          style: const TextStyle(
                            color: Colors.blue,
                            fontWeight: FontWeight.w600,
                            fontSize: 13,
                          ),
                        ),
                      ],
                    ),
                    if (_currentRotation != 0)
                      Padding(
                        padding: const EdgeInsets.only(top: 2),
                        child: Row(
                          mainAxisSize: MainAxisSize.min,
                          children: [
                            const Icon(
                              Icons.rotate_right,
                              size: 14,
                              color: Colors.blue,
                            ),
                            const SizedBox(width: 4),
                            Text(
                              '${(_currentRotation * 180 / math.pi).round()}掳',
                              style: const TextStyle(
                                color: Colors.blue,
                                fontWeight: FontWeight.w600,
                                fontSize: 13,
                              ),
                            ),
                          ],
                        ),
                      ),
                  ],
                ),
              ),
            ),
          ),
      ],
    );
  }

  double _calculateAngle(Offset center, Offset point) {
    return (point - center).direction;
  }

  // 璁＄畻瀵归綈鍙傝€冪嚎
  List<Offset> _calculateGuideLines(Rect rect) {
    final guides = <Offset>[];

    // 娣诲姞姘村钩涓績绾?
    guides.add(Offset(rect.center.dx, 0));
    guides.add(Offset(rect.center.dx, _transformer!.viewportSize.height));

    // 娣诲姞鍨傜洿涓績绾?
    guides.add(Offset(0, rect.center.dy));
    guides.add(Offset(_transformer!.viewportSize.width, rect.center.dy));

    // 娣诲姞姘村钩瀵归綈绾匡紙鎺ヨ繎姘村钩鏃讹級
    if (rect.height < 20) {
      guides.add(Offset(0, rect.top));
      guides.add(Offset(_transformer!.viewportSize.width, rect.top));
    }

    // 娣诲姞鍨傜洿瀵归綈绾匡紙鎺ヨ繎鍨傜洿鏃讹級
    if (rect.width < 20) {
      guides.add(Offset(rect.left, 0));
      guides.add(Offset(rect.left, _transformer!.viewportSize.height));
    }

    return guides;
  }

  /// 璁＄畻鎸囩ず鍣ㄧ殑鐞嗘兂浣嶇疆
  Offset _calculateIndicatorPosition() {
    if (_adjustingRect == null) return Offset.zero;

    const padding = 8.0;
    final viewportSize = _transformer?.viewportSize ?? Size.zero;

    // 榛樿浣嶇疆鍦ㄩ€夊尯鍙充晶
    var x = _adjustingRect!.right + padding;
    var y = _adjustingRect!.top;

    // 濡傛灉鍙充晶绌洪棿涓嶈冻锛屽皢鎸囩ず鍣ㄦ斁鍦ㄥ乏渚?
    if (x + 120 > viewportSize.width) {
      // 120鏄及绠楃殑鎸囩ず鍣ㄥ搴?
      x = _adjustingRect!.left - padding - 120;
    }

    // 濡傛灉椤堕儴绌洪棿涓嶈冻锛屽皢鎸囩ず鍣ㄥ悜涓嬬Щ鍔?
    if (y < padding) {
      y = padding;
    }

    // 濡傛灉搴曢儴绌洪棿涓嶈冻锛屽皢鎸囩ず鍣ㄥ悜涓婄Щ鍔?
    if (y + 50 > viewportSize.height) {
      // 50鏄及绠楃殑鎸囩ず鍣ㄦ渶澶ч珮搴?
      y = viewportSize.height - 50;
    }

    // 褰撻€夊尯鏃嬭浆鏃讹紝纭繚鎸囩ず鍣ㄤ笉浼氳閫夊尯閬尅
    if (_currentRotation != 0) {
      final rotationDegrees = (_currentRotation * 180 / math.pi) % 360;
      if (rotationDegrees > 45 && rotationDegrees < 135) {
        y = math.max(y, _adjustingRect!.bottom + padding);
      } else if (rotationDegrees > 225 && rotationDegrees < 315) {
        y = math.min(y, _adjustingRect!.top - 50 - padding);
      }
    }

    return Offset(x, y);
  }

  // 鍙栨秷閫夊尯璋冩暣
  void _cancelAdjustment() {
    AppLogger.debug('鍙栨秷閫夊尯璋冩暣 (_cancelAdjustment called)', data: {
      'imageViewHasAdjustingRegion': _adjustingRegionId != null,
    });

    // 鏇存柊Provider鐘舵€?
    ref.read(characterCollectionProvider.notifier).finishCurrentAdjustment();

    // 瀹屽叏閲嶇疆鏈湴璋冩暣鐘舵€?
    _resetAdjustmentState();
  }

  void _cancelSelection() {
    setState(() {
      _hasCompletedSelection = false;
      _lastCompletedSelection = null;
    });
  }

  void _confirmAdjustment() {
    if (!_isAdjusting ||
        _adjustingRegionId == null ||
        _adjustingRect == null ||
        _originalRegion == null) {
      return;
    }

    final imageRect = _transformer!.viewportRectToImageRect(_adjustingRect!);

    // 浣跨敤Future寤惰繜鏇存柊provider鐘舵€?
    Future(() {
      if (_mounted) {
        // 鍒涘缓鏇存柊鍚庣殑鍖哄煙
        final updatedRegion = _originalRegion!.copyWith(
          rect: imageRect,
          rotation: _currentRotation,
          updateTime: DateTime.now(),
        );

        // 鏇存柊鍖哄煙
        ref
            .read(characterCollectionProvider.notifier)
            .updateSelectedRegion(updatedRegion);
      }
    });

    // 閲嶇疆鐘舵€?
    setState(() {
      _isAdjusting = false;
      _adjustingRegionId = null;
      _activeHandleIndex = null;
      _guideLines = null;
      _originalRegion = null;
      _adjustingRect = null;
      _isRotating = false;
      _currentRotation = 0.0;
      _rotationCenter = null;
    });
  }

  void _confirmSelection() {
    if (_lastCompletedSelection == null) return;

    final imageRect =
        _transformer!.viewportRectToImageRect(_lastCompletedSelection!);

    // 浣跨敤Future寤惰繜鏇存柊provider
    Future(() {
      if (_mounted) {
        // 娣诲姞鍖哄煙
        ref.read(characterCollectionProvider.notifier).createRegion(imageRect);
      }
    });

    // 閲嶇疆鐘舵€?
    setState(() {
      _hasCompletedSelection = false;
      _lastCompletedSelection = null;
    });
  }

  /// 鑾峰彇鏇存柊鐨勫厜鏍囨牱寮?
  MouseCursor _getCursor() {
    final toolMode = ref.read(toolModeProvider);

    if (_isAdjusting) {
      if (_activeHandleIndex != null) {
        // 鏍规嵁涓嶅悓鎺у埗鐐硅繑鍥炰笉鍚屽厜鏍?
        switch (_activeHandleIndex) {
          case -1: // 鏃嬭浆鎺у埗鐐?
            return SystemMouseCursors.alias; // 鐢ㄤ簬鏃嬭浆鐨勫厜鏍?
          case 0: // 宸︿笂瑙?
          case 4: // 鍙充笅瑙?
            return SystemMouseCursors.resizeUpLeftDownRight;
          case 2: // 鍙充笂瑙?
          case 6: // 宸︿笅瑙?
            return SystemMouseCursors.resizeUpRightDownLeft;
          case 1: // 涓婅竟涓偣
          case 5: // 涓嬭竟涓偣
            return SystemMouseCursors.resizeUpDown;
          case 3: // 鍙宠竟涓偣
          case 7: // 宸﹁竟涓偣
            return SystemMouseCursors.resizeLeftRight;
          case 8: // 绉诲姩鏁翠釜閫夊尯
            return SystemMouseCursors.move;
          default:
            return SystemMouseCursors.basic;
        }
      }

      // 妫€鏌ュ綋鍓嶆偓鍋滀綅缃槸鍚﹀湪鏌愪釜鎺у埗鐐逛笂
      if (_hoveredHandleIndex != null) {
        switch (_hoveredHandleIndex) {
          case -1: // 鏃嬭浆鎺у埗鐐?
            return SystemMouseCursors.alias; // 鐢ㄤ簬鏃嬭浆鐨勫厜鏍?
          case 0: // 宸︿笂瑙?
          case 4: // 鍙充笅瑙?
            return SystemMouseCursors.resizeUpLeftDownRight;
          case 2: // 鍙充笂瑙?
          case 6: // 宸︿笅瑙?
            return SystemMouseCursors.resizeUpRightDownLeft;
          case 1: // 涓婅竟涓偣
          case 5: // 涓嬭竟涓偣
            return SystemMouseCursors.resizeUpDown;
          case 3: // 鍙宠竟涓偣
          case 7: // 宸﹁竟涓偣
            return SystemMouseCursors.resizeLeftRight;
          case 8: // 绉诲姩鏁翠釜閫夊尯
            return SystemMouseCursors.move;
          default:
            return SystemMouseCursors.basic;
        }
      }
    }

    switch (toolMode) {
      case Tool.pan:
        return _isPanning
            ? SystemMouseCursors.grabbing
            : SystemMouseCursors.grab;
      case Tool.select:
        return SystemMouseCursors.precise;
      case Tool.multiSelect:
        return SystemMouseCursors.click;
      default:
        return SystemMouseCursors.basic;
    }
  }

  int? _getHandleIndexFromPosition(Offset position) {
    if (_adjustingRect == null) return null;

    final center = _adjustingRect!.center;

    // Function to transform a point from screen to object space
    Offset transformPoint(Offset point, bool inverse) {
      if (_currentRotation == 0) return point;

      final dx = point.dx - center.dx;
      final dy = point.dy - center.dy;

      // Use inverse rotation for screen to object conversion, forward rotation for object to screen
      final angle = inverse ? -_currentRotation : _currentRotation;
      final cos = math.cos(angle);
      final sin = math.sin(angle);

      final rotatedX = dx * cos - dy * sin + center.dx;
      final rotatedY = dx * sin + dy * cos + center.dy;

      return Offset(rotatedX, rotatedY);
    }

    // Handle rotation control first
    // Transform the rotation point from object space to screen space
    final rotationPoint = transformPoint(
        Offset(_adjustingRect!.topCenter.dx, _adjustingRect!.topCenter.dy - 30),
        false // Transform from object to screen space
        );

    // Check if clicked on rotation handle
    if ((position - rotationPoint).distance < 12) {
      return -1; // Rotation handle
    }

    final handles = [
      _adjustingRect!.topLeft,
      _adjustingRect!.topCenter,
      _adjustingRect!.topRight,
      _adjustingRect!.centerRight,
      _adjustingRect!.bottomRight,
      _adjustingRect!.bottomCenter,
      _adjustingRect!.bottomLeft,
      _adjustingRect!.centerLeft,
    ];

    // Transform these handle positions if we have rotation
    final transformedHandles = _currentRotation != 0
        ? handles.map((p) => transformPoint(p, false)).toList()
        : handles;

    // Check each handle with transformed positions
    for (int i = 0; i < transformedHandles.length; i++) {
      final handleRect = Rect.fromCenter(
        center: transformedHandles[i],
        width: 12.0,
        height: 12.0,
      );

      if (handleRect.contains(position)) {
        return i;
      }
    }

    // If clicked inside the rect (considering rotation)
    if (_isPointInRotatedRect(position, _adjustingRect!, _currentRotation)) {
      return 8; // Move entire selection
    }

    return null;
  }

  /// 鑾峰彇鏇存柊transformer鐨勫師鍥狅紝鐢ㄤ簬璋冭瘯
  String _getUpdateReason(
    Size imageSize,
    Size viewportSize,
    CoordinateTransformer? oldTransformer,
  ) {
    if (oldTransformer == null) return 'initial';
    if (oldTransformer.imageSize != imageSize) return 'image_size_changed';
    if (oldTransformer.viewportSize != viewportSize)
      return 'viewport_size_changed';
    return 'unknown';
  }

  void _handleAdjustmentPanEnd(DragEndDetails details) {
    if (!_isAdjusting || _originalRegion == null || _adjustingRect == null) {
      // Ensure state is reset even if something went wrong
      _resetAdjustmentState();
      return;
    }

    final Rect finalViewportRect = _adjustingRect!;
    final double finalRotation = _currentRotation;
    final CharacterRegion originalRegion = _originalRegion!;

    // 绔嬪嵆鏇存柊provider鐘舵€侊紝纭繚UI鍜岀姸鎬佸悓姝?
    final Rect finalImageRect =
        _transformer!.viewportRectToImageRect(finalViewportRect);

    final updatedRegion = originalRegion.copyWith(
      rect: finalImageRect,
      rotation: finalRotation,
      updateTime: DateTime.now(),
    );

    // 绔嬪嵆鏇存柊provider鐘舵€?
    ref
        .read(characterCollectionProvider.notifier)
        .updateSelectedRegion(updatedRegion);

    // 閲嶇疆UI鐘舵€侊紝浣嗕繚鎸佽皟鏁存ā寮?
    setState(() {
      _activeHandleIndex = null;
      _guideLines = null;
      _isRotating = false;
      _rotationCenter = null;
      _hoveredHandleIndex = null;
      // 涓嶉噸缃甠isAdjusting鍜宊adjustingRect锛屼繚鎸佽皟鏁寸姸鎬?
    });

    AppLogger.debug('閫夊尯璋冩暣瀹屾垚', data: {
      'regionId': updatedRegion.id,
      'newRect':
          '${updatedRegion.rect.left.toStringAsFixed(1)}, ${updatedRegion.rect.top.toStringAsFixed(1)}, ${updatedRegion.rect.width.toStringAsFixed(1)}, ${updatedRegion.rect.height.toStringAsFixed(1)}',
      'newRotation': updatedRegion.rotation.toStringAsFixed(2)
    });
  }

  void _handleAdjustmentPanStart(DragStartDetails details) {
    if (!_isAdjusting || _adjustingRect == null) return; // Safety check

    final handleIndex = _getHandleIndexFromPosition(details.localPosition);

    AppLogger.debug('_handleAdjustmentPanStart', data: {
      'localPosition':
          '${details.localPosition.dx},${details.localPosition.dy}',
      'handleIndex': handleIndex,
    });

    if (handleIndex != null) {
      setState(() {
        _activeHandleIndex = handleIndex;
        _isRotating = (handleIndex == -1);
        if (_isRotating) {
          _rotationCenter = _adjustingRect!.center;
          _rotationStartAngle = _calculateAngle(
            _rotationCenter!,
            details.localPosition, // Use local position directly
          );
        }
      });
    }
  }

  void _handleAdjustmentPanUpdate(DragUpdateDetails details) {
    if (!_isAdjusting || _activeHandleIndex == null || _adjustingRect == null)
      return;

    setState(() {
      if (_isRotating) {
        // Handle rotation
        final currentAngle =
            _calculateAngle(_rotationCenter!, details.localPosition);
        final angleDiff = currentAngle - _rotationStartAngle;
        _currentRotation =
            (_originalRegion!.rotation + angleDiff) % (2 * math.pi);
        if (_currentRotation < 0) _currentRotation += (2 * math.pi);
      } else if (_activeHandleIndex! >= 0 && _activeHandleIndex! < 8) {
        // Handle resizing with proper coordinate transformation
        _adjustingRect = _adjustRect(
          _adjustingRect!,
          details.localPosition,
          _activeHandleIndex!,
        );
        _guideLines = _calculateGuideLines(_adjustingRect!);
      } else if (_activeHandleIndex == 8) {
        // Handle movement - simpler approach that preserves rotation
        _adjustingRect =
            _adjustingRect!.translate(details.delta.dx, details.delta.dy);
        _guideLines = _calculateGuideLines(_adjustingRect!);
      }
    });
  }

  void _handleBlankAreaTap() {
    AppLogger.debug('绌虹櫧鍖哄煙鐐瑰嚮澶勭悊 (_handleBlankAreaTap called)');
    // 瀹炵幇鐐瑰嚮绌虹櫧鍖哄煙閫€鍑鸿皟鏁存ā寮忕殑閫昏緫
    _cancelAdjustment();
    _cancelSelection();
  }

  // 澶勭悊鎺у埗鐐规嫋鍔?
  void _handleHandleDrag(DragUpdateDetails details, int handleIndex) {
    if (_adjustingRect == null) return;

    final delta = details.delta;
    final matrix = _transformationController.value.clone();
    matrix.invert();
    final scale = matrix.getMaxScaleOnAxis();
    final scaledDelta = Offset(delta.dx / scale, delta.dy / scale);

    Rect newRect = _adjustingRect!;
    switch (handleIndex) {
      case 0: // 宸︿笂
        newRect = Rect.fromPoints(
          _adjustingRect!.topLeft.translate(scaledDelta.dx, scaledDelta.dy),
          _adjustingRect!.bottomRight,
        );
        break;
      case 1: // 涓婁腑
        newRect = Rect.fromLTRB(
          _adjustingRect!.left,
          _adjustingRect!.top + scaledDelta.dy,
          _adjustingRect!.right,
          _adjustingRect!.bottom,
        );
        break;
      case 2: // 鍙充笂
        newRect = Rect.fromPoints(
          _adjustingRect!.bottomLeft,
          Offset(_adjustingRect!.right + scaledDelta.dx,
              _adjustingRect!.top + scaledDelta.dy),
        );
        break;
      case 3: // 鍙充腑
        newRect = Rect.fromLTRB(
          _adjustingRect!.left,
          _adjustingRect!.top,
          _adjustingRect!.right + scaledDelta.dx,
          _adjustingRect!.bottom,
        );
        break;
      case 4: // 鍙充笅
        newRect = Rect.fromPoints(
          _adjustingRect!.topLeft,
          _adjustingRect!.bottomRight.translate(scaledDelta.dx, scaledDelta.dy),
        );
        break;
      case 5: // 涓嬩腑
        newRect = Rect.fromLTRB(
          _adjustingRect!.left,
          _adjustingRect!.top,
          _adjustingRect!.right,
          _adjustingRect!.bottom + scaledDelta.dy,
        );
        break;
      case 6: // 宸︿笅
        newRect = Rect.fromPoints(
          Offset(_adjustingRect!.left + scaledDelta.dx,
              _adjustingRect!.bottom + scaledDelta.dy),
          _adjustingRect!.topRight,
        );
        break;
      case 7: // 宸︿腑
        newRect = Rect.fromLTRB(
          _adjustingRect!.left + scaledDelta.dx,
          _adjustingRect!.top,
          _adjustingRect!.right,
          _adjustingRect!.bottom,
        );
        break;
    }

    _updateAdjustingRegion(newRect);
  }

  /// 澶勭悊鍥剧墖鍔犺浇瀹屾垚浜嬩欢
  /// 鏇存柊鍥惧儚鏁版嵁骞惰Е鍙戦€夊尯鍔犺浇
  Future<void> _handleImageLoaded(WorkImageState imageState) async {
    if (!_mounted) return;

    final currentImageId = '${imageState.workId}-${imageState.currentPageId}';
    final provider = ref.read(characterCollectionProvider);
    final notifier = ref.read(characterCollectionProvider.notifier);

    try {
      AppLogger.debug('澶勭悊鍥剧墖鍔犺浇瀹屾垚', data: {
        'workId': imageState.workId,
        'pageId': imageState.currentPageId,
        'imageSize': '${imageState.imageWidth}x${imageState.imageHeight}',
      });

      // 閬垮厤閲嶅澶勭悊
      if (_lastImageId == currentImageId) {
        AppLogger.debug('璺宠繃閲嶅鐨勫浘鐗囧鐞?, data: {
          'imageId': currentImageId,
        });
        return;
      }

      // 1. 璁剧疆鍥惧儚鏁版嵁骞跺姞杞介€夊尯鏁版嵁
      notifier.setCurrentPageImage(imageState.imageData!);
      await _tryLoadCharacterData();

      // 2. 鏇存柊鐘舵€佹爣璁?
      _lastImageId = currentImageId;

      // 3. 閲嶇疆瑙嗗浘鐘舵€?
      if (_mounted) {
        setState(() {
          _isFirstLoad = false;
          _isZoomed = false;
          _isPanning = false;
        });
      }
    } catch (e, stack) {
      AppLogger.error('澶勭悊鍥剧墖鍔犺浇澶辫触', error: e, stackTrace: stack, data: {
        'workId': imageState.workId,
        'pageId': imageState.currentPageId,
        'imageId': currentImageId,
      });

      // 娓呯悊閿欒鐘舵€?
      if (_mounted) {
        notifier.clearState();
        setState(() {
          _isFirstLoad = true;
          _isZoomed = false;
          _isPanning = false;
        });
      }
    }
  }

  void _handleInteractionEnd(ScaleEndDetails details) {
    // 缁撴潫骞崇Щ鍜屾竻鐞嗗畾鏃跺櫒
    _transformationDebouncer?.cancel();
    setState(() {
      _isPanning = false;
      _lastPanPosition = null;
    });

    final scale = _transformer?.currentScale ?? 1.0;
    setState(() {
      _isZoomed = scale > 1.05;
    });
  }

  void _handleInteractionStart(ScaleStartDetails details) {
    final toolMode = ref.read(toolModeProvider);
    final isPanMode = toolMode == Tool.pan;

    // 濡傛灉鏄嫋鎷藉伐鍏锋ā寮忥紝鍚敤骞崇Щ
    if (isPanMode) {
      setState(() {
        _isPanning = true;
        _lastPanPosition = details.localFocalPoint;
      });
    }
  }

  void _handleInteractionUpdate(ScaleUpdateDetails details) {
    final toolMode = ref.read(toolModeProvider);
    final isPanMode = toolMode == Tool.pan;

    // 濡傛灉鏄嫋鎷藉伐鍏锋ā寮忎笖姝ｅ湪骞崇Щ锛屽鐞嗗钩绉婚€昏緫
    if (isPanMode && _isPanning && _lastPanPosition != null) {
      final delta = details.localFocalPoint - _lastPanPosition!;
      final matrix = _transformationController.value.clone();
      matrix.translate(delta.dx, delta.dy);
      _transformationController.value = matrix;
      _lastPanPosition = details.localFocalPoint;
    }

    // 娣诲姞闃叉姈浠ラ伩鍏嶉绻佹洿鏂扮姸鎬?
    _transformationDebouncer?.cancel();
    _transformationDebouncer = Timer(const Duration(milliseconds: 16), () {
      if (!_mounted) return;
      final scale = _transformer?.currentScale ?? 1.0;
      setState(() {
        _isZoomed = scale > 1.05;
      });
    });
  }

  KeyEventResult _handleKeyEvent(FocusNode node, KeyEvent event) {
    if (event is! KeyDownEvent) {
      return KeyEventResult.ignored;
    }

    // Debug妯″紡鍒囨崲 (Alt+D)
    if (event.logicalKey == LogicalKeyboardKey.keyD &&
        HardwareKeyboard.instance.isAltPressed) {
      ref.read(debugOptionsProvider.notifier).toggleDebugMode();
      return KeyEventResult.handled;
    }

    // ESC閿€€鍑鸿皟鏁存ā寮?
    if (event.logicalKey == LogicalKeyboardKey.escape && _isAdjusting) {
      // 閫€鍑鸿皟鏁存ā寮?
      _cancelAdjustment();
      return KeyEventResult.handled;
    }

    // 宸ュ叿鍒囨崲蹇嵎閿?
    if (!HardwareKeyboard.instance.isControlPressed &&
        !HardwareKeyboard.instance.isAltPressed) {
      switch (event.logicalKey) {
        case LogicalKeyboardKey.keyV:
          ref.read(toolModeProvider.notifier).setMode(Tool.pan);
          return KeyEventResult.handled;
        case LogicalKeyboardKey.keyR:
          ref.read(toolModeProvider.notifier).setMode(Tool.select);
          return KeyEventResult.handled;
        case LogicalKeyboardKey.keyM:
          ref.read(toolModeProvider.notifier).setMode(Tool.multiSelect);
          return KeyEventResult.handled;
      }
    }

    // 閫夊尯鎿嶄綔蹇嵎閿?
    if (_adjustingRegionId != null) {
      // 寰皟 (Shift 鏃剁Щ鍔ㄨ窛绂绘洿澶?
      final delta = HardwareKeyboard.instance.isShiftPressed ? 10.0 : 1.0;
      Rect? newRect;

      switch (event.logicalKey) {
        case LogicalKeyboardKey.arrowLeft:
          newRect = _adjustingRect?.translate(-delta, 0);
          break;
        case LogicalKeyboardKey.arrowRight:
          newRect = _adjustingRect?.translate(delta, 0);
          break;
        case LogicalKeyboardKey.arrowUp:
          newRect = _adjustingRect?.translate(0, -delta);
          break;
        case LogicalKeyboardKey.arrowDown:
          newRect = _adjustingRect?.translate(0, delta);
          break;
        case LogicalKeyboardKey.delete:
        case LogicalKeyboardKey.backspace:
          if (_adjustingRegionId != null) {
            // 鏄剧ず纭瀵硅瘽妗?
            _requestDeleteRegion(_adjustingRegionId!);
            return KeyEventResult.handled;
          }
          break;
        default:
          break;
      }

      if (newRect != null) {
        _updateAdjustingRegion(newRect);
        return KeyEventResult.handled;
      }
    }

    // 鍒犻櫎宸查€変腑鍖哄煙 (Delete/Backspace)
    if (!_isAdjusting &&
        (event.logicalKey == LogicalKeyboardKey.delete ||
            event.logicalKey == LogicalKeyboardKey.backspace)) {
      final selectedIds = ref.read(characterCollectionProvider).selectedIds;
      if (selectedIds.isNotEmpty) {
        // 鏄剧ず纭瀵硅瘽妗?
        _requestDeleteSelectedRegions();
        return KeyEventResult.handled;
      }
    }

    return KeyEventResult.ignored;
  }

  // 澶勭悊榧犳爣绉诲姩锛屾洿鏂版偓鍋滅姸鎬?
  void _handleMouseMove(PointerHoverEvent event) {
    if (_isAdjusting && _adjustingRect != null) {
      final handleIndex = _getHandleIndexFromPosition(event.localPosition);
      setState(() {
        _hoveredHandleIndex = handleIndex;
      });
    }
  }

  void _handlePanEnd(DragEndDetails details) {
    if (ref.read(toolModeProvider) != Tool.pan) return;

    setState(() {
      _isPanning = false;
      _lastPanPosition = null;
    });
  }

  // 澶勭悊鎷栨嫿宸ュ叿鐨勬嫋鎷芥搷浣?
  void _handlePanStart(DragStartDetails details) {
    if (ref.read(toolModeProvider) != Tool.pan) return;

    setState(() {
      _isPanning = true;
      _lastPanPosition = details.localPosition;
    });
  }

  void _handlePanUpdate(DragUpdateDetails details) {
    if (!_isPanning || ref.read(toolModeProvider) != Tool.pan) return;

    if (_lastPanPosition != null) {
      final delta = details.localPosition - _lastPanPosition!;
      final matrix = _transformationController.value.clone();
      matrix.translate(delta.dx, delta.dy);
      _transformationController.value = matrix;
      _lastPanPosition = details.localPosition;
    }
  }

  void _handlePointerSignal(PointerSignalEvent event) {
    if (event is! PointerScrollEvent) return;

    try {
      // 鑾峰彇榧犳爣鐩稿浜庤鍙ｇ殑浣嶇疆
      final box = context.findRenderObject() as RenderBox;
      final localPosition = box.globalToLocal(event.position);
      final delta = event.scrollDelta.dy;

      // 璁＄畻鐩爣缂╂斁姣斾緥
      final currentScale = _transformer?.currentScale ?? 1.0;
      final baseScale = _transformer?.baseScale ?? 1.0;
      var targetScale = (currentScale - delta * 0.001).clamp(0.1, 10.0);

      if (targetScale < baseScale * 0.2) {
        targetScale = baseScale * 0.2;
      }

      final scaleChange = targetScale / currentScale;

      if (delta.abs() > 0) {
        setState(() {
          // 鑾峰彇褰撳墠鍙樻崲鐭╅樀骞跺簲鐢ㄧ缉鏀?
          final matrix = Matrix4.copy(_transformationController.value);

          // 绉诲姩鍘熺偣鍒伴紶鏍囦綅缃?
          matrix.translate(localPosition.dx, localPosition.dy);
          matrix.scale(scaleChange, scaleChange);
          matrix.translate(-localPosition.dx, -localPosition.dy);

          _transformationController.value = matrix;
          _isZoomed = targetScale > 1.05;
        });

        AppLogger.debug('缂╂斁鍙樻崲', data: {
          'scale': targetScale,
          'mousePosition': '${localPosition.dx},${localPosition.dy}'
        });
      }
    } catch (e) {
      AppLogger.error('婊氳疆缂╂斁澶辫触', error: e);
    }
  }

  Future<void> _handleRegionCreated(Rect rect) async {
    try {
      AppLogger.debug('妗嗛€夊畬鎴愶紝鍒涘缓鏂伴€夊尯', data: {
        'rect': '${rect.left},${rect.top},${rect.width}x${rect.height}',
      });

      // 1. 鍒涘缓閫夊尯 (Notifier 浼氳缃?isAdjusting = true)
      final notifier = ref.read(characterCollectionProvider.notifier);
      notifier.createRegion(rect);

      // 2. 娓呯悊涓存椂鐨勯€夊尯鐘舵€?
      setState(() {
        _lastCompletedSelection = null;
        _hasCompletedSelection = false;
        _selectionStart = null;
        _selectionCurrent = null;
      });

      // 3. 涓嶅啀闇€瑕佸湪姝ゅ鐩存帴璋冪敤 _activateAdjustmentMode
      //    鐘舵€佸悓姝ュ皢鍦?ref.listen 涓鐞?
      // if (newRegion != null && _mounted) {
      //   AppLogger.debug('鏂伴€夊尯鍒涘缓鎴愬姛锛岀珛鍗宠繘鍏ヨ皟鏁存ā寮?,
      //       data: {'newRegionId': newRegion.id});
      //   _activateAdjustmentMode(newRegion);
      // } else {
      //   AppLogger.warning('鍒涘缓閫夊尯鍚庢湭鑳借幏鍙栨柊Region瀵硅薄鎴栫粍浠跺凡鍗歌浇');
      // }
    } catch (e, stack) {
      AppLogger.error('鍒涘缓閫夊尯澶辫触', error: e, stackTrace: stack);
      // 娓呯悊閫夊尯鐘舵€佷互闃蹭竾涓€
      _resetSelectionState();
    }
  }

  void _handleRegionTap(String id) {
    // 浣跨敤CharacterCollectionNotifier鐨勬墿灞曟柟娉曞鐞嗗尯鍩熺偣鍑?
    ref.read(characterCollectionProvider.notifier).handleRegionClick(id);
  }

  void _handleSelectionEnd(DragEndDetails details) {
    if (!_isInSelectionMode ||
        _selectionStart == null ||
        _selectionCurrent == null) {
      _resetSelectionState();
      return;
    }

    try {
      final dragDistance = (_selectionCurrent! - _selectionStart!).distance;
      if (dragDistance < 5) {
        _resetSelectionState();
        return;
      }

      // 鐩存帴浣跨敤榧犳爣浣嶇疆鍒涘缓瑙嗗彛涓殑鐭╁舰
      final viewportRect =
          Rect.fromPoints(_selectionStart!, _selectionCurrent!);

      // 灏嗚鍙ｇ煩褰㈣浆鎹负鍥惧儚鍧愭爣绯讳腑鐨勭煩褰?
      final rect = _transformer!.viewportRectToImageRect(viewportRect);

      AppLogger.debug('妗嗛€夌煩褰?, data: {
        'viewport':
            '${viewportRect.left},${viewportRect.top},${viewportRect.width}x${viewportRect.height}',
        'image': '${rect.left},${rect.top},${rect.width}x${rect.height}'
      });

      if (rect.width >= 20.0 && rect.height >= 20.0) {
        _handleRegionCreated(rect);
      }

      // 瀹屽叏閲嶇疆閫夊尯鐘舵€?
      _resetSelectionState();
    } catch (e) {
      AppLogger.error('銆愭閫夎皟璇曘€戝彂鐢熼敊璇?, error: e);
      _resetSelectionState();
    }
  }

  void _handleSelectionStart(DragStartDetails details) {
    // If starting a new selection while adjusting, cancel the current adjustment first.
    if (_isAdjusting) {
      _cancelAdjustment();
    }

    if (!_isInSelectionMode) return;

    // 妫€鏌ユ槸鍚﹀綋鍓嶆湁鍖哄煙澶勪簬璋冩暣鐘舵€?
    final collectionState = ref.read(characterCollectionProvider);
    if (collectionState.isAdjusting) {
      // 浣跨敤Provider API閫€鍑鸿皟鏁存ā寮?
      ref.read(characterCollectionProvider.notifier).setAdjusting(false);
    }

    setState(() {
      _selectionStart = details.localPosition;
      _selectionCurrent = details.localPosition;
      _hasCompletedSelection = false;
      _lastCompletedSelection = null;
    });
  }

  void _handleSelectionUpdate(DragUpdateDetails details) {
    if (!_isInSelectionMode || _selectionStart == null) return;

    setState(() {
      _selectionCurrent = details.localPosition;
    });
  }

  // 妫€娴嬬偣鍑绘槸鍚﹀湪鎺у埗鐐逛笂
  int? _hitTestHandle(Offset position) {
    if (_adjustingRect == null || _transformer == null) return null;

    final viewportRect = _transformer!.imageRectToViewportRect(_adjustingRect!);
    final handles = [
      viewportRect.topLeft,
      viewportRect.topCenter,
      viewportRect.topRight,
      viewportRect.centerRight,
      viewportRect.bottomRight,
      viewportRect.bottomCenter,
      viewportRect.bottomLeft,
      viewportRect.centerLeft,
    ];

    for (var i = 0; i < handles.length; i++) {
      final handleRect = Rect.fromCenter(
        center: handles[i],
        width: 16,
        height: 16,
      );
      if (handleRect.contains(position)) {
        return i;
      }
    }
    return null;
  }

  // 妫€娴嬬偣鍑讳綅缃槸鍚﹀湪閫夊尯鍐?
  CharacterRegion? _hitTestRegion(
      Offset position, List<CharacterRegion> regions) {
    if (_transformer == null) return null;

    // 浠庡悗鍚戝墠妫€娴嬶紝浣挎渶涓婂眰鐨勯€夊尯浼樺厛鍝嶅簲
    for (final region in regions.reversed) {
      final rect = _transformer!.imageRectToViewportRect(region.rect);
      if (_isPointInRotatedRect(position, rect, region.rotation)) {
        return region;
      }
    }
    return null;
  }

  void _initializeView() {
    if (!_mounted) return;

    // 閲嶇疆鍙樻崲鎺у埗鍣?
    _transformationController.value = Matrix4.identity();

    WidgetsBinding.instance.addPostFrameCallback((_) {
      // 閲嶇疆鎵€鏈夌姸鎬?
      setState(() {
        _isFirstLoad = true;
        _isZoomed = false;
        _isPanning = false;
        _lastImageId = null;

        // 娓呯悊transformer鐩稿叧鐘舵€?
        if (_transformer != null) {
          _transformer = null;
        }
      });

      // 妫€鏌ュ綋鍓嶅浘鍍忕姸鎬?
      final imageState = ref.read(workImageProvider);
      AppLogger.debug('瑙嗗浘鍒濆鍖?, data: {
        'hasValidImage': imageState.hasValidImage,
        'imageSize': imageState.hasValidImage
            ? '${imageState.imageWidth}x${imageState.imageHeight}'
            : 'none'
      });
    });
  }

  // Helper to determine if a point is inside a rotated rectangle
  bool _isPointInRotatedRect(Offset point, Rect rect, double rotation) {
    if (rotation == 0) return rect.contains(point);

    final center = rect.center;

    // Translate to origin
    final dx = point.dx - center.dx;
    final dy = point.dy - center.dy;

    // Rotate back (apply inverse rotation)
    final cos = math.cos(-rotation);
    final sin = math.sin(-rotation);

    final rotatedX = dx * cos - dy * sin + center.dx;
    final rotatedY = dx * sin + dy * cos + center.dy;

    // Check if rotated point is in original rect
    return rect.contains(Offset(rotatedX, rotatedY));
  }

  // 澶勭悊鐢诲竷鐐瑰嚮
  void _onTapUp(TapUpDetails details) {
    final characterCollection = ref.read(characterCollectionProvider);
    final regions = characterCollection.regions; // 鑾峰彇鍖哄煙鍒楄〃
    final hitRegion = _hitTestRegion(details.localPosition, regions);

    AppLogger.debug('鐢诲竷鐐瑰嚮 (_onTapDown)', data: {
      'position':
          '${details.localPosition.dx.toStringAsFixed(1)},${details.localPosition.dy.toStringAsFixed(1)}',
      'hitRegionId': hitRegion?.id ?? 'null',
      'isAdjusting': characterCollection.isAdjusting,
      'hasTool': _isInSelectionMode ? 'true' : 'false',
      'toolMode': _isInSelectionMode ? Tool.select.toString() : 'null',
    });

    if (characterCollection.isAdjusting && hitRegion == null) {
      // 濡傛灉姝ｅ湪璋冩暣鍖哄煙涓旂偣鍑荤┖鐧斤紝鍒欏彇娑堣皟鏁?
      AppLogger.debug('鐐瑰嚮绌虹櫧澶勪笖isAdjusting涓簍rue锛岃皟鐢╛handleBlankAreaTap()');
      _handleBlankAreaTap();
      return;
    }
    if (characterCollection.currentTool == Tool.pan && hitRegion == null) {
      // 濡傛灉鐐瑰嚮绌虹櫧澶勪笖褰撳墠澶勪簬Pan妯″紡锛屾竻闄ら€夋嫨鐘舵€?
      ref.read(characterCollectionProvider.notifier).selectRegion(null);
      return;
    }
    if (hitRegion != null) {
      // 濡傛灉鐐瑰嚮浜嗗尯鍩燂紝澶勭悊鍖哄煙鐐瑰嚮浜嬩欢
      _handleRegionTap(hitRegion.id);
      return;
    }
  }

  /// 澶勭悊鍙樻崲鐭╅樀鍙樺寲浜嬩欢
  void _onTransformationChanged() {
    if (!_isAdjusting || _originalRegion == null || _transformer == null)
      return;

    // 浣跨敤闃叉姈澶勭悊棰戠箒鐨勫彉鎹㈡洿鏂?
    _transformationDebouncer?.cancel();
    _transformationDebouncer = Timer(const Duration(milliseconds: 16), () {
      if (!_mounted) return;

      // 璁＄畻鏂扮殑瑙嗗彛鐭╁舰
      final newRect =
          _transformer!.imageRectToViewportRect(_originalRegion!.rect);

      // 鍙湪浣嶇疆鎴栧ぇ灏忔湁鏄捐憲鍙樺寲鏃舵洿鏂?
      if (_adjustingRect == null ||
          (newRect.left - _adjustingRect!.left).abs() > 0.1 ||
          (newRect.top - _adjustingRect!.top).abs() > 0.1 ||
          (newRect.width - _adjustingRect!.width).abs() > 0.1 ||
          (newRect.height - _adjustingRect!.height).abs() > 0.1) {
        setState(() {
          _adjustingRect = newRect;
          if (_guideLines != null) {
            _guideLines = _calculateGuideLines(newRect);
          }
        });

        AppLogger.debug('鍙樻崲鏇存柊閫夊尯', data: {
          'scale': _transformer!.currentScale.toStringAsFixed(2),
          'rect':
              '${newRect.width.toStringAsFixed(1)}x${newRect.height.toStringAsFixed(1)}',
          'position':
              '${newRect.left.toStringAsFixed(1)},${newRect.top.toStringAsFixed(1)}'
        });
      }
    });
  }

  // 璇锋眰鍒犻櫎鍗曚釜鍖哄煙锛堟樉绀虹‘璁ゅ璇濇锛?
  Future<void> _requestDeleteRegion(String id) async {
    final regions = ref.read(characterCollectionProvider).regions;
    final region = regions.firstWhere((r) => r.id == id,
        orElse: () => throw Exception('鎵句笉鍒板尯鍩?));

    // 鍙湁淇濆瓨鏍囧織涓簍rue鐨勫尯鍩熸墠闇€瑕佺‘璁?
    bool confirmed = true;
    if (region.isSaved) {
      // 鏄剧ず纭瀵硅瘽妗?
      confirmed = await DeleteConfirmationDialog.show(context);
    }

    if (confirmed) {
      // 鐢ㄦ埛纭鍒犻櫎锛屾墽琛屽垹闄ゆ搷浣?
      if (_mounted) {
        await ref.read(characterCollectionProvider.notifier).deleteRegion(id);

        // 纭繚閲嶇疆璋冩暣鐘舵€?
        _resetAdjustmentState();
      }
    }
  }

  // 璇锋眰鍒犻櫎閫変腑鐨勫尯鍩燂紙鏄剧ず纭瀵硅瘽妗嗭級
  Future<void> _requestDeleteSelectedRegions() async {
    final state = ref.read(characterCollectionProvider);
    final selectedIds = state.selectedIds.toList();
    if (selectedIds.isEmpty) return;

    // 妫€鏌ユ槸鍚︽湁宸蹭繚瀛樼殑鍖哄煙
    final regions = state.regions;
    final savedRegions =
        regions.where((r) => selectedIds.contains(r.id) && r.isSaved).toList();

    bool confirmed = true;
    if (savedRegions.isNotEmpty) {
      // 鍙湁褰撻€変腑鐨勫尯鍩熶腑鏈夊凡淇濆瓨鐨勫尯鍩熸椂鎵嶆樉绀虹‘璁ゅ璇濇
      confirmed = await DeleteConfirmationDialog.show(
        context,
        count: savedRegions.length,
        isBatch: savedRegions.length > 1,
      );
    }

    if (confirmed) {
      // 鐢ㄦ埛纭鍒犻櫎锛屾墽琛屽垹闄ゆ搷浣?
      if (_mounted) {
        await ref
            .read(characterCollectionProvider.notifier)
            .deleteBatchRegions(selectedIds);

        // 纭繚閲嶇疆璋冩暣鐘舵€?
        _resetAdjustmentState();
      }
    }
  }

  // Helper to reset adjustment-specific state
  void _resetAdjustmentState() {
    setState(() {
      _isAdjusting = false;
      _adjustingRegionId = null;
      _activeHandleIndex = null;
      _guideLines = null;
      _originalRegion = null;
      _adjustingRect = null;
      _isRotating = false;
      _currentRotation = 0.0;
      _rotationCenter = null;
      _hoveredHandleIndex = null; // Important reset
    });
  }

  /// 閲嶇疆鎵€鏈夐€夊尯鐩稿叧鐘舵€?
  void _resetSelectionState() {
    if (_isAdjusting) {
      // 閬垮厤鍦╞uild杩囩▼涓慨鏀筽rovider鐘舵€?
      if (_originalRegion != null) {
        Future(() {
          if (_mounted) {
            ref
                .read(characterCollectionProvider.notifier)
                .updateSelectedRegion(_originalRegion!);
          }
        });
      }

      setState(() {
        _isAdjusting = false;
        _adjustingRegionId = null;
        _activeHandleIndex = null;
        _guideLines = null;
        _originalRegion = null;
        _adjustingRect = null;
        _isRotating = false;
        _currentRotation = 0.0;
        _rotationCenter = null;
      });
    }

    setState(() {
      _selectionStart = null;
      _selectionCurrent = null;
      _lastCompletedSelection = null;
      _hasCompletedSelection = false;
      _activeHandleIndex = null;
      _hoveredRegionId = null;
    });
  }

  void _resetView({bool animate = true}) {
    if (_transformer == null) return;

    // 浣跨敤_setInitialScale鏉ュ鐞嗙缉鏀?
    _setInitialScale(
      imageSize: _transformer!.imageSize,
      viewportSize: _transformer!.viewportSize,
    );

    setState(() {
      _isZoomed = false;
    });
  }

  /// 璁剧疆鍥惧儚鍒濆缂╂斁浠ラ€傚簲瑙嗗彛
  void _setInitialScale({
    required Size imageSize,
    required Size viewportSize,
  }) {
    // 閬垮厤閲嶅璋冪敤鍔ㄧ敾璁剧疆
    if (_animationController != null && _animationController!.isAnimating) {
      AppLogger.debug('鍔ㄧ敾宸插湪杩涜涓紝璺宠繃缂╂斁璁剧疆');
      return;
    }

    try {
      // 璁＄畻鍩虹缂╂斁姣斾緥锛氬搴?楂樺害閫傞厤妯″紡锛屽彇杈冨皬鍊间互纭繚瀹屾暣鏄剧ず
      final double widthScale = viewportSize.width / imageSize.width;
      final double heightScale = viewportSize.height / imageSize.height;
      final scale = math.min(widthScale, heightScale);

      // 璁＄畻灞呬腑鍋忕Щ
      final double offsetX = (viewportSize.width - imageSize.width * scale) / 2;
      final double offsetY =
          (viewportSize.height - imageSize.height * scale) / 2;

      // 鏋勫缓鍙樻崲鐭╅樀
      final targetMatrix = Matrix4.identity()
        ..translate(offsetX, offsetY)
        ..scale(scale, scale, 1.0);

      // 浣跨敤鍔ㄧ敾骞虫粦杩囨浮
      if (_animationController != null) {
        _animationController!.dispose();
      }

      _animationController = AnimationController(
        duration: const Duration(milliseconds: 300),
        vsync: this,
      );

      final animation = Matrix4Tween(
        begin: _transformationController.value,
        end: targetMatrix,
      ).animate(CurvedAnimation(
        parent: _animationController!,
        curve: Curves.easeOutCubic,
      ));

      animation.addListener(() {
        if (_mounted) {
          _transformationController.value = animation.value;
        }
      });

      animation.addStatusListener((status) {
        if (status == AnimationStatus.completed) {
          _animationController?.dispose();
          _animationController = null;
        }
      });

      _animationController!.forward();

      AppLogger.debug('璁剧疆鍒濆缂╂斁', data: {
        'scale': scale.toStringAsFixed(3),
        'imageSize': '${imageSize.width}x${imageSize.height}',
        'viewportSize': '${viewportSize.width}x${viewportSize.height}',
        'offset': '${offsetX.toStringAsFixed(1)},${offsetY.toStringAsFixed(1)}'
      });
    } catch (e) {
      AppLogger.error('璁剧疆鍒濆缂╂斁澶辫触', error: e);
    }
  }

  Future<void> _tryLoadCharacterData() async {
    if (!_mounted) return;

    final imageState = ref.read(workImageProvider);
    final currentImageId = '${imageState.workId}-${imageState.currentPageId}';

    try {
      // 鐘舵€佹鏌ュ拰璁板綍
      AppLogger.debug('鍑嗗鍔犺浇閫夊尯鏁版嵁', data: {
        'currentImageId': currentImageId,
        'lastImageId': _lastImageId,
        'hasValidImage': imageState.hasValidImage,
        'workId': imageState.workId,
        'pageId': imageState.currentPageId,
      });

      // 楠岃瘉鏉′欢
      if (!imageState.hasValidImage ||
          imageState.workId.isEmpty ||
          imageState.currentPageId.isEmpty) {
        AppLogger.debug('鍔犺浇鏉′欢涓嶆弧瓒筹紝璺宠繃閫夊尯鏁版嵁鍔犺浇');
        return;
      }

      // 閬垮厤閲嶅鍔犺浇
      if (currentImageId == _lastImageId) {
        AppLogger.debug('妫€娴嬪埌閲嶅鍔犺浇璇锋眰锛岃烦杩?, data: {'imageId': currentImageId});
        return;
      }

      // 鍔犺浇鏂版暟鎹?
      AppLogger.debug('寮€濮嬪姞杞芥柊閫夊尯鏁版嵁', data: {
        'workId': imageState.workId,
        'pageId': imageState.currentPageId,
      });

      await ref.read(characterCollectionProvider.notifier).loadWorkData(
            imageState.workId,
            pageId: imageState.currentPageId,
          );

      // 鏇存柊鏍囪骞惰褰?
      if (_mounted) {
        _lastImageId = currentImageId;
        AppLogger.debug('閫夊尯鏁版嵁鍔犺浇瀹屾垚', data: {
          'imageId': currentImageId,
          'regionsCount': ref.read(characterCollectionProvider).regions.length,
        });
      }
    } catch (e, stack) {
      AppLogger.error(
        '鍔犺浇閫夊尯鏁版嵁澶辫触',
        error: e,
        stackTrace: stack,
        data: {'imageId': currentImageId},
      );

      // 鍙褰曢敊璇棩蹇楋紝涓嶆竻鐞嗙姸鎬?
      // loadWorkData鍐呴儴浼氬鐞嗚嚜宸辩殑閿欒鐘舵€?
    }
  }

  // 鏇存柊璋冩暣涓殑閫夊尯
  void _updateAdjustingRegion(Rect newRect) {
    if (_adjustingRegionId == null || _originalRegion == null) return;

    // 妫€鏌ユ渶灏忓昂瀵?
    if (newRect.width < 20 || newRect.height < 20) return;

    setState(() {
      _adjustingRect = newRect;
      _guideLines = _calculateGuideLines(newRect);
    });

    // 涓嶅啀瀹炴椂鏇存柊棰勮锛岃€屽彧鍦╫nPanEnd鏃舵洿鏂板彸渚ч瑙堝尯
  }

  /// 鏇存柊鎴栧垱寤篊oordinateTransformer
  /// 鍙湪蹇呰鏃跺垱寤烘柊鐨勫疄渚嬩互浼樺寲鎬ц兘
  void _updateTransformer({
    required Size imageSize,
    required Size viewportSize,
    required bool enableLogging,
  }) {
    try {
      final needsUpdate = _transformer == null ||
          _transformer!.imageSize != imageSize ||
          _transformer!.viewportSize != viewportSize;

      if (needsUpdate) {
        final oldScale = _transformer?.currentScale;
        final oldTransformer = _transformer;

        _transformer = CoordinateTransformer(
          transformationController: _transformationController,
          imageSize: imageSize,
          viewportSize: viewportSize,
          enableLogging: enableLogging,
        );

        AppLogger.debug('鏇存柊CoordinateTransformer', data: {
          'imageSize': '${imageSize.width}x${imageSize.height}',
          'viewportSize': '${viewportSize.width}x${viewportSize.height}',
          'previousScale': oldScale?.toStringAsFixed(3) ?? 'null',
          'currentScale': _transformer!.currentScale.toStringAsFixed(3),
          'reason': _getUpdateReason(imageSize, viewportSize, oldTransformer),
        });
      }
    } catch (e, stack) {
      AppLogger.error('鏇存柊CoordinateTransformer澶辫触',
          error: e,
          stackTrace: stack,
          data: {
            'imageSize': '${imageSize.width}x${imageSize.height}',
            'viewportSize': '${viewportSize.width}x${viewportSize.height}',
          });
    }
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\character_collection\navigation_bar.dart
-----------------------------------
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../providers/character/character_collection_provider.dart';

class CharacterNavigationBar extends ConsumerWidget {
  final String workId;
  final VoidCallback onBack;
  final VoidCallback? onHelp;

  const CharacterNavigationBar({
    Key? key,
    required this.workId,
    required this.onBack,
    this.onHelp,
  }) : super(key: key);

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final theme = Theme.of(context);
    final collectionState = ref.watch(characterCollectionProvider);

    // 璁＄畻鐘舵€佷俊鎭枃鏈?
    String statusText = '';
    if (collectionState.processing) {
      statusText = '澶勭悊涓?..';
    } else if (collectionState.error != null) {
      statusText = '閿欒锛?{collectionState.error}';
    } else if (collectionState.selectedIds.isNotEmpty) {
      statusText = '宸查€夋嫨 ${collectionState.selectedIds.length} 涓瓧绗?;
    }

    return Container(
      height: 56,
      padding: const EdgeInsets.symmetric(horizontal: 16),
      decoration: BoxDecoration(
        color: theme.colorScheme.surface,
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.1),
            blurRadius: 4,
            offset: const Offset(0, 2),
          ),
        ],
      ),
      child: Row(
        children: [
          // 杩斿洖鎸夐挳
          IconButton(
            icon: const Icon(Icons.arrow_back),
            tooltip: '杩斿洖',
            onPressed: () {
              onBack();
            },
          ),

          const SizedBox(width: 16),

          // 鏍囬
          Text(
            '闆嗗瓧鍔熻兘',
            style: theme.textTheme.titleLarge,
          ),

          // 鐘舵€佹枃鏈紙鏉′欢鏄剧ず锛?
          if (statusText.isNotEmpty) ...[
            const SizedBox(width: 16),
            Container(
              padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 4),
              decoration: BoxDecoration(
                color: collectionState.error != null
                    ? theme.colorScheme.error.withOpacity(0.1)
                    : theme.colorScheme.primary.withOpacity(0.1),
                borderRadius: BorderRadius.circular(16),
              ),
              child: Text(
                statusText,
                style: theme.textTheme.bodyMedium?.copyWith(
                  color: collectionState.error != null
                      ? theme.colorScheme.error
                      : theme.colorScheme.primary,
                ),
              ),
            ),
          ],

          const Spacer(),

          // 甯姪鎸夐挳
          IconButton(
            icon: const Icon(Icons.help_outline),
            tooltip: '甯姪',
            onPressed: onHelp ?? _showHelpDialog,
          ),
        ],
      ),
    );
  }

  void _showHelpDialog() {
    // 鏄剧ず甯姪瀵硅瘽妗嗭紝鍏蜂綋瀹炵幇鍙互娣诲姞鍦ㄦ澶?
  }

  void _showUnsavedChangesDialog(BuildContext context) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('鏈繚瀛樼殑鏇存敼'),
        content: const Text('鎮ㄦ湁鏈繚瀛樼殑鏇存敼锛岀‘瀹氳绂诲紑鍚楋紵'),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(),
            child: const Text('鍙栨秷'),
          ),
          ElevatedButton(
            onPressed: () {
              Navigator.of(context).pop();
              onBack();
            },
            style: ElevatedButton.styleFrom(
              backgroundColor: Colors.red,
              foregroundColor: Colors.white,
            ),
            child: const Text('鏀惧純鏇存敼'),
          ),
        ],
      ),
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\character_collection\pagination_control.dart
-----------------------------------
import 'package:flutter/material.dart';

class PaginationControl extends StatelessWidget {
  final int currentPage;
  final int totalPages;
  final Function(int) onPageChanged;

  const PaginationControl({
    Key? key,
    required this.currentPage,
    required this.totalPages,
    required this.onPageChanged,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 8.0),
      decoration: BoxDecoration(
        border: Border(
          top: BorderSide(color: theme.dividerColor),
        ),
      ),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.spaceBetween,
        children: [
          // 鏄剧ず鑼冨洿鏂囨湰
          Text(
            '鏄剧ず: ${_getDisplayRange()}',
            style: theme.textTheme.bodyMedium,
          ),

          // 鍒嗛〉鎺т欢
          Row(
            children: [
              // 棣栭〉鎸夐挳
              _buildPageButton(
                context,
                1,
                icon: Icons.first_page,
                enabled: currentPage > 1,
              ),

              // 涓婁竴椤垫寜閽?
              _buildPageButton(
                context,
                currentPage - 1,
                icon: Icons.chevron_left,
                enabled: currentPage > 1,
              ),

              // 椤电爜鎸夐挳
              ..._buildPageNumberButtons(context),

              // 涓嬩竴椤垫寜閽?
              _buildPageButton(
                context,
                currentPage + 1,
                icon: Icons.chevron_right,
                enabled: currentPage < totalPages,
              ),

              // 鏈〉鎸夐挳
              _buildPageButton(
                context,
                totalPages,
                icon: Icons.last_page,
                enabled: currentPage < totalPages,
              ),
            ],
          ),
        ],
      ),
    );
  }

  Widget _buildPageButton(BuildContext context, int targetPage,
      {required IconData icon, required bool enabled}) {
    final theme = Theme.of(context);

    return Container(
      margin: const EdgeInsets.symmetric(horizontal: 2),
      child: InkWell(
        onTap: enabled ? () => onPageChanged(targetPage) : null,
        borderRadius: BorderRadius.circular(4),
        child: Container(
          padding: const EdgeInsets.all(6),
          decoration: BoxDecoration(
            borderRadius: BorderRadius.circular(4),
            border: Border.all(
              color: enabled ? theme.dividerColor : theme.disabledColor,
            ),
          ),
          child: Icon(
            icon,
            size: 18,
            color: enabled ? theme.colorScheme.onSurface : theme.disabledColor,
          ),
        ),
      ),
    );
  }

  List<Widget> _buildPageNumberButtons(BuildContext context) {
    final List<Widget> buttons = [];
    final theme = Theme.of(context);

    // 鍐冲畾鏄剧ず鍝簺椤电爜鎸夐挳
    int startPage, endPage;
    if (totalPages <= 5) {
      // 灏戜簬5椤靛叏閮ㄦ樉绀?
      startPage = 1;
      endPage = totalPages;
    } else if (currentPage <= 3) {
      // 褰撳墠椤甸潬杩戝紑濮?
      startPage = 1;
      endPage = 5;
    } else if (currentPage >= totalPages - 2) {
      // 褰撳墠椤甸潬杩戠粨鏉?
      startPage = totalPages - 4;
      endPage = totalPages;
    } else {
      // 褰撳墠椤靛湪涓棿
      startPage = currentPage - 2;
      endPage = currentPage + 2;
    }

    // 鍒涘缓椤电爜鎸夐挳
    for (int i = startPage; i <= endPage; i++) {
      final isCurrentPage = i == currentPage;

      buttons.add(
        Container(
          margin: const EdgeInsets.symmetric(horizontal: 2),
          child: InkWell(
            onTap: isCurrentPage ? null : () => onPageChanged(i),
            borderRadius: BorderRadius.circular(4),
            child: Container(
              padding: const EdgeInsets.symmetric(horizontal: 10, vertical: 6),
              decoration: BoxDecoration(
                color: isCurrentPage ? theme.colorScheme.primary : null,
                borderRadius: BorderRadius.circular(4),
                border: isCurrentPage
                    ? null
                    : Border.all(color: theme.dividerColor),
              ),
              child: Text(
                '$i',
                style: TextStyle(
                  color: isCurrentPage
                      ? theme.colorScheme.onPrimary
                      : theme.colorScheme.onSurface,
                  fontWeight:
                      isCurrentPage ? FontWeight.bold : FontWeight.normal,
                ),
              ),
            ),
          ),
        ),
      );
    }

    return buttons;
  }

  String _getDisplayRange() {
    // 杩欓噷搴旇鏍规嵁瀹為檯姣忛〉鏄剧ず鐨勬暟閲忚绠?
    // 鍋囪姣忛〉16涓」鐩?
    const itemsPerPage = 16;
    final start = (currentPage - 1) * itemsPerPage + 1;
    final end = currentPage * itemsPerPage;
    return '$start-$end / ${totalPages * itemsPerPage}';
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\character_collection\preview_toolbar.dart
-----------------------------------
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../providers/character/character_collection_provider.dart';
import '../../providers/character/tool_mode_provider.dart';

/// 棰勮宸ュ叿鏍?class PreviewToolbar extends ConsumerWidget {
  const PreviewToolbar({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final toolMode = ref.watch(toolModeProvider);
    final hasSelection =
        ref.watch(characterCollectionProvider).selectedIds.isNotEmpty;

    return Material(
      color: Colors.white,
      elevation: 4,
      child: Container(
        height: 48,
        padding: const EdgeInsets.symmetric(horizontal: 8),
        child: Row(
          children: [
            // 宸ュ叿鎸夐挳缁?            _ToolButton(
              icon: Icons.pan_tool,
              tooltip: '鎷栨嫿宸ュ叿 (V)',
              isSelected: toolMode == Tool.pan,
              onPressed: () =>
                  ref.read(toolModeProvider.notifier).setMode(Tool.pan),
            ),
            const SizedBox(width: 4),
            _ToolButton(
              icon: Icons.crop_square,
              tooltip: '妗嗛€夊伐鍏?(R)',
              isSelected: toolMode == Tool.select,
              onPressed: () =>
                  ref.read(toolModeProvider.notifier).setMode(Tool.select),
            ),
            const SizedBox(width: 16),

            // 鍒嗛殧绾?            const VerticalDivider(),
            const SizedBox(width: 8),

            // 鍒犻櫎鎸夐挳
            _ToolButton(
              icon: Icons.delete,
              tooltip: '鍒犻櫎閫変腑鍖哄煙',
              isEnabled: hasSelection,
              onPressed: hasSelection
                  ? () {
                      final selectedIds =
                          ref.read(characterCollectionProvider).selectedIds;
                      ref
                          .read(characterCollectionProvider.notifier)
                          .deleteBatchRegions(selectedIds.toList());
                    }
                  : null,
            ),
          ],
        ),
      ),
    );
  }
}

/// 宸ュ叿鎸夐挳
class _ToolButton extends StatelessWidget {
  final IconData icon;
  final String tooltip;
  final bool isSelected;
  final bool isEnabled;
  final VoidCallback? onPressed;

  const _ToolButton({
    required this.icon,
    required this.tooltip,
    this.isSelected = false,
    this.isEnabled = true,
    this.onPressed,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Tooltip(
      message: tooltip,
      child: IconButton(
        icon: Icon(icon),
        onPressed: isEnabled ? onPressed : null,
        style: IconButton.styleFrom(
          backgroundColor:
              isSelected ? theme.colorScheme.primary.withOpacity(0.1) : null,
          foregroundColor: isSelected
              ? theme.colorScheme.primary
              : isEnabled
                  ? theme.colorScheme.onSurface
                  : theme.colorScheme.onSurface.withOpacity(0.38),
        ),
      ),
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\character_collection\regions_painter.dart
-----------------------------------
import 'package:flutter/material.dart';

import '../../../domain/models/character/character_region.dart';
import '../../../domain/models/character/character_region_state.dart';
import '../../../presentation/providers/character/tool_mode_provider.dart';
import '../../../utils/coordinate_transformer.dart';
import 'regions_state_utils.dart';

class RegionsPainter extends CustomPainter {
  final List<CharacterRegion> regions;
  final Set<String> selectedIds;
  final Set<String> modifiedIds; // 鏈繚瀛橈紙宸蹭慨鏀癸級鐨勫尯鍩烮D闆嗗悎
  final CoordinateTransformer transformer;
  final String? hoveredId;
  final String? adjustingRegionId; // 褰撳墠姝ｅ湪璋冩暣鐨勫尯鍩烮D
  final Tool currentTool; // 褰撳墠宸ュ叿妯″紡
  final bool isAdjusting; // 鏄惁澶勪簬璋冩暣鐘舵€?

  const RegionsPainter({
    required this.regions,
    required this.selectedIds,
    required this.transformer,
    this.modifiedIds = const {}, // 榛樿涓虹┖闆嗗悎
    this.hoveredId,
    this.adjustingRegionId, // 鎺ユ敹璋冩暣涓殑鍖哄煙ID
    required this.currentTool, // 褰撳墠宸ュ叿妯″紡
    this.isAdjusting = false, // 鏄惁澶勪簬璋冩暣鐘舵€?
  });

  @override
  void paint(Canvas canvas, Size size) {
    // 璁剧疆瑁佸壀鍖哄煙
    canvas.clipRect(Offset.zero & size);

    try {
      // 璁＄畻鍙鍖哄煙
      final viewportBounds = Rect.fromLTWH(0, 0, size.width, size.height);

      // // 璋冭瘯杈撳嚭鍏抽敭缁樺埗鍙傛暟
      // AppLogger.debug('RegionsPainter - 鍏抽敭缁樺埗鍙傛暟', data: {
      //   'currentTool': currentTool.toString(),
      //   'isAdjusting': isAdjusting,
      //   'selectedIds': selectedIds.toString(),
      //   'adjustingRegionId': adjustingRegionId ?? 'null'
      // });

      for (final region in regions) {
        // 濡傛灉鍖哄煙姝ｅ湪琚叾浠栫粍浠惰皟鏁达紝鍒欒烦杩囩粯鍒?
        if (region.id == adjustingRegionId) {
          continue;
        }

        try {
          // 杞崲鍧愭爣
          final viewportRect = transformer.imageRectToViewportRect(region.rect);

          // 妫€鏌ユ槸鍚﹀湪鍙鍖哄煙鍐?
          if (!viewportRect.overlaps(viewportBounds)) {
            continue; // 璺宠繃涓嶅彲瑙佺殑鍖哄煙
          }

          // 纭畾鍖哄煙鐘舵€?
          final isSelected = selectedIds.contains(region.id);
          final isHovered = region.id == hoveredId;
          final isRegionAdjusting =
              isAdjusting && region.id == adjustingRegionId;
          final isSaved = !modifiedIds.contains(region.id);

          // AppLogger.debug('RegionsPainter - 鍖哄煙鐘舵€佽绠?, data: {
          //   'regionId': region.id,
          //   'isSelected': isSelected,
          //   'isHovered': isHovered,
          //   'isRegionAdjusting': isRegionAdjusting,
          //   'isSaved': isSaved,
          //   'modifiedIds': modifiedIds.toList(),
          //   'selectedIds': selectedIds.toList(),
          //   'isAdjusting': isAdjusting,
          //   'adjustingRegionId': adjustingRegionId,
          // });

          // 鑾峰彇鍖哄煙鐘舵€?
          final regionState = RegionStateUtils.getRegionState(
            currentTool: currentTool,
            isSelected: isSelected,
            isAdjusting: isRegionAdjusting,
          );

          // AppLogger.debug('RegionsPainter - 鍖哄煙鐘舵€佺‘瀹?, data: {
          //   'regionId': region.id,
          //   'regionState': regionState.toString(),
          //   'currentTool': currentTool.toString(),
          // });

          // 鑾峰彇棰滆壊鐢ㄤ簬鏃ュ織
          final Color finalBorderColor = RegionStateUtils.getBorderColor(
            state: regionState,
            isSaved: isSaved,
            isHovered: isHovered,
          );
          final Color finalFillColor = RegionStateUtils.getFillColor(
            state: regionState,
            isSaved: isSaved,
            isHovered: isHovered,
          );

          // // 绮剧畝鏃ュ織锛屽彧璁板綍閫変腑鎴栬皟鏁翠腑鐨勫尯鍩?
          // if (isSelected || isRegionAdjusting) {
          //   AppLogger.debug('RegionsPainter - Key Region State', data: {
          //     'regionId': region.id,
          //     'isSelected': isSelected,
          //     'isAdjusting': isRegionAdjusting,
          //     'isSaved': isSaved,
          //     'tool': currentTool.toString(),
          //     'regionState': regionState.toString(),
          //     'borderColor': _colorToString(finalBorderColor),
          //   });
          // }

          // 缁樺埗閫夊尯
          _drawRegion(
            canvas,
            viewportRect,
            region,
            regions.indexOf(region) + 1,
            regionState,
            isSelected,
            isHovered,
            isSaved,
          );
        } catch (e, stack) {
          debugPrint('鍖哄煙缁樺埗澶辫触: ${region.id}, error: $e\n$stack');
        }
      }
    } catch (e, stack) {
      debugPrint('RegionsPainter缁樺埗澶辫触: $e\n$stack');
    }
  }

  @override
  bool shouldRepaint(RegionsPainter oldDelegate) {
    return oldDelegate.regions != regions ||
        oldDelegate.selectedIds != selectedIds ||
        oldDelegate.modifiedIds != modifiedIds ||
        oldDelegate.transformer != transformer ||
        oldDelegate.hoveredId != hoveredId ||
        oldDelegate.currentTool != currentTool ||
        oldDelegate.adjustingRegionId != adjustingRegionId ||
        oldDelegate.isAdjusting != isAdjusting;
  }

  String _colorToString(Color color) {
    return 'rgba(${color.red}, ${color.green}, ${color.blue}, ${color.alpha})';
  }

  void _drawHandles(Canvas canvas, Rect rect, bool isActive) {
    final handlePositions = [
      rect.topLeft,
      rect.topCenter,
      rect.topRight,
      rect.centerRight,
      rect.bottomRight,
      rect.bottomCenter,
      rect.bottomLeft,
      rect.centerLeft,
    ];

    final handlePaths = handlePositions.map((pos) {
      return Path()
        ..addRect(Rect.fromCenter(
          center: pos,
          width: 8.0,
          height: 8.0,
        ));
    }).toList();

    // 鎵归噺缁樺埗鐧借壊濉厖
    canvas.drawPath(
      Path.combine(
        PathOperation.union,
        handlePaths[0],
        Path.combine(
          PathOperation.union,
          handlePaths[1],
          Path.combine(
            PathOperation.union,
            handlePaths[2],
            Path.combine(
              PathOperation.union,
              handlePaths[3],
              Path.combine(
                PathOperation.union,
                handlePaths[4],
                Path.combine(
                  PathOperation.union,
                  handlePaths[5],
                  Path.combine(
                    PathOperation.union,
                    handlePaths[6],
                    handlePaths[7],
                  ),
                ),
              ),
            ),
          ),
        ),
      ),
      Paint()
        ..color = Colors.white
        ..style = PaintingStyle.fill,
    );

    // 鎵归噺缁樺埗钃濊壊杈规
    canvas.drawPath(
      Path.combine(
        PathOperation.union,
        handlePaths[0],
        Path.combine(
          PathOperation.union,
          handlePaths[1],
          Path.combine(
            PathOperation.union,
            handlePaths[2],
            Path.combine(
              PathOperation.union,
              handlePaths[3],
              Path.combine(
                PathOperation.union,
                handlePaths[4],
                Path.combine(
                  PathOperation.union,
                  handlePaths[5],
                  Path.combine(
                    PathOperation.union,
                    handlePaths[6],
                    handlePaths[7],
                  ),
                ),
              ),
            ),
          ),
        ),
      ),
      Paint()
        ..color = Colors.blue
        ..style = PaintingStyle.stroke
        ..strokeWidth = 1.0,
    );
  }

  void _drawRegion(
    Canvas canvas,
    Rect viewportRect,
    CharacterRegion region,
    int index,
    CharacterRegionState regionState,
    bool isSelected,
    bool isHovered,
    bool isSaved,
  ) {
    // 浣跨敤RegionStateUtils鑾峰彇棰滆壊
    final Color borderColor = RegionStateUtils.getBorderColor(
      state: regionState,
      isSaved: isSaved,
      isHovered: isHovered,
    );

    final Color fillColor = RegionStateUtils.getFillColor(
      state: regionState,
      isSaved: isSaved,
      isHovered: isHovered,
    );

    final fillPaint = Paint()
      ..color = fillColor
      ..style = PaintingStyle.fill;

    final borderPaint = Paint()
      ..color = borderColor
      ..style = PaintingStyle.stroke
      ..strokeWidth = isSelected ? 2.0 : 1.5;

    // 濡傛灉鍖哄煙鏈夋棆杞紝闇€瑕佸簲鐢ㄦ棆杞彉鎹?
    if (region.rotation != 0) {
      final center = viewportRect.center;
      canvas.save();
      canvas.translate(center.dx, center.dy);
      canvas.rotate(region.rotation);
      canvas.translate(-center.dx, -center.dy);

      // 缁樺埗鎵€鏈夊厓绱犲苟搴旂敤鏃嬭浆
      // 1. 缁樺埗濉厖
      canvas.drawRect(viewportRect, fillPaint);

      // 2. 缁樺埗杈规
      canvas.drawRect(viewportRect, borderPaint);

      // 3. 缁樺埗鏂囧瓧
      _drawRegionText(
          canvas, viewportRect, region, index, isSelected, borderColor);

      // 4. 濡傛灉澶勪簬Select妯″紡骞朵笖鏄€変腑鐘舵€侊紝缁樺埗鎺у埗鐐?
      if (isSelected && currentTool == Tool.select) {
        _drawHandles(canvas, viewportRect, true);
      }

      canvas.restore();
    } else {
      // 鏃犳棆杞?- 鐩存帴缁樺埗
      // 1. 缁樺埗濉厖
      canvas.drawRect(viewportRect, fillPaint);

      // 2. 缁樺埗杈规
      canvas.drawRect(viewportRect, borderPaint);

      // 3. 缁樺埗鏂囧瓧
      _drawRegionText(
          canvas, viewportRect, region, index, isSelected, borderColor);

      // 4. 濡傛灉澶勪簬Select妯″紡骞朵笖鏄€変腑鐘舵€侊紝缁樺埗鎺у埗鐐?
      if (isSelected && currentTool == Tool.select) {
        _drawHandles(canvas, viewportRect, true);
      }
    }
  }

  void _drawRegionText(
    Canvas canvas,
    Rect viewportRect,
    CharacterRegion region,
    int index,
    bool isSelected,
    Color textColor,
  ) {
    final textPainter = TextPainter(
      text: TextSpan(
        text: region.character.isNotEmpty ? region.character : '$index',
        style: TextStyle(
          color: textColor,
          fontSize: 12,
          fontWeight: isSelected ? FontWeight.bold : FontWeight.normal,
        ),
      ),
      textDirection: TextDirection.ltr,
    );

    textPainter.layout();
    textPainter.paint(
      canvas,
      Offset(
        viewportRect.left + 5,
        viewportRect.top + 5,
      ),
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\character_collection\regions_state_utils.dart
-----------------------------------
import 'package:flutter/material.dart';

import '../../../domain/models/character/character_region_state.dart';
import '../../../infrastructure/logging/logger.dart';
import '../../providers/character/tool_mode_provider.dart';

/// 鍖哄煙鐘舵€佸伐鍏风被
/// 鎻愪緵鑾峰彇鍖哄煙鐘舵€佸拰瀵瑰簲棰滆壊鐨勬柟娉?class RegionStateUtils {
  /// 鑾峰彇鍖哄煙杈规棰滆壊
  /// 鏍规嵁鍖哄煙鐘舵€併€佷繚瀛樼姸鎬佸拰鎮仠鐘舵€佺‘瀹氳竟妗嗛鑹?  static Color getBorderColor({
    required CharacterRegionState state,
    required bool isSaved,
    bool isHovered = false,
  }) {
    // 鏍规嵁鐘舵€佸拰淇濆瓨鐘舵€佺‘瀹氶鑹?    Color result;

    switch (state) {
      case CharacterRegionState.adjusting:
        result = const Color(CharacterRegionColorScheme.adjusting);
        break;
      case CharacterRegionState.selected:
        result = const Color(CharacterRegionColorScheme.selected);
        break;
      case CharacterRegionState.normal:
        result = isSaved
            ? const Color(CharacterRegionColorScheme.normalSaved)
            : const Color(CharacterRegionColorScheme.normalUnsaved);
        break;
    }

    // // 娣诲姞璋冭瘯鏃ュ織锛岀壒鍒叧娉ㄧ孩鑹茶竟妗嗗満鏅?    // if (state == CharacterRegionState.adjusting ||
    //     (result.value == CharacterRegionColorScheme.selected)) {
    //   AppLogger.debug('杈规棰滆壊璁＄畻', data: {
    //     'state': state.toString(),
    //     'isSaved': isSaved,
    //     'colorHex': '#${result.value.toRadixString(16)}',
    //   });
    // }

    return result;
  }

  /// 鑾峰彇鍖哄煙濉厖棰滆壊
  /// 鏍规嵁鍖哄煙鐘舵€併€佷繚瀛樼姸鎬佸拰鎮仠鐘舵€佺‘瀹氬～鍏呴鑹?  static Color getFillColor({
    required CharacterRegionState state,
    required bool isSaved,
    bool isHovered = false,
  }) {
    // 鍩虹棰滆壊
    final baseColor = getBorderColor(
      state: state,
      isSaved: isSaved,
      isHovered: isHovered,
    );

    // 閫忔槑搴?    double opacity;
    switch (state) {
      case CharacterRegionState.adjusting:
        opacity = CharacterRegionColorScheme.adjustingOpacity;
        break;
      case CharacterRegionState.selected:
        opacity = CharacterRegionColorScheme.selectedOpacity;
        break;
      case CharacterRegionState.normal:
        opacity = isSaved
            ? CharacterRegionColorScheme.normalSavedOpacity
            : CharacterRegionColorScheme.normalUnsavedOpacity;
        break;
    }

    // 鎮仠鐘舵€佸鍔犻€忔槑搴?    if (isHovered) {
      opacity = opacity * 1.5;
    }

    return baseColor.withOpacity(opacity);
  }

  /// 鑾峰彇鍖哄煙鐨勭姸鎬?  /// 鏍规嵁褰撳墠宸ュ叿妯″紡鍜屽尯鍩熺殑閫変腑銆佽皟鏁寸姸鎬佺‘瀹氬尯鍩熺姸鎬?  static CharacterRegionState getRegionState({
    required Tool currentTool,
    required bool isSelected,
    required bool isAdjusting,
  }) {
    // AppLogger.debug('鑾峰彇鍖哄煙鐘舵€?, data: {
    //   'currentTool': currentTool.toString(),
    //   'isSelected': isSelected,
    //   'isAdjusting': isAdjusting,
    // });

    // 濡傛灉姝ｅ湪璋冩暣锛岃繑鍥炶皟鏁寸姸鎬?    if (isAdjusting) {
      AppLogger.debug('鍖哄煙鐘舵€? adjusting');
      return CharacterRegionState.adjusting;
    }

    // 濡傛灉琚€変腑锛屾牴鎹伐鍏锋ā寮忕‘瀹氱姸鎬?    if (isSelected) {
      // 鍦⊿elect妯″紡涓嬶紝閫変腑鐨勫尯鍩熷簲璇ユ樉绀轰负adjusting鐘舵€侊紙钃濊壊锛?      if (currentTool == Tool.select) {
        AppLogger.debug('鍖哄煙鐘舵€? adjusting (Select妯″紡)');
        return CharacterRegionState.adjusting;
      }

      // 鍦ㄥ叾浠栨ā寮忎笅锛堝Pan妯″紡锛夛紝浣跨敤selected鐘舵€侊紙绾㈣壊锛?      AppLogger.debug('鍖哄煙鐘舵€? selected');
      return CharacterRegionState.selected;
    }

    // 鍏朵粬鎯呭喌杩斿洖姝ｅ父鐘舵€?    // AppLogger.debug('鍖哄煙鐘舵€? normal');
    return CharacterRegionState.normal;
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\character_collection\region_info_bar.dart
-----------------------------------
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';

class RegionInfoBar extends StatefulWidget {
  final Rect rect;
  final double rotation;
  final Function(Size) onSizeChanged;
  final Function(double) onRotationChanged;

  const RegionInfoBar({
    Key? key,
    required this.rect,
    required this.rotation,
    required this.onSizeChanged,
    required this.onRotationChanged,
  }) : super(key: key);

  @override
  State<RegionInfoBar> createState() => _RegionInfoBarState();
}

class _RegionInfoBarState extends State<RegionInfoBar> {
  late TextEditingController _widthController;
  late TextEditingController _heightController;
  late TextEditingController _rotationController;

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.all(8),
      decoration: BoxDecoration(
        color: Theme.of(context).colorScheme.surfaceContainerLowest,
        borderRadius: BorderRadius.circular(8),
        border: Border.all(color: Theme.of(context).dividerColor),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            '鍖哄煙淇℃伅',
            style: Theme.of(context).textTheme.titleSmall,
          ),
          const SizedBox(height: 8),
          Row(
            children: [
              // 瀹藉害杈撳叆
              Expanded(
                child: _buildNumberField(
                  label: '瀹藉害',
                  controller: _widthController,
                  suffix: 'px',
                  onChanged: (value) {
                    if (value.isNotEmpty) {
                      final width =
                          int.tryParse(value) ?? widget.rect.width.toInt();
                      widget.onSizeChanged(
                          Size(width.toDouble(), widget.rect.height));
                    }
                  },
                ),
              ),

              const SizedBox(width: 16),

              // 楂樺害杈撳叆
              Expanded(
                child: _buildNumberField(
                  label: '楂樺害',
                  controller: _heightController,
                  suffix: 'px',
                  onChanged: (value) {
                    if (value.isNotEmpty) {
                      final height =
                          int.tryParse(value) ?? widget.rect.height.toInt();
                      widget.onSizeChanged(
                          Size(widget.rect.width, height.toDouble()));
                    }
                  },
                ),
              ),

              const SizedBox(width: 16),

              // 鏃嬭浆杈撳叆
              Expanded(
                child: _buildNumberField(
                  label: '鏃嬭浆',
                  controller: _rotationController,
                  suffix: '掳',
                  onChanged: (value) {
                    if (value.isNotEmpty) {
                      final rotation =
                          int.tryParse(value) ?? widget.rotation.toInt();
                      widget.onRotationChanged(rotation.toDouble());
                    }
                  },
                ),
              ),
            ],
          ),
        ],
      ),
    );
  }

  @override
  void didUpdateWidget(RegionInfoBar oldWidget) {
    super.didUpdateWidget(oldWidget);

    // 鍙湁褰撳€煎彉鍖栨椂鎵嶆洿鏂版帶鍒跺櫒
    if (widget.rect.width.toInt() != oldWidget.rect.width.toInt()) {
      _widthController.text = widget.rect.width.toInt().toString();
    }

    if (widget.rect.height.toInt() != oldWidget.rect.height.toInt()) {
      _heightController.text = widget.rect.height.toInt().toString();
    }

    if (widget.rotation.toInt() != oldWidget.rotation.toInt()) {
      _rotationController.text = widget.rotation.toInt().toString();
    }
  }

  @override
  void dispose() {
    _widthController.dispose();
    _heightController.dispose();
    _rotationController.dispose();
    super.dispose();
  }

  @override
  void initState() {
    super.initState();
    _widthController =
        TextEditingController(text: widget.rect.width.toInt().toString());
    _heightController =
        TextEditingController(text: widget.rect.height.toInt().toString());
    _rotationController =
        TextEditingController(text: widget.rotation.toInt().toString());
  }

  Widget _buildNumberField({
    required String label,
    required TextEditingController controller,
    required String suffix,
    required ValueChanged<String> onChanged,
  }) {
    return TextField(
      controller: controller,
      decoration: InputDecoration(
        labelText: label,
        suffixText: suffix,
        border: const OutlineInputBorder(),
        contentPadding: const EdgeInsets.symmetric(horizontal: 10, vertical: 8),
      ),
      keyboardType: TextInputType.number,
      inputFormatters: [
        FilteringTextInputFormatter.digitsOnly,
      ],
      onChanged: onChanged,
      style: const TextStyle(fontSize: 14),
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\character_collection\right_panel.dart
-----------------------------------
import 'dart:async';
import 'dart:ui' as ui;

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../domain/models/character/character_region.dart';
import '../../../domain/models/character/processing_options.dart';
import '../../../application/services/character/character_service.dart';
import '../../../presentation/providers/character/erase_providers.dart';
import '../../../widgets/character_edit/character_edit_panel.dart';
import '../../providers/character/character_collection_provider.dart';
import '../../providers/character/character_grid_provider.dart';
import '../../providers/character/selected_region_provider.dart';
import '../../providers/character/work_image_provider.dart';
import 'character_grid_view.dart';

class RightPanel extends ConsumerStatefulWidget {
  final String workId;

  const RightPanel({
    Key? key,
    required this.workId,
  }) : super(key: key);

  @override
  ConsumerState<RightPanel> createState() => _RightPanelState();
}

class _RightPanelState extends ConsumerState<RightPanel>
    with SingleTickerProviderStateMixin {
  late TabController _tabController;
  int _currentIndex = 0;
  ui.Image? _characterImage;
  bool _wasAdjusting = false;

  @override
  Widget build(BuildContext context) {
    final imageState = ref.watch(workImageProvider);
    final selectedRegion = ref.watch(selectedRegionProvider);
    // 鐩戝惉澶勭悊閫夐」
    final processingOptions = ref.watch(processingOptionsProvider);
    // 鐩戝惉閫夊尯璋冩暣鐘舵€?
    final isAdjusting = ref.watch(characterCollectionProvider).isAdjusting;

    // 澶勭悊閫夊尯璋冩暣鐘舵€佸彉鍖?
    if (isAdjusting != _wasAdjusting) {
      _wasAdjusting = isAdjusting;
      if (!isAdjusting) {
        // 閫夊尯璋冩暣瀹屾垚锛屾洿鏂板浘鍍?
        WidgetsBinding.instance.addPostFrameCallback((_) {
          if (mounted) {
            setState(() {
              _characterImage?.dispose();
              _characterImage = null;
            });
          }
        });
      }
    }

    return Column(
      children: [
        _buildTabBar(),
        Expanded(
          child: TabBarView(
            controller: _tabController,
            children: [
              // 鏍囩1: 闆嗗瓧鏁堟灉棰勮
              _buildPreviewTab(selectedRegion, imageState, processingOptions),
              // 鏍囩2: 浣滃搧闆嗗瓧缁撴灉
              _buildGridTab(),
            ],
          ),
        ),
      ],
    );
  }

  @override
  void dispose() {
    _characterImage?.dispose();
    _tabController.dispose();
    super.dispose();
  }

  void handleTabChange() {
    if (!_tabController.indexIsChanging) {
      setState(() {
        _currentIndex = _tabController.index;
      });
    }
  }

  @override
  void initState() {
    super.initState();
    _tabController = TabController(length: 2, vsync: this);
    _tabController.addListener(handleTabChange);

    // 鍒濆鍖栨椂娓呴櫎鎿﹂櫎鐘舵€?
    WidgetsBinding.instance.addPostFrameCallback((_) {
      ref.read(eraseStateProvider.notifier).clear();
    });
  }

  Widget _buildCharacterEditor(
    CharacterRegion selectedRegion,
    WorkImageState imageState,
    ProcessingOptions processingOptions,
  ) {
    // 浣跨敤selectedRegion鐨刬d銆乺ect鍜宺otation浣滀负key鐨勪竴閮ㄥ垎锛岀‘淇濋€夊尯鍙樺寲鏃堕噸寤?
    return CharacterEditPanel(
      key: ValueKey(
          'editor_${selectedRegion.id}_${selectedRegion.rect.left}_${selectedRegion.rect.top}_${selectedRegion.rect.width}_${selectedRegion.rect.height}_${selectedRegion.rotation}'),
      selectedRegion: selectedRegion,
      workId: widget.workId,
      pageId: imageState.currentPageId ?? '',
      imageData: imageState.imageData,
      processingOptions: processingOptions,
      onEditComplete: _handleEditComplete,
    );
  }

  Widget _buildGridTab() {
    return CharacterGridView(
      workId: widget.workId,
      onCharacterSelected: (characterId) async {
        try {
          // 1. 鑾峰彇褰撳墠椤甸潰鐘舵€?
          final currentState = ref.read(workImageProvider);
          final currentPageId = currentState.currentPageId;
          final currentWorkId = widget.workId;

          // 2. 鑾峰彇瀛楃鏈嶅姟鏉ユ煡璇㈠瓧绗﹁鎯?
          final characterService = ref.read(characterServiceProvider);
          final character =
              await characterService.getCharacterDetails(characterId);

          if (character == null) {
            throw Exception('鎵句笉鍒板瓧绗︿俊鎭?);
          }

          // 3. 妫€鏌ュ瓧绗︽槸鍚﹀湪褰撳墠椤甸潰
          final isOnCurrentPage = character.pageId == currentPageId &&
              character.workId == currentWorkId;

          if (!isOnCurrentPage) {
            // 4. 濡傛灉涓嶅湪褰撳墠椤甸潰锛岄渶瑕佸垏鎹㈤〉闈?
            // 4.1 鏄剧ず鍔犺浇鎻愮ず
            ScaffoldMessenger.of(context).showSnackBar(
              const SnackBar(
                content: Text('姝ｅ湪鍒囨崲鍒板瓧绗︽墍鍦ㄩ〉闈?..'),
                duration: Duration(seconds: 1),
              ),
            );

            // 4.2 鍔犺浇鐩爣椤甸潰
            final imageProvider = ref.read(workImageProvider.notifier);
            await imageProvider.loadWorkImage(
                character.workId, character.pageId);

            // 4.3 鍔犺浇璇ラ〉鐨勫瓧绗﹀尯鍩熸暟鎹?
            await ref.read(characterCollectionProvider.notifier).loadWorkData(
                  character.workId,
                  pageId: character.pageId,
                  defaultSelectedRegionId: characterId,
                );

            // 4.4 鍒囨崲鍒伴瑙堟爣绛鹃〉
            _tabController.animateTo(0);
          } else {
            // 5. 濡傛灉鍦ㄥ綋鍓嶉〉闈紝鐩存帴鍔犺浇鍖哄煙鏁版嵁
            await ref.read(characterCollectionProvider.notifier).loadWorkData(
                  currentWorkId,
                  pageId: currentPageId,
                  defaultSelectedRegionId: characterId,
                );

            // 5.1 鍒囨崲鍒伴瑙堟爣绛鹃〉
            _tabController.animateTo(0);
          }
        } catch (e) {
          if (mounted) {
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(
                content: Text('鏌ユ壘骞跺垏鎹㈤〉闈㈠け璐? $e'),
                backgroundColor: Colors.red,
              ),
            );
          }
        }
      },
    );
  }

  Widget _buildPreviewTab(
    CharacterRegion? selectedRegion,
    WorkImageState imageState,
    ProcessingOptions processingOptions,
  ) {
    if (selectedRegion == null) {
      return const Center(
        child: Text(
          '璇峰湪宸︿晶棰勮鍖洪€夋嫨瀛楃鍖哄煙',
          style: TextStyle(color: Colors.grey),
        ),
      );
    }

    return _buildCharacterEditor(selectedRegion, imageState, processingOptions);
  }

  Widget _buildTabBar() {
    return Container(
      decoration: BoxDecoration(
        color: Theme.of(context).colorScheme.surface,
        border: Border(
          bottom: BorderSide(color: Theme.of(context).dividerColor),
        ),
      ),
      child: TabBar(
        controller: _tabController,
        tabs: const [
          Tab(text: '闆嗗瓧鏁堟灉棰勮'),
          Tab(text: '浣滃搧闆嗗瓧缁撴灉'),
        ],
        labelColor: Theme.of(context).colorScheme.primary,
        unselectedLabelColor: Theme.of(context).colorScheme.onSurface,
        indicatorColor: Theme.of(context).colorScheme.primary,
      ),
    );
  }

  void _handleEditComplete(Map<String, dynamic> result) async {
    final characterId = result['characterId'];
    if (characterId != null) {
      // 鍒囨崲鍒颁綔鍝侀泦瀛楃粨鏋滄爣绛鹃〉
      _tabController.animateTo(1);

      // 鍒锋柊浣滃搧闆嗗瓧缁撴灉
      try {
        await ref.read(characterGridProvider.notifier).loadCharacters();
      } catch (e) {
        print('鍒锋柊瀛楃缃戞牸澶辫触: $e');
      }
    }
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\character_collection\search_filter_bar.dart
-----------------------------------
import 'package:flutter/material.dart';

import 'filter_type.dart';

class SearchFilterBar extends StatelessWidget {
  final String searchTerm;
  final FilterType filterType;
  final ValueChanged<String> onSearchChanged;
  final ValueChanged<FilterType> onFilterChanged;

  const SearchFilterBar({
    Key? key,
    required this.searchTerm,
    required this.filterType,
    required this.onSearchChanged,
    required this.onFilterChanged,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.all(16.0),
      child: Row(
        children: [
          // 鎼滅储杈撳叆妗?
          Expanded(
            flex: 3,
            child: TextField(
              decoration: InputDecoration(
                hintText: '鎼滅储瀛楃...',
                prefixIcon: const Icon(Icons.search),
                border: OutlineInputBorder(
                  borderRadius: BorderRadius.circular(8.0),
                ),
                contentPadding: const EdgeInsets.symmetric(vertical: 0.0),
              ),
              onChanged: onSearchChanged,
              controller: TextEditingController(text: searchTerm),
            ),
          ),

          const SizedBox(width: 16),

          // 绛涢€変笅鎷夎彍鍗?
          Expanded(
            flex: 2,
            child: Container(
              decoration: BoxDecoration(
                border: Border.all(color: Theme.of(context).dividerColor),
                borderRadius: BorderRadius.circular(8.0),
              ),
              child: DropdownButtonHideUnderline(
                child: DropdownButton<FilterType>(
                  value: filterType,
                  isExpanded: true,
                  padding: const EdgeInsets.symmetric(horizontal: 16.0),
                  borderRadius: BorderRadius.circular(8.0),
                  items: [
                    _buildDropdownItem(FilterType.all, '鍏ㄩ儴瀛楃', context),
                    _buildDropdownItem(FilterType.recent, '鏈€杩戞坊鍔?, context),
                    _buildDropdownItem(FilterType.modified, '鏈€杩戜慨鏀?, context),
                    _buildDropdownItem(FilterType.favorite, '宸叉敹钘?, context),
                    _buildDropdownItem(FilterType.byStroke, '鎸夌瑪鐢绘暟', context),
                    _buildDropdownItem(FilterType.custom, '鑷畾涔夋帓搴?, context),
                  ],
                  onChanged: (value) {
                    if (value != null) {
                      onFilterChanged(value);
                    }
                  },
                ),
              ),
            ),
          ),
        ],
      ),
    );
  }

  DropdownMenuItem<FilterType> _buildDropdownItem(
      FilterType type, String label, BuildContext context) {
    return DropdownMenuItem<FilterType>(
      value: type,
      child: Row(
        children: [
          Icon(
            _getFilterIcon(type),
            size: 20,
            color: filterType == type
                ? Theme.of(context).colorScheme.primary
                : null,
          ),
          const SizedBox(width: 8),
          Text(
            label,
            style: TextStyle(
              fontWeight:
                  filterType == type ? FontWeight.bold : FontWeight.normal,
              color: filterType == type
                  ? Theme.of(context).colorScheme.primary
                  : null,
            ),
          ),
        ],
      ),
    );
  }

  IconData _getFilterIcon(FilterType type) {
    switch (type) {
      case FilterType.all:
        return Icons.format_list_bulleted;
      case FilterType.recent:
        return Icons.access_time;
      case FilterType.modified:
        return Icons.edit;
      case FilterType.favorite:
        return Icons.favorite;
      case FilterType.byStroke:
        return Icons.brush;
      case FilterType.custom:
        return Icons.sort;
    }
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\character_collection\selection_painters.dart
-----------------------------------
import 'package:flutter/material.dart';

import '../../../utils/coordinate_transformer.dart';

class ActiveSelectionPainter extends CustomPainter {
  final Offset startPoint;
  final Offset endPoint;
  final Size viewportSize;
  final bool isActive;

  ActiveSelectionPainter({
    required this.startPoint,
    required this.endPoint,
    required this.viewportSize,
    this.isActive = false,
  });

  @override
  void paint(Canvas canvas, Size size) {
    if (!isActive) return;

    // 鐢婚€夊彇妗?
    final rect = Rect.fromPoints(startPoint, endPoint);
    canvas.drawRect(
      rect,
      Paint()
        ..color = Colors.blue.withOpacity(0.3)
        ..style = PaintingStyle.fill,
    );

    // 鐢昏竟妗?
    canvas.drawRect(
      rect,
      Paint()
        ..color = Colors.blue
        ..style = PaintingStyle.stroke
        ..strokeWidth = 1.0,
    );
  }

  @override
  bool shouldRepaint(covariant ActiveSelectionPainter oldDelegate) {
    return startPoint != oldDelegate.startPoint ||
        endPoint != oldDelegate.endPoint ||
        isActive != oldDelegate.isActive;
  }
}

class CompletedSelectionPainter extends CustomPainter {
  final Rect rect;
  final CoordinateTransformer transformer;
  final Size viewportSize;

  const CompletedSelectionPainter({
    required this.rect,
    required this.transformer,
    required this.viewportSize,
  });

  @override
  void paint(Canvas canvas, Size size) {
    if (viewportSize != size) return; // 闃叉瑙嗗彛澶у皬涓嶅尮閰?

    try {
      // 浠庡浘鍍忓潗鏍囪浆鎹㈠埌瑙嗗彛鍧愭爣
      final viewportRect = transformer.imageRectToViewportRect(rect);

      // 缁樺埗閫夊尯
      canvas.drawRect(
        viewportRect,
        Paint()
          ..color = Colors.blue.withOpacity(1.0)
          ..style = PaintingStyle.fill,
      );

      canvas.drawRect(
        viewportRect,
        Paint()
          ..color = Colors.blue
          ..style = PaintingStyle.stroke
          ..strokeWidth = 2.0,
      );

      // 缁樺埗瑙掔偣鎵嬫焺
      const handleSize = 6.0;
      final handlePaint = Paint()..color = Colors.blue;

      final corners = [
        viewportRect.topLeft,
        viewportRect.topRight,
        viewportRect.bottomLeft,
        viewportRect.bottomRight,
      ];

      for (var corner in corners) {
        canvas.drawRect(
          Rect.fromCenter(
            center: corner,
            width: handleSize,
            height: handleSize,
          ),
          handlePaint,
        );
      }
    } catch (e) {}
  }

  @override
  bool shouldRepaint(covariant CompletedSelectionPainter oldDelegate) {
    return rect != oldDelegate.rect ||
        transformer != oldDelegate.transformer ||
        viewportSize != oldDelegate.viewportSize;
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\character_collection\selection_toolbar.dart
-----------------------------------
import 'package:flutter/material.dart';

class SelectionToolbar extends StatelessWidget {
  final VoidCallback onConfirm;
  final VoidCallback onCancel;
  final VoidCallback onDelete;
  final bool enabled;

  const SelectionToolbar({
    Key? key,
    required this.onConfirm,
    required this.onCancel,
    required this.onDelete,
    this.enabled = true,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    if (!enabled) return const SizedBox.shrink();

    return Material(
      elevation: 4,
      borderRadius: BorderRadius.circular(8),
      color: Colors.white,
      child: Padding(
        padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
        child: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            Tooltip(
              message: '纭 (Enter)',
              child: IconButton(
                icon: const Icon(Icons.check),
                onPressed: onConfirm,
                color: Colors.blue,
              ),
            ),
            Tooltip(
              message: '鍒犻櫎 (Delete)',
              child: IconButton(
                icon: const Icon(Icons.delete_outline),
                onPressed: onDelete,
                color: Colors.red,
              ),
            ),
            Tooltip(
              message: '鍙栨秷 (Esc)',
              child: IconButton(
                icon: const Icon(Icons.close),
                onPressed: onCancel,
                color: Colors.grey,
              ),
            ),
          ],
        ),
      ),
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\character_collection\thumbnail_list.dart
-----------------------------------
import 'dart:io';

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../providers/character/character_collection_provider.dart';
import '../../providers/character/work_image_provider.dart';

class ThumbnailList extends ConsumerWidget {
  const ThumbnailList({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final imageState = ref.watch(workImageProvider);

    return Container(
      height: 80,
      decoration: BoxDecoration(
        color: Theme.of(context).colorScheme.surface,
        border: Border(
          top: BorderSide(color: Theme.of(context).dividerColor),
        ),
      ),
      child: Row(
        children: [
          // 椤甸潰鎸囩ず鍣?
          Container(
            padding: const EdgeInsets.all(8),
            alignment: Alignment.center,
            child: Text(
              '椤甸潰: ${imageState.pageIds.indexOf(imageState.currentPageId) + 1}/${imageState.pageIds.length}',
              style: Theme.of(context).textTheme.bodySmall,
            ),
          ),

          // 缂╃暐鍥惧垪琛?
          Expanded(
            child: ListView.builder(
              scrollDirection: Axis.horizontal,
              itemCount: imageState.pageIds.length,
              itemBuilder: (context, index) {
                final pageId = imageState.pageIds[index];
                final isSelected = pageId == imageState.currentPageId;

                return _ThumbnailItem(
                  pageId: pageId,
                  index: index + 1,
                  isSelected: isSelected,
                  onTap: () {
                    final notifier = ref.read(workImageProvider.notifier);
                    // 鍒囨崲椤甸潰
                    notifier.changePage(pageId);
                    // 鍔犺浇璇ラ〉鐨勯€夊尯
                    ref.read(characterCollectionProvider.notifier).loadWorkData(
                          imageState.workId,
                          pageId: pageId,
                        );
                  },
                );
              },
            ),
          ),

          // 瀵艰埅鎸夐挳
          if (imageState.pageIds.length > 1)
            Row(
              children: [
                // 涓婁竴椤?
                IconButton(
                  icon: const Icon(Icons.arrow_back_ios, size: 18),
                  onPressed: imageState.hasPrevious
                      ? () =>
                          ref.read(workImageProvider.notifier).previousPage()
                      : null,
                  tooltip: '涓婁竴椤?,
                ),

                // 涓嬩竴椤?
                IconButton(
                  icon: const Icon(Icons.arrow_forward_ios, size: 18),
                  onPressed: imageState.hasNext
                      ? () => ref.read(workImageProvider.notifier).nextPage()
                      : null,
                  tooltip: '涓嬩竴椤?,
                ),
              ],
            ),
        ],
      ),
    );
  }
}

class _ThumbnailItem extends ConsumerWidget {
  final String pageId;
  final int index;
  final bool isSelected;
  final VoidCallback onTap;

  const _ThumbnailItem({
    Key? key,
    required this.pageId,
    required this.index,
    required this.isSelected,
    required this.onTap,
  }) : super(key: key);

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final theme = Theme.of(context);
    final imageState = ref.watch(workImageProvider);

    return GestureDetector(
      onTap: onTap,
      child: Container(
        width: 60,
        margin: const EdgeInsets.symmetric(horizontal: 4, vertical: 8),
        decoration: BoxDecoration(
          border: Border.all(
            color: isSelected ? theme.colorScheme.primary : theme.dividerColor,
            width: isSelected ? 2 : 1,
          ),
          borderRadius: BorderRadius.circular(4),
        ),
        child: Stack(
          fit: StackFit.expand,
          children: [
            // 瀹為檯缂╃暐鍥?
            FutureBuilder<String?>(
              future:
                  ref.read(workImageProvider.notifier).getThumbnailPath(pageId),
              builder: (context, snapshot) {
                if (snapshot.hasData && snapshot.data != null) {
                  return ClipRRect(
                    borderRadius: BorderRadius.circular(3),
                    child: Image.file(
                      File(snapshot.data!),
                      fit: BoxFit.cover,
                      errorBuilder: (context, error, stackTrace) {
                        return const Icon(
                          Icons.broken_image_outlined,
                          size: 24,
                          color: Colors.grey,
                        );
                      },
                    ),
                  );
                }
                return const Center(
                  child:
                      Icon(Icons.image_outlined, size: 24, color: Colors.grey),
                );
              },
            ),

            // 椤电爜鎸囩ず鍣?
            Positioned(
              left: 0,
              right: 0,
              bottom: 0,
              child: Container(
                padding: const EdgeInsets.symmetric(vertical: 2),
                decoration: BoxDecoration(
                  color:
                      isSelected ? theme.colorScheme.primary : Colors.black54,
                  borderRadius: const BorderRadius.only(
                    bottomLeft: Radius.circular(3),
                    bottomRight: Radius.circular(3),
                  ),
                ),
                child: Text(
                  '$index',
                  textAlign: TextAlign.center,
                  style: TextStyle(
                    color:
                        isSelected ? theme.colorScheme.onPrimary : Colors.white,
                    fontSize: 10,
                  ),
                ),
              ),
            ),

            // 鍔犺浇鎸囩ず鍣?
            if (isSelected && imageState.loading)
              Positioned.fill(
                child: Container(
                  decoration: BoxDecoration(
                    color: Colors.black26,
                    borderRadius: BorderRadius.circular(3),
                  ),
                  child: const Center(
                    child: SizedBox(
                      width: 24,
                      height: 24,
                      child: CircularProgressIndicator(
                        strokeWidth: 2,
                        valueColor: AlwaysStoppedAnimation<Color>(Colors.white),
                      ),
                    ),
                  ),
                ),
              ),
          ],
        ),
      ),
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\character_collection\zoom_control_bar.dart
-----------------------------------
import 'package:flutter/material.dart';

class ZoomControlBar extends StatelessWidget {
  final double zoomLevel;
  final VoidCallback onZoomIn;
  final VoidCallback onZoomOut;
  final VoidCallback onReset;

  const ZoomControlBar({
    Key? key,
    required this.zoomLevel,
    required this.onZoomIn,
    required this.onZoomOut,
    required this.onReset,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Container(
      height: 40,
      decoration: BoxDecoration(
        color: Theme.of(context).colorScheme.surfaceContainerLowest,
        borderRadius: BorderRadius.circular(8),
        border: Border.all(color: Theme.of(context).dividerColor),
      ),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          // 缂╁皬鎸夐挳
          IconButton(
            icon: const Icon(Icons.remove),
            tooltip: '缂╁皬',
            onPressed: zoomLevel > 0.5 ? onZoomOut : null,
            padding: EdgeInsets.zero,
            constraints: const BoxConstraints(
              minWidth: 40,
              minHeight: 40,
            ),
            iconSize: 20,
          ),

          // 閲嶇疆鎸夐挳
          TextButton(
            onPressed: onReset,
            style: TextButton.styleFrom(
              minimumSize: const Size(48, 40),
              padding: const EdgeInsets.symmetric(horizontal: 8),
            ),
            child: Text('${(zoomLevel * 100).toInt()}%'),
          ),

          // 鏀惧ぇ鎸夐挳
          IconButton(
            icon: const Icon(Icons.add),
            tooltip: '鏀惧ぇ',
            onPressed: zoomLevel < 3.0 ? onZoomIn : null,
            padding: EdgeInsets.zero,
            constraints: const BoxConstraints(
              minWidth: 40,
              minHeight: 40,
            ),
            iconSize: 20,
          ),
        ],
      ),
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\character_collection\erase_tool\adapters\erase_processor_adapter.dart
-----------------------------------
import 'dart:ui' as ui;

import 'package:flutter/material.dart';

import '../models/erase_operation.dart';
import '../utils/erase_background_detector.dart';

/// 鎿﹂櫎澶勭悊閫傞厤鍣?
/// 澶勭悊鎿﹂櫎鎿嶄綔骞剁敓鎴愭摝闄ゅ悗鐨勫浘鍍?
class EraseProcessorAdapter {
  /// 鑳屾櫙棰滆壊锛堥粯璁ょ櫧鑹诧級
  Color _backgroundColor = Colors.white;

  /// 鏄惁宸插垵濮嬪寲
  bool _isInitialized = false;

  /// 澶勭悊鍗曚釜鎿﹂櫎鎿嶄綔
  Future<ui.Image> process(ui.Image image, EraseOperation operation) async {
    // 濡傛灉灏氭湭鍒濆鍖栵紝鍏堟娴嬭儗鏅壊
    if (!_isInitialized) {
      await _initialize(image);
    }

    // 鍒涘缓鐢诲竷
    final recorder = ui.PictureRecorder();
    final canvas = Canvas(recorder);

    // 缁樺埗鍘熷鍥惧儚
    canvas.drawImage(image, Offset.zero, Paint());

    // 璁剧疆鎿﹂櫎鐢荤瑪
    final erasePaint = Paint()
      ..color = _backgroundColor // 浣跨敤妫€娴嬪埌鐨勮儗鏅壊
      ..strokeCap = StrokeCap.round
      ..strokeJoin = StrokeJoin.round
      ..strokeWidth = operation.brushSize
      ..style = PaintingStyle.stroke
      ..blendMode = BlendMode.src; // 浣跨敤婧愭ā寮忕‘淇濆畬鍏ㄦ摝闄?

    // 鍒涘缓璺緞
    if (operation.points.length >= 2) {
      final path = Path();
      path.moveTo(operation.points.first.dx, operation.points.first.dy);

      for (int i = 1; i < operation.points.length; i++) {
        path.lineTo(operation.points[i].dx, operation.points[i].dy);
      }

      // 缁樺埗鎿﹂櫎璺緞
      canvas.drawPath(path, erasePaint);
    }

    // 鍗曠嫭澶勭悊瀛ょ珛鐐癸紙鍙湁涓€涓偣鐨勬儏鍐碉級
    if (operation.points.length == 1) {
      canvas.drawCircle(
          operation.points.first,
          operation.brushSize / 2,
          Paint()
            ..color = _backgroundColor
            ..style = PaintingStyle.fill);
    }

    // 鐢熸垚鍥剧墖
    final picture = recorder.endRecording();
    return picture.toImage(image.width, image.height);
  }

  /// 鎵归噺澶勭悊鎿﹂櫎鎿嶄綔
  Future<ui.Image> processBatch(
      ui.Image originalImage, List<EraseOperation> operations) async {
    // 濡傛灉灏氭湭鍒濆鍖栵紝鍏堟娴嬭儗鏅壊
    if (!_isInitialized) {
      await _initialize(originalImage);
    }

    // 娌℃湁鎿嶄綔锛岀洿鎺ヨ繑鍥炲師鍥?
    if (operations.isEmpty) return originalImage;

    // 鍒涘缓鐢诲竷
    final recorder = ui.PictureRecorder();
    final canvas = Canvas(recorder);

    // 缁樺埗鍘熷鍥惧儚
    canvas.drawImage(originalImage, Offset.zero, Paint());

    // 澶勭悊姣忎釜鎿﹂櫎鎿嶄綔
    for (final operation in operations) {
      // 璁剧疆鎿﹂櫎鐢荤瑪
      final erasePaint = Paint()
        ..color = _backgroundColor // 浣跨敤妫€娴嬪埌鐨勮儗鏅壊
        ..strokeCap = StrokeCap.round
        ..strokeJoin = StrokeJoin.round
        ..strokeWidth = operation.brushSize
        ..style = PaintingStyle.stroke
        ..blendMode = BlendMode.src; // 浣跨敤婧愭ā寮忕‘淇濆畬鍏ㄦ摝闄?

      // 鍒涘缓骞剁粯鍒惰矾寰?
      if (operation.points.length >= 2) {
        final path = Path();
        path.moveTo(operation.points.first.dx, operation.points.first.dy);

        for (int i = 1; i < operation.points.length; i++) {
          path.lineTo(operation.points[i].dx, operation.points[i].dy);
        }

        canvas.drawPath(path, erasePaint);
      }

      // 澶勭悊瀛ょ珛鐐?
      if (operation.points.length == 1) {
        canvas.drawCircle(
            operation.points.first,
            operation.brushSize / 2,
            Paint()
              ..color = _backgroundColor
              ..style = PaintingStyle.fill);
      }
    }

    // 鐢熸垚鍥剧墖
    final picture = recorder.endRecording();
    return picture.toImage(originalImage.width, originalImage.height);
  }

  /// 鍒濆鍖栧鐞嗗櫒锛屾娴嬭儗鏅壊
  Future<void> _initialize(ui.Image image) async {
    try {
      // 妫€娴嬭儗鏅壊
      _backgroundColor =
          await EraseBackgroundDetector.detectBackgroundColor(image);
      print('Detected background color: $_backgroundColor');

      // 妫€鏌ユ槸鍚︿负榛戠櫧鍥惧儚
      final isBlackAndWhite =
          await EraseBackgroundDetector.isBlackAndWhiteImage(image);
      print('Is black and white image: $isBlackAndWhite');

      _isInitialized = true;
    } catch (e) {
      print('Error initializing erase processor: $e');
      // 鍑洪敊鏃朵娇鐢ㄩ粯璁ょ櫧鑹茶儗鏅?
      _backgroundColor = Colors.white;
      _isInitialized = true;
    }
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\character_collection\erase_tool\controllers\erase_gesture_mixin.dart
-----------------------------------
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';

import 'erase_tool_controller.dart';

/// 鎿﹂櫎鎵嬪娍澶勭悊娣峰叆
/// 鎻愪緵閫氱敤鐨勬摝闄ゆ墜鍔垮鐞嗚兘鍔?
mixin EraseGestureMixin<T extends StatefulWidget> on State<T> {
  /// 鎿﹂櫎宸ュ叿鎺у埗鍣?
  EraseToolController get controller;

  /// 澶勭悊绗斿埛澶у皬鍙樺寲
  void handleBrushSizeChanged(double size) {
    // 纭繚鎺у埗鍣ㄥ彲鐢?
    controller.setBrushSize(size);
  }

  /// 澶勭悊娓呴櫎鎵€鏈?
  void handleClearAll() {
    // 纭繚鎺у埗鍣ㄥ彲鐢?
    controller.clearAll();
  }

  /// 澶勭悊骞崇Щ鍙栨秷
  void handlePanCancel() {
    // 纭繚鎺у埗鍣ㄥ彲鐢?
    if (kDebugMode) {
      print('鉁忥笍 鎿﹂櫎鍙栨秷');
    }

    // 澶勭悊鎿﹂櫎鍙栨秷
    controller.cancelErase();
  }

  /// 澶勭悊骞崇Щ缁撴潫
  void handlePanEnd(DragEndDetails details) {
    // 纭繚鎺у埗鍣ㄥ彲鐢?
    if (kDebugMode) {
      print('鉁忥笍 鎿﹂櫎缁撴潫');
    }

    // 澶勭悊鎿﹂櫎缁撴潫
    controller.endErase();
  }

  /// 澶勭悊骞崇Щ寮€濮?
  void handlePanStart(DragStartDetails details) {
    // 纭繚鎺у埗鍣ㄥ彲鐢?
    final localPosition = details.localPosition;

    if (kDebugMode) {
      print('鉁忥笍 寮€濮嬫摝闄? $localPosition');
    }

    // 澶勭悊鎿﹂櫎寮€濮?
    controller.startErase(localPosition);
  }

  /// 澶勭悊骞崇Щ鏇存柊
  void handlePanUpdate(DragUpdateDetails details) {
    // 纭繚鎺у埗鍣ㄥ彲鐢?
    final localPosition = details.localPosition;

    if (kDebugMode && details.delta.distance > 5) {
      print('鉁忥笍 鎿﹂櫎鏇存柊: $localPosition (delta: ${details.delta})');
    }

    // 澶勭悊鎿﹂櫎鏇存柊
    controller.continueErase(localPosition);
  }

  /// 澶勭悊閲嶅仛
  void handleRedo() {
    // 纭繚鎺у埗鍣ㄥ彲鐢?
    controller.redo();
  }

  /// 澶勭悊鎾ら攢
  void handleUndo() {
    // 纭繚鎺у埗鍣ㄥ彲鐢?
    controller.undo();
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\character_collection\erase_tool\controllers\erase_tool_controller.dart
-----------------------------------
import 'dart:ui' as ui;

import 'package:flutter/material.dart';

import '../models/erase_mode.dart';
import '../models/erase_operation.dart';

/// 鎿﹂櫎宸ュ叿鎺у埗鍣?
abstract class EraseToolController extends ChangeNotifier {
  /// 褰撳墠绗斿埛澶у皬
  double get brushSize;

  /// 鏄惁鍙互閲嶅仛
  bool get canRedo;

  /// 鏄惁鍙互鎾ら攢
  bool get canUndo;

  /// 褰撳墠鎿嶄綔
  EraseOperation? get currentOperation;

  /// 褰撳墠鐐归泦
  List<Offset> get currentPoints;

  /// 鏄惁姝ｅ湪鎿﹂櫎
  bool get isErasing;

  /// 褰撳墠鎿﹂櫎妯″紡
  EraseMode get mode;

  /// 鎵€鏈夋摝闄ゆ搷浣?
  List<EraseOperation> get operations;

  /// 搴旂敤褰撳墠鎵€鏈夋搷浣滃埌鐢诲竷
  void applyOperations(Canvas canvas);

  /// 鍙栨秷褰撳墠鎿﹂櫎
  void cancelErase();

  /// 娓呴櫎鎵€鏈夋搷浣?
  void clearAll();

  /// 缁х画鎿﹂櫎鎿嶄綔
  void continueErase(Offset point);

  /// 缁撴潫鎿﹂櫎鎿嶄綔
  void endErase();

  /// 鑾峰彇褰撳墠宸ヤ綔鍖哄煙鍥惧儚
  Future<ui.Image?> getResultImage();

  /// 閲嶅仛涓婁竴涓摝闄ゆ搷浣?
  void redo();

  /// 璁剧疆绗斿埛澶у皬
  void setBrushSize(double size);

  /// 璁剧疆鐢诲竷灏哄
  void setCanvasSize(Size size);

  /// 璁剧疆鎿﹂櫎妯″紡
  void setMode(EraseMode mode);

  /// 寮€濮嬫摝闄ゆ搷浣?
  void startErase(Offset point);

  /// 鎾ら攢涓婁竴涓摝闄ゆ搷浣?
  void undo();
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\character_collection\erase_tool\controllers\erase_tool_controller_impl.dart
-----------------------------------
import 'dart:async';
import 'dart:collection';
import 'dart:ui' as ui;

import 'package:flutter/material.dart';

import '../models/erase_mode.dart';
import '../models/erase_operation.dart';
import '../models/render_types.dart';
import 'erase_tool_controller.dart';
import 'render_manager.dart';

class EraseToolControllerImpl extends EraseToolController {
  /// 鏈€澶ф爤澶у皬
  static const int _maxStackSize = 50;
  final RenderManager _renderManager;
  final Queue<EraseOperation> _undoStack = Queue();

  final Queue<EraseOperation> _redoStack = Queue();
  EraseOperation? _currentOperation;
  double _brushSize;
  EraseMode _mode;
  bool _isErasing = false;
  final bool _isInitialized = false;
  Matrix4? _currentTransform;
  Rect? _viewport;

  Size? _canvasSize;

  EraseToolControllerImpl({
    required RenderManager renderManager,
    double? initialBrushSize,
    EraseMode? initialMode,
  })  : _renderManager = renderManager,
        _brushSize = initialBrushSize ?? 20.0,
        _mode = initialMode ?? EraseMode.normal;

  @override
  double get brushSize => _brushSize;

  @override
  bool get canRedo => _redoStack.isNotEmpty;

  @override
  bool get canUndo => _undoStack.isNotEmpty;

  @override
  EraseOperation? get currentOperation => _currentOperation;

  @override
  List<Offset> get currentPoints =>
      _currentOperation?.points.toList() ?? const [];

  @override
  bool get isErasing => _isErasing;

  @override
  EraseMode get mode => _mode;

  @override
  List<EraseOperation> get operations =>
      [..._undoStack, if (_currentOperation != null) _currentOperation!];

  @override
  void applyOperations(Canvas canvas) {
    // 搴旂敤宸插畬鎴愮殑鎿嶄綔
    for (final operation in operations) {
      operation.apply(canvas);
    }

    // 搴旂敤褰撳墠鎿嶄綔
    _currentOperation?.apply(canvas);
  }

  @override
  void cancelErase() {
    if (!_isErasing) return;
    _currentOperation = null;
    _isErasing = false;
    _renderManager.invalidateLayer(LayerType.preview);
    notifyListeners();
  }

  @override
  void clearAll() {
    _undoStack.clear();
    _redoStack.clear();
    _currentOperation = null;
    _isErasing = false;
    _renderManager.invalidateLayer(LayerType.preview);
    notifyListeners();
  }

  @override
  void continueErase(Offset point) {
    if (!_isErasing || _currentOperation == null) return;

    // 娣诲姞鐐瑰埌褰撳墠鎿嶄綔
    _currentOperation!.addPoint(point);

    // 鏇存柊棰勮灞傜殑鑴忓尯鍩?
    final pointBounds = Rect.fromCircle(
      center: point,
      radius: _brushSize / 2,
    );
    _renderManager.setDirtyRegion(LayerType.preview, pointBounds);

    notifyListeners();
  }

  @override
  void dispose() {
    _currentOperation = null;
    _undoStack.clear();
    _redoStack.clear();
    super.dispose();
  }

  @override
  void endErase() {
    if (!_isErasing || _currentOperation == null) return;

    // 浼樺寲璺緞鐐?
    final optimizedOperation = _currentOperation!.optimize();

    // 娣诲姞鍒版挙閿€鏍?
    _pushToUndoStack(optimizedOperation);

    // 娓呯悊褰撳墠鎿嶄綔
    _currentOperation = null;
    _isErasing = false;

    // 鏇存柊棰勮灞?
    _renderManager.invalidateLayer(LayerType.preview);
    notifyListeners();
  }

  @override
  Future<ui.Image?> getResultImage() async {
    if (_canvasSize == null) return null;

    // 鑾峰彇棰勮灞傚浘鍍?
    final recorder = ui.PictureRecorder();
    final canvas = Canvas(recorder);

    // 璁剧疆鍒濆鍓鍖哄煙
    canvas.clipRect(Offset.zero & _canvasSize!);

    // 搴旂敤鎵€鏈夋搷浣?
    applyOperations(canvas);

    // 鑾峰彇鍥惧儚
    final picture = recorder.endRecording();
    final resultImage = await picture.toImage(
      _canvasSize!.width.round(),
      _canvasSize!.height.round(),
    );

    return resultImage;
  }

  /// 浣挎墍鏈夊浘灞傛棤鏁?
  void invalidateAllLayers() {
    _renderManager.invalidateLayer(LayerType.original);
    _renderManager.invalidateLayer(LayerType.buffer);
    _renderManager.invalidateLayer(LayerType.preview);
  }

  @override
  void redo() {
    if (!canRedo) return;

    final operation = _redoStack.removeLast();
    _pushToUndoStack(operation);

    // 鏇存柊棰勮灞?
    _renderManager.invalidateLayer(LayerType.preview);
    notifyListeners();
  }

  @override
  void setBrushSize(double size) {
    if (size == _brushSize) return;
    _brushSize = size.clamp(5.0, 100.0);
    notifyListeners();
  }

  @override
  void setCanvasSize(Size size) {
    if (_canvasSize != size) {
      _canvasSize = size;
      // 閫氱煡娓叉煋绠＄悊鍣?
      _renderManager.prepare(size);
      invalidateAllLayers();
    }
  }

  @override
  void setMode(EraseMode mode) {
    if (mode == _mode) return;
    _mode = mode;

    // 璋冩暣绗斿埛澶у皬鍒版柊妯″紡鐨勮寖鍥?
    final (min, max) = mode.brushSizeRange;
    _brushSize = _brushSize.clamp(min, max);

    notifyListeners();
  }

  @override
  void startErase(Offset point) {
    if (_isErasing) return;

    // 娓呴櫎閲嶅仛鏍?
    _redoStack.clear();

    // 鍒涘缓鏂版搷浣?
    _currentOperation = EraseOperation(
      brushSize: _brushSize,
      mode: _mode,
    );
    _currentOperation!.addPoint(point);

    _isErasing = true;

    // 鏇存柊棰勮灞傜殑鑴忓尯鍩?
    final pointBounds = Rect.fromCircle(
      center: point,
      radius: _brushSize / 2,
    );
    _renderManager.setDirtyRegion(LayerType.preview, pointBounds);

    notifyListeners();
  }

  @override
  void undo() {
    if (!canUndo) return;

    final operation = _undoStack.removeLast();
    _redoStack.add(operation);

    // 鏇存柊棰勮灞?
    _renderManager.invalidateLayer(LayerType.preview);
    notifyListeners();
  }

  /// 灏嗘搷浣滄坊鍔犲埌鎾ら攢鏍?
  void _pushToUndoStack(EraseOperation operation) {
    // 灏濊瘯涓庝笂涓€涓搷浣滃悎骞?
    if (_undoStack.isNotEmpty) {
      final lastOperation = _undoStack.last;
      if (lastOperation.canMergeWith(operation)) {
        _undoStack.removeLast();
        _undoStack.add(lastOperation.mergeWith(operation));
        return;
      }
    }

    _undoStack.add(operation);

    // 闄愬埗鏍堝ぇ灏?
    while (_undoStack.length > _maxStackSize) {
      _undoStack.removeFirst();
    }
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\character_collection\erase_tool\controllers\erase_tool_provider.dart
-----------------------------------
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../models/erase_mode.dart';
import 'erase_tool_controller.dart';
import 'erase_tool_controller_impl.dart';
import 'render_manager_impl.dart';

/// EraseToolController鐨凱rovider
final eraseToolProvider =
    Provider.autoDispose.family<EraseToolController, EraseToolConfig>(
  (ref, config) {
    // 鍒涘缓娓叉煋绠＄悊鍣?
    final renderManager = RenderManagerImpl();

    // 棰勫厛璁剧疆鍥惧儚灏哄锛堝鏋滄湁锛?
    if (config.imageSize != null) {
      renderManager.prepare(config.imageSize!);
    }

    // 鍒涘缓鎺у埗鍣?
    final controller = EraseToolControllerImpl(
      renderManager: renderManager,
      initialBrushSize: config.initialBrushSize,
      initialMode: config.initialMode,
    );

    // 鍦≒rovider閿€姣佹椂閲婃斁璧勬簮
    ref.onDispose(() {
      controller.dispose();
      renderManager.dispose();
    });

    return controller;
  },
);

/// 鎿﹂櫎宸ュ叿閰嶇疆
class EraseToolConfig {
  /// 鍒濆绗斿埛澶у皬
  final double initialBrushSize;

  /// 鍒濆鎿﹂櫎妯″紡
  final EraseMode initialMode;

  /// 鍥惧儚灏哄
  final Size? imageSize;

  /// 鏄惁鍚敤鎬ц兘浼樺寲
  final bool enableOptimizations;

  const EraseToolConfig({
    this.initialBrushSize = 20.0,
    this.initialMode = EraseMode.normal,
    this.imageSize,
    this.enableOptimizations = true,
  });

  /// 鏍规嵁鍥惧儚灏哄鍒涘缓閰嶇疆
  factory EraseToolConfig.fromImage({
    required Size imageSize,
    double? initialBrushSize,
    EraseMode? initialMode,
  }) {
    return EraseToolConfig(
      imageSize: imageSize,
      initialBrushSize: initialBrushSize ?? 20.0,
      initialMode: initialMode ?? EraseMode.normal,
    );
  }

  @override
  int get hashCode => Object.hash(
        initialBrushSize,
        initialMode,
        imageSize,
        enableOptimizations,
      );

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    return other is EraseToolConfig &&
        other.initialBrushSize == initialBrushSize &&
        other.initialMode == initialMode &&
        other.imageSize == imageSize &&
        other.enableOptimizations == enableOptimizations;
  }

  /// 鍒涘缓鏂扮殑閰嶇疆瀹炰緥
  EraseToolConfig copyWith({
    double? initialBrushSize,
    EraseMode? initialMode,
    Size? imageSize,
    bool? enableOptimizations,
  }) {
    return EraseToolConfig(
      initialBrushSize: initialBrushSize ?? this.initialBrushSize,
      initialMode: initialMode ?? this.initialMode,
      imageSize: imageSize ?? this.imageSize,
      enableOptimizations: enableOptimizations ?? this.enableOptimizations,
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\character_collection\erase_tool\controllers\render_manager.dart
-----------------------------------
import 'dart:ui' as ui;

import 'package:flutter/material.dart';

import '../models/render_types.dart';

/// 娓叉煋绠＄悊鍣ㄦ帴鍙?
abstract class RenderManager {
  /// 娓呴櫎鎸囧畾绫诲瀷鐨勭紦瀛?
  void clearCache(CacheType type);

  /// 娓呴櫎鍥惧眰鑴忓尯鍩?
  void clearDirtyRegion(LayerType type);

  /// 閲婃斁璧勬簮
  void dispose();

  /// 寮哄埗閲嶇粯鎵€鏈夊浘灞?
  void forceRepaint();

  /// 鑾峰彇鎸囧畾绫诲瀷鐨勭紦瀛?
  ui.Image? getCache(CacheType type);

  /// 鑾峰彇缂撳瓨缁熻淇℃伅
  CacheStats getCacheStats();

  /// 鑾峰彇鍥惧眰鑴忓尯鍩?
  Rect? getDirtyRegion(LayerType type);

  /// 鑾峰彇鎸囧畾绫诲瀷鐨勫浘灞傚浘鍍?
  ui.Image? getLayerImage(LayerType type);

  /// 浣挎寚瀹氬浘灞傛棤鏁堬紙闇€瑕侀噸缁橈級
  void invalidateLayer(LayerType type);

  /// 鍑嗗娓叉煋璧勬簮
  Future<void> prepare(Size size);

  /// 閲嶅缓鎵€鏈夌紦瀛?
  void rebuildCaches();

  /// 璁剧疆鍥惧眰鑴忓尯鍩?
  void setDirtyRegion(LayerType type, Rect region);

  /// 鏇存柊缂撳瓨
  void updateCache(CacheType type, ui.Image data);

  /// 鏇存柊鍥惧眰
  void updateLayer(LayerType type, dynamic data);
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\character_collection\erase_tool\controllers\render_manager_impl.dart
-----------------------------------
import 'dart:ui' as ui;

import 'package:flutter/material.dart';

import '../models/render_types.dart';
import 'render_manager.dart';

/// 娓叉煋绠＄悊鍣ㄥ疄鐜?
class RenderManagerImpl implements RenderManager {
  /// 鍥惧眰鍥惧儚缂撳瓨
  final Map<LayerType, ui.Image?> _layerImages = {};

  /// 鍥惧眰鑴忓尯鍩?
  final Map<LayerType, Rect?> _dirtyRegions = {};

  /// 绫诲瀷缂撳瓨
  final Map<CacheType, ui.Image?> _caches = {};

  /// 鐢诲竷灏哄
  Size? _size;

  /// 缂撳瓨缁熻
  final Map<CacheType, int> _cacheHits = {};
  final Map<CacheType, int> _cacheMisses = {};

  @override
  void clearCache(CacheType type) {
    _caches[type]?.dispose();
    _caches.remove(type);
  }

  @override
  void clearDirtyRegion(LayerType type) {
    _dirtyRegions.remove(type);
  }

  @override
  void dispose() {
    // 娓呯悊鎵€鏈夊浘鍍忚祫婧?
    for (final image in [..._layerImages.values, ..._caches.values]) {
      image?.dispose();
    }
    _layerImages.clear();
    _caches.clear();
    _dirtyRegions.clear();
  }

  @override
  void forceRepaint() {
    // 灏嗘墍鏈夊浘灞傛爣璁颁负鑴忓尯鍩?
    for (final type in LayerType.values) {
      if (_layerImages.containsKey(type)) {
        _dirtyRegions[type] = Rect.fromLTWH(
          0,
          0,
          _size?.width ?? 0,
          _size?.height ?? 0,
        );
      }
    }
  }

  @override
  ui.Image? getCache(CacheType type) {
    final image = _caches[type];
    if (image != null) {
      _cacheHits[type] = (_cacheHits[type] ?? 0) + 1;
    } else {
      _cacheMisses[type] = (_cacheMisses[type] ?? 0) + 1;
    }
    return image;
  }

  @override
  CacheStats getCacheStats() {
    int totalSize = 0;
    int totalHits = 0;
    int totalMisses = 0;

    for (final type in CacheType.values) {
      if (_caches.containsKey(type)) {
        final image = _caches[type];
        if (image != null) {
          // 浼扮畻鍥惧儚鍐呭瓨澶у皬
          totalSize += image.width * image.height * 4; // 4瀛楄妭/鍍忕礌
        }
      }
      totalHits += _cacheHits[type] ?? 0;
      totalMisses += _cacheMisses[type] ?? 0;
    }

    return CacheStats(
      size: totalSize,
      hits: totalHits,
      misses: totalMisses,
    );
  }

  @override
  Rect? getDirtyRegion(LayerType type) => _dirtyRegions[type];

  @override
  ui.Image? getLayerImage(LayerType type) => _layerImages[type];

  @override
  void invalidateLayer(LayerType type) {
    // 濡傛灉鍥惧眰瀛樺湪锛屾爣璁版暣涓浘灞備负鑴忓尯鍩?
    if (_layerImages.containsKey(type)) {
      _dirtyRegions[type] = Rect.fromLTWH(
        0,
        0,
        _size?.width ?? 0,
        _size?.height ?? 0,
      );
    }
  }

  @override
  Future<void> prepare(Size size) async {
    _size = size;
    // 娓呴櫎鎵€鏈夎剰鍖哄煙
    _dirtyRegions.clear();

    // 妫€鏌ュ苟璋冩暣鍥惧眰灏哄
    for (final entry in _layerImages.entries) {
      final image = entry.value;
      if (image != null &&
          (image.width != size.width.toInt() ||
              image.height != size.height.toInt())) {
        // 鍥惧眰灏哄涓嶅尮閰嶏紝闇€瑕侀噸鏂板垱寤?
        _layerImages[entry.key]?.dispose();
        _layerImages[entry.key] = null;
        invalidateLayer(entry.key);
      }
    }
  }

  @override
  void rebuildCaches() {
    // 娓呴櫎鎵€鏈夌紦瀛?
    for (final cache in _caches.values) {
      cache?.dispose();
    }
    _caches.clear();

    // 閲嶇疆缁熻鏁版嵁
    _cacheHits.clear();
    _cacheMisses.clear();
  }

  @override
  void setDirtyRegion(LayerType type, Rect region) {
    final existing = _dirtyRegions[type];
    if (existing == null) {
      _dirtyRegions[type] = region;
    } else {
      // 鍚堝苟鑴忓尯鍩?
      _dirtyRegions[type] = existing.expandToInclude(region);
    }
  }

  @override
  void updateCache(CacheType type, ui.Image data) {
    _caches[type]?.dispose();
    _caches[type] = data;
  }

  @override
  void updateLayer(LayerType type, dynamic data) {
    if (data is ui.Image) {
      _layerImages[type]?.dispose();
      _layerImages[type] = data;
    } else {
      throw ArgumentError('Invalid layer data type');
    }
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\character_collection\erase_tool\models\erase_mode.dart
-----------------------------------
/// 鎿﹂櫎妯″紡
enum EraseMode {
  /// 鏅€氭摝闄?
  normal,

  /// 绮剧‘鎿﹂櫎
  precise,

  /// 鏅鸿兘鎿﹂櫎
  smart,

  /// 鐭╁舰鎿﹂櫎
  rectangle,

  /// 鍦嗗舰鎿﹂櫎
  circle;

  /// 鑾峰彇绗斿埛澶у皬鑼冨洿
  (double, double) get brushSizeRange {
    switch (this) {
      case EraseMode.normal:
        return (10.0, 50.0);
      case EraseMode.precise:
        return (5.0, 20.0);
      case EraseMode.smart:
        return (15.0, 60.0);
      case EraseMode.rectangle:
        return (20.0, 100.0);
      case EraseMode.circle:
        return (20.0, 100.0);
    }
  }

  /// 鑾峰彇榛樿绗斿埛澶у皬
  double get defaultBrushSize {
    switch (this) {
      case EraseMode.normal:
        return 20.0;
      case EraseMode.precise:
        return 10.0;
      case EraseMode.smart:
        return 30.0;
      case EraseMode.rectangle:
        return 40.0;
      case EraseMode.circle:
        return 40.0;
    }
  }

  /// 鑾峰彇妯″紡鍚嶇О
  String get displayName {
    switch (this) {
      case EraseMode.normal:
        return '鏅€氭摝闄?;
      case EraseMode.precise:
        return '绮剧‘鎿﹂櫎';
      case EraseMode.smart:
        return '鏅鸿兘鎿﹂櫎';
      case EraseMode.rectangle:
        return '鐭╁舰鎿﹂櫎';
      case EraseMode.circle:
        return '鍦嗗舰鎿﹂櫎';
    }
  }

  /// 鏄惁鏀寔绗斿帇鎰熷簲
  bool get supportsPressure {
    switch (this) {
      case EraseMode.normal:
      case EraseMode.precise:
        return true;
      default:
        return false;
    }
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\character_collection\erase_tool\models\erase_operation.dart
-----------------------------------
import 'dart:ui';

import 'erase_mode.dart';

/// 鎿﹂櫎鎿嶄綔
class EraseOperation {
  /// 鍞竴鏍囪瘑绗?
  final String id;

  /// 璺緞鐐瑰垪琛?
  final List<Offset> points;

  /// 绗斿埛澶у皬
  final double brushSize;

  /// 鎿﹂櫎妯″紡
  final EraseMode mode;

  /// 鍒涘缓鏃堕棿
  final DateTime timestamp;

  /// 鑴忓尯鍩?
  Rect? _boundingBox;

  /// 璺緞缂撳瓨
  Path? _cachedPath;

  EraseOperation({
    String? id,
    List<Offset>? points,
    double? brushSize,
    EraseMode? mode,
    DateTime? timestamp,
  })  : id = id ?? DateTime.now().millisecondsSinceEpoch.toString(),
        points = points ?? <Offset>[],
        brushSize = brushSize ?? 20.0,
        mode = mode ?? EraseMode.normal,
        timestamp = timestamp ?? DateTime.now();

  /// 鑾峰彇鎿嶄綔鐨勮竟鐣岀煩褰?
  Rect get bounds {
    if (_boundingBox != null) return _boundingBox!;

    if (points.isEmpty) {
      return Rect.zero;
    }

    double minX = points[0].dx;
    double minY = points[0].dy;
    double maxX = points[0].dx;
    double maxY = points[0].dy;

    for (var point in points) {
      if (point.dx < minX) minX = point.dx;
      if (point.dy < minY) minY = point.dy;
      if (point.dx > maxX) maxX = point.dx;
      if (point.dy > maxY) maxY = point.dy;
    }

    // 鑰冭檻绗斿埛澶у皬
    final halfBrush = brushSize / 2;
    _boundingBox = Rect.fromLTRB(
      minX - halfBrush,
      minY - halfBrush,
      maxX + halfBrush,
      maxY + halfBrush,
    );

    return _boundingBox!;
  }

  @override
  int get hashCode => id.hashCode;

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    return other is EraseOperation && other.id == id;
  }

  /// 娣诲姞鐐?
  void addPoint(Offset point) {
    points.add(point);
    // 娓呴櫎缂撳瓨
    _boundingBox = null;
    _cachedPath = null;
  }

  /// 搴旂敤鎿﹂櫎鏁堟灉鍒扮敾甯?
  void apply(Canvas canvas) {
    if (points.isEmpty) return;

    final path = createPath();
    final paint = Paint()
      ..color = const Color(0xFFFFFFFF) // 鐧借壊
      ..strokeWidth = brushSize
      ..strokeCap = StrokeCap.round
      ..strokeJoin = StrokeJoin.round
      ..style = PaintingStyle.stroke
      ..blendMode = BlendMode.clear; // 娓呴櫎妯″紡

    // 缁樺埗璺緞
    canvas.drawPath(path, paint);

    // 鍦ㄦ瘡涓偣缁樺埗鍦嗗舰锛岀‘淇濇柇鐐瑰涔熻鎿﹂櫎
    paint.style = PaintingStyle.fill;
    for (final point in points) {
      canvas.drawCircle(point, brushSize / 2, paint);
    }
  }

  /// 妫€鏌ユ槸鍚﹀彲浠ヤ笌鍙︿竴涓搷浣滃悎骞?
  bool canMergeWith(EraseOperation other) {
    if (mode != other.mode || brushSize != other.brushSize) {
      return false;
    }

    // 妫€鏌ユ椂闂撮棿闅?
    const maxTimeGap = Duration(milliseconds: 500);
    if (other.timestamp.difference(timestamp).abs() > maxTimeGap) {
      return false;
    }

    // 妫€鏌ョ┖闂磋窛绂?
    if (points.isNotEmpty && other.points.isNotEmpty) {
      final lastPoint = points.last;
      final firstPoint = other.points.first;
      const maxDistance = 20.0;
      if ((lastPoint - firstPoint).distance > maxDistance) {
        return false;
      }
    }

    return true;
  }

  /// 鍒涘缓绗斿埛璺緞
  Path createPath() {
    if (_cachedPath != null) return _cachedPath!;

    final path = Path();
    if (points.isEmpty) return path;

    path.moveTo(points[0].dx, points[0].dy);
    for (int i = 1; i < points.length; i++) {
      path.lineTo(points[i].dx, points[i].dy);
    }

    _cachedPath = path;
    return path;
  }

  /// 鑾峰彇杈圭晫鐭╁舰锛堢敤浜庡吋瀹规€э級
  Rect getBounds() => bounds;

  /// 涓庡彟涓€涓搷浣滃悎骞?
  EraseOperation mergeWith(EraseOperation other) {
    if (!canMergeWith(other)) {
      throw StateError('Cannot merge incompatible operations');
    }

    return EraseOperation(
      id: id, // 淇濇寔鍘焛d
      points: [...points, ...other.points],
      brushSize: brushSize,
      mode: mode,
      timestamp: timestamp,
    );
  }

  /// 浼樺寲璺緞鐐?
  EraseOperation optimize() {
    if (points.length < 3) return this;

    final optimizedPoints = <Offset>[points.first];
    const minDistance = 5.0; // 鏈€灏忕偣璺濈

    for (int i = 1; i < points.length - 1; i++) {
      final prev = points[i - 1];
      final curr = points[i];
      final next = points[i + 1];

      // 璁＄畻褰撳墠鐐瑰埌鍓嶅悗鐐圭殑璺濈
      final d1 = (curr - prev).distance;
      final d2 = (next - curr).distance;

      // 濡傛灉璺濈澶皬锛岃烦杩囧綋鍓嶇偣
      if (d1 < minDistance && d2 < minDistance) continue;

      // 璁＄畻瑙掑害鍙樺寲
      final angle1 = (curr - prev).direction;
      final angle2 = (next - curr).direction;
      final angleDiff = (angle2 - angle1).abs();

      // 濡傛灉瑙掑害鍙樺寲澶э紝淇濈暀璇ョ偣
      if (angleDiff > 0.3) {
        // 绾?7搴?
        optimizedPoints.add(curr);
      }
    }

    optimizedPoints.add(points.last);

    return EraseOperation(
      id: id,
      points: optimizedPoints,
      brushSize: brushSize,
      mode: mode,
      timestamp: timestamp,
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\character_collection\erase_tool\models\render_types.dart
-----------------------------------
import 'dart:ui' as ui;

import 'package:flutter/material.dart';

/// 缂撳瓨缁熻淇℃伅
class CacheStats {
  /// 缂撳瓨澶у皬
  final int size;

  /// 鍛戒腑娆℃暟
  final int hits;

  /// 鏈懡涓鏁?
  final int misses;

  const CacheStats({
    this.size = 0,
    this.hits = 0,
    this.misses = 0,
  });

  /// 璁＄畻鍛戒腑鐜?
  double get hitRate => hits / (hits + misses);
}

/// 缂撳瓨绫诲瀷
enum CacheType {
  /// 涓存椂缂撳瓨
  temp,

  /// 鎸佷箙缂撳瓨
  persistent,

  /// 鍚堟垚缂撳瓨
  composite;

  /// 鑾峰彇缂撳瓨鍚嶇О
  String get displayName {
    switch (this) {
      case CacheType.temp:
        return '涓存椂缂撳瓨';
      case CacheType.persistent:
        return '鎸佷箙缂撳瓨';
      case CacheType.composite:
        return '鍚堟垚缂撳瓨';
    }
  }
}

/// 鍥惧眰鏁版嵁缁撴瀯
class LayerData {
  /// 鍥惧儚鏁版嵁
  final ui.Image? image;

  /// 鑴忓尯鍩?
  final Rect? dirtyRegion;

  /// 鏄惁闇€瑕侀噸缁?
  final bool needsRepaint;

  const LayerData({
    this.image,
    this.dirtyRegion,
    this.needsRepaint = false,
  });

  /// 鍒涘缓鏂扮殑鍥惧眰鏁版嵁
  LayerData copyWith({
    ui.Image? image,
    Rect? dirtyRegion,
    bool? needsRepaint,
  }) {
    return LayerData(
      image: image ?? this.image,
      dirtyRegion: dirtyRegion ?? this.dirtyRegion,
      needsRepaint: needsRepaint ?? this.needsRepaint,
    );
  }
}

/// 鍥惧眰绫诲瀷
enum LayerType {
  /// 鍘熷鍥惧眰
  original,

  /// 缂撳啿鍥惧眰
  buffer,

  /// 棰勮鍥惧眰
  preview,

  /// UI鍥惧眰
  ui;

  /// 鑾峰彇鍥惧眰鍚嶇О
  String get displayName {
    switch (this) {
      case LayerType.original:
        return '鍘熷鍥惧眰';
      case LayerType.buffer:
        return '缂撳啿鍥惧眰';
      case LayerType.preview:
        return '棰勮鍥惧眰';
      case LayerType.ui:
        return 'UI鍥惧眰';
    }
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\character_collection\erase_tool\states\erase_layer_state.dart
-----------------------------------
import 'dart:ui' as ui;

import 'package:flutter/material.dart';

import '../models/erase_operation.dart';
import '../utils/render_cache.dart';

/// 鎿﹂櫎鍥惧眰鐘舵€?
/// 绠＄悊鎿﹂櫎鎿嶄綔鐨勭姸鎬佸拰缂撳啿
class EraseLayerState extends ChangeNotifier {
  /// 宸插畬鎴愮殑鎿﹂櫎鎿嶄綔鍒楄〃
  final List<EraseOperation> _operations = [];

  /// 褰撳墠姝ｅ湪杩涜鐨勬摝闄ゆ搷浣?
  EraseOperation? _currentOperation;

  /// 鍥惧眰缂撳啿
  ui.Image? _buffer;

  /// 鏄惁闇€瑕侀噸鏂扮敓鎴愮紦鍐?
  bool _isDirty = true;

  /// 鍘熷鍥惧儚
  ui.Image? _originalImage;

  /// 褰撳墠鐘舵€佺被鍨?
  EraseStateType _stateType = EraseStateType.idle;

  /// 娓叉煋缂撳瓨
  final RenderCache _renderCache = RenderCache();

  /// 鏄剧ず鐨勮建杩圭偣
  final List<Offset> _displayPoints = [];

  /// 鏄剧ず鐨勮竟鐣屽尯鍩?
  Rect? _dirtyRegion;

  /// 鐘舵€侀攣锛岄槻姝㈠苟鍙戦棶棰?
  bool _isUpdating = false;

  /// 鑾峰彇鍥惧眰缂撳啿
  ui.Image? get buffer => _buffer;

  /// 璁剧疆鍥惧眰缂撳啿
  set buffer(ui.Image? buffer) {
    _buffer = buffer;
    _isDirty = false;
  }

  /// 鑾峰彇褰撳墠鎿嶄綔
  EraseOperation? get currentOperation => _currentOperation;

  /// 鑾峰彇褰撳墠鎿﹂櫎鐐?
  List<Offset> get currentPoints => _currentOperation?.points ?? <Offset>[];

  /// 鑾峰彇鑴忓尯鍩?
  Rect? get dirtyRegion => _dirtyRegion;

  /// 鑾峰彇鏄剧ず鐐?
  List<Offset> get displayPoints => List.unmodifiable(_displayPoints);

  /// 鏄惁鏈夊綋鍓嶆搷浣?
  bool get hasCurrentOperation => _currentOperation != null;

  /// 鏄惁闇€瑕侀噸寤虹紦鍐?
  bool get isDirty => _isDirty;

  /// 鑾峰彇鎵€鏈夊凡瀹屾垚鐨勬搷浣?
  List<EraseOperation> get operations => List.unmodifiable(_operations);

  /// 鑾峰彇鍘熷鍥惧儚
  ui.Image? get originalImage => _originalImage;

  /// 璁剧疆鍘熷鍥惧儚
  set originalImage(ui.Image? image) {
    _originalImage = image;
    _isDirty = true;
    notifyListeners();
  }

  /// 鑾峰彇娓叉煋缂撳瓨
  RenderCache get renderCache => _renderCache;

  /// 鑾峰彇褰撳墠鐘舵€佺被鍨?
  EraseStateType get stateType => _stateType;

  /// 娣诲姞鎿嶄綔
  void addOperation(EraseOperation operation) {
    _operations.add(operation);
    _isDirty = true;
    notifyListeners();
  }

  /// 娣诲姞鐐瑰埌褰撳墠鎿嶄綔
  void addPoint(Offset point) {
    if (_currentOperation == null || _isUpdating) return;
    _isUpdating = true;

    try {
      _currentOperation!.addPoint(point);
      _displayPoints.add(point);

      // 鏇存柊鑴忓尯鍩?
      _updateDirtyRegion(point, _currentOperation!.brushSize);

      notifyListeners();
    } finally {
      _isUpdating = false;
    }
  }

  /// 鎵ц閲嶅仛鎿嶄綔
  void applyRedo(EraseOperation operation) {
    if (_isUpdating) return;
    _isUpdating = true;

    try {
      _stateType = EraseStateType.redoing;

      // 娣诲姞鍒版搷浣滃垪琛?
      _operations.add(operation);

      // 鏇存柊娓叉煋缂撳瓨
      _renderCache.invalidateCache();
      _isDirty = true;

      // 鎭㈠鐘舵€?
      _stateType = EraseStateType.idle;

      notifyListeners();
    } finally {
      _isUpdating = false;
    }
  }

  /// 鎵ц鎾ら攢鎿嶄綔
  void applyUndo(EraseOperation operation) {
    if (_isUpdating) return;
    _isUpdating = true;

    try {
      _stateType = EraseStateType.undoing;

      // 浠庢搷浣滃垪琛ㄤ腑绉婚櫎
      _operations.removeWhere((op) => op.id == operation.id);

      // 鏇存柊娓叉煋缂撳瓨
      _renderCache.invalidateCache();
      _isDirty = true;

      // 鎭㈠鐘舵€?
      _stateType = EraseStateType.idle;

      notifyListeners();
    } finally {
      _isUpdating = false;
    }
  }

  /// 鍙栨秷褰撳墠鎿嶄綔
  void cancelCurrentOperation() {
    if (_currentOperation == null || _isUpdating) return;
    _isUpdating = true;

    try {
      _currentOperation = null;
      _displayPoints.clear();
      _dirtyRegion = null;
      _stateType = EraseStateType.idle;

      notifyListeners();
    } finally {
      _isUpdating = false;
    }
  }

  /// 娓呴櫎鎵€鏈夋搷浣?
  void clearOperations() {
    if (_isUpdating) return;
    _isUpdating = true;

    try {
      _operations.clear();
      _currentOperation = null;
      _displayPoints.clear();
      _dirtyRegion = null;
      _renderCache.clearCache();
      _isDirty = true;
      _stateType = EraseStateType.idle;

      notifyListeners();
    } finally {
      _isUpdating = false;
    }
  }

  /// 鎻愪氦褰撳墠鎿嶄綔
  EraseOperation? commitCurrentOperation() {
    if (_currentOperation == null || _isUpdating) return null;
    _isUpdating = true;

    try {
      _stateType = EraseStateType.committing;
      final operation = _currentOperation!;

      if (operation.points.length > 1) {
        // 鍙繚瀛樻湁鏁堢殑鎿嶄綔
        _operations.add(operation);
        _isDirty = true;

        // 灏嗗綋鍓嶆樉绀虹偣娣诲姞鍒版覆鏌撶紦瀛?
        _renderCache.addDisplayOperation(operation);
      }

      _currentOperation = null;
      _displayPoints.clear();
      _dirtyRegion = null;
      _stateType = EraseStateType.idle;

      notifyListeners();

      return operation.points.length > 1 ? operation : null;
    } finally {
      _isUpdating = false;
    }
  }

  /// 閲婃斁璧勬簮
  @override
  void dispose() {
    _buffer?.dispose();
    _renderCache.dispose();
    super.dispose();
  }

  /// 鏍囪鍥惧眰涓鸿剰锛岄渶瑕侀噸鏂扮敓鎴愮紦鍐?
  void markDirty() {
    _isDirty = true;
    notifyListeners();
  }

  /// 绉婚櫎鏈€鍚庝竴涓搷浣?
  EraseOperation? removeLastOperation() {
    if (_operations.isEmpty) return null;

    final operation = _operations.removeLast();
    _isDirty = true;
    notifyListeners();

    return operation;
  }

  /// 閲嶇疆鑴忓尯鍩?
  void resetDirtyRegion() {
    _dirtyRegion = null;
  }

  /// 寮€濮嬫柊鐨勬摝闄ゆ搷浣?
  void startNewOperation(Offset point, double brushSize) {
    if (_isUpdating) return;
    _isUpdating = true;

    try {
      _stateType = EraseStateType.erasing;
      _currentOperation = EraseOperation(
        id: DateTime.now().toString(),
        brushSize: brushSize,
      );

      _currentOperation!.addPoint(point);
      _displayPoints.clear();
      _displayPoints.add(point);

      // 鏇存柊鑴忓尯鍩?
      _updateDirtyRegion(point, brushSize);

      notifyListeners();
    } finally {
      _isUpdating = false;
    }
  }

  /// 鏇存柊鑴忓尯鍩?
  void _updateDirtyRegion(Offset point, double brushSize) {
    final pointRect = Rect.fromCircle(
      center: point,
      radius: brushSize / 2,
    );

    if (_dirtyRegion == null) {
      _dirtyRegion = pointRect;
    } else {
      _dirtyRegion = _dirtyRegion!.expandToInclude(pointRect);
    }
  }
}

/// 鎿﹂櫎鐘舵€佺被鍨?
enum EraseStateType {
  /// 绌洪棽鐘舵€?
  idle,

  /// 鎿﹂櫎涓姸鎬?
  erasing,

  /// 鎻愪氦鎿嶄綔鐘舵€?
  committing,

  /// 鎾ら攢涓姸鎬?
  undoing,

  /// 閲嶅仛涓姸鎬?
  redoing,
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\character_collection\erase_tool\states\erase_state_manager.dart
-----------------------------------
import 'dart:async';
import 'dart:ui' as ui;

import 'package:flutter/material.dart';

import '../models/erase_operation.dart';
import '../utils/render_cache.dart';
import '../utils/undo_manager.dart';
import 'erase_layer_state.dart';

/// 鎿﹂櫎鐘舵€佹洿鏂颁簨浠?
class EraseStateEvent {
  /// 浜嬩欢绫诲瀷
  final EraseStateType type;

  /// 鐩稿叧鎿嶄綔
  final EraseOperation? operation;

  /// 鐩稿叧鐐?
  final List<Offset>? points;

  /// 鏋勯€犲嚱鏁?
  EraseStateEvent({
    required this.type,
    this.operation,
    this.points,
  });
}

/// 鎿﹂櫎鐘舵€佺鐞嗗櫒
/// 璐熻矗鍗忚皟鍚勭粍浠剁殑鐘舵€侊紝纭繚鐘舵€佸悓姝?
class EraseStateManager {
  /// 鍥惧眰鐘舵€?
  final EraseLayerState _layerState;

  /// 鎾ら攢绠＄悊鍣?
  final UndoManager _undoManager;

  /// 娓叉煋缂撳瓨
  final RenderCache _renderCache;

  /// 鐘舵€佷簨浠舵祦鎺у埗鍣?
  final StreamController<EraseStateEvent> _stateEventController =
      StreamController<EraseStateEvent>.broadcast();

  /// 鏋勯€犲嚱鏁?
  EraseStateManager({
    EraseLayerState? layerState,
    UndoManager? undoManager,
    RenderCache? renderCache,
  })  : _layerState = layerState ?? EraseLayerState(),
        _undoManager = undoManager ?? UndoManager(),
        _renderCache = renderCache ?? RenderCache() {
    // 璁剧疆鐘舵€佸悓姝?
    _setupStateSynchronization();
  }

  /// 鑾峰彇鍥惧眰鐘舵€?
  EraseLayerState get layerState => _layerState;

  /// 鑾峰彇娓叉煋缂撳瓨
  RenderCache get renderCache => _renderCache;

  /// 鑾峰彇鐘舵€佷簨浠舵祦
  Stream<EraseStateEvent> get stateEvents => _stateEventController.stream;

  /// 鑾峰彇鎾ら攢绠＄悊鍣?
  UndoManager get undoManager => _undoManager;

  /// 鍙栨秷鎿﹂櫎鎿嶄綔
  void cancelErase() {
    _layerState.cancelCurrentOperation();
  }

  /// 娓呴櫎鎵€鏈?
  void clearAll() {
    _undoManager.clear();
    _layerState.clearOperations();
    _renderCache.clearCache();
  }

  /// 缁х画鎿﹂櫎鎿嶄綔
  void continueErase(Offset point) {
    _layerState.addPoint(point);
  }

  /// 閲婃斁璧勬簮
  void dispose() {
    _stateEventController.close();
    _layerState.dispose();
    _renderCache.dispose();
    _undoManager.removeStateChangeListener(_handleUndoManagerStateChange);
  }

  /// 缁撴潫鎿﹂櫎鎿嶄綔
  void endErase() {
    final operation = _layerState.commitCurrentOperation();
    if (operation != null) {
      _undoManager.push(operation);
      _undoManager.tryMergeLastOperations();
    }
  }

  /// 閲嶅仛鎿嶄綔
  void redo() {
    _undoManager.redo();
  }

  /// 寮€濮嬫摝闄ゆ搷浣?
  void startErase(Offset point, double brushSize) {
    _layerState.startNewOperation(point, brushSize);
  }

  /// 鎾ら攢鎿嶄綔
  void undo() {
    _undoManager.undo();
  }

  /// 鏇存柊鍥惧眰鐘舵€?
  Future<void> updateLayerState(ui.Image originalImage) async {
    // 鏇存柊娓叉煋缂撳瓨
    if (_renderCache.isDirty) {
      await _renderCache.updateStaticCache(originalImage);

      // 鏇存柊鍥惧眰鐘舵€佺殑缂撳啿
      _layerState.buffer = _renderCache.staticCache;
    }
  }

  /// 澶勭悊鍥惧眰鐘舵€佸彉鍖?
  void _handleLayerStateChange() {
    // 鍚屾缂撳瓨鐘舵€?
    if (_layerState.isDirty) {
      _renderCache.invalidateCache();
    }

    // 閫氱煡鐘舵€佷簨浠?
    _stateEventController.add(EraseStateEvent(
      type: _layerState.stateType,
      points: _layerState.displayPoints,
    ));
  }

  /// 澶勭悊鎾ら攢绠＄悊鍣ㄧ姸鎬佸彉鍖?
  void _handleUndoManagerStateChange(EraseOperation operation, bool isUndo) {
    if (isUndo) {
      _layerState.applyUndo(operation);

      // 閫氱煡鐘舵€佷簨浠?
      _stateEventController.add(EraseStateEvent(
        type: EraseStateType.undoing,
        operation: operation,
      ));
    } else {
      _layerState.applyRedo(operation);

      // 閫氱煡鐘舵€佷簨浠?
      _stateEventController.add(EraseStateEvent(
        type: EraseStateType.redoing,
        operation: operation,
      ));
    }
  }

  /// 璁剧疆鐘舵€佸悓姝?
  void _setupStateSynchronization() {
    // 鐩戝惉鎾ら攢绠＄悊鍣ㄧ姸鎬佸彉鍖?
    _undoManager.addStateChangeListener(_handleUndoManagerStateChange);

    // 鐩戝惉鍥惧眰鐘舵€佸彉鍖?
    _layerState.addListener(_handleLayerStateChange);
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\character_collection\erase_tool\utils\coordinate_transformer.dart
-----------------------------------
import 'dart:math' as math;
import 'dart:ui' as ui;

import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:vector_math/vector_math_64.dart' as vm;

/// 鍧愭爣杞崲鍣?
/// 璐熻矗灏嗗鍣ㄥ潗鏍囪浆鎹负鍥惧儚鍧愭爣
class CoordinateTransformer {
  /// 鍙樻崲鐭╅樀
  Matrix4 _transformMatrix = Matrix4.identity();

  /// 瀹瑰櫒澶у皬
  Size _containerSize = Size.zero;

  /// 鍥惧儚澶у皬
  Size _imageSize = Size.zero;

  /// 瀹瑰櫒鍋忕Щ
  Offset _containerOffset = Offset.zero;

  /// 瑙嗗彛鍖哄煙
  Rect _viewport = Rect.zero;

  /// 璋冭瘯妯″紡鏍囪
  bool _isDebugging = true; // 榛樿鍚敤璋冭瘯锛屽府鍔╂帓鏌ラ棶棰?

  /// 鏈€鍚庝竴娆¤浆鎹㈢殑鐐?
  final List<Offset> _lastTransformedPoints = [];

  /// 棰濆缂╂斁绯绘暟锛屼慨姝ｇ缉鏀鹃棶棰?
  double _scaleCorrection = 1.0;

  /// 鏍″噯鍋忕Щ閲忥紝寰皟浣嶇疆鍖归厤
  Offset _calibrationOffset = Offset.zero;

  /// 鑾峰彇鏈€鍚庝竴娆¤浆鎹㈢殑鐐癸紝鐢ㄤ簬璋冭瘯
  List<Offset> get lastTransformedPoints =>
      List.unmodifiable(_lastTransformedPoints);

  /// 绂佺敤璋冭瘯妯″紡
  void disableDebug() {
    _isDebugging = false;
  }

  /// 鍚敤璋冭瘯妯″紡
  void enableDebug() {
    _isDebugging = true;
  }

  /// 鍒濆鍖栧彉鎹?
  void initializeTransform({
    required Matrix4 transformMatrix,
    required Size containerSize,
    required Size imageSize,
    required Offset containerOffset,
    Rect? viewport,
    double scaleCorrection = 1.0,
    Offset calibrationOffset = Offset.zero,
  }) {
    if (kDebugMode) {
      print('馃敡 鍒濆鍖栧潗鏍囪浆鎹㈠櫒');
      print('  - 瀹瑰櫒澶у皬: $containerSize');
      print('  - 鍥惧儚澶у皬: $imageSize');
      print('  - 瀹瑰櫒鍋忕Щ: $containerOffset');
      print('  - 鍙樻崲鐭╅樀: ${_matrixToString(transformMatrix)}');
    }

    _transformMatrix = transformMatrix;
    _containerSize = containerSize;
    _imageSize = imageSize;
    _containerOffset = containerOffset;
    _scaleCorrection = scaleCorrection;
    _calibrationOffset = calibrationOffset;

    if (viewport != null) {
      _viewport = viewport;
    } else {
      // 榛樿瑙嗗彛涓哄畬鏁村鍣?
      _viewport =
          Rect.fromLTWH(0, 0, containerSize.width, containerSize.height);
    }

    // 璁＄畻鏈夋晥姣斾緥锛岀敤浜庤皟璇曡緭鍑?
    final effectiveScale = _getEffectiveScale();

    _logDebugInfo('鍒濆鍖栧彉鎹?, {
      'transformMatrix': _matrixToString(transformMatrix),
      'containerSize': containerSize,
      'imageSize': imageSize,
      'containerOffset': containerOffset,
      'viewport': _viewport,
      'effectiveScale': effectiveScale,
      'scaleCorrection': _scaleCorrection,
      'calibrationOffset': _calibrationOffset,
    });
  }

  /// 璁剧疆鏍″噯鍋忕Щ锛岀敤浜庡井璋冨潗鏍囧尮閰?
  void setCalibrationOffset(Offset offset) {
    _calibrationOffset = offset;
    _logDebugInfo('鏇存柊鏍″噯鍋忕Щ', {'calibrationOffset': offset});
  }

  /// 杞崲鐐瑰潗鏍?(瀹瑰櫒鍧愭爣 -> 鍥惧儚鍧愭爣)
  Offset transformPoint(Offset point) {
    try {
      // 搴旂敤璁惧鍍忕礌姣?
      final physicalPoint = point * ui.window.devicePixelRatio;

      // 妫€鏌ュ鍣ㄥ拰鍥惧儚灏哄锛岄伩鍏嶉櫎浠ラ浂閿欒
      if (_containerSize.isEmpty || _imageSize.isEmpty) {
        _logDebugInfo('杞崲閿欒', {'reason': '瀹瑰櫒鎴栧浘鍍忓昂瀵镐负闆?});
        return point;
      }

      // 鑾峰彇鐭╅樀鍙樻崲鐨勫奖鍝?
      final matrixScale = _getMatrixScale();

      // 璁＄畻瀹瑰櫒涓浘鍍忕殑瀹為檯鏄剧ず灏哄鍜岀缉鏀炬瘮渚?
      final effectiveScale = _getEffectiveScale() * _scaleCorrection;
      final imageDisplaySize = Size(_imageSize.width * effectiveScale,
          _imageSize.height * effectiveScale);

      // 璁＄畻鍥惧儚鍦ㄥ鍣ㄤ腑鐨勫眳涓亸绉?
      final offsetX = (_containerSize.width - imageDisplaySize.width) / 2;
      final offsetY = (_containerSize.height - imageDisplaySize.height) / 2;

      // 灏嗙偣浠庡鍣ㄥ潗鏍囩郴杞崲鍒板浘鍍忓潗鏍囩郴
      // 鑰冭檻鍙樻崲鐭╅樀鐨勭缉鏀惧奖鍝?
      final imageX =
          (physicalPoint.dx - offsetX) / (effectiveScale * matrixScale.dx) +
              _calibrationOffset.dx;
      final imageY =
          (physicalPoint.dy - offsetY) / (effectiveScale * matrixScale.dy) +
              _calibrationOffset.dy;

      // 鑾峰彇鍙樻崲鐭╅樀鐨勫钩绉诲垎閲忥紝浣嗕笉鐩存帴浣跨敤
      // 鍥犱负 InteractiveViewer 浼氳嚜鍔ㄥ鐞嗗钩绉?
      final matrixTranslation = _getMatrixTranslation();

      // 鏈€缁堣浆鎹㈠悗鐨勭偣
      final transformedPoint = Offset(imageX, imageY);

      // 璁板綍杞崲缁撴灉锛岀敤浜庤皟璇?
      if (_isDebugging) {
        _lastTransformedPoints.add(transformedPoint);
        if (_lastTransformedPoints.length > 20) {
          _lastTransformedPoints.removeAt(0);
        }

        _logDebugInfo('鍧愭爣杞崲', {
          'input': point,
          'physical': physicalPoint,
          'effectiveScale': effectiveScale,
          'imageDisplay': imageDisplaySize,
          'offset': Offset(offsetX, offsetY),
          'imageCoords': Offset(imageX, imageY),
          'matrixTranslation': matrixTranslation,
          'matrixScale': matrixScale,
          'transformed': transformedPoint,
        });
      }

      return transformedPoint;
    } catch (e) {
      if (kDebugMode) {
        print('鉂?鍧愭爣杞崲閿欒: $e');
      }
      return point;
    }
  }

  /// 鏇存柊瀹瑰櫒鍋忕Щ
  void updateContainerOffset(Offset offset) {
    final oldOffset = _containerOffset;
    if ((oldOffset - offset).distance > 0.1) {
      _containerOffset = offset;
      _logDebugInfo('鏇存柊瀹瑰櫒鍋忕Щ', {
        'old': oldOffset,
        'new': offset,
      });
    }
  }

  /// 鏇存柊瀹瑰櫒澶у皬
  void updateContainerSize(Size size) {
    if (_containerSize != size) {
      _containerSize = size;
      _logDebugInfo('鏇存柊瀹瑰櫒澶у皬', {'size': size});
    }
  }

  /// 鏇存柊鍥惧儚澶у皬
  void updateImageSize(Size size) {
    if (_imageSize != size) {
      _imageSize = size;
      _logDebugInfo('鏇存柊鍥惧儚澶у皬', {'size': size});
    }
  }

  /// 鏇存柊鍙樻崲鐭╅樀
  void updateTransform(Matrix4 transformMatrix) {
    // 妫€鏌ユ槸鍚︽湁鏄庢樉鍙樺寲
    bool hasChange = false;
    for (int i = 0; i < 16; i++) {
      if ((_transformMatrix.storage[i] - transformMatrix.storage[i]).abs() >
          0.001) {
        hasChange = true;
        break;
      }
    }

    if (hasChange) {
      _transformMatrix = transformMatrix;
      if (_isDebugging) {
        _logDebugInfo('鏇存柊鍙樻崲鐭╅樀', {
          'matrix': _matrixToString(transformMatrix),
          'scale': _getMatrixScale(),
          'translation': _getMatrixTranslation(),
        });
      }
    }
  }

  /// 鏇存柊瑙嗗彛鍖哄煙
  void updateViewport(Rect viewport) {
    if (_viewport != viewport) {
      _viewport = viewport;
      _logDebugInfo('鏇存柊瑙嗗彛', {'viewport': viewport});
    }
  }

  /// 鑾峰彇鏈夋晥缂╂斁姣斾緥
  double _getEffectiveScale() {
    // 璁＄畻瀹瑰櫒鍜屽浘鍍忕殑瀹介珮姣?
    final containerRatio = _containerSize.width / _containerSize.height;
    final imageRatio = _imageSize.width / _imageSize.height;

    // 鏍规嵁瀹介珮姣斿喅瀹氫娇鐢ㄥ摢涓淮搴︾殑缂╂斁
    final scale = math.min(_containerSize.width / _imageSize.width,
        _containerSize.height / _imageSize.height);

    return scale;
  }

  /// 鑾峰彇鍙樻崲鐭╅樀鐨勭缉鏀惧垎閲?
  Vector2 _getMatrixScale() {
    // 浠庡彉鎹㈢煩闃典腑鎻愬彇缂╂斁鍒嗛噺
    final scaleX = vm.Vector3(_transformMatrix.getColumn(0).x,
            _transformMatrix.getColumn(0).y, _transformMatrix.getColumn(0).z)
        .length;
    final scaleY = vm.Vector3(_transformMatrix.getColumn(1).x,
            _transformMatrix.getColumn(1).y, _transformMatrix.getColumn(1).z)
        .length;

    return Vector2(scaleX, scaleY);
  }

  /// 鑾峰彇鍙樻崲鐭╅樀鐨勫钩绉诲垎閲?
  Offset _getMatrixTranslation() {
    // 浠庡彉鎹㈢煩闃典腑鎻愬彇骞崇Щ鍒嗛噺
    final translation = _transformMatrix.getTranslation();
    return Offset(translation.x, translation.y);
  }

  /// 璁板綍璋冭瘯淇℃伅
  void _logDebugInfo(String action, Map<String, dynamic> data) {
    if (!_isDebugging) return;

    if (kDebugMode) {
      print('馃攳 CoordinateTransformer - $action:');
      data.forEach((key, value) {
        print('  $key: $value');
      });
    }
  }

  /// 灏嗙煩闃佃浆鎹负鍙瀛楃涓?
  String _matrixToString(Matrix4 matrix) {
    return 'Matrix4(${matrix.storage.take(4).join(', ')}...)';
  }
}

/// 2D鍚戦噺
class Vector2 {
  final double dx;
  final double dy;

  const Vector2(this.dx, this.dy);

  @override
  String toString() => 'Vector2($dx, $dy)';
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\character_collection\erase_tool\utils\erase_background_detector.dart
-----------------------------------
import 'dart:math';
import 'dart:ui' as ui;

import 'package:flutter/material.dart';

/// 鑳屾櫙妫€娴嬪櫒锛岀敤浜庣‘瀹氬浘鍍忚儗鏅壊鍜屾摝闄ら鑹?
class EraseBackgroundDetector {
  /// 妫€娴嬪浘鍍忔槸鍚︿负榛戠櫧浜屽€煎浘
  /// 濡傛灉鏄簩鍊煎浘锛屼細杩斿洖搴旇浣跨敤鐨勮儗鏅鑹?鐧借壊鎴栭粦鑹?
  static Future<Color> detectBackgroundColor(ui.Image image) async {
    // 鑾峰彇鍥惧儚杈圭紭鍍忕礌鏍锋湰鏉ョ‘瀹氳儗鏅壊
    final byteData = await image.toByteData(format: ui.ImageByteFormat.rawRgba);
    if (byteData == null) return Colors.white; // 榛樿浣跨敤鐧借壊鑳屾櫙

    final bytes = byteData.buffer.asUint8List();
    final width = image.width;
    final height = image.height;

    // 閲囨牱鐐规暟閲?
    const sampleSize = 20;

    // 缁熻杈圭紭鍍忕礌棰滆壊
    int whiteCount = 0;
    int blackCount = 0;

    // 閲囨牱鍑芥暟
    void samplePixel(int x, int y) {
      if (x < 0 || x >= width || y < 0 || y >= height) return;

      final pixelIndex = (y * width + x) * 4; // 4 bytes per pixel (RGBA)
      final r = bytes[pixelIndex];
      final g = bytes[pixelIndex + 1];
      final b = bytes[pixelIndex + 2];

      // 鍒ゆ柇鏄寒鑹茶繕鏄殫鑹?
      final brightness = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
      if (brightness > 0.7) {
        whiteCount++;
      } else if (brightness < 0.3) {
        blackCount++;
      }
    }

    // 閲囨牱鍥惧儚杈圭紭
    for (int i = 0; i < sampleSize; i++) {
      // 涓婅竟缂?
      samplePixel((width * i) ~/ sampleSize, 0);
      // 涓嬭竟缂?
      samplePixel((width * i) ~/ sampleSize, height - 1);
      // 宸﹁竟缂?
      samplePixel(0, (height * i) ~/ sampleSize);
      // 鍙宠竟缂?
      samplePixel(width - 1, (height * i) ~/ sampleSize);
    }

    print('Background detection - white: $whiteCount, black: $blackCount');

    // 鍒ゆ柇鑳屾櫙鑹诧細濡傛灉杈圭紭鍖哄煙鐧借壊鍍忕礌鏇村锛屽垯鍒ゅ畾涓虹櫧鑹茶儗鏅?
    if (whiteCount >= blackCount) {
      return Colors.white;
    } else {
      return Colors.black;
    }
  }

  /// 鍒ゆ柇鍥惧儚鏄惁涓洪粦鐧戒簩鍊煎浘
  static Future<bool> isBlackAndWhiteImage(ui.Image image) async {
    final byteData = await image.toByteData(format: ui.ImageByteFormat.rawRgba);
    if (byteData == null) return false;

    final bytes = byteData.buffer.asUint8List();
    final width = image.width;
    final height = image.height;

    // 闅忔満閲囨牱鐐规暟閲?
    const sampleCount = 100;
    const threshold = 30; // 鐏板害闃堝€?

    bool hasGray = false;

    // 闅忔満閲囨牱妫€娴嬫槸鍚﹀瓨鍦ㄥぇ閲忕伆搴﹀€?
    for (int i = 0; i < sampleCount; i++) {
      final x = (i * width / sampleCount).toInt();
      final y = (i * height / sampleCount).toInt();

      final pixelIndex = (y * width + x) * 4;
      final r = bytes[pixelIndex];
      final g = bytes[pixelIndex + 1];
      final b = bytes[pixelIndex + 2];

      // 妫€鏌ユ槸鍚︿负鏄庢樉鐨勭伆搴︼紙闈為粦鐧斤級
      if ((r > threshold && r < 225) ||
          (g > threshold && g < 225) ||
          (b > threshold && b < 225)) {
        // 妫€鏌GB鏄惁鎺ヨ繎涓€鑷达紙鐏板害鐗瑰緛锛?
        final maxDiff = max(max((r - g).abs(), (r - b).abs()), (g - b).abs());
        if (maxDiff < 20) {
          hasGray = true;
          break;
        }
      }
    }

    return !hasGray; // 濡傛灉娌℃湁鏄庢樉鐨勭伆搴﹀€硷紝鍒ゅ畾涓洪粦鐧藉浘鍍?
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\character_collection\erase_tool\utils\image_converter.dart
-----------------------------------
import 'dart:async';
import 'dart:ui' as ui;

import 'package:flutter/foundation.dart';

/// 鍥惧儚杞崲宸ュ叿绫?
class ImageConverter {
  /// 缂撳瓨宸茶浆鎹㈢殑鍥惧儚锛岄伩鍏嶉噸澶嶈浆鎹?
  static final Map<String, ui.Image> _imageCache = {};

  /// 灏嗗浘鍍忓瓧鑺傛暟鎹浆鎹负ui.Image
  static Future<ui.Image?> bytesToImage(Uint8List bytes) async {
    try {
      // 浣跨敤bytes鐨刪ashCode浣滀负缂撳瓨key
      final key = bytes.hashCode.toString();
      if (_imageCache.containsKey(key)) {
        return _imageCache[key];
      }

      final completer = Completer<ui.Image>();
      ui.decodeImageFromList(bytes, (result) {
        _imageCache[key] = result;
        completer.complete(result);
      });
      return await completer.future;
    } catch (e) {
      debugPrint('鍥惧儚杞崲澶辫触: $e');
      return null;
    }
  }

  /// 娓呴櫎鍥惧儚缂撳瓨
  static void clearCache() {
    _imageCache.clear();
  }

  /// 灏唘i.Image杞崲涓哄浘鍍忓瓧鑺傛暟鎹?
  static Future<Uint8List?> imageToBytes(ui.Image image) async {
    try {
      final byteData = await image.toByteData(format: ui.ImageByteFormat.png);
      return byteData?.buffer.asUint8List();
    } catch (e) {
      debugPrint('鍥惧儚杞崲澶辫触: $e');
      return null;
    }
  }

  /// 浠庣紦瀛樹腑绉婚櫎鎸囧畾鍥惧儚
  static void removeFromCache(String key) {
    _imageCache.remove(key);
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\character_collection\erase_tool\utils\performance_monitor.dart
-----------------------------------
import 'dart:collection';
import 'dart:math' as math;
import 'dart:ui';

import 'package:flutter/material.dart';
import 'package:flutter/scheduler.dart';

/// 鎿﹂櫎宸ュ叿鎬ц兘鐩戞帶鍣?
/// 鐢ㄤ簬鏀堕泦鍜屽垎鏋愭€ц兘鏁版嵁
class ErasePerformanceMonitor {
  /// 鍗曚緥瀹炰緥
  static final ErasePerformanceMonitor _instance =
      ErasePerformanceMonitor._internal();

  /// 鏄惁姝ｅ湪鐩戞帶
  bool _isMonitoring = false;

  /// 鎬ц兘鏁版嵁鍘嗗彶
  final ListQueue<PerformanceDataPoint> _dataPoints =
      ListQueue<PerformanceDataPoint>();

  /// 鏈€澶у巻鍙茶褰曟暟
  final int maxDataPoints = 120; // 淇濆瓨2鍒嗛挓鐨勬暟鎹?(鍋囪60fps)

  /// 褰撳墠甯ф椂闂?(ms)
  double _currentFrameTime = 0;

  /// 褰撳墠甯х巼
  double _currentFps = 0;

  /// 涓婁竴甯ф椂闂存埑
  Duration? _lastFrameTimestamp;

  /// 鎬ц兘鐩戝惉鍣?
  final ValueNotifier<PerformanceDataPoint?> performanceNotifier =
      ValueNotifier(null);

  /// 宸ュ巶鏋勯€犲嚱鏁?
  factory ErasePerformanceMonitor() => _instance;

  /// 鍐呴儴鏋勯€犲嚱鏁?
  ErasePerformanceMonitor._internal();

  /// 鑾峰彇褰撳墠甯х巼
  double get currentFps => _currentFps;

  /// 鑾峰彇褰撳墠甯ф椂闂?
  double get currentFrameTime => _currentFrameTime;

  /// 鑾峰彇鎵€鏈夋€ц兘鏁版嵁鐐?
  List<PerformanceDataPoint> get dataPoints => List.unmodifiable(_dataPoints);

  /// 鏄惁姝ｅ湪鐩戞帶
  bool get isMonitoring => _isMonitoring;

  /// 鑾峰彇鎬ц兘缁熻
  Map<String, double> getPerformanceStats() {
    if (_dataPoints.isEmpty) {
      return {
        'avgFrameTime': 0.0,
        'avgFps': 0.0,
        'minFps': 0.0,
        'maxFps': 0.0,
      };
    }

    double totalFrameTime = 0.0;
    double minFrameTime = double.infinity;
    double maxFrameTime = 0.0;

    for (final point in _dataPoints) {
      totalFrameTime += point.frameTime;
      minFrameTime = math.min(minFrameTime, point.frameTime);
      maxFrameTime = math.max(maxFrameTime, point.frameTime);
    }

    final avgFrameTime = totalFrameTime / _dataPoints.length;
    final avgFps = avgFrameTime > 0 ? 1000 / avgFrameTime : 0.0;
    final maxFps = minFrameTime > 0 ? 1000 / minFrameTime : 0.0;
    final minFps = maxFrameTime > 0 ? 1000 / maxFrameTime : 0.0;

    return {
      'avgFrameTime': avgFrameTime,
      'avgFps': avgFps,
      'minFps': minFps,
      'maxFps': maxFps,
    };
  }

  /// 寮€濮嬬洃鎺?
  void startMonitoring() {
    if (_isMonitoring) return;

    _isMonitoring = true;
    _dataPoints.clear();
    _lastFrameTimestamp = null;

    SchedulerBinding.instance.addTimingsCallback(_handleTimings);
  }

  /// 鍋滄鐩戞帶
  void stopMonitoring() {
    if (!_isMonitoring) return;

    _isMonitoring = false;
    SchedulerBinding.instance.removeTimingsCallback(_handleTimings);
  }

  /// 澶勭悊甯ф椂闂?
  void _handleTimings(List<FrameTiming> timings) {
    if (!_isMonitoring || timings.isEmpty) return;

    for (final timing in timings) {
      final buildDuration =
          timing.buildDuration.inMicroseconds / 1000.0; // 杞崲涓烘绉?
      final rasterDuration =
          timing.rasterDuration.inMicroseconds / 1000.0; // 杞崲涓烘绉?

      // 鎬诲抚鏃堕棿
      final totalFrameTime = buildDuration + rasterDuration;
      _currentFrameTime = totalFrameTime;

      // 璁＄畻甯х巼
      final now = timing.timestampInMicroseconds(FramePhase.rasterStart);
      if (_lastFrameTimestamp != null) {
        final frameDuration = now - _lastFrameTimestamp!.inMicroseconds;
        if (frameDuration > 0) {
          _currentFps = 1000000 / frameDuration; // 寰杞崲涓哄抚鐜?
        }
      }
      _lastFrameTimestamp = Duration(microseconds: now);

      // 鍒涘缓鏁版嵁鐐?
      final dataPoint = PerformanceDataPoint(
        timestamp: DateTime.now(),
        frameTime: totalFrameTime,
        // 杩欓噷鍙互娣诲姞鍏朵粬鎬ц兘鎸囨爣
      );

      // 娣诲姞鍒板巻鍙茶褰?
      _dataPoints.add(dataPoint);

      // 闄愬埗鍘嗗彶璁板綍澶у皬
      while (_dataPoints.length > maxDataPoints) {
        _dataPoints.removeFirst();
      }

      // 閫氱煡鐩戝惉鍣?
      performanceNotifier.value = dataPoint;
    }
  }
}

/// 鎬ц兘鏁版嵁鐐?
class PerformanceDataPoint {
  /// 鏃堕棿鎴?
  final DateTime timestamp;

  /// 甯ф椂闂?(ms)
  final double frameTime;

  /// CPU浣跨敤鐜?(%)锛屽彲閫?
  final double? cpuUsage;

  /// 鍐呭瓨浣跨敤 (MB)锛屽彲閫?
  final double? memoryUsage;

  PerformanceDataPoint({
    required this.timestamp,
    required this.frameTime,
    this.cpuUsage,
    this.memoryUsage,
  });
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\character_collection\erase_tool\utils\render_cache.dart
-----------------------------------
import 'dart:ui' as ui;

import 'package:flutter/material.dart';

import '../models/erase_operation.dart';

/// 娓叉煋缂撳瓨
/// 璐熻矗绠＄悊鍥惧儚缂撳瓨鍜屼紭鍖栨覆鏌撴€ц兘
class RenderCache {
  /// 闈欐€佺紦瀛?
  ui.Image? _staticCache;

  /// 鍔ㄦ€佺紦瀛?
  ui.Image? _dynamicCache;

  /// 鏄惁闇€瑕侀噸寤虹紦瀛?
  bool _isDirty = true;

  /// 缂撳瓨鐨勬搷浣?
  final List<EraseOperation> _cachedOperations = [];

  /// 鏈€杩戞坊鍔犵殑鎿嶄綔
  final List<EraseOperation> _recentOperations = [];

  /// 鑾峰彇鍔ㄦ€佺紦瀛?
  ui.Image? get dynamicCache => _dynamicCache;

  /// 璁剧疆鍔ㄦ€佺紦瀛?
  set dynamicCache(ui.Image? cache) {
    if (_dynamicCache != null && _dynamicCache != cache) {
      _dynamicCache!.dispose();
    }
    _dynamicCache = cache;
  }

  /// 鏄惁闇€瑕侀噸寤虹紦瀛?
  bool get isDirty => _isDirty;

  /// 鑾峰彇闈欐€佺紦瀛?
  ui.Image? get staticCache => _staticCache;

  /// 璁剧疆闈欐€佺紦瀛?
  set staticCache(ui.Image? cache) {
    if (_staticCache != null && _staticCache != cache) {
      _staticCache!.dispose();
    }
    _staticCache = cache;
  }

  /// 娣诲姞鏄剧ず鎿嶄綔
  void addDisplayOperation(EraseOperation operation) {
    _recentOperations.add(operation);

    // 濡傛灉鏈€杩戞搷浣滃お澶氾紝杞Щ鍒扮紦瀛樻搷浣滀腑
    if (_recentOperations.length > 5) {
      _cachedOperations.addAll(_recentOperations);
      _recentOperations.clear();
      _isDirty = true;
    }
  }

  /// 娓呴櫎缂撳瓨
  void clearCache() {
    if (_staticCache != null) {
      _staticCache!.dispose();
      _staticCache = null;
    }

    if (_dynamicCache != null) {
      _dynamicCache!.dispose();
      _dynamicCache = null;
    }

    _cachedOperations.clear();
    _recentOperations.clear();
    _isDirty = true;
  }

  /// 閲婃斁璧勬簮
  void dispose() {
    clearCache();
  }

  /// 鑾峰彇鎵€鏈夋搷浣?
  List<EraseOperation> getAllOperations() {
    return [..._cachedOperations, ..._recentOperations];
  }

  /// 鑾峰彇鏈€杩戠殑鎿嶄綔
  List<EraseOperation> getRecentOperations() {
    return List.unmodifiable(_recentOperations);
  }

  /// 浣跨紦瀛樺け鏁?
  void invalidateCache() {
    _isDirty = true;
  }

  /// 鏇存柊鍔ㄦ€佺紦瀛?
  Future<void> updateDynamicCache(
    ui.Image baseImage,
    List<Offset> currentPoints,
    double brushSize,
  ) async {
    // 瀹炵幇绂诲睆娓叉煋鏉ユ洿鏂板姩鎬佺紦瀛?
    // 杩欓噷闇€瑕佸疄鐜板叿浣撶殑娓叉煋閫昏緫
  }

  /// 鏇存柊闈欐€佺紦瀛?
  Future<void> updateStaticCache(ui.Image originalImage) async {
    if (!_isDirty && _staticCache != null) return;

    // 瀹炵幇绂诲睆娓叉煋鏉ユ洿鏂伴潤鎬佺紦瀛?
    // 杩欓噷闇€瑕佸疄鐜板叿浣撶殑娓叉煋閫昏緫

    _isDirty = false;
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\character_collection\erase_tool\utils\undo_manager.dart
-----------------------------------
import 'dart:collection';

import '../models/erase_operation.dart';

/// 鎾ら攢/閲嶅仛绠＄悊鍣?
/// 璐熻矗绠＄悊鎿嶄綔鍘嗗彶锛屾敮鎸佹挙閿€鍜岄噸鍋氬姛鑳?
class UndoManager {
  /// 鏈€澶у巻鍙茶褰曟暟閲?
  final int maxHistorySize;

  /// 鎾ら攢鏍?
  final ListQueue<EraseOperation> _undoStack = ListQueue<EraseOperation>();

  /// 閲嶅仛鏍?
  final ListQueue<EraseOperation> _redoStack = ListQueue<EraseOperation>();

  /// 鐘舵€佸彉鏇寸洃鍚櫒
  final List<Function(EraseOperation, bool)> _stateChangeListeners = [];

  /// 鏋勯€犲嚱鏁?
  UndoManager({this.maxHistorySize = 50});

  /// 鏄惁鍙互閲嶅仛
  bool get canRedo => _redoStack.isNotEmpty;

  /// 鏄惁鍙互鎾ら攢
  bool get canUndo => _undoStack.isNotEmpty;

  /// 鑾峰彇閲嶅仛鏍堜腑鐨勬墍鏈夋搷浣?
  List<EraseOperation> get redoOperations => List.unmodifiable(_redoStack);

  /// 鑾峰彇鎾ら攢鏍堜腑鐨勬墍鏈夋搷浣?
  List<EraseOperation> get undoOperations => List.unmodifiable(_undoStack);

  /// 娣诲姞鐘舵€佸彉鏇寸洃鍚櫒
  void addStateChangeListener(Function(EraseOperation, bool) listener) {
    _stateChangeListeners.add(listener);
  }

  /// 娓呯┖鍘嗗彶璁板綍
  void clear() {
    _undoStack.clear();
    _redoStack.clear();
  }

  /// 璁板綍涓€涓搷浣?
  void push(EraseOperation operation) {
    // 娣诲姞鍒版挙閿€鏍?
    _undoStack.addLast(operation);

    // 娓呯┖閲嶅仛鏍?
    _redoStack.clear();

    // 濡傛灉鍘嗗彶璁板綍瓒呰繃鏈€澶ф暟閲忥紝娓呯悊鏈€鑰佺殑璁板綍
    _trimHistory();

    // 閫氱煡鐩戝惉鍣?
    _notifyStateChange(operation, false);
  }

  /// 閲嶅仛鎿嶄綔
  /// 杩斿洖琚噸鍋氱殑鎿嶄綔锛屽鏋滄病鏈夊彲閲嶅仛鐨勬搷浣滃垯杩斿洖null
  EraseOperation? redo() {
    if (_redoStack.isEmpty) return null;

    final operation = _redoStack.removeLast();
    _undoStack.addLast(operation);

    // 閫氱煡鐩戝惉鍣?
    _notifyStateChange(operation, false);

    return operation;
  }

  /// 绉婚櫎鐘舵€佸彉鏇寸洃鍚櫒
  void removeStateChangeListener(Function(EraseOperation, bool) listener) {
    _stateChangeListeners.remove(listener);
  }

  /// 灏濊瘯鍚堝苟鏈€杩戠殑鎿嶄綔
  /// 濡傛灉鏈€杩戜袱涓搷浣滃彲浠ュ悎骞讹紝鍒欏悎骞跺畠浠苟杩斿洖true
  bool tryMergeLastOperations() {
    if (_undoStack.length < 2) return false;

    final lastOp = _undoStack.removeLast();
    final prevOp = _undoStack.removeLast();

    // 妫€鏌ユ槸鍚﹀彲浠ュ悎骞?
    if (lastOp.canMergeWith(prevOp)) {
      // 鍒涘缓鏂扮殑鍚堝苟鎿嶄綔
      final newPoints = [...prevOp.points, ...lastOp.points];
      final mergedOp = EraseOperation(
        id: prevOp.id,
        points: newPoints,
        brushSize: prevOp.brushSize,
        timestamp: prevOp.timestamp,
      );

      // 灏嗗悎骞跺悗鐨勬搷浣滄坊鍔犲洖鎾ら攢鏍?
      _undoStack.addLast(mergedOp);
      return true;
    } else {
      // 鏃犳硶鍚堝苟锛屾仮澶嶅師鏉ョ殑鎿嶄綔
      _undoStack.addLast(prevOp);
      _undoStack.addLast(lastOp);
      return false;
    }
  }

  /// 鎾ら攢鎿嶄綔
  /// 杩斿洖琚挙閿€鐨勬搷浣滐紝濡傛灉娌℃湁鍙挙閿€鐨勬搷浣滃垯杩斿洖null
  EraseOperation? undo() {
    if (_undoStack.isEmpty) return null;

    final operation = _undoStack.removeLast();
    _redoStack.addLast(operation);

    // 閫氱煡鐩戝惉鍣?
    _notifyStateChange(operation, true);

    return operation;
  }

  /// 閫氱煡鐘舵€佸彉鏇?
  void _notifyStateChange(EraseOperation operation, bool isUndo) {
    for (final listener in _stateChangeListeners) {
      listener(operation, isUndo);
    }
  }

  /// 瑁佸壀鍘嗗彶璁板綍锛屼繚鎸佸湪鏈€澶ф暟閲忎互鍐?
  void _trimHistory() {
    while (_undoStack.length > maxHistorySize) {
      _undoStack.removeFirst();
    }
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\character_collection\erase_tool\utils\prototype\base_layer.dart
-----------------------------------
import 'package:flutter/material.dart';
import 'package:flutter/scheduler.dart';

import 'coordinate_transformer.dart';
import 'performance_monitor.dart';

/// 璋冭瘯缁樺埗宸ュ叿
mixin DebugPaintMixin {
  /// 缁樺埗璋冭瘯缃戞牸
  void drawDebugGrid(
    Canvas canvas,
    Size size, {
    double gridSize = 50.0,
    Color color = const Color(0x40FF0000),
  }) {
    final paint = Paint()
      ..color = color
      ..strokeWidth = 1.0
      ..style = PaintingStyle.stroke;

    // 缁樺埗绔栫嚎
    for (var x = 0.0; x <= size.width; x += gridSize) {
      canvas.drawLine(
        Offset(x, 0),
        Offset(x, size.height),
        paint,
      );
    }

    // 缁樺埗妯嚎
    for (var y = 0.0; y <= size.height; y += gridSize) {
      canvas.drawLine(
        Offset(0, y),
        Offset(size.width, y),
        paint,
      );
    }

    // 缁樺埗涓績鐐?
    final centerPaint = Paint()
      ..color = const Color(0x80FF0000)
      ..strokeWidth = 2.0
      ..style = PaintingStyle.stroke;

    final center = Offset(size.width / 2, size.height / 2);
    canvas.drawCircle(center, 5.0, centerPaint);
    canvas.drawLine(
      Offset(center.dx - 10, center.dy),
      Offset(center.dx + 10, center.dy),
      centerPaint,
    );
    canvas.drawLine(
      Offset(center.dx, center.dy - 10),
      Offset(center.dx, center.dy + 10),
      centerPaint,
    );
  }

  /// 缁樺埗璋冭瘯淇℃伅
  void drawDebugInfo(Canvas canvas, Size size, Map<String, String> info) {
    final textPainter = TextPainter(
      textDirection: TextDirection.ltr,
    );

    var y = 10.0;
    for (final entry in info.entries) {
      textPainter.text = TextSpan(
        text: '${entry.key}: ${entry.value}',
        style: const TextStyle(
          color: Color(0xFFFF0000),
          fontSize: 12,
        ),
      );
      textPainter.layout();
      textPainter.paint(canvas, Offset(10, y));
      y += textPainter.height + 5;
    }
  }
}

/// 鍥惧眰鍩虹被 - 鍘熷瀷楠岃瘉鐗堟湰
abstract class PrototypeBaseLayer extends StatefulWidget {
  /// 鍧愭爣杞崲鍣?
  final PrototypeCoordinateTransformer transformer;

  /// 鎬ц兘鐩戞帶鍣?
  final PrototypePerformanceMonitor monitor;

  /// 鍥惧眰灏哄
  final Size size;

  /// 鏄惁寮€鍚皟璇曟ā寮?
  final bool debugMode;

  const PrototypeBaseLayer({
    Key? key,
    required this.transformer,
    required this.monitor,
    required this.size,
    this.debugMode = false,
  }) : super(key: key);

  @override
  PrototypeBaseLayerState createState();
}

/// 鍥惧眰鐘舵€佸熀绫?
abstract class PrototypeBaseLayerState<T extends PrototypeBaseLayer>
    extends State<T> {
  /// 閲嶇粯閫氱煡鍣?
  final ValueNotifier<int> _repaintNotifier = ValueNotifier<int>(0);

  /// 缁樺埗寮€濮嬫椂闂?
  int? _paintStartTime;

  /// 鏄惁姝ｅ湪娴嬮噺鎬ц兘
  bool _isMeasuring = false;

  @override
  Widget build(BuildContext context) {
    return RepaintBoundary(
      child: CustomPaint(
        size: widget.size,
        isComplex: true,
        willChange: true,
        painter: _PerformanceWrappedPainter(
          painter: createPainter(),
          onPaintStart: _onPaintStart,
          onPaintEnd: _onPaintEnd,
        ),
      ),
    );
  }

  /// 鍒涘缓缁樺埗鍣?
  CustomPainter createPainter();

  @override
  void dispose() {
    _repaintNotifier.dispose();
    super.dispose();
  }

  @override
  void initState() {
    super.initState();
    _repaintNotifier.addListener(_onRepaint);
  }

  /// 璇锋眰閲嶇粯
  void requestRepaint() {
    _repaintNotifier.value++;
  }

  /// 缁樺埗缁撴潫鍥炶皟
  void _onPaintEnd() {
    if (_isMeasuring || _paintStartTime == null) return;

    _isMeasuring = true;
    final paintTime =
        (DateTime.now().microsecondsSinceEpoch - _paintStartTime!) / 1000.0;

    // 浣跨敤post-frame鍥炶皟鏉ヨ褰曟€ц兘鏁版嵁
    SchedulerBinding.instance.addPostFrameCallback((_) {
      if (mounted) {
        widget.monitor.recordFrameTime(paintTime);
        _paintStartTime = null;
        _isMeasuring = false;
      }
    });
  }

  /// 缁樺埗寮€濮嬪洖璋?
  void _onPaintStart() {
    if (_isMeasuring) return;
    _paintStartTime = DateTime.now().microsecondsSinceEpoch;
  }

  /// 閲嶇粯鍥炶皟
  void _onRepaint() {
    if (mounted) {
      setState(() {});
    }
  }
}

/// 鎬ц兘鍖呰缁樺埗鍣?
class _PerformanceWrappedPainter extends CustomPainter {
  final CustomPainter painter;
  final VoidCallback onPaintStart;
  final VoidCallback onPaintEnd;

  _PerformanceWrappedPainter({
    required this.painter,
    required this.onPaintStart,
    required this.onPaintEnd,
  }) : super(repaint: painter);

  @override
  void paint(Canvas canvas, Size size) {
    onPaintStart();
    painter.paint(canvas, size);
    onPaintEnd();
  }

  @override
  bool shouldRepaint(covariant _PerformanceWrappedPainter oldDelegate) {
    return painter.shouldRepaint(oldDelegate.painter);
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\character_collection\erase_tool\utils\prototype\coordinate_transformer.dart
-----------------------------------
import 'dart:math' as math;

import 'package:flutter/material.dart';
import 'package:flutter/rendering.dart';
import 'package:vector_math/vector_math_64.dart';

/// 鍧愭爣杞崲鍣?- 鍘熷瀷楠岃瘉鐗堟湰
/// 澶勭悊鍚勪釜鍧愭爣绯荤粺涔嬮棿鐨勮浆鎹紝骞舵彁渚涜皟璇曞拰鎬ц兘鐩戞帶鍔熻兘
class PrototypeCoordinateTransformer {
  static const int _maxTimeRecords = 100;

  /// 瀹瑰櫒灏哄
  final Size viewportSize;

  /// 鍥惧儚灏哄
  final Size imageSize;

  /// 璁惧鍍忕礌姣?
  final double devicePixelRatio;

  /// 鏄惁鍚敤璋冭瘯妯″紡
  final bool debugMode;

  /// 鍙樻崲鐭╅樀
  Matrix4 _transform;

  /// 缂撳瓨鐨勫彉鎹㈠弬鏁?
  double _scale = 1.0;

  Offset _translation = Offset.zero;

  /// 鎬ц兘鐩戞帶鏁版嵁
  final List<double> _conversionTimes = [];

  PrototypeCoordinateTransformer({
    required this.viewportSize,
    required this.imageSize,
    required this.devicePixelRatio,
    Matrix4? transform,
    this.debugMode = false,
  }) : _transform = transform ?? Matrix4.identity();

  /// 鑾峰彇骞冲潎杞崲鏃堕棿锛堟绉掞級
  double get averageConversionTime {
    if (_conversionTimes.isEmpty) return 0.0;
    return _conversionTimes.reduce((a, b) => a + b) / _conversionTimes.length;
  }

  /// 鑾峰彇瀹為檯缂╂斁姣斾緥
  double get effectiveScale => _scale * devicePixelRatio;

  /// 娓呯悊鎬ц兘鏁版嵁
  void clearPerformanceData() {
    _conversionTimes.clear();
  }

  /// 鑾峰彇鎬ц兘鏁版嵁
  Map<String, dynamic> getPerformanceData() {
    return {
      'averageConversionTime': averageConversionTime,
      'maxConversionTime':
          _conversionTimes.isEmpty ? 0.0 : _conversionTimes.reduce(math.max),
      'minConversionTime':
          _conversionTimes.isEmpty ? 0.0 : _conversionTimes.reduce(math.min),
      'transformScale': _scale,
      'sampleCount': _conversionTimes.length,
    };
  }

  /// 鍥惧儚鍧愭爣杞崲涓鸿鍙ｅ潗鏍?
  Offset imageToViewport(Offset imagePoint) {
    final stopwatch = Stopwatch()..start();

    try {
      // 1. 搴旂敤缂╂斁鍜屽钩绉?
      final scaled = (imagePoint * effectiveScale) + _translation;

      // 2. 搴旂敤鍙樻崲鐭╅樀鐨勯€嗙煩闃?
      final inverse = Matrix4.inverted(_transform);
      final vector = Vector3(scaled.dx, scaled.dy, 0.0);
      final transformed = _transformPoint(vector, matrix: inverse);

      // 3. 搴旂敤璁惧鍍忕礌姣旂殑閫?
      final result = Offset(transformed.x, transformed.y) / devicePixelRatio;

      // 璁板綍鎬ц兘鏁版嵁
      _recordConversionTime(stopwatch.elapsedMicroseconds / 1000.0);

      if (debugMode) {
        print(
            '馃攳 閫嗗悜杞崲: $imagePoint -> $result (${stopwatch.elapsedMicroseconds}渭s)');
      }

      return result;
    } catch (e) {
      print('鉂?閫嗗悜杞崲閿欒: $e');
      return imagePoint;
    }
  }

  /// 鏇存柊鍙樻崲鐭╅樀
  void updateTransform(Matrix4 newTransform) {
    _transform = newTransform;
    _updateTransformParameters();
  }

  /// 楠岃瘉杞崲绮惧害
  double validateAccuracy(Offset original) {
    final transformed = viewportToImage(original);
    final backTransformed = imageToViewport(transformed);

    return (backTransformed - original).distance;
  }

  /// 瑙嗗彛鍧愭爣杞崲涓哄浘鍍忓潗鏍?
  Offset viewportToImage(Offset viewportPoint) {
    final stopwatch = Stopwatch()..start();

    try {
      // 1. 搴旂敤璁惧鍍忕礌姣?
      final physicalPoint = viewportPoint * devicePixelRatio;

      // 2. 搴旂敤鍙樻崲鐭╅樀
      final vector = Vector3(physicalPoint.dx, physicalPoint.dy, 0.0);
      final transformed = _transformPoint(vector);

      // 3. 搴旂敤缂╂斁鍜屽钩绉?
      final result = (Offset(transformed.x, transformed.y) - _translation) /
          effectiveScale;

      // 璁板綍鎬ц兘鏁版嵁
      _recordConversionTime(stopwatch.elapsedMicroseconds / 1000.0);

      if (debugMode) {
        print(
            '锟?鍧愭爣杞崲: $viewportPoint -> $result (${stopwatch.elapsedMicroseconds}渭s)');
      }

      return result;
    } catch (e) {
      print('鉂?鍧愭爣杞崲閿欒: $e');
      return viewportPoint;
    }
  }

  /// 绉佹湁鏂规硶锛氳褰曡浆鎹㈡椂闂?
  void _recordConversionTime(double milliseconds) {
    _conversionTimes.add(milliseconds);
    if (_conversionTimes.length > _maxTimeRecords) {
      _conversionTimes.removeAt(0);
    }
  }

  /// 绉佹湁鏂规硶锛氱偣鍙樻崲
  Vector3 _transformPoint(Vector3 point, {Matrix4? matrix}) {
    final m = matrix ?? _transform;
    final w = 1.0 / (m[3] * point.x + m[7] * point.y + m[11] * point.z + m[15]);

    return Vector3(
      (m[0] * point.x + m[4] * point.y + m[8] * point.z + m[12]) * w,
      (m[1] * point.x + m[5] * point.y + m[9] * point.z + m[13]) * w,
      (m[2] * point.x + m[6] * point.y + m[10] * point.z + m[14]) * w,
    );
  }

  /// 绉佹湁鏂规硶锛氭洿鏂板彉鎹㈠弬鏁?
  void _updateTransformParameters() {
    try {
      // 鎻愬彇缂╂斁鍒嗛噺
      final row0 = _transform.getRow(0);
      final row1 = _transform.getRow(1);
      _scale = math.sqrt(row0[0] * row0[0] + row0[1] * row0[1]);

      // 鎻愬彇骞崇Щ鍒嗛噺
      _translation =
          Offset(_transform.getTranslation().x, _transform.getTranslation().y);

      if (debugMode) {
        print('馃搳 鍙樻崲鍙傛暟鏇存柊: scale=$_scale, translation=$_translation');
      }
    } catch (e) {
      print('鉂?鏇存柊鍙樻崲鍙傛暟閿欒: $e');
    }
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\character_collection\erase_tool\utils\prototype\main.dart
-----------------------------------
import 'package:flutter/material.dart';

import 'test_page.dart';

void main() {
  WidgetsFlutterBinding.ensureInitialized();

  runApp(const PrototypeApp());
}

/// 鍘熷瀷楠岃瘉搴旂敤
class PrototypeApp extends StatelessWidget {
  const PrototypeApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      title: '瀛楃缂栬緫闈㈡澘鍘熷瀷楠岃瘉',
      debugShowCheckedModeBanner: false, // 绉婚櫎璋冭瘯鏍囪
      theme: ThemeData(
        colorScheme: ColorScheme.fromSeed(seedColor: Colors.blue),
        useMaterial3: true,
      ),
      home: const PrototypeTestPage(),
    );
  }
}

/* 杩愯璇存槑

1. 鍒涘缓璧勬簮鐩綍鍜屾祴璇曞浘鍍忥細
   mkdir -p assets/test_images
   # 灏嗘祴璇曠敤鐨勫瓧浣撳浘鐗囧鍒跺埌 assets/test_images/test_char.png

2. 鍦?pubspec.yaml 涓坊鍔犺祫婧愰厤缃細
   flutter:
     assets:
       - assets/test_images/

3. 杩愯鍘熷瀷楠岃瘉绋嬪簭锛?
   flutter run -t lib/presentation/widgets/character_collection/erase_tool/utils/prototype/main.dart

4. 楠岃瘉椤圭洰锛?
   - 鍧愭爣杞崲绮剧‘鎬ф祴璇?
   - 鎬ц兘鐩戞帶瑙傚療
   - 鍐呭瓨浣跨敤鍒嗘瀽
   - 浜や簰浣撻獙楠岃瘉
*/



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\character_collection\erase_tool\utils\prototype\performance_monitor.dart
-----------------------------------
import 'dart:collection';
import 'dart:math' as math;

import 'package:flutter/material.dart';
import 'package:flutter/scheduler.dart';

/// 鎬ц兘鎸囨爣鏁版嵁
class PerformanceMetric {
  final double value;
  final String label;
  final double threshold;
  final DateTime timestamp;

  PerformanceMetric({
    required this.value,
    required this.label,
    required this.threshold,
    DateTime? timestamp,
  }) : timestamp = timestamp ?? DateTime.now();

  bool get isOverThreshold => value > threshold;
}

/// 鎬ц兘鐩戞帶鏄剧ず缁勪欢
class PerformanceMonitorWidget extends StatelessWidget {
  final PrototypePerformanceMonitor monitor;
  final bool showDetails;

  const PerformanceMonitorWidget({
    Key? key,
    required this.monitor,
    this.showDetails = false,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return ListenableBuilder(
      listenable: monitor,
      builder: (context, _) {
        final snapshot = monitor.snapshot;
        return Container(
          padding: const EdgeInsets.all(8.0),
          decoration: BoxDecoration(
            color: Colors.black87,
            borderRadius: BorderRadius.circular(8.0),
          ),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              _buildMetricRow(
                'FPS',
                snapshot.averageFrameTime > 0
                    ? (1000 / snapshot.averageFrameTime).round()
                    : 0,
                suffix: 'fps',
                isWarning: snapshot.averageFrameTime > 16.0,
              ),
              if (showDetails) ...[
                _buildMetricRow(
                  'Frame Time',
                  snapshot.averageFrameTime,
                  suffix: 'ms',
                  isWarning: snapshot.averageFrameTime > 16.0,
                ),
                _buildMetricRow(
                  'Memory',
                  snapshot.averageMemoryUsage,
                  suffix: 'MB',
                  isWarning: snapshot.averageMemoryUsage > 200.0,
                ),
                _buildMetricRow(
                  'Latency',
                  snapshot.averageLatency,
                  suffix: 'ms',
                  isWarning: snapshot.averageLatency > 30.0,
                ),
              ],
            ],
          ),
        );
      },
    );
  }

  Widget _buildMetricRow(String label, num value,
      {String? suffix, bool isWarning = false}) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 2.0),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Text(
            '$label: ',
            style: const TextStyle(
              color: Colors.white70,
              fontSize: 12.0,
            ),
          ),
          Text(
            value.toStringAsFixed(1) + (suffix ?? ''),
            style: TextStyle(
              color: isWarning ? Colors.red : Colors.white,
              fontSize: 12.0,
              fontWeight: FontWeight.bold,
            ),
          ),
        ],
      ),
    );
  }
}

/// 鎬ц兘鏁版嵁蹇収
class PerformanceSnapshot {
  final double averageFrameTime;
  final double maxFrameTime;
  final double averageMemoryUsage;
  final double averageLatency;
  final int frameTimeOverThresholdCount;
  final int memoryOverThresholdCount;
  final int latencyOverThresholdCount;

  PerformanceSnapshot({
    required this.averageFrameTime,
    required this.maxFrameTime,
    required this.averageMemoryUsage,
    required this.averageLatency,
    required this.frameTimeOverThresholdCount,
    required this.memoryOverThresholdCount,
    required this.latencyOverThresholdCount,
  });

  Map<String, dynamic> toJson() => {
        'averageFrameTime': averageFrameTime,
        'maxFrameTime': maxFrameTime,
        'averageMemoryUsage': averageMemoryUsage,
        'averageLatency': averageLatency,
        'frameTimeOverThresholdCount': frameTimeOverThresholdCount,
        'memoryOverThresholdCount': memoryOverThresholdCount,
        'latencyOverThresholdCount': latencyOverThresholdCount,
      };
}

/// 鎬ц兘鐩戞帶鍣?- 鍘熷瀷楠岃瘉鐗堟湰
class PrototypePerformanceMonitor extends ChangeNotifier {
  /// 鎬ц兘鏁版嵁
  final _PerformanceData _data = _PerformanceData();

  /// 鏄惁澶勪簬娲昏穬鐘舵€?
  bool _isActive = false;
  bool get isActive => _isActive;

  /// 鑾峰彇鎬ц兘鏁版嵁蹇収
  PerformanceSnapshot get snapshot => _data.snapshot;

  /// 娓呴櫎鏁版嵁
  void clearData() {
    _data.clear();
    notifyListeners();
  }

  /// 鑾峰彇鎬ц兘鎶ュ憡
  Map<String, dynamic> getReport() => _data.generateReport();

  /// 璁板綍甯ф椂闂?
  void recordFrameTime(double milliseconds) {
    if (!_isActive) return;

    // 浣跨敤post-frame鍥炶皟寤惰繜鏇存柊
    SchedulerBinding.instance.addPostFrameCallback((_) {
      _data.addFrameTime(milliseconds);
      if (milliseconds > _PerformanceData.frameTimeThreshold) {
        print('鈿狅笍 甯ф椂闂磋繃闀? ${milliseconds.toStringAsFixed(2)}ms');
      }
      notifyListeners();
    });
  }

  /// 璁板綍鍐呭瓨浣跨敤
  void recordMemoryUsage(double megabytes) {
    if (!_isActive) return;

    // 浣跨敤post-frame鍥炶皟寤惰繜鏇存柊
    SchedulerBinding.instance.addPostFrameCallback((_) {
      _data.addMemoryUsage(megabytes);
      if (megabytes > _PerformanceData.memoryThreshold) {
        print('鈿狅笍 鍐呭瓨浣跨敤杩囬珮: ${megabytes.toStringAsFixed(2)}MB');
      }
      notifyListeners();
    });
  }

  /// 璁板綍鎿嶄綔寤惰繜
  void recordOperationLatency(double milliseconds) {
    if (!_isActive) return;

    // 浣跨敤post-frame鍥炶皟寤惰繜鏇存柊
    SchedulerBinding.instance.addPostFrameCallback((_) {
      _data.addOperationLatency(milliseconds);
      if (milliseconds > _PerformanceData.latencyThreshold) {
        print('鈿狅笍 鎿嶄綔寤惰繜杩囬珮: ${milliseconds.toStringAsFixed(2)}ms');
      }
      notifyListeners();
    });
  }

  /// 鍚姩鐩戞帶
  void start() {
    if (_isActive) return;
    _isActive = true;
    _data.clear();
    notifyListeners();
    print('馃搳 鎬ц兘鐩戞帶宸插惎鍔?);
  }

  /// 鍋滄鐩戞帶
  void stop() {
    if (!_isActive) return;
    _isActive = false;
    notifyListeners();
    print('馃搳 鎬ц兘鐩戞帶宸插仠姝?);
  }
}

/// 鎬ц兘鏁版嵁瀹瑰櫒
class _PerformanceData {
  static const int maxRecords = 120; // 淇濆瓨2鍒嗛挓鐨勬暟鎹紙浠?0fps璁★級
  static const double frameTimeThreshold = 16.0; // ms
  static const double memoryThreshold = 200.0; // MB
  static const double latencyThreshold = 30.0; // ms

  final Queue<PerformanceMetric> _frameTimes = Queue<PerformanceMetric>();
  final Queue<PerformanceMetric> _memoryUsages = Queue<PerformanceMetric>();
  final Queue<PerformanceMetric> _operationLatencies =
      Queue<PerformanceMetric>();

  PerformanceSnapshot get snapshot => PerformanceSnapshot(
        averageFrameTime: _calculateAverage(_frameTimes),
        maxFrameTime: _calculateMax(_frameTimes),
        averageMemoryUsage: _calculateAverage(_memoryUsages),
        averageLatency: _calculateAverage(_operationLatencies),
        frameTimeOverThresholdCount: _countOverThreshold(_frameTimes),
        memoryOverThresholdCount: _countOverThreshold(_memoryUsages),
        latencyOverThresholdCount: _countOverThreshold(_operationLatencies),
      );

  void addFrameTime(double value) => _addMetric(
        _frameTimes,
        value,
        'Frame Time',
        frameTimeThreshold,
      );

  void addMemoryUsage(double value) => _addMetric(
        _memoryUsages,
        value,
        'Memory Usage',
        memoryThreshold,
      );

  void addOperationLatency(double value) => _addMetric(
        _operationLatencies,
        value,
        'Operation Latency',
        latencyThreshold,
      );

  void clear() {
    _frameTimes.clear();
    _memoryUsages.clear();
    _operationLatencies.clear();
  }

  Map<String, dynamic> generateReport() => {
        'timestamp': DateTime.now().toIso8601String(),
        'metrics': snapshot.toJson(),
        'sampleCounts': {
          'frameTimes': _frameTimes.length,
          'memoryUsages': _memoryUsages.length,
          'operationLatencies': _operationLatencies.length,
        },
      };

  void _addMetric(Queue<PerformanceMetric> queue, double value, String label,
      double threshold) {
    queue.add(PerformanceMetric(
      value: value,
      label: label,
      threshold: threshold,
    ));
    while (queue.length > maxRecords) {
      queue.removeFirst();
    }
  }

  double _calculateAverage(Queue<PerformanceMetric> queue) {
    if (queue.isEmpty) return 0.0;
    final sum = queue.fold<double>(0.0, (sum, metric) => sum + metric.value);
    return sum / queue.length;
  }

  double _calculateMax(Queue<PerformanceMetric> queue) {
    if (queue.isEmpty) return 0.0;
    return queue.fold<double>(
        0.0, (max, metric) => math.max(max, metric.value));
  }

  int _countOverThreshold(Queue<PerformanceMetric> queue) {
    return queue.where((metric) => metric.isOverThreshold).length;
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\character_collection\erase_tool\utils\prototype\test_page.dart
-----------------------------------
import 'dart:ui' as ui;

import 'package:flutter/material.dart';
import 'package:flutter/services.dart';

import 'test_widget.dart';

/// 鍘熷瀷楠岃瘉娴嬭瘯椤甸潰
class PrototypeTestPage extends StatefulWidget {
  const PrototypeTestPage({Key? key}) : super(key: key);

  @override
  State<PrototypeTestPage> createState() => _PrototypeTestPageState();
}

class _PrototypeTestPageState extends State<PrototypeTestPage> {
  ui.Image? _testImage;
  String? _error;
  bool _isLoading = false;

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('鍘熷瀷楠岃瘉娴嬭瘯'),
        actions: [
          // 閲嶆柊鍔犺浇鎸夐挳
          IconButton(
            icon: const Icon(Icons.refresh),
            onPressed: _isLoading ? null : _loadTestImage,
            tooltip: '閲嶆柊鍔犺浇娴嬭瘯鍥惧儚',
          ),
        ],
      ),
      body: _buildBody(),
    );
  }

  @override
  void dispose() {
    _testImage?.dispose();
    super.dispose();
  }

  @override
  void initState() {
    super.initState();
    _loadTestImage();
  }

  Widget _buildBody() {
    if (_isLoading) {
      return const Center(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            CircularProgressIndicator(),
            SizedBox(height: 16),
            Text('鍔犺浇娴嬭瘯鍥惧儚...'),
          ],
        ),
      );
    }

    if (_error != null) {
      return Center(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            const Icon(
              Icons.error_outline,
              size: 48,
              color: Colors.red,
            ),
            const SizedBox(height: 16),
            Text(
              _error!,
              style: const TextStyle(color: Colors.red),
            ),
            const SizedBox(height: 16),
            ElevatedButton(
              onPressed: _loadTestImage,
              child: const Text('閲嶈瘯'),
            ),
          ],
        ),
      );
    }

    if (_testImage == null) {
      return const Center(
        child: Text('鏈姞杞芥祴璇曞浘鍍?),
      );
    }

    // 鏄剧ず娴嬭瘯缁勪欢
    return Center(
      child: ConstrainedBox(
        constraints: const BoxConstraints(
          maxWidth: 800,
          maxHeight: 600,
        ),
        child: Card(
          elevation: 4,
          child: Padding(
            padding: const EdgeInsets.all(16.0),
            child: Column(
              children: [
                // 鎿嶄綔璇存槑
                Container(
                  padding: const EdgeInsets.all(8.0),
                  decoration: BoxDecoration(
                    color: Colors.grey.shade100,
                    borderRadius: BorderRadius.circular(4),
                  ),
                  child: const Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                        '鎿嶄綔璇存槑锛?,
                        style: TextStyle(fontWeight: FontWeight.bold),
                      ),
                      SizedBox(height: 4),
                      Text('鈥?鐐瑰嚮娴嬭瘯鍧愭爣杞崲'),
                      Text('鈥?婊氳疆鎴栧弻鎸囩缉鏀?),
                      Text('鈥?Alt + 鎷栧姩骞崇Щ'),
                    ],
                  ),
                ),
                const SizedBox(height: 16),

                // 娴嬭瘯鍖哄煙
                Expanded(
                  child: Container(
                    decoration: BoxDecoration(
                      border: Border.all(color: Colors.grey.shade300),
                      borderRadius: BorderRadius.circular(4),
                    ),
                    child: ClipRRect(
                      borderRadius: BorderRadius.circular(4),
                      child: PrototypeTestWidget(
                        image: _testImage!,
                      ),
                    ),
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }

  /// 鍔犺浇娴嬭瘯鍥惧儚
  Future<void> _loadTestImage() async {
    if (_isLoading) return;

    setState(() {
      _isLoading = true;
      _error = null;
    });

    try {
      // 鍔犺浇娴嬭瘯鍥惧儚
      const assetPath = 'assets/test_images/test_char.png';
      final data = await rootBundle.load(assetPath);
      final codec = await ui.instantiateImageCodec(data.buffer.asUint8List());
      final frame = await codec.getNextFrame();

      setState(() {
        _testImage = frame.image;
        _isLoading = false;
      });
    } catch (e) {
      setState(() {
        _error = '鍔犺浇娴嬭瘯鍥惧儚澶辫触: $e';
        _isLoading = false;
      });
    }
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\character_collection\erase_tool\utils\prototype\test_widget.dart
-----------------------------------
import 'dart:ui' as ui;

import 'package:flutter/material.dart';

import 'base_layer.dart';
import 'coordinate_transformer.dart';
import 'performance_monitor.dart';

/// 鍘熷瀷娴嬭瘯鍥惧眰
class PrototypeTestLayer extends PrototypeBaseLayer {
  final ui.Image image;

  const PrototypeTestLayer({
    Key? key,
    required this.image,
    required super.transformer,
    required super.monitor,
    required super.size,
    super.debugMode = true,
  }) : super(key: key);

  @override
  PrototypeBaseLayerState<PrototypeBaseLayer> createState() =>
      _PrototypeTestLayerState();
}

/// 鍘熷瀷娴嬭瘯缁勪欢
class PrototypeTestWidget extends StatefulWidget {
  final ui.Image image;

  const PrototypeTestWidget({
    Key? key,
    required this.image,
  }) : super(key: key);

  @override
  State<PrototypeTestWidget> createState() => _PrototypeTestWidgetState();
}

class _PrototypeTestLayerState
    extends PrototypeBaseLayerState<PrototypeTestLayer> {
  Offset? _lastTapPosition;
  Offset? _lastTransformedPosition;

  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      onTapDown: _handleTapDown,
      child: super.build(context),
    );
  }

  @override
  CustomPainter createPainter() {
    return _TestLayerPainter(
      image: widget.image,
      debugMode: widget.debugMode,
      lastTapPosition: _lastTapPosition,
      lastTransformedPosition: _lastTransformedPosition,
    );
  }

  void _handleTapDown(TapDownDetails details) {
    setState(() {
      _lastTapPosition = details.localPosition;
      _lastTransformedPosition =
          widget.transformer.viewportToImage(details.localPosition);
    });

    // 璁板綍杞崲寤惰繜
    widget.monitor.recordOperationLatency(
      widget.transformer.averageConversionTime,
    );
  }
}

class _PrototypeTestWidgetState extends State<PrototypeTestWidget> {
  late final PrototypePerformanceMonitor _monitor;
  late final TransformationController _transformationController;
  late final ValueNotifier<Size> _sizeNotifier;

  @override
  Widget build(BuildContext context) {
    return Stack(
      children: [
        // 涓昏娴嬭瘯鍖哄煙
        LayoutBuilder(
          builder: (context, constraints) {
            final size = constraints.biggest;
            if (_sizeNotifier.value != size) {
              _sizeNotifier.value = size;
            }

            return ValueListenableBuilder<Size>(
              valueListenable: _sizeNotifier,
              builder: (context, size, child) {
                final transformer = PrototypeCoordinateTransformer(
                  viewportSize: size,
                  imageSize: Size(
                    widget.image.width.toDouble(),
                    widget.image.height.toDouble(),
                  ),
                  devicePixelRatio: MediaQuery.of(context).devicePixelRatio,
                  transform: _transformationController.value,
                  debugMode: true,
                );

                return InteractiveViewer(
                  transformationController: _transformationController,
                  onInteractionEnd: (_) => setState(() {}),
                  child: PrototypeTestLayer(
                    image: widget.image,
                    transformer: transformer,
                    monitor: _monitor,
                    size: size,
                  ),
                );
              },
            );
          },
        ),

        // 鎬ц兘鐩戞帶鏄剧ず
        Positioned(
          top: 16,
          right: 16,
          child: PerformanceMonitorWidget(
            monitor: _monitor,
            showDetails: true,
          ),
        ),
      ],
    );
  }

  @override
  void dispose() {
    _monitor.dispose();
    _transformationController.dispose();
    _sizeNotifier.dispose();
    super.dispose();
  }

  @override
  void initState() {
    super.initState();
    _monitor = PrototypePerformanceMonitor()..start();
    _transformationController = TransformationController();
    _sizeNotifier = ValueNotifier(Size.zero);
  }
}

class _TestLayerPainter extends CustomPainter with DebugPaintMixin {
  final ui.Image image;
  final bool debugMode;
  final Offset? lastTapPosition;
  final Offset? lastTransformedPosition;

  _TestLayerPainter({
    required this.image,
    this.debugMode = true,
    this.lastTapPosition,
    this.lastTransformedPosition,
  });

  @override
  void paint(Canvas canvas, Size size) {
    // 缁樺埗鑳屾櫙鍥惧儚
    paintImage(
      canvas: canvas,
      rect: Offset.zero & size,
      image: image,
      fit: BoxFit.contain,
    );

    if (debugMode) {
      // 缁樺埗璋冭瘯缃戞牸
      drawDebugGrid(canvas, size);

      // 缁樺埗鐐瑰嚮浣嶇疆
      if (lastTapPosition != null) {
        final paint = Paint()
          ..color = Colors.blue.withOpacity(0.5)
          ..strokeWidth = 2
          ..style = PaintingStyle.stroke;

        // 缁樺埗鍘熷鐐瑰嚮浣嶇疆
        canvas.drawCircle(lastTapPosition!, 10, paint);
        canvas.drawLine(
          lastTapPosition! - const Offset(15, 0),
          lastTapPosition! + const Offset(15, 0),
          paint,
        );
        canvas.drawLine(
          lastTapPosition! - const Offset(0, 15),
          lastTapPosition! + const Offset(0, 15),
          paint,
        );
      }

      // 缁樺埗杞崲鍚庣殑浣嶇疆
      if (lastTransformedPosition != null) {
        final paint = Paint()
          ..color = Colors.red.withOpacity(0.5)
          ..strokeWidth = 2
          ..style = PaintingStyle.stroke;

        canvas.drawCircle(lastTransformedPosition!, 5, paint);
        canvas.drawRect(
          lastTransformedPosition! - const Offset(10, 10) & const Size(20, 20),
          paint,
        );
      }

      // 缁樺埗璋冭瘯淇℃伅
      final info = {
        'Image Size': '${image.width}x${image.height}',
        'View Size':
            '${size.width.toStringAsFixed(1)}x${size.height.toStringAsFixed(1)}',
        if (lastTapPosition != null)
          'Tap Position':
              '(${lastTapPosition!.dx.toStringAsFixed(1)}, ${lastTapPosition!.dy.toStringAsFixed(1)})',
        if (lastTransformedPosition != null)
          'Transformed':
              '(${lastTransformedPosition!.dx.toStringAsFixed(1)}, ${lastTransformedPosition!.dy.toStringAsFixed(1)})',
      };
      drawDebugInfo(canvas, size, info);
    }
  }

  @override
  bool shouldRepaint(covariant _TestLayerPainter oldDelegate) {
    return image != oldDelegate.image ||
        debugMode != oldDelegate.debugMode ||
        lastTapPosition != oldDelegate.lastTapPosition ||
        lastTransformedPosition != oldDelegate.lastTransformedPosition;
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\character_collection\erase_tool\widgets\brush_cursor.dart
-----------------------------------
import 'package:flutter/material.dart';

/// 绗斿埛鍏夋爣
/// 璺熼殢榧犳爣浣嶇疆鏄剧ず绗斿埛澶у皬鎸囩ず鍣?
class BrushCursor extends StatefulWidget {
  /// 绗斿埛澶у皬
  final double brushSize;

  /// 鏄惁姝ｅ湪鎿﹂櫎
  final bool isErasing;

  /// 鏋勯€犲嚱鏁?
  const BrushCursor({
    Key? key,
    required this.brushSize,
    required this.isErasing,
  }) : super(key: key);

  @override
  State<BrushCursor> createState() => _BrushCursorState();
}

class _BrushCursorState extends State<BrushCursor> {
  Offset _cursorPosition = Offset.zero;
  bool _isPointerInside = false;

  @override
  Widget build(BuildContext context) {
    return Listener(
      onPointerHover: (event) {
        setState(() {
          _cursorPosition = event.localPosition;
          _isPointerInside = true;
          print('绗斿埛鍏夋爣: 鎮仠鍦?$_cursorPosition');
        });
      },
      onPointerDown: (event) {
        setState(() {
          _cursorPosition = event.localPosition;
          _isPointerInside = true;
          print('馃幆 绗斿埛鍏夋爣浣嶇疆鏇存柊 [鎸変笅]');
          print('鉃★笍 鍘熷浣嶇疆: ${event.position}');
          print('馃摫 璁惧鍍忕礌姣? ${MediaQuery.of(context).devicePixelRatio}');
          print('鉁?鏈湴浣嶇疆: $_cursorPosition');
        });
      },
      onPointerMove: (event) {
        // 鍑忓皯鏃ュ織棰戠巼锛屽彧璁板綍鏄捐憲绉诲姩
        if (event.delta.distance > 5) {
          setState(() {
            _cursorPosition = event.localPosition;
            _isPointerInside = true;
            print('馃幆 绗斿埛鍏夋爣浣嶇疆鏇存柊 [绉诲姩]');
            print('鈫旓笍 绉诲姩璺濈: ${event.delta.distance}');
            print('鉁?鏈湴浣嶇疆: $_cursorPosition');
          });
        }
      },
      onPointerUp: (event) {
        setState(() {
          _isPointerInside = false;
          print('绗斿埛鍏夋爣: 鎶捣 - 閲嶇疆鎸囬拡鐘舵€?);
        });
      },
      child: Stack(
        children: [
          if (_isPointerInside)
            Positioned(
              left: _cursorPosition.dx - widget.brushSize / 2,
              top: _cursorPosition.dy - widget.brushSize / 2,
              child: Container(
                width: widget.brushSize,
                height: widget.brushSize,
                decoration: BoxDecoration(
                  color: widget.isErasing
                      ? Colors.red.withOpacity(0.3)
                      : Colors.transparent,
                  shape: BoxShape.circle,
                  border: Border.all(
                    color: widget.isErasing ? Colors.red : Colors.blue,
                    width: 1.5,
                  ),
                ),
              ),
            ),
        ],
      ),
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\character_collection\erase_tool\widgets\brush_size_slider.dart
-----------------------------------
import 'package:flutter/material.dart';

/// 绗斿埛澶у皬婊戝潡
/// 鎻愪緵绗斿埛澶у皬璋冭妭鍔熻兘
class BrushSizeSlider extends StatelessWidget {
  /// 褰撳墠鍊?
  final double value;

  /// 鏈€灏忓€?
  final double min;

  /// 鏈€澶у€?
  final double max;

  /// 鍙樻洿鍥炶皟
  final ValueChanged<double>? onChanged;

  /// 鏋勯€犲嚱鏁?
  const BrushSizeSlider({
    Key? key,
    required this.value,
    required this.min,
    required this.max,
    this.onChanged,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Row(
      children: [
        const Icon(Icons.brush, size: 16),

        Expanded(
          child: Slider(
            value: value,
            min: min,
            max: max,
            divisions: ((max - min) / 1).round(),
            label: '${value.round()}px',
            onChanged: onChanged,
          ),
        ),

        // 鏄剧ず褰撳墠绗斿埛澶у皬
        Container(
          padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
          decoration: BoxDecoration(
            color: Theme.of(context).primaryColor.withOpacity(0.1),
            borderRadius: BorderRadius.circular(4),
          ),
          child: Text(
            '${value.round()}px',
            style: TextStyle(
              fontSize: 12,
              color: Theme.of(context).primaryColor,
            ),
          ),
        ),
      ],
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\character_collection\erase_tool\widgets\calibration_tool.dart
-----------------------------------
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';

/// 鏍″噯宸ュ叿 - 甯姪寮€鍙戣€呰皟鏁村潗鏍囩簿纭害
class CalibrationTool extends StatefulWidget {
  /// 鍥炶皟鍑芥暟锛屽綋鍋忕Щ閲忓彉鍖栨椂璋冪敤
  final Function(Offset offset, double scale) onCalibrationChanged;

  /// 鍒濆鍋忕Щ閲?
  final Offset initialOffset;

  /// 鍒濆缂╂斁姣斾緥
  final double initialScale;

  const CalibrationTool({
    Key? key,
    required this.onCalibrationChanged,
    this.initialOffset = Offset.zero,
    this.initialScale = 1.0,
  }) : super(key: key);

  @override
  State<CalibrationTool> createState() => _CalibrationToolState();
}

class _CalibrationToolState extends State<CalibrationTool> {
  late double _offsetX;
  late double _offsetY;
  late double _scale;

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(8),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.1),
            blurRadius: 4,
            offset: const Offset(0, 2),
          ),
        ],
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        mainAxisSize: MainAxisSize.min,
        children: [
          const Text(
            '鍧愭爣鏍″噯宸ュ叿',
            style: TextStyle(
              fontSize: 16,
              fontWeight: FontWeight.bold,
            ),
          ),
          const SizedBox(height: 8),
          const Text('X鍋忕Щ'),
          Row(
            children: [
              Expanded(
                child: Slider(
                  value: _offsetX,
                  min: -100,
                  max: 100,
                  divisions: 200,
                  onChanged: (value) {
                    setState(() {
                      _offsetX = value;
                      _notifyCalibrationChanged();
                    });
                  },
                ),
              ),
              SizedBox(
                width: 50,
                child: Text(
                  _offsetX.toStringAsFixed(1),
                  textAlign: TextAlign.center,
                ),
              ),
            ],
          ),
          const Text('Y鍋忕Щ'),
          Row(
            children: [
              Expanded(
                child: Slider(
                  value: _offsetY,
                  min: -100,
                  max: 100,
                  divisions: 200,
                  onChanged: (value) {
                    setState(() {
                      _offsetY = value;
                      _notifyCalibrationChanged();
                    });
                  },
                ),
              ),
              SizedBox(
                width: 50,
                child: Text(
                  _offsetY.toStringAsFixed(1),
                  textAlign: TextAlign.center,
                ),
              ),
            ],
          ),
          const Text('姣斾緥鏍℃'),
          Row(
            children: [
              Expanded(
                child: Slider(
                  value: _scale,
                  min: 0.5,
                  max: 2.0,
                  divisions: 30,
                  onChanged: (value) {
                    setState(() {
                      _scale = value;
                      _notifyCalibrationChanged();
                    });
                  },
                ),
              ),
              SizedBox(
                width: 50,
                child: Text(
                  _scale.toStringAsFixed(2),
                  textAlign: TextAlign.center,
                ),
              ),
            ],
          ),
          const SizedBox(height: 8),
          Row(
            mainAxisAlignment: MainAxisAlignment.end,
            children: [
              TextButton(
                onPressed: _resetCalibration,
                child: const Text('閲嶇疆'),
              ),
              const SizedBox(width: 8),
              ElevatedButton(
                onPressed: _applyCalibration,
                child: const Text('搴旂敤'),
              ),
            ],
          ),
        ],
      ),
    );
  }

  @override
  void initState() {
    super.initState();
    _offsetX = widget.initialOffset.dx;
    _offsetY = widget.initialOffset.dy;
    _scale = widget.initialScale;
  }

  /// 搴旂敤鏍″噯璁剧疆
  void _applyCalibration() {
    _notifyCalibrationChanged();

    if (kDebugMode) {
      print(
          '搴旂敤鏍″噯璁剧疆: 鍋忕Щ=(${_offsetX.toStringAsFixed(1)}, ${_offsetY.toStringAsFixed(1)}), 姣斾緥=${_scale.toStringAsFixed(2)}');
    }

    ScaffoldMessenger.of(context).showSnackBar(
      const SnackBar(
        content: Text('鏍″噯璁剧疆宸插簲鐢?),
        duration: Duration(seconds: 1),
      ),
    );
  }

  /// 閫氱煡鏍″噯鍙樺寲
  void _notifyCalibrationChanged() {
    widget.onCalibrationChanged(
      Offset(_offsetX, _offsetY),
      _scale,
    );
  }

  /// 閲嶇疆鏍″噯璁剧疆
  void _resetCalibration() {
    setState(() {
      _offsetX = 0;
      _offsetY = 0;
      _scale = 1.0;
      _notifyCalibrationChanged();
    });
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\character_collection\erase_tool\widgets\erase_layer_stack.dart
-----------------------------------
import 'dart:ui' as ui;

import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';

import 'layers/background_layer.dart';
import 'layers/preview_layer.dart';

/// 鎿﹂櫎鍥惧眰鏍?
/// 鍖呭惈鑳屾櫙鍥惧眰鍜岄瑙堝浘灞?
class EraseLayerStack extends StatelessWidget {
  /// 鍥惧儚鏁版嵁
  final ui.Image image;

  /// 鍙樻崲鎺у埗鍣?
  final TransformationController transformationController;

  /// 绗斿埛澶у皬
  final double brushSize;

  /// 鍙樻崲鍥炶皟
  final VoidCallback? onTransformationChanged;

  /// 鎵嬪娍浜嬩欢鍥炶皟
  final GestureDragStartCallback? onPanStart;
  final GestureDragUpdateCallback? onPanUpdate;
  final GestureDragEndCallback? onPanEnd;
  final GestureDragCancelCallback? onPanCancel;

  /// 鏄惁鏄剧ず鑳屾櫙鍥惧儚
  final bool showBackgroundImage;

  /// 鏋勯€犲嚱鏁?
  const EraseLayerStack({
    Key? key,
    required this.image,
    required this.transformationController,
    this.brushSize = 20.0,
    this.onTransformationChanged,
    this.onPanStart,
    this.onPanUpdate,
    this.onPanEnd,
    this.onPanCancel,
    this.showBackgroundImage = true,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    // 鏍规嵁璁惧鎬ц兘杩涜娓叉煋浼樺寲
    final imageRatio = image.width / image.height;

    return AspectRatio(
      aspectRatio: imageRatio,
      child: LayoutBuilder(
        builder: (context, constraints) {
          final Size containerSize = constraints.biggest;
          final double containerRatio =
              containerSize.width / containerSize.height;

          // 鏍规嵁瀹瑰櫒灏哄鍜屽浘鍍忔瘮渚嬭绠楀浘鍍忓疄闄呮樉绀哄昂瀵?
          final Size displaySize = _calculateDisplaySize(
            containerSize: containerSize,
            imageRatio: imageRatio,
            containerRatio: containerRatio,
          );

          // 娣诲姞鍧愭爣绯昏皟璇曠綉鏍肩敤浜庢牎鍑?
          bool showDebugGrid = kDebugMode && false; // 寮€鍙戞椂鍙涓簍rue浠ユ樉绀虹綉鏍?

          return Center(
            child: SizedBox.fromSize(
              size: displaySize,
              child: MouseRegion(
                cursor: SystemMouseCursors.precise, // 浣跨敤绮剧‘鍏夋爣
                onHover: (event) {
                  if (kDebugMode && showDebugGrid) {
                    print('馃柋锔?榧犳爣鎮仠: ${event.localPosition}');
                  }
                },
                child: Listener(
                  // 浣跨敤Listener浠ｆ浛GestureDetector浠ヨ幏鍙栧師濮嬫寚閽堜簨浠?
                  onPointerDown: (event) {
                    if (onPanStart != null) {
                      onPanStart!(DragStartDetails(
                        globalPosition: event.position,
                        localPosition: event.localPosition,
                      ));
                    }
                  },
                  onPointerMove: (event) {
                    if (onPanUpdate != null) {
                      onPanUpdate!(DragUpdateDetails(
                        globalPosition: event.position,
                        localPosition: event.localPosition,
                        delta: event.delta,
                      ));
                    }
                  },
                  onPointerUp: (event) {
                    if (onPanEnd != null) {
                      onPanEnd!(DragEndDetails());
                    }
                  },
                  onPointerCancel: (event) {
                    if (onPanCancel != null) {
                      onPanCancel!();
                    }
                  },
                  child: Stack(
                    fit: StackFit.expand,
                    children: [
                      // 鑳屾櫙鍥惧眰
                      if (showBackgroundImage)
                        RepaintBoundary(
                          child: BackgroundLayer(
                            image: image,
                            transformationController: transformationController,
                          ),
                        ),

                      // 棰勮鍥惧眰
                      RepaintBoundary(
                        child: PreviewLayer(
                          transformationController: transformationController,
                          brushSize: brushSize,
                          scale: transformationController.value
                              .getMaxScaleOnAxis(),
                        ),
                      ),

                      // 璋冭瘯缃戞牸
                      if (showDebugGrid) _buildDebugGrid(),
                    ],
                  ),
                ),
              ),
            ),
          );
        },
      ),
    );
  }

  /// 鏋勫缓璋冭瘯缃戞牸
  Widget _buildDebugGrid() {
    return IgnorePointer(
      child: CustomPaint(
        painter: _DebugGridPainter(),
      ),
    );
  }

  /// 璁＄畻鏈€浣虫樉绀哄昂瀵?
  Size _calculateDisplaySize({
    required Size containerSize,
    required double imageRatio,
    required double containerRatio,
  }) {
    if (imageRatio > containerRatio) {
      // 鍥惧儚鏇村锛屼娇鐢ㄥ鍣ㄥ搴?
      return Size(containerSize.width, containerSize.width / imageRatio);
    } else {
      // 鍥惧儚鏇撮珮锛屼娇鐢ㄥ鍣ㄩ珮搴?
      return Size(containerSize.height * imageRatio, containerSize.height);
    }
  }
}

/// 璋冭瘯缃戞牸缁樺埗鍣?
class _DebugGridPainter extends CustomPainter {
  @override
  void paint(Canvas canvas, Size size) {
    // 缁樺埗鍙傝€冪綉鏍?
    final gridPaint = Paint()
      ..color = Colors.green.withOpacity(0.2)
      ..strokeWidth = 0.5
      ..style = PaintingStyle.stroke;

    // 姘村钩绾?
    for (double y = 0; y <= size.height; y += 50) {
      canvas.drawLine(Offset(0, y), Offset(size.width, y), gridPaint);
    }

    // 鍨傜洿绾?
    for (double x = 0; x <= size.width; x += 50) {
      canvas.drawLine(Offset(x, 0), Offset(x, size.height), gridPaint);
    }

    // 缁樺埗涓績鍗佸瓧绾?
    final centerPaint = Paint()
      ..color = Colors.red.withOpacity(0.3)
      ..strokeWidth = 1.0;

    canvas.drawLine(Offset(size.width / 2, 0),
        Offset(size.width / 2, size.height), centerPaint);

    canvas.drawLine(Offset(0, size.height / 2),
        Offset(size.width, size.height / 2), centerPaint);

    // 缁樺埗灏哄鏍囩
    final textPainter = TextPainter(
      textDirection: TextDirection.ltr,
    );

    // 鏄剧ず灏哄
    textPainter.text = TextSpan(
      text:
          '${size.width.toStringAsFixed(0)} x ${size.height.toStringAsFixed(0)}',
      style: TextStyle(color: Colors.black.withOpacity(0.7), fontSize: 10),
    );
    textPainter.layout();
    textPainter.paint(canvas, const Offset(5, 5));
  }

  @override
  bool shouldRepaint(_DebugGridPainter oldDelegate) => false;
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\character_collection\erase_tool\widgets\erase_toolbar.dart
-----------------------------------
import 'package:flutter/material.dart';

import '../controllers/erase_tool_controller.dart';
import '../models/erase_mode.dart';
import 'brush_size_slider.dart';

/// 鎿﹂櫎宸ュ叿鏍?
/// 鎻愪緵鎾ら攢/閲嶅仛銆佺瑪鍒峰ぇ灏忚皟鑺傜瓑鎺у埗
class EraseToolbar extends StatelessWidget {
  /// 鎺у埗鍣?
  final EraseToolController controller;

  /// 鎿嶄綔鍥炶皟
  final VoidCallback? onUndo;
  final VoidCallback? onRedo;
  final VoidCallback? onClearAll;
  final ValueChanged<double>? onBrushSizeChanged;

  /// 鏋勯€犲嚱鏁?
  const EraseToolbar({
    Key? key,
    required this.controller,
    this.onUndo,
    this.onRedo,
    this.onClearAll,
    this.onBrushSizeChanged,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(4),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.1),
            blurRadius: 4,
            offset: const Offset(0, 2),
          ),
        ],
      ),
      child: Row(
        children: [
          // 鎾ら攢鎸夐挳
          IconButton(
            icon: const Icon(Icons.undo),
            onPressed: controller.canUndo ? onUndo : null,
            tooltip: '鎾ら攢',
          ),

          // 閲嶅仛鎸夐挳
          IconButton(
            icon: const Icon(Icons.redo),
            onPressed: controller.canRedo ? onRedo : null,
            tooltip: '閲嶅仛',
          ),

          const SizedBox(width: 16),

          // 绗斿埛澶у皬璋冭妭
          Expanded(
            child: BrushSizeSlider(
              value: controller.brushSize,
              min: 3.0,
              max: 30.0,
              onChanged: onBrushSizeChanged,
            ),
          ),

          const SizedBox(width: 16),

          // 娓呴櫎鎵€鏈夋寜閽?
          IconButton(
            icon: const Icon(Icons.delete_outline),
            onPressed: onClearAll,
            tooltip: '娓呴櫎鎵€鏈?,
          ),

          // 妯″紡閫夋嫨
          PopupMenuButton<EraseMode>(
            icon: const Icon(Icons.more_vert),
            tooltip: '鎿﹂櫎妯″紡',
            onSelected: (EraseMode mode) {
              controller.setMode(mode);
            },
            itemBuilder: (BuildContext context) => <PopupMenuEntry<EraseMode>>[
              const PopupMenuItem<EraseMode>(
                value: EraseMode.normal,
                child: Text('鏅€氭ā寮?),
              ),
              const PopupMenuItem<EraseMode>(
                value: EraseMode.precise,
                child: Text('绮剧‘妯″紡'),
              ),
            ],
          ),
        ],
      ),
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\character_collection\erase_tool\widgets\erase_tool_widget.dart
-----------------------------------
import 'dart:ui' as ui;

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../controllers/erase_tool_controller.dart';
import '../controllers/erase_tool_provider.dart';
import '../models/erase_mode.dart';
import 'layers/background_layer.dart';
import 'layers/preview_layer.dart';
import 'layers/ui_layer.dart';

/// 鎿﹂櫎宸ュ叿Widget
class EraseToolWidget extends ConsumerStatefulWidget {
  /// 鍘熷鍥惧儚
  final ui.Image image;

  /// 鍙樻崲鎺у埗鍣?
  final TransformationController transformationController;

  /// 鍒濆绗斿埛澶у皬
  final double initialBrushSize;

  /// 鍒濆鎿﹂櫎妯″紡
  final EraseMode initialMode;

  /// 澶у皬鍙樺寲鍥炶皟
  final void Function(Size)? onSizeChanged;

  /// 鎺у埗鍣ㄥ氨缁洖璋?
  final void Function(EraseToolController)? onControllerReady;

  /// 鎿﹂櫎瀹屾垚鍥炶皟
  final void Function(ui.Image)? onEraseComplete;

  const EraseToolWidget({
    Key? key,
    required this.image,
    required this.transformationController,
    this.initialBrushSize = 20.0,
    this.initialMode = EraseMode.normal,
    this.onSizeChanged,
    this.onControllerReady,
    this.onEraseComplete,
  }) : super(key: key);

  @override
  ConsumerState<EraseToolWidget> createState() => _EraseToolWidgetState();
}

class _EraseToolWidgetState extends ConsumerState<EraseToolWidget> {
  // 鑺傛祦鎺у埗
  static const _updateThrottleMs = 16; // 绾?0fps
  late final EraseToolConfig _config;
  late final FocusNode _focusNode;
  Size? _currentSize;
  bool _isErasing = false;
  bool _isProcessingResult = false;

  DateTime? _lastUpdate;

  @override
  Widget build(BuildContext context) {
    // 浣跨敤Provider鑾峰彇鎺у埗鍣?
    final controller = ref.watch(eraseToolProvider(_config));

    // 鐩戝惉鎺у埗鍣ㄥ氨缁姸鎬?
    ref.listen(eraseToolProvider(_config), (previous, next) {
      if (widget.onControllerReady != null) {
        widget.onControllerReady!(next);
      }
    });

    return Focus(
      focusNode: _focusNode,
      autofocus: true,
      onFocusChange: (hasFocus) {
        if (!hasFocus) {
          _focusNode.requestFocus(); // 澶卞幓鐒︾偣鏃惰嚜鍔ㄩ噸鏂拌姹?
        }
      },
      child: GestureDetector(
        onTapDown: (_) => _focusNode.requestFocus(),
        behavior: HitTestBehavior.opaque,
        child: RepaintBoundary(
          child: LayoutBuilder(
            builder: (context, constraints) {
              final size = Size(constraints.maxWidth, constraints.maxHeight);

              // 閫氱煡瀹瑰櫒灏哄鍙樺寲
              _handleSizeChanged(size);

              return Stack(
                fit: StackFit.expand,
                children: [
                  // 鑳屾櫙鍥惧眰
                  Positioned.fill(
                    child: RepaintBoundary(
                      child: BackgroundLayer(
                        image: widget.image,
                        transformationController:
                            widget.transformationController,
                      ),
                    ),
                  ),

                  // 棰勮鍥惧眰
                  Positioned.fill(
                    child: RepaintBoundary(
                      child: PreviewLayer(
                        transformationController:
                            widget.transformationController,
                        brushSize: widget.initialBrushSize,
                        operations: controller.operations,
                        currentOperation: controller.currentOperation,
                        scale: widget.transformationController.value
                            .getMaxScaleOnAxis(),
                      ),
                    ),
                  ),

                  // UI鍥惧眰
                  Positioned.fill(
                    child: RepaintBoundary(
                      child: UILayer(
                        transformationController:
                            widget.transformationController,
                        eraseMode: true,
                        brushSize: widget.initialBrushSize,
                        onPanStart: (details) {
                          _isErasing = true;
                          controller.startErase(details.localPosition);
                        },
                        onPanUpdate: (details) {
                          if (_isErasing) {
                            controller.continueErase(details.localPosition);
                          }
                        },
                        onPanEnd: (details) {
                          if (_isErasing) {
                            controller.endErase();
                            _handleEraseComplete();
                          }
                        },
                        onPanCancel: () {
                          if (_isErasing) {
                            controller.cancelErase();
                            _isErasing = false;
                          }
                        },
                      ),
                    ),
                  ),

                  // 鍔犺浇鎸囩ず鍣?
                  if (_isProcessingResult)
                    const Positioned.fill(
                      child: RepaintBoundary(
                        child: ColoredBox(
                          color: Color(0x80FFFFFF),
                          child: Center(
                            child: CircularProgressIndicator(),
                          ),
                        ),
                      ),
                    ),
                ],
              );
            },
          ),
        ),
      ),
    );
  }

  @override
  void dispose() {
    _focusNode.dispose();
    super.dispose();
  }

  @override
  void initState() {
    super.initState();
    _focusNode = FocusNode();
    final imageSize = Size(
      widget.image.width.toDouble(),
      widget.image.height.toDouble(),
    );

    _config = EraseToolConfig(
      initialBrushSize: widget.initialBrushSize,
      initialMode: widget.initialMode,
      imageSize: imageSize,
    );

    // 璁剧疆鍒濆鐢诲竷灏哄
    WidgetsBinding.instance.addPostFrameCallback((_) {
      final controller = ref.read(eraseToolProvider(_config));
      controller.setCanvasSize(imageSize);
      _focusNode.requestFocus(); // 璇锋眰鐒︾偣
    });
  }

  /// 澶勭悊鎿﹂櫎瀹屾垚
  Future<void> _handleEraseComplete() async {
    if (!_isErasing || _isProcessingResult) return;
    _isErasing = false;
    _isProcessingResult = true;

    try {
      // 鑾峰彇鏈€缁堝浘鍍忓苟閫氱煡
      if (widget.onEraseComplete != null) {
        final controller = ref.read(eraseToolProvider(_config));
        final resultImage = await controller.getResultImage();
        if (resultImage != null && mounted) {
          widget.onEraseComplete!(resultImage);
        }
      }
    } finally {
      if (mounted) {
        setState(() {
          _isProcessingResult = false;
        });
      }
    }
  }

  /// 澶勭悊澶у皬鍙樺寲
  void _handleSizeChanged(Size size) {
    if (_currentSize == size) return;

    // 鑺傛祦鎺у埗
    final now = DateTime.now();
    if (_lastUpdate != null &&
        now.difference(_lastUpdate!).inMilliseconds < _updateThrottleMs) {
      return;
    }
    _lastUpdate = now;

    _currentSize = size;
    widget.onSizeChanged?.call(size);
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\character_collection\erase_tool\widgets\layers\background_layer.dart
-----------------------------------
import 'dart:ui' as ui;

import 'package:flutter/material.dart';

/// 鑳屾櫙鍥惧眰
/// 璐熻矗鏄剧ず鍘熷鍥惧儚鍐呭
class BackgroundLayer extends StatelessWidget {
  /// 鍘熷鍥惧儚
  final ui.Image image;

  /// 鍙樻崲鎺у埗鍣?
  final TransformationController transformationController;

  /// 鍙樻崲鍥炶皟
  final VoidCallback? onChanged;

  /// 鏋勯€犲嚱鏁?
  const BackgroundLayer({
    Key? key,
    required this.image,
    required this.transformationController,
    this.onChanged,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return RepaintBoundary(
      child: CustomPaint(
        painter: _BackgroundPainter(
          image: image,
          transform: transformationController.value,
        ),
        isComplex: true,
        willChange: false,
      ),
    );
  }
}

/// 鑳屾櫙缁樺埗鍣?
class _BackgroundPainter extends CustomPainter {
  final ui.Image image;
  final Matrix4 transform;

  const _BackgroundPainter({
    required this.image,
    required this.transform,
  });

  @override
  void paint(Canvas canvas, Size size) {
    // 璁＄畻缂╂斁姣斾緥浠ラ€傚簲鐢诲竷
    final imageAspectRatio = image.width / image.height;
    final canvasAspectRatio = size.width / size.height;

    double scale;
    double dx = 0;
    double dy = 0;

    if (imageAspectRatio > canvasAspectRatio) {
      // 鍥惧儚鏇村锛屼互瀹藉害涓哄噯
      scale = size.width / image.width;
      dy = (size.height - image.height * scale) / 2;
    } else {
      // 鍥惧儚鏇撮珮锛屼互楂樺害涓哄噯
      scale = size.height / image.height;
      dx = (size.width - image.width * scale) / 2;
    }

    // 搴旂敤鍙樻崲
    canvas.save();
    canvas.translate(dx, dy);
    canvas.scale(scale);

    // 缁樺埗鍥惧儚
    final paint = Paint()
      ..filterQuality = FilterQuality.high
      ..isAntiAlias = true;

    canvas.drawImage(image, Offset.zero, paint);
    canvas.restore();
  }

  @override
  bool shouldRepaint(covariant _BackgroundPainter oldDelegate) {
    return image != oldDelegate.image || transform != oldDelegate.transform;
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\character_collection\erase_tool\widgets\layers\cached_layer.dart
-----------------------------------
import 'dart:ui' as ui;

import 'package:flutter/material.dart';

/// 缂撳瓨灞傚熀绫?
/// 鎻愪緵鍩虹鐨勭紦瀛樺拰缁樺埗閫昏緫
abstract class CachedLayer extends StatefulWidget {
  const CachedLayer({super.key});
}

/// 缂撳瓨灞傜姸鎬佸熀绫?
abstract class CachedLayerState<T extends CachedLayer> extends State<T> {
  /// 鍥惧眰缂撳瓨
  ui.Image? _cachedImage;

  /// 鑴忓尯鍩?
  Rect? _dirtyRegion;

  /// 鏄惁闇€瑕侀噸寤?
  bool _needsRebuild = true;

  /// 鑾峰彇缂撳瓨鍥惧儚
  ui.Image? get cachedImage => _cachedImage;

  /// 璁剧疆缂撳瓨鍥惧儚
  set cachedImage(ui.Image? value) {
    if (_cachedImage != value) {
      _cachedImage?.dispose();
      _cachedImage = value;
      _needsRebuild = false;
      _dirtyRegion = null;
    }
  }

  /// 鑾峰彇鑴忓尯鍩?
  Rect? get dirtyRegion => _dirtyRegion;

  /// 妫€鏌ユ槸鍚﹂渶瑕侀噸寤?
  bool get needsRebuild => _needsRebuild;

  @override
  void dispose() {
    _cachedImage?.dispose();
    super.dispose();
  }

  /// 鏍囪鑴忓尯鍩?
  void markDirty(Rect region) {
    if (_dirtyRegion == null) {
      _dirtyRegion = region;
    } else {
      _dirtyRegion = _dirtyRegion!.expandToInclude(region);
    }
    setState(() {});
  }

  /// 鏍囪涓洪渶瑕侀噸寤?
  void markNeedsRebuild() {
    _needsRebuild = true;
    setState(() {});
  }

  /// 閲嶅缓缂撳瓨
  Future<void> rebuildCache();

  /// 鏇存柊缂撳瓨
  Future<void> updateCache() async {
    if (_needsRebuild || _cachedImage == null) {
      await rebuildCache();
    } else if (_dirtyRegion != null) {
      await updateDirtyRegion(_dirtyRegion!);
      _dirtyRegion = null;
    }
  }

  /// 鏇存柊鑴忓尯鍩?
  Future<void> updateDirtyRegion(Rect region);
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\character_collection\erase_tool\widgets\layers\image_layer.dart
-----------------------------------
import 'dart:ui' as ui;

import 'package:flutter/material.dart';

/// 鍥惧儚灞?
/// 璐熻矗鏄剧ず鍜屽彉鎹㈠師濮嬪浘鍍?
class ImageLayer extends StatelessWidget {
  /// 鍥惧儚鏁版嵁
  final ui.Image image;

  /// 鍙樻崲鎺у埗鍣?
  final TransformationController transformationController;

  /// 鍙樻崲鍙樻洿鍥炶皟
  final VoidCallback? onTransformationChanged;

  /// 鏋勯€犲嚱鏁?
  const ImageLayer({
    Key? key,
    required this.image,
    required this.transformationController,
    this.onTransformationChanged,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    // 鑾峰彇鍥惧儚鍘熷灏哄
    final imageSize = Size(
      image.width.toDouble(),
      image.height.toDouble(),
    );

    return InteractiveViewer(
      transformationController: transformationController,
      minScale: 0.1,
      maxScale: 5.0,
      constrained: false, // 鍏佽鍥惧儚瓒呭嚭杈圭晫
      onInteractionUpdate: (_) {
        onTransformationChanged?.call();
      },
      onInteractionEnd: (_) {
        onTransformationChanged?.call();
      },
      child: FittedBox(
        fit: BoxFit.contain, // 浣跨敤contain淇濇寔绾垫í姣?
        child: SizedBox(
          width: imageSize.width,
          height: imageSize.height,
          child: RawImage(
            image: image,
            width: imageSize.width,
            height: imageSize.height,
            fit: BoxFit.fill, // 浣跨敤fill鍥犱负宸茬粡鍦⊿izedBox涓缃簡姝ｇ‘鐨勫昂瀵?
          ),
        ),
      ),
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\character_collection\erase_tool\widgets\layers\preview_layer.dart
-----------------------------------
import 'package:flutter/material.dart';

import '../../models/erase_operation.dart';

/// 棰勮鍥惧眰
/// 璐熻矗鏄剧ず鎿﹂櫎鏁堟灉
class PreviewLayer extends StatelessWidget {
  /// 鍙樻崲鎺у埗鍣?
  final TransformationController transformationController;

  /// 绗斿埛澶у皬
  final double brushSize;

  /// 缂╂斁姣斾緥
  final double scale;

  /// 宸插畬鎴愮殑鎿嶄綔鍒楄〃
  final List<EraseOperation> operations;

  /// 褰撳墠姝ｅ湪杩涜鐨勬搷浣?
  final EraseOperation? currentOperation;

  const PreviewLayer({
    Key? key,
    required this.transformationController,
    required this.brushSize,
    this.scale = 1.0,
    this.operations = const [],
    this.currentOperation,
  }) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return RepaintBoundary(
      child: CustomPaint(
        painter: _PreviewPainter(
          operations: operations,
          currentOperation: currentOperation,
          transform: transformationController.value,
          brushSize: brushSize,
          scale: scale,
        ),
        isComplex: true,
      ),
    );
  }
}

/// 棰勮缁樺埗鍣?
class _PreviewPainter extends CustomPainter {
  final List<EraseOperation> operations;
  final EraseOperation? currentOperation;
  final Matrix4 transform;
  final double brushSize;
  final double scale;

  const _PreviewPainter({
    required this.operations,
    this.currentOperation,
    required this.transform,
    required this.brushSize,
    required this.scale,
  });

  @override
  void paint(Canvas canvas, Size size) {
    // 搴旂敤鍙樻崲
    canvas.save();
    canvas.transform(transform.storage);

    // 缁樺埗宸插畬鎴愮殑鎿嶄綔
    for (final operation in operations) {
      operation.apply(canvas);
    }

    // 缁樺埗褰撳墠鎿嶄綔
    currentOperation?.apply(canvas);

    canvas.restore();
  }

  @override
  bool shouldRepaint(covariant _PreviewPainter oldDelegate) {
    return operations != oldDelegate.operations ||
        currentOperation != oldDelegate.currentOperation ||
        transform != oldDelegate.transform ||
        brushSize != oldDelegate.brushSize ||
        scale != oldDelegate.scale;
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\character_collection\erase_tool\widgets\layers\ui_layer.dart
-----------------------------------
import 'package:flutter/gestures.dart';
import 'package:flutter/material.dart';

/// UI鍥惧眰
/// 澶勭悊鐢ㄦ埛浜や簰
class UILayer extends StatefulWidget {
  /// 鍙樻崲鎺у埗鍣?
  final TransformationController transformationController;

  /// 鏄惁澶勪簬鎿﹂櫎妯″紡
  final bool eraseMode;

  /// 绗斿埛澶у皬
  final double brushSize;

  /// 鎵嬪娍鍥炶皟
  final GestureDragStartCallback? onPanStart;
  final GestureDragUpdateCallback? onPanUpdate;
  final GestureDragEndCallback? onPanEnd;
  final GestureDragCancelCallback? onPanCancel;

  const UILayer({
    Key? key,
    required this.transformationController,
    this.eraseMode = true,
    this.brushSize = 20.0,
    this.onPanStart,
    this.onPanUpdate,
    this.onPanEnd,
    this.onPanCancel,
  }) : super(key: key);

  @override
  State<UILayer> createState() => _UILayerState();
}

/// 鍏夋爣缁樺埗鍣?
class _CursorPainter extends CustomPainter {
  final double brushSize;
  final bool showCursor;
  final Offset position;

  const _CursorPainter({
    required this.brushSize,
    required this.position,
    this.showCursor = true,
  });

  @override
  void paint(Canvas canvas, Size size) {
    if (!showCursor) return;

    final paint = Paint()
      ..color = Colors.black
      ..style = PaintingStyle.stroke
      ..strokeWidth = 1.0;

    // 缁樺埗鍦嗗舰绗斿埛鎸囩ず鍣?
    final radius = brushSize / 2;
    canvas.drawCircle(position, radius, paint);

    // 缁樺埗鍗佸瓧绾?
    const crossSize = 4.0;
    canvas.drawLine(
      position.translate(-radius - crossSize, 0),
      position.translate(-radius + crossSize, 0),
      paint,
    );
    canvas.drawLine(
      position.translate(radius - crossSize, 0),
      position.translate(radius + crossSize, 0),
      paint,
    );
    canvas.drawLine(
      position.translate(0, -radius - crossSize),
      position.translate(0, -radius + crossSize),
      paint,
    );
    canvas.drawLine(
      position.translate(0, radius - crossSize),
      position.translate(0, radius + crossSize),
      paint,
    );
  }

  @override
  bool shouldRepaint(covariant _CursorPainter oldDelegate) {
    return brushSize != oldDelegate.brushSize ||
        showCursor != oldDelegate.showCursor ||
        position != oldDelegate.position;
  }
}

class _UILayerState extends State<UILayer> {
  bool _isAltPressed = false;
  bool _isPanning = false;
  bool _isTransforming = false;
  Offset _mousePosition = Offset.zero;
  final FocusNode _focusNode = FocusNode();

  @override
  Widget build(BuildContext context) {
    return RawKeyboardListener(
      focusNode: _focusNode,
      onKey: _handleKeyEvent,
      child: Stack(
        children: [
          // 鍩虹灞?- 澶勭悊鎿﹂櫎
          if (!_isAltPressed)
            Positioned.fill(
              child: Listener(
                onPointerHover: _updateMousePosition,
                onPointerDown: (event) {
                  if (event.kind == PointerDeviceKind.mouse &&
                      event.buttons == kPrimaryMouseButton) {
                    _isPanning = true;
                    widget.onPanStart?.call(DragStartDetails(
                      globalPosition: event.position,
                      localPosition: event.localPosition,
                    ));
                  }
                },
                onPointerMove: (event) {
                  if (_isPanning) {
                    widget.onPanUpdate?.call(DragUpdateDetails(
                      globalPosition: event.position,
                      localPosition: event.localPosition,
                      delta: event.delta,
                    ));
                  }
                },
                onPointerUp: (event) {
                  if (_isPanning) {
                    _isPanning = false;
                    widget.onPanEnd?.call(DragEndDetails());
                  }
                },
                onPointerCancel: (event) {
                  if (_isPanning) {
                    _isPanning = false;
                    widget.onPanCancel?.call();
                  }
                },
                child: MouseRegion(
                  cursor: widget.eraseMode
                      ? SystemMouseCursors.precise
                      : SystemMouseCursors.basic,
                  child: CustomPaint(
                    painter: _CursorPainter(
                      brushSize: widget.brushSize,
                      showCursor: widget.eraseMode,
                      position: _mousePosition,
                    ),
                    child: Container(
                      color: Colors.transparent,
                    ),
                  ),
                ),
              ),
            ),

          // 鍙樻崲灞?- 澶勭悊绉诲姩鍜岀缉鏀?
          if (_isAltPressed)
            Positioned.fill(
              child: MouseRegion(
                cursor: _isTransforming
                    ? SystemMouseCursors.grabbing
                    : SystemMouseCursors.grab,
                child: InteractiveViewer(
                  transformationController: widget.transformationController,
                  minScale: 0.5,
                  maxScale: 4.0,
                  boundaryMargin: const EdgeInsets.all(20.0),
                  panEnabled: true,
                  scaleEnabled: true,
                  onInteractionStart: (_) {
                    setState(() {
                      _isTransforming = true;
                    });
                  },
                  onInteractionEnd: (_) {
                    setState(() {
                      _isTransforming = false;
                    });
                  },
                  child: Container(
                    decoration: BoxDecoration(
                      color: Colors.black.withOpacity(0.05),
                      border: Border.all(
                        color: Colors.blue.withOpacity(0.3),
                        width: 2,
                      ),
                    ),
                  ),
                ),
              ),
            ),

          // 鐘舵€佹彁绀?
          if (_isAltPressed)
            Positioned(
              left: 16,
              bottom: 16,
              child: Container(
                padding: const EdgeInsets.symmetric(
                  horizontal: 12,
                  vertical: 6,
                ),
                decoration: BoxDecoration(
                  color: Colors.black54,
                  borderRadius: BorderRadius.circular(4),
                ),
                child: const Row(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    Icon(
                      Icons.pan_tool_outlined,
                      color: Colors.white,
                      size: 16,
                    ),
                    SizedBox(width: 8),
                    Text(
                      '绉诲姩鍜岀缉鏀炬ā寮?(Alt)',
                      style: TextStyle(
                        color: Colors.white,
                        fontSize: 12,
                      ),
                    ),
                  ],
                ),
              ),
            ),
        ],
      ),
    );
  }

  @override
  void dispose() {
    _focusNode.dispose();
    super.dispose();
  }

  @override
  void initState() {
    super.initState();
    _focusNode.requestFocus();
  }

  /// 澶勭悊閿洏浜嬩欢
  void _handleKeyEvent(RawKeyEvent event) {
    final bool isAltPressed = event.isAltPressed;
    if (_isAltPressed != isAltPressed) {
      setState(() {
        _isAltPressed = isAltPressed;
        if (!isAltPressed) {
          _isTransforming = false;
        }
      });
    }
  }

  /// 鏇存柊榧犳爣浣嶇疆
  void _updateMousePosition(PointerEvent event) {
    if (mounted && !_isAltPressed) {
      setState(() {
        _mousePosition = event.localPosition;
      });
    }
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\common\base_card.dart
-----------------------------------
import 'package:flutter/material.dart';

class BaseCard extends StatelessWidget {
  final Widget child;
  final EdgeInsets? padding;
  final Color? color;

  const BaseCard({
    super.key,
    required this.child,
    this.padding,
    this.color,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Container(
      decoration: BoxDecoration(
        color: color ?? theme.cardColor,
        borderRadius: BorderRadius.circular(8),
        border: Border.all(color: theme.dividerColor),
      ),
      clipBehavior: Clip.antiAlias,
      child: padding != null ? Padding(padding: padding!, child: child) : child,
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\common\base_image_preview.dart
-----------------------------------
import 'dart:io';

import 'package:flutter/material.dart';

import '../../../infrastructure/logging/logger.dart';

class BaseImagePreview extends StatefulWidget {
  final List<String> imagePaths;
  final int initialIndex;
  final Function(int)? onIndexChanged;
  final bool showThumbnails;
  final bool enableZoom;
  final BoxDecoration? previewDecoration;
  final EdgeInsets? padding;

  const BaseImagePreview({
    super.key,
    required this.imagePaths,
    this.initialIndex = 0,
    this.onIndexChanged,
    this.showThumbnails = true,
    this.enableZoom = true,
    this.previewDecoration,
    this.padding,
  });

  @override
  State<BaseImagePreview> createState() => _BaseImagePreviewState();
}

class _BaseImagePreviewState extends State<BaseImagePreview> {
  static const double _minZoomScale = 0.1;
  static const double _maxZoomScale = 10.0;
  static const EdgeInsets _viewerPadding = EdgeInsets.all(20.0);
  final Map<String, bool> _fileExistsCache = {};

  final TransformationController _transformationController =
      TransformationController();
  late int _currentIndex;
  bool _isZoomed = false;

  @override
  Widget build(BuildContext context) {
    AppLogger.debug('BaseImagePreview build', tag: 'BaseImagePreview', data: {
      'hasPaths': widget.imagePaths.isNotEmpty,
      'pathCount': widget.imagePaths.length,
      'currentIndex': _currentIndex,
      'currentPath': widget.imagePaths.isNotEmpty
          ? widget.imagePaths[_currentIndex]
          : null,
    });

    return Container(
      decoration: widget.previewDecoration ??
          BoxDecoration(
            border: Border.all(color: Colors.grey.shade300),
            borderRadius: BorderRadius.circular(4),
          ),
      child: widget.imagePaths.isEmpty
          ? const Center(child: Text('娌℃湁鍥剧墖'))
          : _buildImageViewer(),
    );
  }

  @override
  void dispose() {
    _transformationController.dispose();
    super.dispose();
  }

  @override
  void initState() {
    super.initState();
    _currentIndex = widget.imagePaths.isEmpty
        ? 0
        : widget.initialIndex.clamp(0, widget.imagePaths.length - 1);
    _checkImageFiles();
  }

  Widget _buildImageViewer() {
    final currentPath = widget.imagePaths[_currentIndex];
    final fileExists = _fileExistsCache[currentPath] ?? false;

    if (!fileExists) {
      return const Center(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Icon(Icons.broken_image, size: 64, color: Colors.grey),
            SizedBox(height: 16),
            Text('鍥剧墖鏂囦欢涓嶅瓨鍦?),
          ],
        ),
      );
    }

    final file = File(currentPath);

    return GestureDetector(
      onHorizontalDragEnd: (details) {
        if (_isZoomed) return; // 濡傛灉宸茬缉鏀惧垯涓嶅垏鎹㈠浘鐗?

        if (details.primaryVelocity == null) return;
        if (details.primaryVelocity! > 0 && _currentIndex > 0) {
          // 鍚戝彸婊戝姩锛屾樉绀轰笂涓€寮?
          _updateIndex(_currentIndex - 1);
        } else if (details.primaryVelocity! < 0 &&
            _currentIndex < widget.imagePaths.length - 1) {
          // 鍚戝乏婊戝姩锛屾樉绀轰笅涓€寮?
          _updateIndex(_currentIndex + 1);
        }
      },
      onTapDown: (details) {
        if (_isZoomed) return; // 濡傛灉宸茬缉鏀惧垯涓嶅垏鎹㈠浘鐗?

        final x = details.localPosition.dx;
        final screenWidth = context.size?.width ?? 0;
        if (x < screenWidth / 3) {
          // 鐐瑰嚮宸︿晶涓夊垎涔嬩竴鍖哄煙锛屾樉绀轰笂涓€寮?
          if (_currentIndex > 0) {
            _updateIndex(_currentIndex - 1);
          }
        } else if (x > screenWidth * 2 / 3) {
          // 鐐瑰嚮鍙充晶涓夊垎涔嬩竴鍖哄煙锛屾樉绀轰笅涓€寮?
          if (_currentIndex < widget.imagePaths.length - 1) {
            _updateIndex(_currentIndex + 1);
          }
        }
      },
      child: InteractiveViewer(
        transformationController: _transformationController,
        boundaryMargin: _viewerPadding,
        minScale: _minZoomScale,
        maxScale: _maxZoomScale,
        onInteractionStart: (details) {
          if (details.pointerCount > 1) {
            _isZoomed = true;
          }
        },
        onInteractionEnd: (details) {
          // 妫€鏌ユ槸鍚︽仮澶嶅埌鍘熷澶у皬
          final matrix = _transformationController.value;
          if (matrix == Matrix4.identity()) {
            _isZoomed = false;
          }
        },
        child: Center(
          child: AnimatedSwitcher(
            duration: const Duration(milliseconds: 200),
            child: Image.file(
              file,
              key: ValueKey(currentPath),
              fit: BoxFit.contain,
              errorBuilder: (context, error, stackTrace) {
                AppLogger.error(
                  '鍥剧墖鍔犺浇澶辫触',
                  tag: 'BaseImagePreview',
                  error: error,
                  stackTrace: stackTrace,
                  data: {'path': currentPath},
                );
                return const Center(
                  child: Column(
                    mainAxisSize: MainAxisSize.min,
                    children: [
                      Icon(Icons.broken_image, size: 64, color: Colors.red),
                      SizedBox(height: 16),
                      Text('鍥剧墖鍔犺浇澶辫触', style: TextStyle(color: Colors.red)),
                    ],
                  ),
                );
              },
            ),
          ),
        ),
      ),
    );
  }

  Future<void> _checkImageFiles() async {
    for (final path in widget.imagePaths) {
      try {
        final file = File(path);
        _fileExistsCache[path] = await file.exists();
      } catch (e) {
        _fileExistsCache[path] = false;
        AppLogger.error('妫€鏌ュ浘鐗囨枃浠跺け璐?,
            tag: 'BaseImagePreview', error: e, data: {'path': path});
      }
    }
    if (mounted) {
      setState(() {});
    }
  }

  void _updateIndex(int newIndex) {
    if (newIndex != _currentIndex &&
        newIndex >= 0 &&
        newIndex < widget.imagePaths.length) {
      setState(() {
        _currentIndex = newIndex;
        // 閲嶇疆缂╂斁
        _transformationController.value = Matrix4.identity();
        _isZoomed = false;
      });
      widget.onIndexChanged?.call(_currentIndex);
    }
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\common\confirm_dialog.dart
-----------------------------------
import 'package:flutter/material.dart';

import '../../../theme/app_sizes.dart';

/// 閫氱敤纭瀵硅瘽妗?
class ConfirmDialog extends StatelessWidget {
  final String title;
  final String content;
  final VoidCallback onConfirm;
  final VoidCallback? onCancel;
  final String? confirmText;
  final String? cancelText;
  final bool isDestructive;

  const ConfirmDialog({
    super.key,
    required this.title,
    required this.content,
    required this.onConfirm,
    this.onCancel,
    this.confirmText,
    this.cancelText,
    this.isDestructive = false,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return AlertDialog(
      title: Text(title),
      content: Text(content),
      contentPadding: const EdgeInsets.fromLTRB(
        AppSizes.l,
        AppSizes.m,
        AppSizes.l,
        0,
      ),
      actionsPadding: const EdgeInsets.all(AppSizes.m),
      actions: [
        TextButton(
          onPressed: () {
            onCancel?.call();
            Navigator.of(context).pop(false);
          },
          child: Text(cancelText ?? '鍙栨秷'),
        ),
        FilledButton(
          onPressed: () {
            onConfirm();
            Navigator.of(context).pop(true);
          },
          style: isDestructive
              ? FilledButton.styleFrom(
                  backgroundColor: theme.colorScheme.error,
                  foregroundColor: theme.colorScheme.onError,
                )
              : null,
          child: Text(confirmText ?? '纭畾'),
        ),
      ],
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\common\data_list.dart
-----------------------------------
import 'package:flutter/material.dart';

class DataList extends StatelessWidget {
  final bool isGridView;
  final int itemCount;
  final IndexedWidgetBuilder itemBuilder;
  final double gridSpacing;
  final int gridCrossAxisCount;

  const DataList({
    super.key,
    this.isGridView = true,
    required this.itemCount,
    required this.itemBuilder,
    this.gridSpacing = 16.0,
    this.gridCrossAxisCount = 4,
  });

  @override
  Widget build(BuildContext context) {
    if (isGridView) {
      return GridView.builder(
        padding: const EdgeInsets.all(16),
        gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(
          crossAxisCount: gridCrossAxisCount,
          mainAxisSpacing: gridSpacing,
          crossAxisSpacing: gridSpacing,
          childAspectRatio: 1,
        ),
        itemCount: itemCount,
        itemBuilder: itemBuilder,
      );
    }
    
    return ListView.builder(
      padding: const EdgeInsets.all(16),
      itemCount: itemCount,
      itemBuilder: itemBuilder,
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\common\detail_toolbar.dart
-----------------------------------
import 'package:flutter/material.dart';

import '../../../theme/app_colors.dart';
import '../../../theme/app_sizes.dart';

class DetailBadge {
  final String text;
  final Color? backgroundColor;
  final Color? textColor;

  const DetailBadge({
    required this.text,
    this.backgroundColor,
    this.textColor,
  });
}

class DetailToolbar extends StatelessWidget implements PreferredSizeWidget {
  final String title;
  final IconData? leadingIcon;
  final String? subtitle;
  final DetailBadge? badge;
  final List<DetailToolbarAction> actions;
  final VoidCallback? onBack;

  const DetailToolbar({
    super.key,
    required this.title,
    this.leadingIcon,
    this.subtitle,
    this.badge,
    this.actions = const [],
    this.onBack,
  });

  @override
  Size get preferredSize => const Size.fromHeight(kToolbarHeight);

  @override
  Widget build(BuildContext context) {
    return AppBar(
      leading: IconButton(
        icon: const Icon(Icons.arrow_back),
        onPressed: onBack ?? () => Navigator.of(context).pop(),
      ),
      title: Row(
        children: [
          if (leadingIcon != null) ...[
            Icon(
              leadingIcon!,
              size: 24,
              color: Theme.of(context).primaryColor,
            ),
            const SizedBox(width: AppSizes.s),
          ],
          Expanded(
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              mainAxisSize: MainAxisSize.min,
              children: [
                Text(title),
                if (subtitle != null)
                  Text(
                    subtitle!,
                    style: Theme.of(context).textTheme.bodySmall,
                  ),
              ],
            ),
          ),
          if (badge != null)
            Container(
              padding: const EdgeInsets.symmetric(
                horizontal: AppSizes.s,
                vertical: AppSizes.xxs,
              ),
              decoration: BoxDecoration(
                color: badge!.backgroundColor ?? AppColors.primary,
                borderRadius: BorderRadius.circular(12),
              ),
              child: Text(
                badge!.text,
                style: Theme.of(context).textTheme.bodySmall?.copyWith(
                      color: badge!.textColor ?? Colors.white,
                    ),
              ),
            ),
        ],
      ),
      actions: actions.map((action) {
        return IconButton(
          icon: Icon(
            action.icon,
            color: action.color,
          ),
          tooltip: action.tooltip,
          onPressed: action.onPressed,
        );
      }).toList(),
    );
  }
}

class DetailToolbarAction {
  final IconData icon;
  final String tooltip;
  final VoidCallback onPressed;
  final Color? color;
  final bool primary;

  const DetailToolbarAction({
    required this.icon,
    required this.tooltip,
    required this.onPressed,
    this.color,
    this.primary = false,
  });
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\common\empty_state.dart
-----------------------------------
import 'package:flutter/material.dart';

import '../../../theme/app_sizes.dart';

class EmptyState extends StatelessWidget {
  final EmptyStateType type;
  final String? message;
  final IconData? icon;
  final String? actionLabel;
  final VoidCallback? onAction;
  final Widget? customContent;

  const EmptyState({
    super.key,
    this.type = EmptyStateType.noResults,
    this.message,
    this.icon,
    this.actionLabel,
    this.onAction,
    this.customContent,
  });

  @override
  Widget build(BuildContext context) {
    return Center(
      child: Padding(
        padding: const EdgeInsets.all(AppSizes.spacingLarge),
        child: customContent ?? _buildDefaultContent(context),
      ),
    );
  }

  Widget _buildDefaultContent(BuildContext context) {
    final theme = Theme.of(context);

    // 鏍规嵁绫诲瀷璁剧疆榛樿鍥炬爣鍜屾秷鎭?
    final IconData defaultIcon = _getDefaultIcon();
    final String defaultMessage = _getDefaultMessage();

    return Column(
      mainAxisSize: MainAxisSize.min,
      children: [
        Icon(
          icon ?? defaultIcon,
          size: 64,
          color: theme.colorScheme.onSurfaceVariant.withOpacity(0.5),
        ),
        const SizedBox(height: AppSizes.spacingMedium),
        Text(
          message ?? defaultMessage,
          style: theme.textTheme.bodyLarge?.copyWith(
            color: theme.colorScheme.onSurfaceVariant,
          ),
          textAlign: TextAlign.center,
        ),
        if (actionLabel != null && onAction != null) ...[
          const SizedBox(height: AppSizes.spacingLarge),
          FilledButton.icon(
            onPressed: onAction,
            icon: const Icon(Icons.add),
            label: Text(actionLabel!),
          ),
        ],
      ],
    );
  }

  IconData _getDefaultIcon() {
    switch (type) {
      case EmptyStateType.noWorks:
        return Icons.collections_outlined;
      case EmptyStateType.noCharacters:
        return Icons.text_fields_outlined;
      case EmptyStateType.noPractices:
        return Icons.edit_note_outlined;
      case EmptyStateType.noResults:
        return Icons.search_off_outlined;
      case EmptyStateType.noSelection:
        return Icons.select_all_outlined;
      case EmptyStateType.error:
        return Icons.error_outline;
      case EmptyStateType.custom:
        return Icons.info_outline;
    }
  }

  String _getDefaultMessage() {
    switch (type) {
      case EmptyStateType.noWorks:
        return '娌℃湁浣滃搧\n鐐瑰嚮娣诲姞鎸夐挳瀵煎叆浣滃搧';
      case EmptyStateType.noCharacters:
        return '娌℃湁瀛楀舰\n浠庝綔鍝佷腑鎻愬彇瀛楀舰鍚庡彲鍦ㄦ鏌ョ湅';
      case EmptyStateType.noPractices:
        return '娌℃湁缁冧範\n鐐瑰嚮娣诲姞鎸夐挳鍒涘缓鏂扮粌涔?;
      case EmptyStateType.noResults:
        return '娌℃湁鎵惧埌鍖归厤鐨勭粨鏋淺n灏濊瘯鏇存敼鎼滅储鏉′欢';
      case EmptyStateType.noSelection:
        return '鏈€夋嫨浠讳綍椤圭洰\n鐐瑰嚮椤圭洰浠ラ€夋嫨';
      case EmptyStateType.error:
        return '鍔犺浇澶辫触\n璇风◢鍚庡啀璇?;
      case EmptyStateType.custom:
        return '';
    }
  }
}

enum EmptyStateType {
  noWorks,
  noCharacters,
  noPractices,
  noResults,
  noSelection,
  error,
  custom,
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\common\error_display.dart
-----------------------------------
import 'package:flutter/material.dart';

import '../../../theme/app_colors.dart';
import '../../../theme/app_sizes.dart';

class ErrorDisplay extends StatelessWidget {
  final String error;
  final VoidCallback? onRetry;
  final IconData? icon;

  const ErrorDisplay({
    super.key,
    required this.error,
    this.onRetry,
    this.icon = Icons.error_outline,
  });

  @override
  Widget build(BuildContext context) {
    return Center(
      child: Padding(
        padding: const EdgeInsets.all(AppSizes.l),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Icon(
              icon,
              size: 48,
              color: AppColors.error,
            ),
            const SizedBox(height: AppSizes.m),
            Text(
              error,
              style: Theme.of(context).textTheme.titleMedium,
              textAlign: TextAlign.center,
            ),
            if (onRetry != null) ...[
              const SizedBox(height: AppSizes.l),
              ElevatedButton(
                onPressed: onRetry,
                child: const Text('閲嶈瘯'),
              ),
            ],
          ],
        ),
      ),
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\common\error_view.dart
-----------------------------------
import 'package:flutter/material.dart';

import '../../../theme/app_sizes.dart';

/// 閫氱敤閿欒瑙嗗浘
class ErrorView extends StatelessWidget {
  final String message;
  final VoidCallback? onRetry;
  final bool showBackground;
  final Color? backgroundColor;
  final IconData? icon;

  const ErrorView({
    super.key,
    required this.message,
    this.onRetry,
    this.showBackground = false,
    this.backgroundColor,
    this.icon,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final bgColor = backgroundColor ?? theme.colorScheme.surface;

    Widget content = Column(
      mainAxisSize: MainAxisSize.min,
      children: [
        Icon(
          icon ?? Icons.error_outline,
          size: 48,
          color: theme.colorScheme.error,
        ),
        const SizedBox(height: AppSizes.m),
        Text(
          message,
          style: TextStyle(color: theme.colorScheme.error),
          textAlign: TextAlign.center,
        ),
        if (onRetry != null) ...[
          const SizedBox(height: AppSizes.m),
          FilledButton.icon(
            onPressed: onRetry,
            icon: const Icon(Icons.refresh),
            label: const Text('閲嶈瘯'),
          ),
        ],
      ],
    );

    if (showBackground) {
      content = Container(
        color: bgColor,
        padding: const EdgeInsets.all(AppSizes.m),
        child: content,
      );
    }

    return Center(child: content);
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\common\grid_placeholder.dart
-----------------------------------
import 'package:flutter/material.dart';

/// A placeholder widget for grid items during loading
class GridPlaceholder extends StatelessWidget {
  const GridPlaceholder({super.key});

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Card(
      clipBehavior: Clip.antiAlias,
      elevation: 1,
      color: theme.colorScheme.surface,
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Image placeholder
          Expanded(
            flex: 3,
            child: Container(
              color: theme.colorScheme.surfaceContainerHighest.withOpacity(0.5),
            ),
          ),

          // Title placeholder
          Padding(
            padding: const EdgeInsets.all(8.0),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Container(
                  height: 16,
                  width: double.infinity,
                  decoration: BoxDecoration(
                    color: theme.colorScheme.surfaceContainerHighest
                        .withOpacity(0.7),
                    borderRadius: BorderRadius.circular(4),
                  ),
                ),
                const SizedBox(height: 8),
                Row(
                  children: [
                    // Author placeholder
                    Expanded(
                      child: Container(
                        height: 12,
                        decoration: BoxDecoration(
                          color: theme.colorScheme.surfaceContainerHighest
                              .withOpacity(0.5),
                          borderRadius: BorderRadius.circular(4),
                        ),
                      ),
                    ),
                    const SizedBox(width: 8),
                    // Style placeholder
                    Container(
                      height: 12,
                      width: 40,
                      decoration: BoxDecoration(
                        color:
                            theme.colorScheme.primaryContainer.withOpacity(0.5),
                        borderRadius: BorderRadius.circular(4),
                      ),
                    ),
                  ],
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\common\loading_indicator.dart
-----------------------------------
import 'package:flutter/material.dart';

import '../../../theme/app_sizes.dart';

class LoadingIndicator extends StatelessWidget {
  final String? message;
  final double size;

  const LoadingIndicator({
    super.key,
    this.message,
    this.size = 24.0,
  });

  @override
  Widget build(BuildContext context) {
    return Center(
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          const CircularProgressIndicator(
            strokeWidth: 3.0,
          ),
          if (message != null) ...[
            const SizedBox(height: AppSizes.m),
            Text(
              message!,
              style: Theme.of(context).textTheme.bodyMedium,
            ),
          ],
        ],
      ),
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\common\loading_view.dart
-----------------------------------
import 'package:flutter/material.dart';

import '../../../theme/app_sizes.dart';

/// 閫氱敤鍔犺浇瑙嗗浘
class LoadingView extends StatelessWidget {
  final String? message;
  final double? size;
  final double? strokeWidth;
  final bool showBackground;
  final Color? backgroundColor;

  const LoadingView({
    super.key,
    this.message,
    this.size,
    this.strokeWidth,
    this.showBackground = false,
    this.backgroundColor,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final bgColor = backgroundColor ?? theme.colorScheme.surface;

    Widget content = Column(
      mainAxisSize: MainAxisSize.min,
      children: [
        SizedBox(
          width: size ?? 32,
          height: size ?? 32,
          child: CircularProgressIndicator(
            strokeWidth: strokeWidth ?? 2,
          ),
        ),
        if (message != null) ...[
          const SizedBox(height: AppSizes.s),
          Text(message!),
        ],
      ],
    );

    if (showBackground) {
      content = Container(
        color: bgColor,
        child: content,
      );
    }

    return Center(child: content);
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\common\section_title.dart
-----------------------------------
import 'package:flutter/material.dart';

/// 涓€涓畝鍗曠殑閮ㄥ垎鏍囬缁勪欢锛岀敤浜庡湪琛ㄥ崟鎴栭〉闈㈢殑涓嶅悓閮ㄥ垎涔嬮棿鎻愪緵鍒嗛殧鍜屾爣棰?
class SectionTitle extends StatelessWidget {
  final String title;
  final EdgeInsetsGeometry? padding;
  final Color? color;
  final TextStyle? textStyle;
  final Widget? trailing;

  const SectionTitle({
    super.key,
    required this.title,
    this.padding = const EdgeInsets.only(bottom: 8.0),
    this.color,
    this.textStyle,
    this.trailing,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Padding(
      padding: padding ?? EdgeInsets.zero,
      child: Row(
        children: [
          Expanded(
            child: Text(
              title,
              style: textStyle ??
                  theme.textTheme.titleMedium?.copyWith(
                    fontWeight: FontWeight.bold,
                    color: color ?? theme.colorScheme.primary,
                  ),
            ),
          ),
          if (trailing != null) trailing!,
        ],
      ),
    );
  }
}

/// 涓€涓甫鏈夊簳閮ㄥ垎闅旂嚎鐨勯儴鍒嗘爣棰?
class SectionTitleWithDivider extends StatelessWidget {
  final String title;
  final EdgeInsetsGeometry? padding;
  final Color? color;
  final TextStyle? textStyle;
  final Widget? trailing;
  final Color? dividerColor;

  const SectionTitleWithDivider({
    super.key,
    required this.title,
    this.padding = const EdgeInsets.only(bottom: 8.0),
    this.color,
    this.textStyle,
    this.trailing,
    this.dividerColor,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        SectionTitle(
          title: title,
          padding: padding,
          color: color,
          textStyle: textStyle,
          trailing: trailing,
        ),
        Divider(
          height: 1,
          thickness: 1,
          color: dividerColor ?? theme.dividerColor.withOpacity(0.5),
        ),
      ],
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\common\sidebar_toggle.dart
-----------------------------------
import 'package:flutter/material.dart';

import '../../../theme/app_sizes.dart';

class SidebarToggle extends StatelessWidget {
  final bool isOpen;
  final VoidCallback onToggle;
  final bool alignRight; // 鏂板鍙傛暟锛屾帶鍒剁澶存柟鍚戝拰瀵归綈鏂瑰紡

  const SidebarToggle({
    super.key,
    required this.isOpen,
    required this.onToggle,
    this.alignRight = false, // 榛樿宸﹀榻愶紙鐢ㄤ簬娴忚椤碉級
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Container(
      margin: const EdgeInsets.symmetric(vertical: AppSizes.spacingMedium),
      child: Material(
        color: theme.colorScheme.surfaceContainerHighest,
        // 鏍规嵁alignRight鍙傛暟璋冩暣鍦嗚浣嶇疆
        borderRadius: BorderRadius.horizontal(
          left: alignRight ? const Radius.circular(8) : Radius.zero,
          right: alignRight ? Radius.zero : const Radius.circular(8),
        ),
        clipBehavior: Clip.antiAlias,
        child: InkWell(
          onTap: onToggle,
          child: SizedBox(
            width: 20,
            child: Center(
              child: Padding(
                padding: const EdgeInsets.symmetric(vertical: 16.0),
                child: Icon(
                  // 淇鍥炬爣鏂瑰悜閫昏緫
                  alignRight
                      // 鍙充晶闈㈡澘锛堣鎯呴〉锛?
                      ? (isOpen ? Icons.chevron_right : Icons.chevron_left)
                      // 鍙充晶闈㈡澘锛堟祻瑙堥〉锛? 杩欓噷鏄弽鐨勶紝闇€瑕佷慨澶?
                      : (isOpen ? Icons.chevron_right : Icons.chevron_left),
                  size: 16,
                  color: theme.colorScheme.onSurfaceVariant,
                ),
              ),
            ),
          ),
        ),
      ),
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\common\tab_bar_theme_wrapper.dart
-----------------------------------
import 'package:flutter/material.dart';

class TabBarThemeWrapper extends StatelessWidget {
  final Widget child;

  const TabBarThemeWrapper({
    super.key,
    required this.child,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Theme(
      data: theme.copyWith(
        tabBarTheme: TabBarTheme(
          labelColor: theme.colorScheme.primary,
          unselectedLabelColor: theme.colorScheme.onSurface.withOpacity(0.7),
          dividerColor: theme.dividerColor,
          indicatorColor: theme.colorScheme.primary,
          // 娣诲姞涓€浜涙按骞冲唴杈硅窛锛屼娇鏍囩椤垫爣棰樹笉浼氶潬寰楀お杩?
          indicatorSize: TabBarIndicatorSize.tab,
          // 杞诲井鎻愬崌鏍囩鍒囨崲鐨勫姩鐢绘椂闀?
          labelPadding: const EdgeInsets.symmetric(horizontal: 16.0),
        ),
        dividerTheme: const DividerThemeData(
          thickness: 1,
          space: 1,
        ),
      ),
      child: child,
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\common\toolbar_action_button.dart
-----------------------------------
import 'package:flutter/material.dart';

/// A standardized button for use in toolbars
class ToolbarActionButton extends StatelessWidget {
  /// The child widget to display (usually an Icon)
  final Widget child;

  /// Callback when button is pressed
  final VoidCallback? onPressed;

  /// Tooltip text to show on hover
  final String? tooltip;

  /// Whether the button is enabled
  final bool enabled;

  /// Whether to show a loading indicator instead of the child
  final bool isLoading;

  const ToolbarActionButton({
    super.key,
    required this.child,
    this.onPressed,
    this.tooltip,
    this.enabled = true,
    this.isLoading = false,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Tooltip(
      message: tooltip ?? '',
      child: Container(
        width: 40,
        height: 40,
        margin: const EdgeInsets.symmetric(horizontal: 4.0),
        decoration: BoxDecoration(
          color: enabled
              ? theme.colorScheme.primaryContainer.withOpacity(0.1)
              : theme.colorScheme.surfaceContainerHighest.withOpacity(0.2),
          borderRadius: BorderRadius.circular(20),
        ),
        child: Material(
          type: MaterialType.transparency,
          child: InkWell(
            borderRadius: BorderRadius.circular(20),
            onTap: enabled && !isLoading ? onPressed : null,
            child: Center(
              child: isLoading
                  ? SizedBox(
                      width: 20,
                      height: 20,
                      child: CircularProgressIndicator(
                        strokeWidth: 2,
                        color: theme.colorScheme.primary,
                      ),
                    )
                  : IconTheme(
                      data: IconThemeData(
                        color: enabled
                            ? theme.colorScheme.primary
                            : theme.colorScheme.onSurface.withOpacity(0.38),
                        size: 20,
                      ),
                      child: child,
                    ),
            ),
          ),
        ),
      ),
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\common\zoomable_image_view.dart
-----------------------------------
import 'dart:io';

import 'package:flutter/gestures.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';

/// A widget that displays an image with zoom and pan capabilities
class ZoomableImageView extends StatefulWidget {
  /// Path to the image file
  final String imagePath;

  /// Whether to enable mouse wheel zoom
  final bool enableMouseWheel;

  /// Minimum allowed scale
  final double minScale;

  /// Maximum allowed scale
  final double maxScale;

  /// Called when scale changes
  final Function(double)? onScaleChanged;

  /// Custom error widget builder
  final Widget Function(BuildContext, Object, StackTrace?)? errorBuilder;

  /// Custom loading widget builder
  final Widget Function(BuildContext)? loadingBuilder;

  /// Optional tap down callback for specialized interactions
  final Function(Offset)? onTapDown;

  /// Whether to enable gesture interactions
  final bool enableGestures;

  /// Called when zoom is reset
  final VoidCallback? onResetZoom;

  /// Whether to show zoom control buttons
  final bool showControls;

  const ZoomableImageView({
    super.key,
    required this.imagePath,
    this.enableMouseWheel = true,
    this.minScale = 0.5,
    this.maxScale = 4.0,
    this.onScaleChanged,
    this.errorBuilder,
    this.loadingBuilder,
    this.onTapDown,
    this.onResetZoom,
    this.enableGestures = true,
    this.showControls = false,
  });

  @override
  State<ZoomableImageView> createState() => _ZoomableImageViewState();
}

class _ZoomableImageViewState extends State<ZoomableImageView> {
  final TransformationController _transformationController =
      TransformationController();
  bool _isZoomed = false;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Stack(
      fit: StackFit.expand,
      children: [
        // Main image with zoom
        Listener(
          onPointerSignal:
              widget.enableMouseWheel ? _handlePointerSignal : null,
          child: GestureDetector(
            onTapDown: widget.onTapDown != null
                ? (details) => widget.onTapDown!(details.localPosition)
                : null,
            child: InteractiveViewer(
              panEnabled: widget.enableGestures,
              transformationController: _transformationController,
              minScale: widget.minScale,
              maxScale: widget.maxScale,
              onInteractionStart: _handleInteractionStart,
              onInteractionEnd: _handleInteractionEnd,
              child: Image.file(
                File(widget.imagePath),
                fit: BoxFit.contain,
                frameBuilder: (context, child, frame, wasSynchronouslyLoaded) {
                  if (wasSynchronouslyLoaded) return child;

                  return AnimatedSwitcher(
                    duration: const Duration(milliseconds: 200),
                    child: frame != null
                        ? child
                        : widget.loadingBuilder?.call(context) ??
                            Container(
                              color: theme.colorScheme.surfaceContainerHighest,
                              child: const Center(
                                child:
                                    CircularProgressIndicator(strokeWidth: 2),
                              ),
                            ),
                  );
                },
                errorBuilder: widget.errorBuilder ??
                    (context, error, stackTrace) => Center(
                          child: Column(
                            mainAxisSize: MainAxisSize.min,
                            children: [
                              Icon(
                                Icons.broken_image,
                                size: 64,
                                color: theme.colorScheme.error,
                              ),
                              const SizedBox(height: 16),
                              Text(
                                '鏃犳硶鍔犺浇鍥剧墖',
                                style: TextStyle(
                                  color: theme.colorScheme.error,
                                ),
                              ),
                            ],
                          ),
                        ),
              ),
            ),
          ),
        ),

        // Zoom controls
        if (widget.showControls && _isZoomed)
          Positioned(
            right: 16,
            bottom: 16,
            child: FloatingActionButton.small(
              onPressed: _resetZoom,
              tooltip: '閲嶇疆缂╂斁',
              child: const Icon(Icons.zoom_out_map),
            ),
          ),
      ],
    );
  }

  @override
  void dispose() {
    _transformationController.dispose();
    super.dispose();
  }

  void _handleInteractionEnd(ScaleEndDetails details) {
    final matrix = _transformationController.value;
    if (matrix == Matrix4.identity()) {
      setState(() => _isZoomed = false);
      widget.onScaleChanged?.call(1.0);
    }
  }

  void _handleInteractionStart(ScaleStartDetails details) {
    if (details.pointerCount > 1) {
      setState(() => _isZoomed = true);
    }
  }

  void _handlePointerSignal(PointerSignalEvent event) {
    if (event is PointerScrollEvent &&
        HardwareKeyboard.instance.isControlPressed) {
      final delta = event.scrollDelta.dy * 0.001;
      final currentScale = _transformationController.value.getMaxScaleOnAxis();
      final newScale =
          (currentScale - delta).clamp(widget.minScale, widget.maxScale);

      _transformationController.value = Matrix4.identity()..scale(newScale);

      setState(() => _isZoomed = newScale > 1.0);
      widget.onScaleChanged?.call(newScale);
    }
  }

  void _resetZoom() {
    _transformationController.value = Matrix4.identity();
    setState(() => _isZoomed = false);
    widget.onScaleChanged?.call(1.0);
    widget.onResetZoom?.call();
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\dialogs\confirmation_dialog.dart
-----------------------------------
import 'package:flutter/material.dart';

class ConfirmationDialog extends StatelessWidget {
  final String title;
  final String message;
  final String confirmText;
  final String cancelText;
  final bool isDestructive;
  final VoidCallback? onConfirm;

  const ConfirmationDialog({
    super.key,
    required this.title,
    required this.message,
    this.confirmText = '纭',
    this.cancelText = '鍙栨秷',
    this.isDestructive = false,
    this.onConfirm,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return AlertDialog(
      title: Row(
        children: [
          Icon(
            isDestructive ? Icons.warning_amber_rounded : Icons.help_outline,
            color: isDestructive
                ? theme.colorScheme.error
                : theme.colorScheme.primary,
            size: 24,
          ),
          const SizedBox(width: 12),
          Text(title),
        ],
      ),
      content: Text(message),
      actions: [
        TextButton(
          onPressed: () => Navigator.of(context).pop(false),
          child: Text(cancelText),
        ),
        FilledButton(
          onPressed: () {
            if (onConfirm != null) onConfirm!();
            Navigator.of(context).pop(true);
          },
          style: FilledButton.styleFrom(
            backgroundColor: isDestructive
                ? theme.colorScheme.error
                : theme.colorScheme.primary,
            foregroundColor: isDestructive
                ? theme.colorScheme.onError
                : theme.colorScheme.onPrimary,
          ),
          child: Text(confirmText),
        ),
      ],
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\displays\error_text.dart
-----------------------------------
import 'package:flutter/material.dart';

class ErrorText extends StatelessWidget {
  final String text;
  final int? maxLines;
  final TextStyle? style;

  const ErrorText({
    super.key,
    required this.text,
    this.maxLines = 2,
    this.style,
  });

  @override
  Widget build(BuildContext context) {
    final defaultStyle = Theme.of(context).textTheme.bodyMedium?.copyWith(
      color: Theme.of(context).colorScheme.error,
    );

    return Tooltip(
      message: text,
      waitDuration: const Duration(milliseconds: 500),
      child: Text(
        text,
        style: style ?? defaultStyle,
        maxLines: maxLines,
        overflow: TextOverflow.ellipsis,
      ),
    );
  }
}


C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\filter\filter_panel.dart
-----------------------------------
import 'package:flutter/material.dart';

import '../../../theme/app_sizes.dart';

class FilterPanel extends StatelessWidget {
  final String title;
  final List<dynamic> items;
  final dynamic selectedValue;
  final ValueChanged<dynamic> onSelected;

  const FilterPanel({
    super.key,
    required this.title,
    required this.items,
    required this.selectedValue,
    required this.onSelected,
  });

  @override
  Widget build(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(title, style: Theme.of(context).textTheme.titleMedium),
        const SizedBox(height: AppSizes.s),
        Wrap(
          spacing: AppSizes.s,
          runSpacing: AppSizes.xs,
          children: items.map((item) {
            final bool isSelected = item == selectedValue;
            return FilterChip(
              label: Text(item.label),
              selected: isSelected,
              onSelected: (_) => onSelected(item),
            );
          }).toList(),
        ),
      ],
    );
  }
}

class FilterSection extends StatelessWidget {
  final String title;
  final Widget child;

  const FilterSection({
    super.key,
    required this.title,
    required this.child,
  });

  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: const EdgeInsets.all(AppSizes.spacingMedium),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            title,
            style: Theme.of(context).textTheme.titleSmall,
          ),
          const SizedBox(height: AppSizes.spacingSmall),
          child,
        ],
      ),
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\forms\date_picker_field.dart
-----------------------------------
import 'package:flutter/material.dart';
import 'package:intl/intl.dart';

class DatePickerField extends StatelessWidget {
  final DateTime? value;
  final ValueChanged<DateTime?>? onChanged;
  final String? hint;
  final DateTime? firstDate;
  final DateTime? lastDate;

  const DatePickerField({
    super.key,
    this.value,
    this.onChanged,
    this.hint,
    this.firstDate,
    this.lastDate,
  });

  @override
  Widget build(BuildContext context) {
    final dateFormatter = DateFormat('yyyy-MM-dd');

    return TextFormField(
      controller: TextEditingController(
        text: value != null ? dateFormatter.format(value!) : '',
      ),
      readOnly: true,
      onTap: () => _showDatePicker(context),
      decoration: InputDecoration(
        border: const OutlineInputBorder(),
        hintText: hint,
        suffixIcon: const Icon(Icons.calendar_today),
        contentPadding: const EdgeInsets.symmetric(
          horizontal: 12,
          vertical: 0,
        ),
      ),
    );
  }

  Future<void> _showDatePicker(BuildContext context) async {
    final picked = await showDatePicker(
      context: context,
      initialDate: value ?? DateTime.now(),
      firstDate: firstDate ?? DateTime(1900),
      lastDate: lastDate ?? DateTime.now(),
    );

    if (picked != null) {
      onChanged?.call(picked);
    }
  }
}


C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\forms\dropdown_field.dart
-----------------------------------
import 'package:flutter/material.dart';

class DropdownField<T> extends StatelessWidget {
  final T? value;
  final List<T> items;
  final ValueChanged<T?>? onChanged;
  final Widget Function(T)? itemBuilder;
  final String? hint;
  final bool isExpanded;
  final bool isDense;

  const DropdownField({
    super.key,
    this.value,
    required this.items,
    this.onChanged,
    this.itemBuilder,
    this.hint,
    this.isExpanded = true,
    this.isDense = true,
  });

  @override
  Widget build(BuildContext context) {
    return DropdownButtonFormField<T>(
      value: value,
      items: items.map((item) {
        return DropdownMenuItem<T>(
          value: item,
          child: itemBuilder?.call(item) ?? Text(item.toString()),
        );
      }).toList(),
      onChanged: onChanged,
      hint: hint != null ? Text(hint!) : null,
      isExpanded: isExpanded,
      isDense: isDense,
      decoration: const InputDecoration(
        border: OutlineInputBorder(),
        contentPadding: EdgeInsets.symmetric(
          horizontal: 12,
          vertical: 12,
        ),
      ),
    );
  }
}


C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\forms\form_field_wrapper.dart
-----------------------------------
import 'package:flutter/material.dart';

import '../../../theme/app_sizes.dart';

class FormFieldWrapper extends StatelessWidget {
  final String label;
  final Widget child;
  final bool required;
  final String? tooltip;

  const FormFieldWrapper({
    super.key,
    required this.label,
    required this.child,
    this.required = false,
    this.tooltip,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      mainAxisSize: MainAxisSize.min,
      children: [
        Row(
          children: [
            Text(
              label,
              style: theme.textTheme.bodyMedium,
            ),
            if (required)
              Text(
                ' *',
                style: theme.textTheme.bodyMedium?.copyWith(
                  color: theme.colorScheme.error,
                ),
              ),
            if (tooltip != null) ...[
              const SizedBox(width: AppSizes.xs),
              Tooltip(
                message: tooltip!,
                child: Icon(
                  Icons.info_outline,
                  size: 16,
                  color: theme.colorScheme.outline,
                ),
              ),
            ],
          ],
        ),
        const SizedBox(height: AppSizes.formFieldSpacing),
        child,
      ],
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\forms\tag_editor.dart
-----------------------------------
import 'package:flutter/material.dart';

class TagEditor extends StatefulWidget {
  final List<String> tags;
  final List<String> suggestedTags;
  final ValueChanged<List<String>> onTagsChanged;
  final Color? chipColor;
  final Color? textColor;

  const TagEditor({
    super.key,
    required this.tags,
    this.suggestedTags = const [],
    required this.onTagsChanged,
    this.chipColor,
    this.textColor,
  });

  @override
  State<TagEditor> createState() => _TagEditorState();
}

class _TagEditorState extends State<TagEditor> {
  final TextEditingController _controller = TextEditingController();
  final FocusNode _focusNode = FocusNode();
  List<String> _tags = [];

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        // 鐜版湁鏍囩鏄剧ず
        if (_tags.isNotEmpty)
          Wrap(
            spacing: 8,
            runSpacing: 8,
            children: _tags.map((tag) {
              return Chip(
                label: Text(
                  tag,
                  style: TextStyle(
                    color: widget.textColor ?? theme.colorScheme.onSurface,
                  ),
                ),
                backgroundColor: widget.chipColor ?? theme.colorScheme.surface,
                deleteIconColor:
                    widget.textColor ?? theme.colorScheme.onSurface,
                onDeleted: () => _removeTag(tag),
              );
            }).toList(),
          ),

        const SizedBox(height: 8),

        // 娣诲姞鏂版爣绛剧殑杈撳叆妗?
        Row(
          children: [
            Expanded(
              child: TextField(
                controller: _controller,
                focusNode: _focusNode,
                decoration: const InputDecoration(
                  hintText: '杈撳叆鏂版爣绛?..',
                  isDense: true,
                ),
                onSubmitted: _addTag,
              ),
            ),
            IconButton(
              icon: const Icon(Icons.add),
              onPressed: () => _addTag(_controller.text),
              tooltip: '娣诲姞鏍囩',
            ),
          ],
        ),

        const SizedBox(height: 16),

        // 甯哥敤鏍囩寤鸿
        if (widget.suggestedTags.isNotEmpty) ...[
          const Text('甯哥敤鏍囩:'),
          const SizedBox(height: 8),
          Wrap(
            spacing: 8,
            runSpacing: 8,
            children: widget.suggestedTags
                .where((tag) => !_tags.contains(tag))
                .map((tag) {
              return ActionChip(
                label: Text(tag),
                onPressed: () => _addTag(tag),
              );
            }).toList(),
          ),
        ],
      ],
    );
  }

  @override
  void didUpdateWidget(TagEditor oldWidget) {
    super.didUpdateWidget(oldWidget);

    if (oldWidget.tags != widget.tags) {
      _tags = List.from(widget.tags);
    }
  }

  @override
  void dispose() {
    _controller.dispose();
    _focusNode.dispose();
    super.dispose();
  }

  @override
  void initState() {
    super.initState();
    _tags = List.from(widget.tags);
  }

  void _addTag(String tag) {
    if (tag.isEmpty) return;

    // 绉婚櫎鍓嶅悗绌烘牸
    final trimmedTag = tag.trim();
    if (trimmedTag.isEmpty) return;

    // 妫€鏌ユ爣绛炬槸鍚﹀凡瀛樺湪
    if (_tags.contains(trimmedTag)) return;

    setState(() {
      _tags.add(trimmedTag);
      _controller.clear();
      widget.onTagsChanged(_tags);
    });

    // 淇濇寔鐒︾偣鍦ㄨ緭鍏ユ
    _focusNode.requestFocus();
  }

  void _removeTag(String tag) {
    setState(() {
      _tags.remove(tag);
      widget.onTagsChanged(_tags);
    });
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\forms\work_form.dart
-----------------------------------
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';

import '../../../domain/enums/work_style.dart';
import '../../../domain/enums/work_tool.dart';
import '../../../theme/app_sizes.dart';
import '../common/section_title.dart';
import '../inputs/date_input_field.dart';
import '../inputs/dropdown_field.dart';

/// A unified form component for work entity data entry
/// Can be used in both import and edit scenarios
class WorkForm extends StatefulWidget {
  /// The form title
  final String? title;

  /// Initial title value
  final String initialTitle;

  /// Initial author value
  final String? initialAuthor;

  /// Initial style value
  final WorkStyle? initialStyle;

  /// Initial tool value
  final WorkTool? initialTool;

  /// Initial creation date
  final DateTime? initialCreationDate;

  /// Initial remark value
  final String? initialRemark;

  /// Whether the form is in processing state (disabled)
  final bool isProcessing;

  /// Error message to display
  final String? error;

  /// Callback when title changes
  final ValueChanged<String>? onTitleChanged;

  /// Callback when author changes
  final ValueChanged<String?>? onAuthorChanged;

  /// Callback when style changes
  final ValueChanged<WorkStyle?>? onStyleChanged;

  /// Callback when tool changes
  final ValueChanged<WorkTool?>? onToolChanged;

  /// Callback when creation date changes
  final ValueChanged<DateTime?>? onCreationDateChanged;

  /// Callback when remark changes
  final ValueChanged<String?>? onRemarkChanged;

  /// Which fields are required
  final Set<WorkFormField> requiredFields;

  /// Which fields to display
  final Set<WorkFormField> visibleFields;

  /// Show help text under fields
  final bool showHelp;

  /// Show keyboard shortcuts
  final bool showKeyboardShortcuts;

  /// Custom field builders for extending the form
  final Map<String, WidgetBuilder> customFieldBuilders;

  /// Positions to insert custom fields (by field name)
  final Map<WorkFormField, List<String>> insertPositions;

  /// Form key for validation
  final GlobalKey<FormState>? formKey;

  const WorkForm({
    super.key,
    this.title,
    this.initialTitle = '',
    this.initialAuthor,
    this.initialStyle,
    this.initialTool,
    this.initialCreationDate,
    this.initialRemark,
    this.isProcessing = false,
    this.error,
    this.onTitleChanged,
    this.onAuthorChanged,
    this.onStyleChanged,
    this.onToolChanged,
    this.onCreationDateChanged,
    this.onRemarkChanged,
    this.requiredFields = const {WorkFormField.title},
    this.visibleFields = const {
      WorkFormField.title,
      WorkFormField.author,
      WorkFormField.style,
      WorkFormField.tool,
      WorkFormField.creationDate,
      WorkFormField.remark,
    },
    this.showHelp = true,
    this.showKeyboardShortcuts = true,
    this.customFieldBuilders = const {},
    this.insertPositions = const {},
    this.formKey,
  });

  @override
  State<WorkForm> createState() => _WorkFormState();
}

/// Fields available in the work form
enum WorkFormField {
  title,
  author,
  style,
  tool,
  creationDate,
  remark,
}

/// Preset configurations for common WorkForm use cases
class WorkFormPresets {
  /// Import form configuration
  static Set<WorkFormField> importFields = {
    WorkFormField.title,
    WorkFormField.author,
    WorkFormField.style,
    WorkFormField.tool,
    WorkFormField.creationDate,
    WorkFormField.remark,
  };

  /// Edit form configuration
  static Set<WorkFormField> editFields = {
    WorkFormField.title,
    WorkFormField.author,
    WorkFormField.style,
    WorkFormField.tool,
    WorkFormField.creationDate,
    WorkFormField.remark,
  };

  /// Minimal form configuration
  static Set<WorkFormField> minimalFields = {
    WorkFormField.title,
    WorkFormField.author,
  };
}

class _ErrorAnimation extends StatefulWidget {
  final String errorText;
  final Color color;

  const _ErrorAnimation({
    required this.errorText,
    required this.color,
  });

  @override
  State<_ErrorAnimation> createState() => _ErrorAnimationState();
}

class _ErrorAnimationState extends State<_ErrorAnimation>
    with SingleTickerProviderStateMixin {
  late final AnimationController _controller;
  late final Animation<double> _animation;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    // Use a softer color for error text
    final errorColor = theme.colorScheme.tertiary.withOpacity(0.8);

    return FadeTransition(
      opacity: _animation,
      child: SlideTransition(
        position: Tween<Offset>(
          begin: const Offset(-0.1, 0),
          end: Offset.zero,
        ).animate(_animation),
        child: Padding(
          padding: const EdgeInsets.only(left: 12, top: 4),
          child: Row(
            children: [
              Icon(
                Icons.info_outline, // Use info icon instead of error icon
                size: 14,
                color: errorColor,
              ),
              const SizedBox(width: 8),
              Flexible(
                child: Text(
                  widget.errorText,
                  style: TextStyle(
                    color: errorColor,
                    fontSize: 12,
                  ),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  @override
  void initState() {
    super.initState();
    _controller = AnimationController(
      duration: const Duration(milliseconds: 300),
      vsync: this,
    );
    _animation = CurvedAnimation(
      parent: _controller,
      curve: Curves.easeOut,
    );
    _controller.forward();
  }
}

class _HelpText extends StatelessWidget {
  final String text;
  final IconData? icon;

  const _HelpText({
    required this.text,
    this.icon,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    return Padding(
      padding: const EdgeInsets.only(left: 12, top: 4),
      child: Row(
        children: [
          if (icon != null) ...[
            Icon(
              icon,
              size: 14,
              color: theme.hintColor,
            ),
            const SizedBox(width: 4),
          ],
          Text(
            text,
            style: theme.textTheme.bodySmall?.copyWith(
              color: theme.hintColor,
            ),
          ),
        ],
      ),
    );
  }
}

class _WorkFormState extends State<WorkForm> {
  final _titleFocus = FocusNode();
  final _authorFocus = FocusNode();
  final _remarkFocus = FocusNode();

  final _titleController = TextEditingController();
  final _authorController = TextEditingController();
  final _remarkController = TextEditingController();

  bool _hasInteracted = false;
  late GlobalKey<FormState> _formKey;

  // Check if form is in read-only mode based on callback presence
  bool get _isReadOnly {
    return widget.isProcessing ||
        (widget.onTitleChanged == null &&
            widget.onAuthorChanged == null &&
            widget.onStyleChanged == null &&
            widget.onToolChanged == null &&
            widget.onCreationDateChanged == null &&
            widget.onRemarkChanged == null);
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    // Use a more gentle color for form error message
    final errorColor = theme.colorScheme.tertiary;

    return Focus(
      onKey: (_, event) {
        _handleKeyPress(event);
        return KeyEventResult.ignored;
      },
      child: Form(
        key: _formKey,
        autovalidateMode: _hasInteracted
            ? AutovalidateMode.onUserInteraction
            : AutovalidateMode.disabled,
        child: SingleChildScrollView(
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.stretch,
            mainAxisSize: MainAxisSize.min,
            children: [
              if (widget.title != null) ...[
                SectionTitle(title: widget.title!),
                const SizedBox(height: AppSizes.spacingMedium),
              ],

              // Title field
              if (widget.visibleFields.contains(WorkFormField.title))
                _buildTitleField(),

              // Insert custom fields after title
              ..._buildCustomFields(WorkFormField.title),

              // Author field
              if (widget.visibleFields.contains(WorkFormField.author)) ...[
                const SizedBox(height: AppSizes.spacingMedium),
                _buildAuthorField(),
              ],

              // Insert custom fields after author
              ..._buildCustomFields(WorkFormField.author),

              // Style field
              if (widget.visibleFields.contains(WorkFormField.style)) ...[
                const SizedBox(height: AppSizes.spacingMedium),
                _buildStyleField(),
              ],

              // Insert custom fields after style
              ..._buildCustomFields(WorkFormField.style),

              // Tool field
              if (widget.visibleFields.contains(WorkFormField.tool)) ...[
                const SizedBox(height: AppSizes.spacingMedium),
                _buildToolField(),
              ],

              // Insert custom fields after tool
              ..._buildCustomFields(WorkFormField.tool),

              // Creation date field
              if (widget.visibleFields
                  .contains(WorkFormField.creationDate)) ...[
                const SizedBox(height: AppSizes.spacingMedium),
                _buildDateField(),
              ],

              // Insert custom fields after creation date
              ..._buildCustomFields(WorkFormField.creationDate),

              // Remark field
              if (widget.visibleFields.contains(WorkFormField.remark)) ...[
                const SizedBox(height: AppSizes.spacingMedium),
                _buildRemarkField(),
              ],

              // Insert custom fields after remark
              ..._buildCustomFields(WorkFormField.remark),

              // Form error message with gentler styling
              if (widget.error != null) ...[
                const SizedBox(height: AppSizes.spacingMedium),
                _ErrorAnimation(
                  errorText: widget.error!,
                  color: errorColor, // Use gentler color
                ),
              ],

              // Keyboard shortcuts section
              if (widget.showKeyboardShortcuts) ...[
                const SizedBox(height: AppSizes.spacingLarge),
                Text(
                  '閿洏蹇嵎閿?',
                  style: theme.textTheme.titleSmall,
                ),
                const SizedBox(height: AppSizes.spacingSmall),
                Text(
                  'Ctrl+T: 鏍囬  Ctrl+A: 浣滆€? Ctrl+R: 澶囨敞\n'
                  'Enter: 纭  Tab: 涓嬩竴椤? Shift+Tab: 涓婁竴椤?,
                  style: theme.textTheme.bodySmall,
                ),
              ],
            ],
          ),
        ),
      ),
    );
  }

  @override
  void didUpdateWidget(WorkForm oldWidget) {
    super.didUpdateWidget(oldWidget);
    _updateControllers();
  }

  @override
  void dispose() {
    _titleFocus.dispose();
    _authorFocus.dispose();
    _remarkFocus.dispose();

    _titleController.dispose();
    _authorController.dispose();
    _remarkController.dispose();
    super.dispose();
  }

  @override
  void initState() {
    super.initState();
    _formKey = widget.formKey ?? GlobalKey<FormState>();
    _updateControllers();
    _setupKeyboardListeners();
  }

  // Mark form as interacted to show validation errors
  void markAsInteracted() {
    setState(() => _hasInteracted = true);
  }

  Widget _buildAuthorField() {
    final theme = Theme.of(context);
    final readOnlyFillColor = theme.disabledColor.withOpacity(0.05);

    return _buildFieldWithTooltip(
      shortcut: 'Ctrl+A',
      tooltip: '鎸?Ctrl+A 蹇€熻烦杞埌浣滆€呰緭鍏ユ',
      helpText: widget.showHelp ? '鍙€夛紝浣滃搧鐨勫垱浣滆€? : null,
      helpIcon: Icons.person_outline,
      child: TextFormField(
        focusNode: _authorFocus,
        controller: _authorController,
        decoration: InputDecoration(
          labelText: '浣滆€?,
          hintText: _isReadOnly ? null : '璇疯緭鍏ヤ綔鑰呭悕',
          suffixText: _authorFocus.hasFocus && !_isReadOnly ? 'Ctrl+A' : null,
          errorStyle: const TextStyle(height: 0),
          counterText: '${_authorController.text.length}/50',
          filled: _isReadOnly,
          fillColor: _isReadOnly ? readOnlyFillColor : null,
          border: const OutlineInputBorder(),
        ),
        onChanged: widget.onAuthorChanged,
        validator: _validateAuthor,
        textInputAction: TextInputAction.next,
        onEditingComplete: () => FocusScope.of(context).nextFocus(),
        enabled: true,
        readOnly: _isReadOnly,
        maxLength: 50,
        // Update readOnly style to match normal input style
        style: theme.textTheme.bodyLarge?.copyWith(
          color: _isReadOnly
              ? theme.textTheme.bodyLarge?.color
              : theme.textTheme.bodyLarge?.color,
        ),
      ),
    );
  }

  List<Widget> _buildCustomFields(WorkFormField position) {
    final customFieldNames = widget.insertPositions[position] ?? [];
    return customFieldNames.map((name) {
      final builder = widget.customFieldBuilders[name];
      if (builder == null) return const SizedBox.shrink();

      return Column(
        children: [
          const SizedBox(height: AppSizes.spacingMedium),
          builder(context),
        ],
      );
    }).toList();
  }

  Widget _buildDateField() {
    return _buildFieldWithTooltip(
      shortcut: 'Tab',
      tooltip: '鎸?Tab 閿鑸埌涓嬩竴涓瓧娈?,
      helpText: widget.showHelp ? '浣滃搧鐨勫畬鎴愭棩鏈? : null,
      helpIcon: Icons.calendar_today_outlined,
      child: DateInputField(
        label: '鍒涗綔鏃ユ湡',
        value: widget.initialCreationDate,
        onChanged: _handleDateChange,
        textInputAction: TextInputAction.next,
        onEditingComplete:
            _isReadOnly ? null : () => _remarkFocus.requestFocus(),
        enabled: true,
        readOnly: _isReadOnly,
      ),
    );
  }

  Widget _buildFieldWithTooltip({
    required Widget child,
    required String shortcut,
    required String tooltip,
    String? helpText,
    IconData? helpIcon,
  }) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Tooltip(
          message: tooltip,
          waitDuration: const Duration(milliseconds: 500),
          child: child,
        ),
        if (helpText != null)
          _HelpText(
            text: helpText,
            icon: helpIcon,
          ),
      ],
    );
  }

  Widget _buildRemarkField() {
    final theme = Theme.of(context);
    final readOnlyFillColor = theme.disabledColor.withOpacity(0.05);

    return _buildFieldWithTooltip(
      shortcut: 'Ctrl+R',
      tooltip: '鎸?Ctrl+R 蹇€熻烦杞埌澶囨敞杈撳叆妗?,
      helpText: widget.showHelp ? '鍙€夛紝鍏充簬浣滃搧鐨勫叾浠栬鏄? : null,
      helpIcon: Icons.notes_outlined,
      child: TextFormField(
        focusNode: _remarkFocus,
        controller: _remarkController,
        decoration: InputDecoration(
          labelText: '澶囨敞',
          hintText: _isReadOnly ? null : '鍙€?,
          suffixText: _remarkFocus.hasFocus && !_isReadOnly ? 'Ctrl+R' : null,
          errorStyle: const TextStyle(height: 0),
          counterText: '${_remarkController.text.length}/500',
          filled: _isReadOnly,
          fillColor: _isReadOnly ? readOnlyFillColor : null,
          border: const OutlineInputBorder(),
        ),
        maxLines: 3,
        onChanged: widget.onRemarkChanged,
        validator: _validateRemark,
        textInputAction: TextInputAction.done,
        enabled: true,
        readOnly: _isReadOnly,
        maxLength: 500,
        // Update readOnly style to match normal input style
        style: theme.textTheme.bodyLarge?.copyWith(
          color: _isReadOnly
              ? theme.textTheme.bodyLarge?.color
              : theme.textTheme.bodyLarge?.color,
        ),
      ),
    );
  }

  Widget _buildStyleField() {
    final theme = Theme.of(context);

    return _buildFieldWithTooltip(
      shortcut: 'Tab',
      tooltip: '鎸?Tab 閿鑸埌涓嬩竴涓瓧娈?,
      helpText: widget.showHelp ? '浣滃搧鐨勪富瑕佺敾椋庣被鍨? : null,
      helpIcon: Icons.palette_outlined,
      child: DropdownField<String>(
        label: '鐢婚',
        value: widget.initialStyle?.value,
        items: WorkStyle.values
            .map((e) => DropdownMenuItem(
                  value: e.value,
                  child: Text(e.label),
                ))
            .toList(),
        onChanged: _handleStyleChange,
        enabled: true,
        readOnly: _isReadOnly,
        // Ensure dropdown text uses the same style as other fields
        textStyle: theme.textTheme.bodyLarge,
      ),
    );
  }

  Widget _buildTitleField() {
    final theme = Theme.of(context);
    final readOnlyFillColor = theme.disabledColor.withOpacity(0.05);

    return _buildFieldWithTooltip(
      shortcut: 'Ctrl+T',
      tooltip: '鎸?Ctrl+T 蹇€熻烦杞埌鏍囬杈撳叆妗?,
      helpText: widget.showHelp ? '浣滃搧鐨勪富瑕佹爣棰橈紝灏嗘樉绀哄湪浣滃搧鍒楄〃涓? : null,
      helpIcon: Icons.info_outline,
      child: TextFormField(
        focusNode: _titleFocus,
        controller: _titleController,
        decoration: InputDecoration(
          labelText: widget.requiredFields.contains(WorkFormField.title)
              ? '鏍囬 *'
              : '鏍囬',
          hintText: _isReadOnly ? null : '璇疯緭鍏ユ爣棰?,
          suffixText: _titleFocus.hasFocus && !_isReadOnly ? 'Ctrl+T' : null,
          errorStyle: const TextStyle(height: 0),
          counterText: '${_titleController.text.length}/100',
          filled: _isReadOnly,
          fillColor: _isReadOnly ? readOnlyFillColor : null,
          border: const OutlineInputBorder(),
        ),
        onChanged: widget.onTitleChanged,
        validator: _validateTitle,
        textInputAction: TextInputAction.next,
        onEditingComplete: () => _authorFocus.requestFocus(),
        enabled: true,
        readOnly: _isReadOnly,
        maxLength: 100,
        // Update readOnly style to match normal input style
        style: theme.textTheme.bodyLarge?.copyWith(
          color: _isReadOnly
              ? theme.textTheme.bodyLarge?.color
              : theme.textTheme.bodyLarge?.color,
        ),
      ),
    );
  }

  Widget _buildToolField() {
    final theme = Theme.of(context);

    return _buildFieldWithTooltip(
      shortcut: 'Tab',
      tooltip: '鎸?Tab 閿鑸埌涓嬩竴涓瓧娈?,
      helpText: widget.showHelp ? '鍒涗綔鏈綔鍝佷娇鐢ㄧ殑涓昏宸ュ叿' : null,
      helpIcon: Icons.brush_outlined,
      child: DropdownField<String>(
        label: '鍒涗綔宸ュ叿',
        value: widget.initialTool?.value,
        items: WorkTool.values
            .map((e) => DropdownMenuItem(
                  value: e.value,
                  child: Text(e.label),
                ))
            .toList(),
        onChanged: _handleToolChange,
        enabled: true,
        readOnly: _isReadOnly,
        // Ensure dropdown text uses the same style as other fields
        textStyle: theme.textTheme.bodyLarge,
      ),
    );
  }

  void _handleDateChange(DateTime? date) {
    if (date != null) {
      if (date.isAfter(DateTime.now())) {
        // 鏃ユ湡涓嶈兘瓒呰繃褰撳墠鏃ユ湡
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('鍒涗綔鏃ユ湡涓嶈兘瓒呰繃褰撳墠鏃ユ湡'),
            behavior: SnackBarBehavior.floating,
          ),
        );
        return;
      }
      widget.onCreationDateChanged?.call(date);
    }
  }

  void _handleFocusChange() {
    setState(() {});
  }

  void _handleKeyPress(RawKeyEvent event) {
    if (event is! RawKeyDownEvent) return;
    if (!event.isControlPressed) return;

    switch (event.logicalKey) {
      case LogicalKeyboardKey.keyT:
        _titleFocus.requestFocus();
        break;
      case LogicalKeyboardKey.keyA:
        _authorFocus.requestFocus();
        break;
      case LogicalKeyboardKey.keyR:
        _remarkFocus.requestFocus();
        break;
      default:
        break;
    }
  }

  void _handleStyleChange(String? value) {
    if (value != null && !widget.isProcessing) {
      final style = WorkStyle.values.firstWhere(
        (s) => s.value == value,
        orElse: () => WorkStyle.other,
      );
      widget.onStyleChanged?.call(style);
      FocusScope.of(context).nextFocus();
    }
  }

  void _handleToolChange(String? value) {
    if (value != null && !widget.isProcessing) {
      final tool = WorkTool.values.firstWhere(
        (t) => t.value == value,
        orElse: () => WorkTool.other,
      );
      widget.onToolChanged?.call(tool);
      FocusScope.of(context).nextFocus();
    }
  }

  void _setupKeyboardListeners() {
    _titleFocus.addListener(_handleFocusChange);
    _authorFocus.addListener(_handleFocusChange);
    _remarkFocus.addListener(_handleFocusChange);
  }

  void _updateControllers() {
    final newText = widget.initialTitle;
    if (_titleController.text != newText) {
      _titleController.value = TextEditingValue(
        text: newText,
        selection: TextSelection.collapsed(offset: newText.length),
      );
    }

    final newAuthor = widget.initialAuthor ?? '';
    if (_authorController.text != newAuthor) {
      _authorController.value = TextEditingValue(
        text: newAuthor,
        selection: TextSelection.collapsed(offset: newAuthor.length),
      );
    }

    final newRemark = widget.initialRemark ?? '';
    if (_remarkController.text != newRemark) {
      _remarkController.value = TextEditingValue(
        text: newRemark,
        selection: TextSelection.collapsed(offset: newRemark.length),
      );
    }
  }

  String? _validateAuthor(String? value) {
    if (!_hasInteracted) return null;
    if (value != null && value.trim().length > 50) {
      return '浣滆€呭悕涓嶈兘瓒呰繃50涓瓧绗?;
    }
    return null;
  }

  String? _validateRemark(String? value) {
    if (!_hasInteracted) return null;
    if (value != null && value.trim().length > 500) {
      return '澶囨敞涓嶈兘瓒呰繃500涓瓧绗?;
    }
    return null;
  }

  String? _validateTitle(String? value) {
    if (!_hasInteracted) return null;

    if (widget.requiredFields.contains(WorkFormField.title)) {
      if (value == null || value.trim().isEmpty) {
        return '璇疯緭鍏ヤ綔鍝佹爣棰?;
      }
      if (value.trim().length < 2) {
        return '鏍囬鑷冲皯闇€瑕?涓瓧绗?;
      }
    }

    if (value != null && value.trim().length > 100) {
      return '鏍囬涓嶈兘瓒呰繃100涓瓧绗?;
    }

    return null;
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\image\cached_image.dart
-----------------------------------
import 'dart:io';

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../infrastructure/providers/storage_providers.dart';
import '../skeleton_loader.dart';

class CachedImage extends ConsumerWidget {
  final String path;
  final double? width;
  final double? height;
  final BoxFit? fit;
  final BorderRadius? borderRadius;
  final String? cacheKey;

  const CachedImage({
    super.key,
    required this.path,
    this.width,
    this.height,
    this.fit,
    this.borderRadius,
    this.cacheKey,
  });

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final storage = ref.watch(initializedStorageProvider);

    return FutureBuilder<bool>(
      // Add cache key to trigger rebuild when needed
      key: ValueKey('cached_image_${path}_${cacheKey ?? ''}'),
      future: _checkFile(storage),
      builder: (context, snapshot) {
        if (!snapshot.hasData || !snapshot.data!) {
          return SkeletonLoader(
            width: width ?? 200,
            height: height ?? 200,
            borderRadius: borderRadius,
          );
        }

        return _buildImage();
      },
    );
  }

  Widget _buildImage() {
    return ClipRRect(
      borderRadius: borderRadius ?? BorderRadius.zero,
      child: Image.file(
        File(path),
        width: width,
        height: height,
        fit: fit,
        cacheWidth: width?.toInt(),
        cacheHeight: height?.toInt(),
        errorBuilder: (context, error, stackTrace) {
          return SkeletonLoader(
            width: width ?? 200,
            height: height ?? 200,
            borderRadius: borderRadius,
          );
        },
      ),
    );
  }

  Future<bool> _checkFile(storage) async {
    return await storage.fileExists(path);
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\indicators\button_progress_indicator.dart
-----------------------------------
import 'package:flutter/material.dart';

class ButtonProgressIndicator extends StatelessWidget {
  final double size;
  final double strokeWidth;
  final Color? color;

  const ButtonProgressIndicator({
    super.key,
    this.size = 20,
    this.strokeWidth = 2,
    this.color,
  });

  @override
  Widget build(BuildContext context) {
    return SizedBox(
      width: size,
      height: size,
      child: CircularProgressIndicator(
        strokeWidth: strokeWidth,
        valueColor: AlwaysStoppedAnimation<Color>(
          color ?? Theme.of(context).colorScheme.onPrimary,
        ),
      ),
    );
  }
}


C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\inputs\date_input_field.dart
-----------------------------------
import 'package:flutter/material.dart';
import 'package:intl/intl.dart';

/// A custom date input field with consistent styling
class DateInputField extends StatelessWidget {
  final String label;
  final DateTime? value;
  final ValueChanged<DateTime?>? onChanged;
  final TextInputAction? textInputAction;
  final VoidCallback? onEditingComplete;
  final bool enabled;
  final bool readOnly;
  final TextStyle? textStyle; // Add this parameter for consistent styling

  const DateInputField({
    super.key,
    required this.label,
    this.value,
    this.onChanged,
    this.textInputAction,
    this.onEditingComplete,
    this.enabled = true,
    this.readOnly = false,
    this.textStyle, // Add this parameter to the constructor
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final effectiveTextStyle = textStyle ?? theme.textTheme.bodyLarge;
    final readOnlyFillColor = theme.disabledColor.withOpacity(0.05);
    final dateFormat = DateFormat('yyyy-MM-dd');
    final displayText = value != null ? dateFormat.format(value!) : '';

    // Build read-only display with consistent styling
    if (readOnly) {
      return InputDecorator(
        decoration: InputDecoration(
          labelText: label,
          filled: true,
          fillColor: readOnlyFillColor,
          border: const OutlineInputBorder(),
        ),
        child: Text(
          displayText,
          style: effectiveTextStyle, // Use the provided text style
        ),
      );
    }

    // Build editable field
    return TextFormField(
      decoration: InputDecoration(
        labelText: label,
        hintText: enabled ? '閫夋嫨鏃ユ湡' : null,
        border: const OutlineInputBorder(),
        suffixIcon: enabled
            ? IconButton(
                icon: const Icon(Icons.calendar_today),
                onPressed: () => _selectDate(context),
              )
            : null,
      ),
      readOnly: true, // Always read-only for the text field itself
      controller: TextEditingController(text: displayText),
      style: effectiveTextStyle, // Use the provided text style
      onTap: enabled ? () => _selectDate(context) : null,
      textInputAction: textInputAction,
      onEditingComplete: onEditingComplete,
    );
  }

  Future<void> _selectDate(BuildContext context) async {
    final DateTime? picked = await showDatePicker(
      context: context,
      initialDate: value ?? DateTime.now(),
      firstDate: DateTime(1900),
      lastDate: DateTime.now(),
      builder: (context, child) {
        return Theme(
          data: Theme.of(context),
          child: child!,
        );
      },
    );

    if (picked != null && onChanged != null) {
      onChanged!(picked);
    }
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\inputs\dropdown_field.dart
-----------------------------------
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';

class DropdownField<T> extends StatefulWidget {
  final String label;
  final T? value;
  final List<DropdownMenuItem<T>> items;
  final ValueChanged<T?>? onChanged;
  final bool isRequired;
  final String? Function(T?)? validator;
  final String? hintText;
  final TextInputAction? textInputAction;
  final VoidCallback? onEditingComplete;
  final bool enabled;
  final bool readOnly;
  final TextStyle? textStyle; // Add this parameter to accept text style

  const DropdownField({
    super.key,
    required this.label,
    required this.value,
    required this.items,
    required this.onChanged,
    this.isRequired = false,
    this.validator,
    this.hintText,
    this.textInputAction,
    this.onEditingComplete,
    this.enabled = true,
    this.readOnly = false,
    this.textStyle, // Add this parameter to the constructor
  });

  @override
  State<DropdownField<T>> createState() => _DropdownFieldState<T>();
}

class _DropdownFieldState<T> extends State<DropdownField<T>> {
  final _focusNode = FocusNode();
  bool _hasFocus = false;
  bool _isDropdownOpen = false;
  final LayerLink _layerLink = LayerLink();
  OverlayEntry? _overlayEntry;
  int _selectedIndex = -1;
  final _textController = TextEditingController();

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final displayText = _getSelectedItemText();
    final effectiveTextStyle = widget.textStyle ?? theme.textTheme.bodyLarge;

    // 鏇存柊鎺у埗鍣ㄦ枃鏈?
    if (_textController.text != displayText) {
      _textController.text = displayText;
    }

    final readOnlyFillColor = theme.disabledColor.withOpacity(0.05);

    // 鍙妯″紡
    if (widget.readOnly) {
      return TextFormField(
        controller: _textController,
        decoration: InputDecoration(
          labelText: widget.label,
          border: const OutlineInputBorder(),
          suffixIcon: Icon(
            Icons.arrow_drop_down,
            color: theme.disabledColor,
          ),
          contentPadding: const EdgeInsets.symmetric(
            horizontal: 12,
            vertical: 16,
          ),
          filled: true,
          fillColor: readOnlyFillColor,
          // 涓嶆樉绀烘彁绀烘枃鏈?
          hintText: null,
        ),
        enabled: true,
        readOnly: true,
        style: effectiveTextStyle, // Use the provided text style
      );
    }

    final isEnabled =
        widget.enabled && !widget.readOnly && widget.onChanged != null;
    _updateTextController();

    if (widget.readOnly) {
      // 鍙妯″紡涓嬩娇鐢?TextFormField
      return TextFormField(
        controller: _textController,
        decoration: InputDecoration(
          labelText: widget.label,
          suffixIcon: Icon(
            Icons.arrow_drop_down,
            color: theme.disabledColor,
          ),
        ),
        enabled: true,
        readOnly: true,
      );
    }

    return FormField<T>(
      initialValue: widget.value,
      validator:
          widget.validator ?? (widget.isRequired ? _requiredValidator : null),
      builder: (FormFieldState<T> field) {
        return CompositedTransformTarget(
          link: _layerLink,
          child: InputDecorator(
            decoration: InputDecoration(
              labelText: widget.label,
              errorText: field.errorText,
              focusedBorder: OutlineInputBorder(
                borderSide: BorderSide(
                  color: theme.colorScheme.primary,
                  width: 2,
                ),
              ),
              enabledBorder: OutlineInputBorder(
                borderSide: BorderSide(
                  color: theme.colorScheme.outline,
                ),
              ),
              disabledBorder: OutlineInputBorder(
                borderSide: BorderSide(
                  color: theme.colorScheme.outline.withOpacity(0.5),
                ),
              ),
              suffixIcon: Icon(
                Icons.arrow_drop_down,
                color:
                    _hasFocus && isEnabled ? theme.colorScheme.primary : null,
              ),
              filled: _hasFocus && isEnabled,
              fillColor: _hasFocus && isEnabled
                  ? theme.colorScheme.primaryContainer.withOpacity(0.1)
                  : null,
              enabled: isEnabled,
            ),
            isEmpty: widget.value == null,
            isFocused: _hasFocus,
            child: Focus(
              focusNode: _focusNode,
              onKeyEvent: isEnabled ? _handleKeyEvent : null,
              child: GestureDetector(
                onTap: isEnabled ? _showDropdown : null,
                behavior: HitTestBehavior.opaque,
                child: Container(
                  padding: const EdgeInsets.symmetric(vertical: 8.0),
                  child: _buildText(theme, isEnabled),
                ),
              ),
            ),
          ),
        );
      },
    );
  }

  @override
  void didUpdateWidget(DropdownField<T> oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (oldWidget.value != widget.value) {
      _updateSelectedIndex();
      _updateTextController();
    }
  }

  @override
  void dispose() {
    _focusNode.removeListener(_handleFocusChange);
    if (_overlayEntry != null) {
      _overlayEntry?.remove();
      _overlayEntry = null;
      _isDropdownOpen = false;
    }
    _focusNode.dispose();
    _textController.dispose();
    super.dispose();
  }

  @override
  void initState() {
    super.initState();
    _focusNode.addListener(_handleFocusChange);
    _updateSelectedIndex();
    _updateTextController();
  }

  Widget _buildText(ThemeData theme, bool isEnabled) {
    if (widget.value != null) {
      final selectedItem = widget.items.firstWhere(
        (item) => item.value == widget.value,
        orElse: () => widget.items.first,
      );
      return DefaultTextStyle(
        style: widget.textStyle ??
            theme.textTheme.bodyMedium!.copyWith(
              color: isEnabled ? null : theme.disabledColor,
            ),
        child: selectedItem.child,
      );
    }
    return Text(
      widget.hintText ?? '',
      style: widget.textStyle ??
          theme.textTheme.bodyMedium?.copyWith(
            color: theme.hintColor,
          ),
    );
  }

  // 鑾峰彇褰撳墠閫変腑椤圭殑鏄剧ず鏂囨湰
  String _getSelectedItemText() {
    if (widget.value == null) return '';

    // 鎵惧埌閫変腑鐨勯」
    final selectedItem = widget.items.firstWhere(
      (item) => item.value == widget.value,
      orElse: () => widget.items.isNotEmpty
          ? widget.items.first
          : DropdownMenuItem<T>(value: null, child: Container()),
    );

    // 濡傛灉瀛愮粍浠舵槸鏂囨湰锛岀洿鎺ヨ幏鍙栨枃鏈唴瀹?
    if (selectedItem.child is Text) {
      return (selectedItem.child as Text).data ?? '';
    }

    // 鍚﹀垯杩斿洖绌哄瓧绗︿覆
    return '';
  }

  void _handleFocusChange() {
    if (mounted) {
      setState(() {
        _hasFocus = _focusNode.hasFocus;
        if (!_hasFocus) {
          _hideDropdown();
        }
      });
    }
  }

  KeyEventResult _handleKeyEvent(FocusNode node, KeyEvent event) {
    if (event is! KeyDownEvent) return KeyEventResult.ignored;

    if (event.logicalKey == LogicalKeyboardKey.arrowDown) {
      if (!_isDropdownOpen) {
        _showDropdown();
      } else {
        _selectNextItem();
      }
      return KeyEventResult.handled;
    }

    if (event.logicalKey == LogicalKeyboardKey.arrowUp && _isDropdownOpen) {
      _selectPreviousItem();
      return KeyEventResult.handled;
    }

    if (event.logicalKey == LogicalKeyboardKey.enter ||
        event.logicalKey == LogicalKeyboardKey.space) {
      if (_isDropdownOpen && _selectedIndex >= 0) {
        _selectCurrentItem();
      } else {
        _showDropdown();
      }
      return KeyEventResult.handled;
    }

    if (event.logicalKey == LogicalKeyboardKey.escape && _isDropdownOpen) {
      _hideDropdown();
      return KeyEventResult.handled;
    }

    return KeyEventResult.ignored;
  }

  void _hideDropdown() {
    if (_overlayEntry != null) {
      _overlayEntry?.remove();
      _overlayEntry = null;
      if (mounted) {
        setState(() => _isDropdownOpen = false);
      }
    }
  }

  String? _requiredValidator(T? value) {
    if (widget.isRequired && value == null) {
      return '璇烽€夋嫨${widget.label}';
    }
    return null;
  }

  void _selectCurrentItem() {
    if (_selectedIndex >= 0 && _selectedIndex < widget.items.length) {
      final selectedItem = widget.items[_selectedIndex];
      widget.onChanged!(selectedItem.value);
      _hideDropdown();
      if (widget.onEditingComplete != null) {
        widget.onEditingComplete!();
      }
    }
  }

  void _selectNextItem() {
    if (_selectedIndex < widget.items.length - 1) {
      setState(() {
        _selectedIndex++;
        _updateOverlay();
      });
    }
  }

  void _selectPreviousItem() {
    if (_selectedIndex > 0) {
      setState(() {
        _selectedIndex--;
        _updateOverlay();
      });
    }
  }

  void _showDropdown() {
    if (!widget.enabled || widget.onChanged == null) return;

    if (_isDropdownOpen) {
      _hideDropdown();
      return;
    }

    final overlay = Overlay.of(context);
    final renderBox = context.findRenderObject() as RenderBox;
    final size = renderBox.size;

    _overlayEntry = OverlayEntry(
      builder: (context) {
        return Positioned(
          width: size.width,
          child: CompositedTransformFollower(
            link: _layerLink,
            showWhenUnlinked: false,
            offset: Offset(0.0, size.height + 5.0),
            child: Material(
              elevation: 4.0,
              child: Container(
                padding: const EdgeInsets.symmetric(vertical: 8.0),
                decoration: BoxDecoration(
                  color: Theme.of(context).colorScheme.surface,
                  border:
                      Border.all(color: Theme.of(context).colorScheme.outline),
                  borderRadius: BorderRadius.circular(4.0),
                ),
                child: Column(
                  mainAxisSize: MainAxisSize.min,
                  children: widget.items.asMap().entries.map((entry) {
                    final index = entry.key;
                    final item = entry.value;
                    final isSelected = index == _selectedIndex;

                    return InkWell(
                      onTap: () {
                        widget.onChanged!(item.value);
                        _hideDropdown();
                        if (widget.onEditingComplete != null) {
                          widget.onEditingComplete!();
                        }
                      },
                      child: Container(
                        padding: const EdgeInsets.symmetric(
                          horizontal: 16.0,
                          vertical: 12.0,
                        ),
                        color: isSelected
                            ? Theme.of(context).colorScheme.primaryContainer
                            : null,
                        child: DefaultTextStyle(
                          style: widget.textStyle ??
                              Theme.of(context).textTheme.bodyMedium!.copyWith(
                                    color: isSelected
                                        ? Theme.of(context)
                                            .colorScheme
                                            .onPrimaryContainer
                                        : null,
                                  ),
                          child: item.child,
                        ),
                      ),
                    );
                  }).toList(),
                ),
              ),
            ),
          ),
        );
      },
    );

    setState(() => _isDropdownOpen = true);
    overlay.insert(_overlayEntry!);
  }

  void _updateOverlay() {
    if (_overlayEntry != null) {
      _overlayEntry!.markNeedsBuild();
    }
  }

  void _updateSelectedIndex() {
    if (widget.value != null) {
      _selectedIndex =
          widget.items.indexWhere((item) => item.value == widget.value);
    }
  }

  // 鏇存柊鎺у埗鍣ㄤ腑鐨勬枃瀛椾负褰撳墠閫変腑椤圭殑鏄剧ず鍊?
  void _updateTextController() {
    final selectedText = _getSelectedItemText();
    if (_textController.text != selectedText) {
      _textController.text = selectedText;
    }
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\layouts\sidebar_page.dart
-----------------------------------



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\layouts\work_layout.dart
-----------------------------------



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\list\grouped_list_view.dart
-----------------------------------
import 'package:flutter/material.dart';

import '../../../theme/app_sizes.dart';

class GroupedListView<T> extends StatelessWidget {
  final List<ListGroup<T>> groups;
  final Widget Function(BuildContext, T) itemBuilder;
  final Widget Function(BuildContext, ListGroup<T>)? headerBuilder;
  final EdgeInsetsGeometry? padding;
  final ScrollController? controller;
  final bool showDividers;

  const GroupedListView({
    super.key,
    required this.groups,
    required this.itemBuilder,
    this.headerBuilder,
    this.padding,
    this.controller,
    this.showDividers = true,
  });

  @override
  Widget build(BuildContext context) {
    return ListView.builder(
      controller: controller,
      padding: padding,
      itemCount: _calculateItemCount(),
      itemBuilder: (context, index) {
        final groupInfo = _getItemForIndex(index);
        if (groupInfo.isHeader) {
          return headerBuilder?.call(context, groupInfo.group!) ??
              _defaultHeaderBuilder(context, groupInfo.group!);
        }
        return itemBuilder(context, groupInfo.item as T);
      },
    );
  }

  int _calculateItemCount() {
    return groups.fold(0, (sum, group) => sum + group.items.length + 1);
  }

  Widget _defaultHeaderBuilder(BuildContext context, ListGroup<T> group) {
    return Container(
      padding: const EdgeInsets.all(AppSizes.spacingMedium),
      color: Theme.of(context).colorScheme.surfaceContainerHighest,
      child: Text(
        group.header,
        style: Theme.of(context).textTheme.titleSmall,
      ),
    );
  }

  _GroupedItemInfo<T> _getItemForIndex(int index) {
    int currentIndex = 0;
    for (var group in groups) {
      if (index == currentIndex) {
        return _GroupedItemInfo(isHeader: true, group: group);
      }
      if (index <= currentIndex + group.items.length) {
        return _GroupedItemInfo(
          isHeader: false,
          item: group.items[index - currentIndex - 1],
        );
      }
      currentIndex += group.items.length + 1;
    }
    throw RangeError('Index out of range');
  }
}

class ListGroup<T> {
  final String header;
  final List<T> items;

  const ListGroup({
    required this.header,
    required this.items,
  });
}

class _GroupedItemInfo<T> {
  final bool isHeader;
  final ListGroup<T>? group;
  final T? item;

  _GroupedItemInfo({
    required this.isHeader,
    this.group,
    this.item,
  });
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\list\selectable_list_item.dart
-----------------------------------
import 'package:flutter/material.dart';

import '../../../theme/app_sizes.dart';

class SelectableListItem extends StatelessWidget {
  final Widget? leading;
  final Widget title;
  final Widget? subtitle;
  final List<Widget>? actions;
  final VoidCallback? onTap;
  final bool selected;
  final ValueChanged<bool>? onSelected;
  final bool showDivider;

  const SelectableListItem({
    super.key,
    this.leading,
    required this.title,
    this.subtitle,
    this.actions,
    this.onTap,
    this.selected = false,
    this.onSelected,
    this.showDivider = true,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Column(
      mainAxisSize: MainAxisSize.min,
      children: [
        InkWell(
          onTap: onSelected != null ? () => onSelected!(!selected) : onTap,
          child: Container(
            padding: const EdgeInsets.all(AppSizes.spacingMedium),
            color: selected ? theme.colorScheme.primary.withOpacity(0.1) : null,
            child: Row(
              children: [
                if (onSelected != null)
                  Padding(
                    padding: const EdgeInsets.only(
                      right: AppSizes.spacingMedium,
                    ),
                    child: Checkbox(
                      value: selected,
                      onChanged: (value) => onSelected?.call(value ?? false),
                    ),
                  ),
                if (leading != null) ...[
                  leading!,
                  const SizedBox(width: AppSizes.spacingMedium),
                ],
                Expanded(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      DefaultTextStyle(
                        style: theme.textTheme.titleMedium!,
                        child: title,
                      ),
                      if (subtitle != null) ...[
                        const SizedBox(height: AppSizes.spacingTiny),
                        DefaultTextStyle(
                          style: theme.textTheme.bodyMedium!,
                          child: subtitle!,
                        ),
                      ],
                    ],
                  ),
                ),
                if (actions != null) ...[
                  const SizedBox(width: AppSizes.spacingMedium),
                  ...actions!,
                ],
              ],
            ),
          ),
        ),
        if (showDivider) const Divider(height: 1),
      ],
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\loading\loading_overlay.dart
-----------------------------------
import 'package:flutter/material.dart';

class LoadingOverlay extends StatelessWidget {
  final Widget child;
  final bool isLoading;
  final String? message;
  final Color? backgroundColor;

  const LoadingOverlay({
    super.key,
    required this.child,
    required this.isLoading,
    this.message,
    this.backgroundColor,
  });

  @override
  Widget build(BuildContext context) {
    return Stack(
      children: [
        child,
        if (isLoading)
          Container(
            color: backgroundColor ?? Colors.black26,
            child: Center(
              child: Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  const CircularProgressIndicator(),
                  if (message != null) ...[
                    const SizedBox(height: 16),
                    Text(
                      message!,
                      style: const TextStyle(color: Colors.white),
                    ),
                  ],
                ],
              ),
            ),
          ),
      ],
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\navigation\side_nav.dart
-----------------------------------
import 'package:flutter/material.dart';

import '../../../theme/app_sizes.dart';

class SideNavigation extends StatelessWidget {
  final int selectedIndex;
  final ValueChanged<int> onDestinationSelected;

  const SideNavigation({
    super.key,
    required this.selectedIndex,
    required this.onDestinationSelected,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return NavigationRail(
      selectedIndex: selectedIndex,
      onDestinationSelected: onDestinationSelected,
      backgroundColor: theme.scaffoldBackgroundColor,
      minWidth: AppSizes.navigationRailWidth,
      selectedIconTheme: IconThemeData(
        size: AppSizes.iconMedium,
        color: theme.primaryColor,
      ),
      unselectedIconTheme: IconThemeData(
        size: AppSizes.iconMedium,
        color: theme.unselectedWidgetColor,
      ),
      labelType: NavigationRailLabelType.all,
      destinations: const [
        NavigationRailDestination(
          icon: Icon(Icons.image),
          label: Text('浣滃搧'),
        ),
        NavigationRailDestination(
          icon: Icon(Icons.font_download),
          label: Text('闆嗗瓧'),
        ),
        NavigationRailDestination(
          icon: Icon(Icons.article),
          label: Text('瀛楀笘'),
        ),
        NavigationRailDestination(
          icon: Icon(Icons.settings),
          label: Text('璁剧疆'),
        ),
      ],
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\practice\practice_layer_panel.dart
-----------------------------------
import 'package:flutter/material.dart';

class PracticeLayerPanel extends StatefulWidget {
  final List<Map<String, dynamic>> layers;
  final Function(int) onLayerSelected;
  final Function(int, bool) onLayerVisibilityChanged;
  final Function(int, bool) onLayerLockChanged;
  final Function(int) onLayerDeleted;
  final Function(int, int) onLayerReordered;

  const PracticeLayerPanel({
    super.key,
    required this.layers,
    required this.onLayerSelected,
    required this.onLayerVisibilityChanged,
    required this.onLayerLockChanged,
    required this.onLayerDeleted,
    required this.onLayerReordered,
  });

  @override
  State<PracticeLayerPanel> createState() => _PracticeLayerPanelState();
}

class _PracticeLayerPanelState extends State<PracticeLayerPanel> {
  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        Container(
          height: 48,
          padding: const EdgeInsets.symmetric(horizontal: 16),
          child: Row(
            children: [
              const Text('鍥惧眰'),
              const Spacer(),
              IconButton(
                icon: const Icon(Icons.add),
                onPressed: () {
                  // TODO: 娣诲姞鏂板浘灞?
                },
                tooltip: '娣诲姞鍥惧眰',
              ),
            ],
          ),
        ),
        Expanded(
          child: ReorderableListView(
            padding: const EdgeInsets.symmetric(vertical: 8),
            onReorder: widget.onLayerReordered,
            children: [
              for (var i = 0; i < widget.layers.length; i++)
                ListTile(
                  key: ValueKey(widget.layers[i]['id']),
                  leading: Row(
                    mainAxisSize: MainAxisSize.min,
                    children: [
                      IconButton(
                        icon: Icon(
                          widget.layers[i]['visible'] as bool
                              ? Icons.visibility
                              : Icons.visibility_off,
                        ),
                        onPressed: () => widget.onLayerVisibilityChanged(
                          i,
                          !(widget.layers[i]['visible'] as bool),
                        ),
                      ),
                      IconButton(
                        icon: Icon(
                          widget.layers[i]['locked'] as bool
                              ? Icons.lock
                              : Icons.lock_open,
                        ),
                        onPressed: () => widget.onLayerLockChanged(
                          i,
                          !(widget.layers[i]['locked'] as bool),
                        ),
                      ),
                    ],
                  ),
                  title: Text(widget.layers[i]['name'] as String),
                  trailing: IconButton(
                    icon: const Icon(Icons.delete),
                    onPressed: () => widget.onLayerDeleted(i),
                  ),
                  selected: widget.layers[i]['selected'] as bool,
                  onTap: () => widget.onLayerSelected(i),
                ),
            ],
          ),
        ),
      ],
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\practice\practice_property_panel.dart
-----------------------------------
import 'package:flutter/material.dart';

class PracticePropertyPanel extends StatelessWidget {
  final Map<String, dynamic>? selectedElement;
  final Function(Map<String, dynamic>) onPropertyChanged;

  const PracticePropertyPanel({
    super.key,
    this.selectedElement,
    required this.onPropertyChanged,
  });

  @override
  Widget build(BuildContext context) {
    if (selectedElement == null) {
      return const Center(
        child: Text('璇烽€夋嫨涓€涓厓绱?),
      );
    }

    // 鏍规嵁閫変腑鍏冪礌绫诲瀷鏄剧ず涓嶅悓鐨勫睘鎬х紪杈戝櫒
    switch (selectedElement!['type']) {
      case 'chars':
        return _buildCharsProperties(context);
      case 'text':
        return _buildTextProperties(context);
      case 'image':
        return _buildImageProperties(context);
      default:
        return const Center(
          child: Text('鏈煡鍏冪礌绫诲瀷'),
        );
    }
  }

  Widget _buildCharsProperties(BuildContext context) {
    return SingleChildScrollView(
      padding: const EdgeInsets.all(16),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // 鍩烘湰灞炴€?
          _buildSection(
            '鍩烘湰灞炴€?,
            [
              TextField(
                decoration: const InputDecoration(labelText: '鍐呭'),
                onChanged: (value) => _updateProperty('content', value),
              ),
              const SizedBox(height: 16),
              Row(
                children: [
                  Expanded(
                    child: TextField(
                      decoration: const InputDecoration(labelText: '瀛楀彿'),
                      keyboardType: TextInputType.number,
                      onChanged: (value) => _updateProperty('fontSize', int.tryParse(value)),
                    ),
                  ),
                  const SizedBox(width: 16),
                  Expanded(
                    child: TextField(
                      decoration: const InputDecoration(labelText: '闂磋窛'),
                      keyboardType: TextInputType.number,
                      onChanged: (value) => _updateProperty('spacing', int.tryParse(value)),
                    ),
                  ),
                ],
              ),
            ],
          ),
          // 浣嶇疆鍜屽昂瀵?
          _buildSection(
            '浣嶇疆鍜屽昂瀵?,
            [
              Row(
                children: [
                  Expanded(
                    child: TextField(
                      decoration: const InputDecoration(labelText: 'X'),
                      keyboardType: TextInputType.number,
                      onChanged: (value) => _updateProperty('x', double.tryParse(value)),
                    ),
                  ),
                  const SizedBox(width: 16),
                  Expanded(
                    child: TextField(
                      decoration: const InputDecoration(labelText: 'Y'),
                      keyboardType: TextInputType.number,
                      onChanged: (value) => _updateProperty('y', double.tryParse(value)),
                    ),
                  ),
                ],
              ),
              const SizedBox(height: 16),
              Row(
                children: [
                  Expanded(
                    child: TextField(
                      decoration: const InputDecoration(labelText: '瀹藉害'),
                      keyboardType: TextInputType.number,
                      onChanged: (value) => _updateProperty('width', double.tryParse(value)),
                    ),
                  ),
                  const SizedBox(width: 16),
                  Expanded(
                    child: TextField(
                      decoration: const InputDecoration(labelText: '楂樺害'),
                      keyboardType: TextInputType.number,
                      onChanged: (value) => _updateProperty('height', double.tryParse(value)),
                    ),
                  ),
                ],
              ),
            ],
          ),
          // 鏍峰紡
          _buildSection(
            '鏍峰紡',
            [
              // TODO: 娣诲姞棰滆壊閫夋嫨鍣ㄥ拰鍏朵粬鏍峰紡灞炴€?
            ],
          ),
        ],
      ),
    );
  }

  Widget _buildTextProperties(BuildContext context) {
    // TODO: 瀹炵幇鏂囨湰鍏冪礌灞炴€х紪杈戝櫒
    return Container();
  }

  Widget _buildImageProperties(BuildContext context) {
    // TODO: 瀹炵幇鍥剧墖鍏冪礌灞炴€х紪杈戝櫒
    return Container();
  }

  Widget _buildSection(String title, List<Widget> children) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          title,
          style: const TextStyle(
            fontSize: 16,
            fontWeight: FontWeight.bold,
          ),
        ),
        const SizedBox(height: 16),
        ...children,
        const SizedBox(height: 24),
      ],
    );
  }

  void _updateProperty(String key, dynamic value) {
    final updatedElement = Map<String, dynamic>.from(selectedElement!);
    updatedElement[key] = value;
    onPropertyChanged(updatedElement);
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\practice\practice_tool_panel.dart
-----------------------------------
import 'package:flutter/material.dart';

class PracticeToolPanel extends StatelessWidget {
  final Function(String) onToolSelected;

  const PracticeToolPanel({
    super.key,
    required this.onToolSelected,
  });

  @override
  Widget build(BuildContext context) {
    return ListView(
      padding: const EdgeInsets.all(16),
      children: [
        Text('椤甸潰璁剧疆', style: Theme.of(context).textTheme.titleSmall),
        const SizedBox(height: 8),
        Wrap(
          spacing: 8,
          runSpacing: 8,
          children: [
            _buildToolButton(
              context,
              icon: Icons.crop_landscape,
              label: '椤甸潰澶у皬',
              onPressed: () => onToolSelected('page_size'),
            ),
            _buildToolButton(
              context,
              icon: Icons.space_bar,
              label: '椤佃竟璺?,
              onPressed: () => onToolSelected('margins'),
            ),
            _buildToolButton(
              context,
              icon: Icons.grid_on,
              label: '鑳屾櫙',
              onPressed: () => onToolSelected('background'),
            ),
          ],
        ),
        const Divider(height: 32),
        Text('鍐呭宸ュ叿', style: Theme.of(context).textTheme.titleSmall),
        const SizedBox(height: 8),
        Wrap(
          spacing: 8,
          runSpacing: 8,
          children: [
            _buildToolButton(
              context,
              icon: Icons.font_download,
              label: '闆嗗瓧濉厖',
              onPressed: () => onToolSelected('chars'),
            ),
            _buildToolButton(
              context,
              icon: Icons.text_fields,
              label: '鏂囨湰',
              onPressed: () => onToolSelected('text'),
            ),
            _buildToolButton(
              context,
              icon: Icons.image,
              label: '鍥剧墖',
              onPressed: () => onToolSelected('image'),
            ),
          ],
        ),
        const Divider(height: 32),
        Text('杈呭姪宸ュ叿', style: Theme.of(context).textTheme.titleSmall),
        const SizedBox(height: 8),
        Wrap(
          spacing: 8,
          runSpacing: 8,
          children: [
            _buildToolButton(
              context,
              icon: Icons.grid_4x4,
              label: '鍙傝€冪嚎',
              onPressed: () => onToolSelected('guides'),
            ),
            _buildToolButton(
              context,
              icon: Icons.straighten,
              label: '鏍囧昂',
              onPressed: () => onToolSelected('ruler'),
            ),
          ],
        ),
      ],
    );
  }

  Widget _buildToolButton(
    BuildContext context, {
    required IconData icon,
    required String label,
    required VoidCallback onPressed,
  }) {
    return ElevatedButton.icon(
      onPressed: onPressed,
      icon: Icon(icon, size: 18),
      label: Text(label),
      style: ElevatedButton.styleFrom(
        padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
      ),
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\preview\image_preview.dart
-----------------------------------
import 'dart:io';

import 'package:flutter/material.dart';

import '../../../theme/app_sizes.dart';

class ImagePreview extends StatelessWidget {
  final File? file;
  final String? networkUrl;
  final double? width;
  final double? height;
  final BoxFit fit;
  final Widget? placeholder;
  final Widget? errorWidget;

  const ImagePreview({
    super.key,
    this.file,
    this.networkUrl,
    this.width,
    this.height,
    this.fit = BoxFit.cover,
    this.placeholder,
    this.errorWidget,
  }) : assert(file != null || networkUrl != null);

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Container(
      width: width,
      height: height,
      decoration: BoxDecoration(
        color: theme.colorScheme.surfaceContainerHighest,
        borderRadius: BorderRadius.circular(AppSizes.radiusSmall),
      ),
      child: ClipRRect(
        borderRadius: BorderRadius.circular(AppSizes.radiusSmall),
        child: _buildImage(theme),
      ),
    );
  }

  Widget _buildError(ThemeData theme) {
    return errorWidget ??
        Center(
          child: Icon(
            Icons.broken_image_outlined,
            color: theme.colorScheme.error,
          ),
        );
  }

  Widget _buildImage(ThemeData theme) {
    if (file != null) {
      return Image.file(
        file!,
        fit: fit,
        errorBuilder: (_, __, ___) => _buildError(theme),
      );
    }

    if (networkUrl != null) {
      return Image.network(
        networkUrl!,
        fit: fit,
        loadingBuilder: (_, child, progress) {
          if (progress == null) return child;
          return _buildPlaceholder(theme);
        },
        errorBuilder: (_, __, ___) => _buildError(theme),
      );
    }

    return _buildError(theme);
  }

  Widget _buildPlaceholder(ThemeData theme) {
    return placeholder ??
        Center(
          child: CircularProgressIndicator(
            color: theme.primaryColor,
          ),
        );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\preview\practice_preview.dart
-----------------------------------
import 'dart:io';

import 'package:flutter/material.dart';

import '../../../theme/app_sizes.dart';
import 'image_preview.dart';

class PracticePreview extends StatelessWidget {
  final String? imagePath;
  final String? backgroundImagePath;
  final double opacity;
  final VoidCallback? onRefresh;

  const PracticePreview({
    super.key,
    this.imagePath,
    this.backgroundImagePath,
    this.opacity = 0.5,
    this.onRefresh,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Stack(
      children: [
        // 鑳屾櫙鍥惧眰
        if (backgroundImagePath != null)
          Opacity(
            opacity: opacity,
            child: ImagePreview(
              file: File(backgroundImagePath!),
              width: double.infinity,
              height: double.infinity,
            ),
          ),
        // 缁冧範鍥惧眰
        if (imagePath != null)
          ImagePreview(
            file: File(imagePath!),
            width: double.infinity,
            height: double.infinity,
          ),
        // 鏃犲唴瀹规椂鐨勫崰浣?
        if (imagePath == null && backgroundImagePath == null)
          Center(
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                Icon(
                  Icons.image_outlined,
                  size: 48,
                  color: theme.colorScheme.outline,
                ),
                const SizedBox(height: AppSizes.spacingSmall),
                Text(
                  '鏆傛棤棰勮鍐呭',
                  style: theme.textTheme.bodyMedium?.copyWith(
                    color: theme.colorScheme.outline,
                  ),
                ),
              ],
            ),
          ),
        // 鍒锋柊鎸夐挳
        if (onRefresh != null)
          Positioned(
            top: AppSizes.spacingSmall,
            right: AppSizes.spacingSmall,
            child: IconButton(
              icon: const Icon(Icons.refresh),
              onPressed: onRefresh,
              tooltip: '鍒锋柊棰勮',
            ),
          ),
      ],
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\scroll\scrollable_container.dart
-----------------------------------
import 'package:flutter/material.dart';

import '../../../theme/app_sizes.dart';

class ScrollableContainer extends StatelessWidget {
  final Widget child;
  final EdgeInsets? padding;
  final ScrollController? controller;
  final bool showScrollbar;

  const ScrollableContainer({
    super.key,
    required this.child,
    this.padding,
    this.controller,
    this.showScrollbar = true,
  });

  @override
  Widget build(BuildContext context) {
    Widget content = SingleChildScrollView(
      controller: controller,
      padding: padding ?? const EdgeInsets.all(AppSizes.spacingMedium),
      child: child,
    );

    if (showScrollbar) {
      content = Scrollbar(
        controller: controller,
        child: content,
      );
    }

    return content;
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\search\search_box.dart
-----------------------------------
import 'package:flutter/material.dart';

import '../../../theme/app_sizes.dart';

class SearchBox extends StatelessWidget {
  final String? hintText;
  final ValueChanged<String>? onChanged;
  final VoidCallback? onSubmitted;
  final TextEditingController? controller;
  final double? width;

  const SearchBox({
    super.key,
    this.hintText,
    this.onChanged,
    this.onSubmitted,
    this.controller,
    this.width,
  });

  @override
  Widget build(BuildContext context) {
    return SizedBox(
      width: width ?? 240,
      child: SearchBar(
        controller: controller,
        hintText: hintText,
        leading: const Icon(Icons.search),
        padding: const WidgetStatePropertyAll(
          EdgeInsets.symmetric(
            horizontal: AppSizes.spacingMedium,
          ),
        ),
        onChanged: onChanged,
        onSubmitted: (value) => onSubmitted?.call(),
      ),
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\settings\settings_section.dart
-----------------------------------
import 'package:flutter/material.dart';

class SettingsSection extends StatelessWidget {
  final String title;
  final IconData? icon;
  final List<Widget> children;
  final bool initiallyExpanded;

  const SettingsSection({
    super.key,
    required this.title,
    this.icon,
    required this.children,
    this.initiallyExpanded = true,
  });

  @override
  Widget build(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Padding(
          padding: const EdgeInsets.fromLTRB(16, 16, 16, 8),
          child: Row(
            children: [
              if (icon != null) ...[
                Icon(
                  icon,
                  size: 20,
                  color: Theme.of(context).colorScheme.primary,
                ),
                const SizedBox(width: 8),
              ],
              Text(
                title,
                style: TextStyle(
                  fontSize: 16,
                  fontWeight: FontWeight.bold,
                  color: Theme.of(context).colorScheme.primary,
                ),
              ),
            ],
          ),
        ),
        ...children,
        const SizedBox(height: 8),
      ],
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\upload\image_upload.dart
-----------------------------------
import 'dart:io';

import 'package:flutter/material.dart';

import '../../../theme/app_sizes.dart';
import '../preview/image_preview.dart';

class ImageUpload extends StatelessWidget {
  final File? file;
  final VoidCallback onUpload;
  final VoidCallback? onRemove;
  final double? width;
  final double? height;
  final String? uploadHint;
  final bool showPreview;

  const ImageUpload({
    super.key,
    this.file,
    required this.onUpload,
    this.onRemove,
    this.width,
    this.height,
    this.uploadHint,
    this.showPreview = true,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Container(
      width: width,
      height: height,
      decoration: BoxDecoration(
        border: Border.all(color: theme.dividerColor),
        borderRadius: BorderRadius.circular(AppSizes.radiusMedium),
      ),
      child: file != null && showPreview
          ? _buildPreview(context)
          : _buildUploadButton(context),
    );
  }

  Widget _buildPreview(BuildContext context) {
    return Stack(
      children: [
        ImagePreview(file: file),
        if (onRemove != null)
          Positioned(
            top: AppSizes.spacingSmall,
            right: AppSizes.spacingSmall,
            child: IconButton(
              icon: const Icon(Icons.close),
              onPressed: onRemove,
              style: IconButton.styleFrom(
                backgroundColor: Colors.black38,
                foregroundColor: Colors.white,
              ),
            ),
          ),
      ],
    );
  }

  Widget _buildUploadButton(BuildContext context) {
    final theme = Theme.of(context);

    return InkWell(
      onTap: onUpload,
      borderRadius: BorderRadius.circular(AppSizes.radiusMedium),
      child: Center(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Icon(
              Icons.cloud_upload_outlined,
              size: 32,
              color: theme.colorScheme.primary,
            ),
            const SizedBox(height: AppSizes.spacingSmall),
            Text(
              uploadHint ?? '鐐瑰嚮涓婁紶鍥剧墖',
              style: theme.textTheme.bodyMedium?.copyWith(
                color: theme.colorScheme.primary,
              ),
            ),
          ],
        ),
      ),
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\window\title_bar.dart
-----------------------------------
import 'package:flutter/material.dart';
import 'package:window_manager/window_manager.dart';

import '../../../theme/app_sizes.dart';

class TitleBar extends StatefulWidget {
  final String? title;

  const TitleBar({super.key, this.title});

  @override
  State<TitleBar> createState() => _TitleBarState();
}

class WindowButtons extends StatefulWidget {
  const WindowButtons({super.key});

  @override
  State<WindowButtons> createState() => _WindowButtonsState();
}

class _TitleBarState extends State<TitleBar> with WindowListener {
  bool _isMaximized = false;

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return GestureDetector(
      onDoubleTap: _handleDoubleClick,
      child: Container(
        height: AppSizes.appBarHeight,
        decoration: BoxDecoration(
          color: theme.colorScheme.surface,
          border: Border(
            bottom: BorderSide(
              color: theme.dividerColor,
              width: AppSizes.dividerThickness,
            ),
          ),
          boxShadow: [
            BoxShadow(
              color: theme.shadowColor.withOpacity(0.05),
              blurRadius: 2,
              offset: const Offset(0, 1),
            ),
          ],
        ),
        child: Row(
          children: [
            // 搴旂敤鍥炬爣
            Padding(
              padding: const EdgeInsets.symmetric(horizontal: AppSizes.s),
              child: Icon(
                Icons.brush_outlined,
                color: theme.colorScheme.primary,
                size: AppSizes.iconMedium,
              ),
            ),
            // 鏍囬鎷栧姩鍖哄煙
            Expanded(
              child: DragToMoveArea(
                child: Padding(
                  padding: const EdgeInsets.symmetric(horizontal: AppSizes.s),
                  child: Text(
                    widget.title ?? '涔︽硶闆嗗瓧',
                    style: theme.textTheme.titleMedium?.copyWith(
                      fontWeight: FontWeight.w500,
                      color: theme.colorScheme.onSurface,
                    ),
                    overflow: TextOverflow.ellipsis,
                  ),
                ),
              ),
            ),
            // 绐楀彛鎸夐挳
            const WindowButtons(),
          ],
        ),
      ),
    );
  }

  @override
  void dispose() {
    windowManager.removeListener(this);
    super.dispose();
  }

  @override
  void initState() {
    super.initState();
    windowManager.addListener(this);
    _init();
  }

  @override
  void onWindowMaximize() {
    setState(() {
      _isMaximized = true;
    });
  }

  @override
  void onWindowRestore() {
    setState(() {
      _isMaximized = false;
    });
  }

  @override
  void onWindowUnmaximize() {
    setState(() {
      _isMaximized = false;
    });
  }

  Future<void> _handleDoubleClick() async {
    if (_isMaximized) {
      await windowManager.unmaximize();
    } else {
      await windowManager.maximize();
    }
  }

  void _init() async {
    _isMaximized = await windowManager.isMaximized();
    if (mounted) setState(() {});
  }
}

class _WindowButton extends StatelessWidget {
  final IconData icon;
  final String tooltip;
  final VoidCallback onPressed;
  final bool isClose;

  const _WindowButton({
    required this.icon,
    required this.tooltip,
    required this.onPressed,
    this.isClose = false,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Tooltip(
      message: tooltip,
      preferBelow: false,
      child: SizedBox(
        height: AppSizes.appBarHeight,
        width: 46,
        child: Material(
          color: Colors.transparent,
          child: InkWell(
            onTap: onPressed,
            hoverColor: isClose
                ? theme.colorScheme.error.withOpacity(0.1)
                : theme.colorScheme.onSurface.withOpacity(0.05),
            child: Icon(
              icon,
              size: AppSizes.iconSmall,
              color: isClose
                  ? theme.colorScheme.error
                  : theme.colorScheme.onSurfaceVariant,
            ),
          ),
        ),
      ),
    );
  }
}

class _WindowButtonsState extends State<WindowButtons> with WindowListener {
  bool _isMaximized = false;

  @override
  Widget build(BuildContext context) {
    return Row(
      children: [
        _WindowButton(
          icon: Icons.remove,
          tooltip: '鏈€灏忓寲',
          onPressed: () async {
            await windowManager.minimize();
          },
        ),
        _WindowButton(
          icon: _isMaximized ? Icons.filter_none : Icons.crop_square,
          tooltip: _isMaximized ? '杩樺師' : '鏈€澶у寲',
          onPressed: () async {
            if (_isMaximized) {
              await windowManager.unmaximize();
            } else {
              await windowManager.maximize();
            }
          },
        ),
        _WindowButton(
          icon: Icons.close,
          tooltip: '鍏抽棴',
          isClose: true,
          onPressed: () async {
            await windowManager.close();
          },
        ),
      ],
    );
  }

  @override
  void dispose() {
    windowManager.removeListener(this);
    super.dispose();
  }

  @override
  void initState() {
    super.initState();
    windowManager.addListener(this);
    _init();
  }

  @override
  void onWindowMaximize() {
    setState(() => _isMaximized = true);
  }

  @override
  void onWindowRestore() {
    setState(() => _isMaximized = false);
  }

  @override
  void onWindowUnmaximize() {
    setState(() => _isMaximized = false);
  }

  Future<void> _init() async {
    _isMaximized = await windowManager.isMaximized();
    if (mounted) setState(() {});
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\workbench\workbench_container.dart
-----------------------------------
import 'package:flutter/material.dart';

import '../../../theme/app_sizes.dart';

class WorkbenchContainer extends StatelessWidget {
  final Widget? toolbar;
  final Widget body;
  final Widget? sidebar;
  final double? sidebarWidth;
  final Widget? footer;

  const WorkbenchContainer({
    super.key,
    this.toolbar,
    required this.body,
    this.sidebar,
    this.sidebarWidth = 320.0,
    this.footer,
  });

  @override
  Widget build(BuildContext context) {
    return Column(
      children: [
        if (toolbar != null)
          Container(
            height: AppSizes.pageToolbarHeight,
            decoration: BoxDecoration(
              border: Border(
                bottom: BorderSide(color: Theme.of(context).dividerColor),
              ),
            ),
            child: toolbar,
          ),
        Expanded(
          child: Row(
            children: [
              Expanded(child: body),
              if (sidebar != null) ...[
                VerticalDivider(
                    width: 1, color: Theme.of(context).dividerColor),
                SizedBox(
                  width: sidebarWidth,
                  child: sidebar!,
                ),
              ],
            ],
          ),
        ),
        if (footer != null)
          Container(
            decoration: BoxDecoration(
              border: Border(
                top: BorderSide(color: Theme.of(context).dividerColor),
              ),
            ),
            child: footer,
          ),
      ],
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\workbench\workbench_toolbar.dart
-----------------------------------
import 'package:flutter/material.dart';

import '../../../theme/app_sizes.dart';

class WorkbenchToolbar extends StatelessWidget {
  final String? title;
  final List<Widget>? actions;
  final List<Widget>? tools;
  final EdgeInsetsGeometry? padding;

  const WorkbenchToolbar({
    super.key,
    this.title,
    this.actions,
    this.tools,
    this.padding,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Container(
      padding: padding ?? const EdgeInsets.all(AppSizes.spacingMedium),
      child: Row(
        children: [
          if (title != null) Text(title!, style: theme.textTheme.titleMedium),
          if (tools != null) ...[
            const SizedBox(width: AppSizes.spacingMedium),
            ...tools!,
          ],
          const Spacer(),
          if (actions != null)
            Row(
              mainAxisSize: MainAxisSize.min,
              children: actions!,
            ),
        ],
      ),
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\works\enhanced_work_preview.dart
-----------------------------------
import 'package:flutter/material.dart';

import '../../../domain/models/work/work_image.dart';
import '../../../infrastructure/logging/logger.dart';
import '../../pages/works/components/thumbnail_strip.dart';
import '../common/zoomable_image_view.dart';

/// An enhanced work preview component that combines image viewing and thumbnails
class EnhancedWorkPreview extends StatefulWidget {
  final List<WorkImage> images;
  final int selectedIndex;
  final bool isEditing;
  final bool showToolbar;
  final List<Widget>? toolbarActions;
  final Function(int)? onIndexChanged;
  final Function(WorkImage)? onImageAdded;
  final Function(String)? onImageDeleted;
  final Function(int, int)? onImagesReordered;

  const EnhancedWorkPreview({
    super.key,
    required this.images,
    required this.selectedIndex,
    this.isEditing = false,
    this.showToolbar = false,
    this.toolbarActions,
    this.onIndexChanged,
    this.onImageAdded,
    this.onImageDeleted,
    this.onImagesReordered,
  });

  @override
  State<EnhancedWorkPreview> createState() => _EnhancedWorkPreviewState();
}

class _EnhancedWorkPreviewState extends State<EnhancedWorkPreview> {
  @override
  Widget build(BuildContext context) {
    AppLogger.debug(
        'Building EnhancedWorkPreview with ${widget.images.length} images');
    final currentImage = widget.selectedIndex < widget.images.length
        ? widget.images[widget.selectedIndex]
        : null;
    final theme = Theme.of(context);

    return LayoutBuilder(builder: (context, constraints) {
      final availableHeight = constraints.maxHeight;
      final toolbarHeight = widget.showToolbar ? 48.0 : 0.0;
      final thumbnailHeight = widget.images.isNotEmpty ? 120.0 : 0.0;
      final imageHeight = availableHeight - toolbarHeight - thumbnailHeight;

      return Column(
        children: [
          // 宸ュ叿鏍?- 鍥炬爣鎸夐挳璁捐
          if (widget.showToolbar && widget.toolbarActions != null)
            Container(
              height: toolbarHeight,
              padding:
                  const EdgeInsets.symmetric(horizontal: 16.0, vertical: 6.0),
              alignment: Alignment.centerLeft,
              child: Row(
                children: [
                  Expanded(
                    child: SingleChildScrollView(
                      scrollDirection: Axis.horizontal,
                      child: Row(
                        mainAxisSize: MainAxisSize.min,
                        children: widget.toolbarActions!,
                      ),
                    ),
                  ),
                ],
              ),
            ),

          // 涓诲浘鐗囨樉绀哄尯鍩?
          Expanded(
            child: currentImage != null
                ? ZoomableImageView(
                    imagePath: currentImage.path,
                    enableMouseWheel: true,
                    minScale: 0.5,
                    maxScale: 4.0,
                    showControls: true,
                  )
                : Center(
                    child: Column(
                      mainAxisAlignment: MainAxisAlignment.center,
                      children: [
                        Icon(Icons.image_not_supported,
                            size: 48, color: theme.colorScheme.outline),
                        const SizedBox(height: 16),
                        Text('娌℃湁鍙樉绀虹殑鍥剧墖',
                            style: TextStyle(color: theme.colorScheme.outline)),
                      ],
                    ),
                  ),
          ),

          // 缂╃暐鍥炬潯 - 浠呭湪鏈夊浘鐗囨椂鏄剧ず
          if (widget.images.isNotEmpty)
            SizedBox(
              height: thumbnailHeight,
              child: ThumbnailStrip<WorkImage>(
                images: widget.images,
                selectedIndex: widget.selectedIndex,
                isEditable: widget.isEditing,
                onTap: (index) {
                  AppLogger.debug('EnhancedWorkPreview onTap: $index');
                  widget.onIndexChanged?.call(index);
                },
                onReorder: (oldIndex, newIndex) {
                  AppLogger.debug(
                      'EnhancedWorkPreview onReorder: $oldIndex -> $newIndex');
                  widget.onImagesReordered?.call(oldIndex, newIndex);
                },
                pathResolver: (image) => image.path,
                keyResolver: (image) => image.id,
              ),
            ),
        ],
      );
    });
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\works\preview_mode_config.dart
-----------------------------------
import 'package:flutter/material.dart';

import 'preview_types.dart';

class PreviewModeConfig {
  /// Edit mode configuration
  static PreviewModeConfig get edit => PreviewModeConfig(
        toolbarActions: [
          ToolbarAction(
            icon: Icons.add_photo_alternate,
            tooltip: '娣诲姞鍥剧墖',
            onPressed: () {}, // Will be set by consumer
          ),
          ToolbarAction(
            icon: Icons.save,
            tooltip: '淇濆瓨鏇存敼',
            onPressed: () {}, // Will be set by consumer
            placement: ToolbarActionPlacement.right,
          ),
          ToolbarAction(
            icon: Icons.delete,
            tooltip: '鍒犻櫎鍥剧墖',
            onPressed: () {}, // Will be set by consumer
          ),
        ],
        allowReordering: true,
        enableDeletion: true,
      );

  /// Extract mode configuration
  static PreviewModeConfig get extract => PreviewModeConfig(
        toolbarActions: [
          ToolbarAction(
            icon: Icons.crop_free,
            tooltip: '妗嗛€夊伐鍏?,
            onPressed: () {}, // Will be set by consumer
          ),
          ToolbarAction(
            icon: Icons.select_all,
            tooltip: '澶氶€夊伐鍏?,
            onPressed: () {}, // Will be set by consumer
          ),
          ToolbarAction(
            icon: Icons.delete,
            tooltip: '鍒犻櫎閫変腑鍖哄煙',
            onPressed: () {}, // Will be set by consumer
          ),
        ],
        showControls: false,
        allowReordering: false,
      );

  /// Import mode configuration
  static PreviewModeConfig get import => PreviewModeConfig(
        toolbarActions: [
          ToolbarAction(
            icon: Icons.add_photo_alternate,
            tooltip: '娣诲姞鍥剧墖',
            onPressed: () {}, // Will be set by consumer
          ),
          ToolbarAction(
            icon: Icons.delete,
            tooltip: '鍒犻櫎鍥剧墖',
            onPressed: () {}, // Will be set by consumer
          ),
        ],
        allowReordering: true,
        enableDeletion: true,
        emptyStateMessage: '鐐瑰嚮娣诲姞鎴栨嫋鏀惧浘鐗?,
      );

  /// View mode configuration
  static PreviewModeConfig get view => const PreviewModeConfig(
        toolbarActions: [],
        showControls: true,
        showToolbar: false,
      );
  final List<ToolbarAction> toolbarActions;
  final bool allowReordering;
  final bool showControls;

  final bool showToolbar;

  final bool showThumbnails;

  final bool enableDeletion;

  final String emptyStateMessage;

  const PreviewModeConfig({
    required this.toolbarActions,
    this.allowReordering = false,
    this.showControls = true,
    this.showToolbar = true,
    this.showThumbnails = true,
    this.enableDeletion = false,
    this.emptyStateMessage = '鏃犲浘鐗?,
  });

  /// Create a copy with updated action handlers
  PreviewModeConfig copyWithActions({
    VoidCallback? onAdd,
    VoidCallback? onDelete,
    VoidCallback? onSave,
    VoidCallback? onBoxSelect,
    VoidCallback? onMultiSelect,
  }) {
    return PreviewModeConfig(
      toolbarActions: toolbarActions.map((action) {
        if (action.icon == Icons.add_photo_alternate && onAdd != null) {
          return action.copyWith(onPressed: onAdd);
        }
        if (action.icon == Icons.delete && onDelete != null) {
          return action.copyWith(onPressed: onDelete);
        }
        if (action.icon == Icons.save && onSave != null) {
          return action.copyWith(onPressed: onSave);
        }
        if (action.icon == Icons.crop_free && onBoxSelect != null) {
          return action.copyWith(onPressed: onBoxSelect);
        }
        if (action.icon == Icons.select_all && onMultiSelect != null) {
          return action.copyWith(onPressed: onMultiSelect);
        }
        return action;
      }).toList(),
      allowReordering: allowReordering,
      showControls: showControls,
      showToolbar: showToolbar,
      showThumbnails: showThumbnails,
      enableDeletion: enableDeletion,
      emptyStateMessage: emptyStateMessage,
    );
  }

  /// Get configuration for specific mode
  static PreviewModeConfig forMode(PreviewMode mode) {
    switch (mode) {
      case PreviewMode.import:
        return import;
      case PreviewMode.edit:
        return edit;
      case PreviewMode.view:
        return view;
      case PreviewMode.extract:
        return extract;
    }
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\presentation\widgets\works\preview_types.dart
-----------------------------------
import 'package:flutter/material.dart';

/// 棰勮妯″紡鏋氫妇
enum PreviewMode {
  /// 瀵煎叆妯″紡
  import,

  /// 缂栬緫妯″紡
  edit,

  /// 鏌ョ湅妯″紡
  view,

  /// 鎻愬彇妯″紡
  extract,
}

/// 宸ュ叿鏍忔搷浣滈」
class ToolbarAction {
  /// 鍥炬爣
  final IconData icon;

  /// 鏍囬
  final String? tooltip;

  /// 鏄惁鍙敤
  final bool enabled;

  /// 鎿嶄綔鍥炶皟
  final VoidCallback? onPressed;

  /// 浣嶇疆
  final ToolbarActionPlacement placement;

  const ToolbarAction({
    required this.icon,
    this.tooltip,
    this.enabled = true,
    this.onPressed,
    this.placement = ToolbarActionPlacement.left,
  });

  /// 鍒涘缓涓€涓柊鐨?ToolbarAction 瀹炰緥锛屽彲閫夋嫨鎬у湴瑕嗙洊鐜版湁灞炴€?
  ToolbarAction copyWith({
    IconData? icon,
    String? tooltip,
    bool? enabled,
    VoidCallback? onPressed,
    ToolbarActionPlacement? placement,
  }) {
    return ToolbarAction(
      icon: icon ?? this.icon,
      tooltip: tooltip ?? this.tooltip,
      enabled: enabled ?? this.enabled,
      onPressed: onPressed ?? this.onPressed,
      placement: placement ?? this.placement,
    );
  }
}

/// 宸ュ叿鏍忔搷浣滀綅缃灇涓?
enum ToolbarActionPlacement {
  /// 宸︿晶
  left,

  /// 鍙充晶
  right,

  /// 灞呬腑
  center,
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\providers\character\contour_state_provider.dart
-----------------------------------
import 'package:flutter_riverpod/flutter_riverpod.dart';

/// 鎺у埗鎻忚竟鏄剧ず鐨勭姸鎬丳rovider
final contourStateProvider =
    StateNotifierProvider<ContourStateNotifier, bool>((ref) {
  return ContourStateNotifier();
});

class ContourStateNotifier extends StateNotifier<bool> {
  ContourStateNotifier() : super(false);

  void setShowContour(bool show) {
    state = show;
  }

  void toggle() {
    state = !state;
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\routes\app_routes.dart
-----------------------------------
import 'package:go_router/go_router.dart';

import '../presentation/pages/home_page.dart';

/// The route configuration.
final routes = <RouteBase>[
  GoRoute(
    path: AppRoutes.home,
    builder: (context, state) =>
        const HomePagePlaceholder(), // Placeholder for home page
  ),
];

/// App route definitions
class AppRoutes {
  static const home = '/';
  static const workBrowse = '/work_browse';
  static const workDetail = '/work_detail';
  static const workImport = '/work_import';
  static const characterList = '/character_list';
  static const characterDetail = '/character_detail';
  static const practiceList = '/practice_list';
  static const practiceDetail = '/practice_detail';
  static const practiceEdit = '/practice_edit';
  static const settings = '/settings';
  static const String workEdit = '/work/edit';
  static const String workExtract = '/work/extract';
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\theme\app_colors.dart
-----------------------------------
import 'package:flutter/material.dart';

class AppColors {
  // Primary colors
  static const primary = Color(0xFF2196F3);
  static const primaryLight = Color(0xFF64B5F6);
  static const primaryDark = Color(0xFF1976D2);

  // Secondary colors
  static const secondary = Color(0xFF4CAF50);
  static const secondaryLight = Color(0xFF81C784);
  static const secondaryDark = Color(0xFF388E3C);

  // Background colors
  static const background = Color(0xFFF5F5F5);
  static const surface = Colors.white;
  static const selectedCard = Color(0xFFE3F2FD);

  // Text colors
  static const textPrimary = Color(0xFF212121);
  static const textSecondary = Color(0xFF757575);
  static const textHint = Color(0xFFBDBDBD);

  // Status colors
  static const success = Color(0xFF4CAF50);
  static const warning = Color(0xFFFFC107);
  static const error = Color(0xFFF44336);
  static const info = Color(0xFF2196F3);

  // Card colors
  static const cardShadow = Color(0x1F000000);
  static const divider = Color(0xFFE0E0E0);

  // Icon colors
  static const iconPrimary = Color(0xFF616161);
  static const iconSecondary = Color(0xFF9E9E9E);
  static const iconDisabled = Color(0xFFBDBDBD);
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\theme\app_images.dart
-----------------------------------
class AppImages {
  // 鍥炬爣灏哄
  static const double iconSizeSmall = 16;
  static const double iconSizeMedium = 24;
  static const double iconSizeLarge = 32;

  // 棰勮鍥惧昂瀵?
  static const double thumbnailSizeSmall = 100;
  static const double thumbnailSizeMedium = 150;
  static const double thumbnailSizeLarge = 200;

  // 鍗犱綅鍥炬牱寮?
  static const double placeholderOpacity = 0.1;
  static const double placeholderIconSize = 48;
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\theme\app_sizes.dart
-----------------------------------
/// 搴旂敤灏哄甯搁噺
class AppSizes {
  // Padding
  static const double p2 = 2.0;
  static const double p4 = 4.0;
  static const double p8 = 8.0;
  static const double p12 = 12.0;
  static const double p16 = 16.0;
  static const double p24 = 24.0;
  static const double p32 = 32.0;
  static const double p48 = 48.0;
  static const double p64 = 64.0;

  // Margin
  static const double m2 = 2.0;
  static const double m4 = 4.0;
  static const double m8 = 8.0;
  static const double m12 = 12.0;
  static const double m16 = 16.0;
  static const double m24 = 24.0;
  static const double m32 = 32.0;
  static const double m48 = 48.0;
  static const double m64 = 64.0;

  // Spacing
  static const double xxs = 2.0;
  static const double xs = 4.0;
  static const double s = 8.0;
  static const double m = 16.0;
  static const double l = 24.0;
  static const double xl = 32.0;
  static const double xxl = 48.0;

  // Component specific
  static const double spacingTiny = 2.0;
  static const double spacingSmall = 8.0;
  static const double spacingMedium = 16.0;
  static const double spacingLarge = 24.0;

  // Border radius
  static const double r4 = 4.0;
  static const double r8 = 8.0;
  static const double r12 = 12.0;
  static const double r16 = 16.0;
  static const double r24 = 24.0;

  static const double radiusSmall = 4.0;
  static const double radiusMedium = 8.0;
  static const double radiusLarge = 12.0;

  // Card
  static const double cardRadius = 8.0;
  static const double cardElevation = 1.0;
  static const double cardElevationSelected = 4.0;

  // Icon sizes
  static const double iconSmall = 16.0;
  static const double iconMedium = 24.0;
  static const double iconLarge = 32.0;

  // Layout
  static const double appBarHeight = 48.0;
  static const double sidebarWidth = 256.0;
  static const double navigationRailWidth = 72.0;
  static const double dividerThickness = 1.0;
  static const double pageToolbarHeight = 48.0;
  static const double dialogHeaderHeight = 48.0;
  static const double tableHeaderHeight = 48.0;

  // Grid
  static const double gridCardWidth = 280.0;
  static const double gridCardImageHeight = 200.0;
  static const double gridCardInfoHeight = 80.0;
  static const int gridCrossAxisCount = 4;
  static const double gridMainAxisSpacing = 16.0;
  static const double gridCrossAxisSpacing = 16.0;

  // Form
  static const double formFieldSpacing = 16.0;

  // Breakpoints
  static const double breakpointXs = 600.0;
  static const double breakpointMd = 905.0;
  static const double breakpointLg = 1240.0;
  static const double breakpointXl = 1440.0;
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\theme\app_text_styles.dart
-----------------------------------
import 'package:flutter/material.dart';

import 'app_colors.dart';

class AppTextStyles {
  static const displayLarge = TextStyle(
    fontSize: 57,
    fontWeight: FontWeight.normal,
    color: AppColors.textPrimary,
  );

  static const displayMedium = TextStyle(
    fontSize: 45,
    fontWeight: FontWeight.normal,
    color: AppColors.textPrimary,
  );

  static const displaySmall = TextStyle(
    fontSize: 36,
    fontWeight: FontWeight.normal,
    color: AppColors.textPrimary,
  );

  static const headlineLarge = TextStyle(
    fontSize: 32,
    fontWeight: FontWeight.normal,
    color: AppColors.textPrimary,
  );

  static const headlineMedium = TextStyle(
    fontSize: 28,
    fontWeight: FontWeight.normal,
    color: AppColors.textPrimary,
  );

  static const headlineSmall = TextStyle(
    fontSize: 24,
    fontWeight: FontWeight.normal,
    color: AppColors.textPrimary,
  );

  static const titleLarge = TextStyle(
    fontSize: 22,
    fontWeight: FontWeight.w500,
    color: AppColors.textPrimary,
  );

  static const titleMedium = TextStyle(
    fontSize: 16,
    fontWeight: FontWeight.w500,
    color: AppColors.textPrimary,
  );

  static const titleSmall = TextStyle(
    fontSize: 14,
    fontWeight: FontWeight.w500,
    color: AppColors.textPrimary,
  );

  static const bodyLarge = TextStyle(
    fontSize: 16,
    fontWeight: FontWeight.normal,
    color: AppColors.textPrimary,
  );

  static const bodyMedium = TextStyle(
    fontSize: 14,
    fontWeight: FontWeight.normal,
    color: AppColors.textPrimary,
  );

  static const bodySmall = TextStyle(
    fontSize: 12,
    fontWeight: FontWeight.normal,
    color: AppColors.textSecondary,
  );

  static const labelLarge = TextStyle(
    fontSize: 14,
    fontWeight: FontWeight.w500,
    color: AppColors.textPrimary,
  );

  static const labelMedium = TextStyle(
    fontSize: 12,
    fontWeight: FontWeight.w500,
    color: AppColors.textPrimary,
  );

  static const labelSmall = TextStyle(
    fontSize: 11,
    fontWeight: FontWeight.w500,
    color: AppColors.textSecondary,
  );
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\theme\app_theme.dart
-----------------------------------
import 'package:flutter/material.dart';

import 'app_colors.dart';
import 'app_sizes.dart';
import 'app_text_styles.dart';

/// Application Theme
class AppTheme {
  /// 鑾峰彇鏆楄壊涓婚
  static ThemeData dark() {
    return ThemeData.dark().copyWith(
      colorScheme: ColorScheme.dark(
        primary: AppColors.primary,
        onPrimary: Colors.white,
        secondary: AppColors.secondary,
        onSecondary: Colors.white,
        surface: Colors.grey[850]!,
        onSurface: Colors.white,
        error: AppColors.error,
        onError: Colors.white,
      ),
    );
  }

  /// 鑾峰彇浜壊涓婚
  static ThemeData light() {
    return ThemeData.light().copyWith(
      colorScheme: const ColorScheme.light(
        primary: AppColors.primary,
        onPrimary: Colors.white,
        secondary: AppColors.secondary,
        onSecondary: Colors.white,
        surface: AppColors.surface,
        onSurface: AppColors.textPrimary,
        error: AppColors.error,
        onError: Colors.white,
      ),
      scaffoldBackgroundColor: AppColors.background,
      cardTheme: CardTheme(
        elevation: AppSizes.cardElevation,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(AppSizes.cardRadius),
        ),
      ),
      textTheme: const TextTheme(
        displayLarge: AppTextStyles.displayLarge,
        displayMedium: AppTextStyles.displayMedium,
        displaySmall: AppTextStyles.displaySmall,
        headlineLarge: AppTextStyles.headlineLarge,
        headlineMedium: AppTextStyles.headlineMedium,
        headlineSmall: AppTextStyles.headlineSmall,
        titleLarge: AppTextStyles.titleLarge,
        titleMedium: AppTextStyles.titleMedium,
        titleSmall: AppTextStyles.titleSmall,
        bodyLarge: AppTextStyles.bodyLarge,
        bodyMedium: AppTextStyles.bodyMedium,
        bodySmall: AppTextStyles.bodySmall,
        labelLarge: AppTextStyles.labelLarge,
        labelMedium: AppTextStyles.labelMedium,
        labelSmall: AppTextStyles.labelSmall,
      ),
      dividerTheme: const DividerThemeData(
        color: AppColors.divider,
        space: 1,
      ),
      iconTheme: const IconThemeData(
        color: AppColors.iconPrimary,
        size: AppSizes.iconMedium,
      ),
      inputDecorationTheme: InputDecorationTheme(
        border: OutlineInputBorder(
          borderRadius: BorderRadius.circular(AppSizes.r4),
        ),
        contentPadding: const EdgeInsets.symmetric(
          horizontal: AppSizes.p12,
          vertical: AppSizes.p8,
        ),
      ),
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\tools\generate_code.dart
-----------------------------------
import 'dart:io';

void main() async {
  print('Running build_runner to generate code files...');

  // Clean first to ensure we don't have stale files
  final cleanResult = await Process.run(
    'flutter',
    ['pub', 'run', 'build_runner', 'clean'],
    runInShell: true,
  );

  if (cleanResult.exitCode != 0) {
    print('Error during clean:');
    print(cleanResult.stderr);
    return;
  }

  print('Clean successful. Building generated files...');

  // Build with delete-conflicting-outputs flag to handle conflicts
  final buildResult = await Process.run(
    'flutter',
    ['pub', 'run', 'build_runner', 'build', '--delete-conflicting-outputs'],
    runInShell: true,
  );

  if (buildResult.exitCode != 0) {
    print('Error during build:');
    print(buildResult.stderr);
    return;
  }

  print('Build successful. Generated files are ready!');
  print(buildResult.stdout);
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\tools\debug\path_visualizer.dart
-----------------------------------
import 'dart:async';
import 'dart:ui' as ui;

import 'package:flutter/material.dart';

/// 璺緞鍙鍖栬皟璇曞伐鍏?- 甯姪璇婃柇璺緞闂
class PathVisualizer {
  static bool isEnabled = true;

  /// 鍙鍖朠ath瀵硅薄骞朵繚瀛樺埌Widget
  static Widget pathToWidget(
    Path path, {
    Size size = const Size(300, 300),
    Color pathColor = Colors.red,
    double strokeWidth = 2.0,
  }) {
    return FutureBuilder<ui.Image>(
      future: visualizePath(path, size,
          pathColor: pathColor, strokeWidth: strokeWidth),
      builder: (context, snapshot) {
        if (snapshot.connectionState == ConnectionState.waiting) {
          return const SizedBox(
            width: 50,
            height: 50,
            child: CircularProgressIndicator(),
          );
        }

        if (!snapshot.hasData) {
          return const SizedBox(
            width: 50,
            height: 50,
            child: Icon(Icons.error),
          );
        }

        return RawImage(
          image: snapshot.data,
          width: size.width,
          height: size.height,
          fit: BoxFit.contain,
        );
      },
    );
  }

  /// 灏哖ath瀵硅薄鍙鍖栦负鍥剧墖
  static Future<ui.Image> visualizePath(
    Path path,
    Size size, {
    Color pathColor = Colors.red,
    double strokeWidth = 2.0,
    Color backgroundColor = Colors.white,
  }) async {
    if (!isEnabled) {
      // 鍒涘缓1x1鐨勭┖鐧藉浘鍍?
      final recorder = ui.PictureRecorder();
      final picture = recorder.endRecording();
      return picture.toImage(1, 1);
    }

    final recorder = ui.PictureRecorder();
    final canvas = Canvas(recorder);

    // 缁樺埗鑳屾櫙
    canvas.drawRect(
      Offset.zero & size,
      Paint()..color = backgroundColor,
    );

    // 缁樺埗缃戞牸
    _drawGrid(canvas, size);

    // 缁樺埗璺緞
    canvas.drawPath(
      path,
      Paint()
        ..color = pathColor
        ..strokeWidth = strokeWidth
        ..style = PaintingStyle.stroke
        ..strokeCap = StrokeCap.round
        ..strokeJoin = StrokeJoin.round,
    );

    // 鑾峰彇璺緞鐨勮竟鐣岀偣
    final bounds = path.getBounds();

    // 缁樺埗杈圭晫鐭╁舰
    canvas.drawRect(
      bounds,
      Paint()
        ..color = Colors.blue.withOpacity(0.3)
        ..style = PaintingStyle.fill,
    );

    // 缁樺埗杈圭晫淇℃伅鏂囨湰
    final textPainter = TextPainter(
      text: TextSpan(
        text: '杈圭晫: (${bounds.left.toInt()},${bounds.top.toInt()}) '
            '${bounds.width.toInt()}x${bounds.height.toInt()}',
        style: const TextStyle(color: Colors.black, fontSize: 12),
      ),
      textDirection: TextDirection.ltr,
    );
    textPainter.layout();
    textPainter.paint(canvas, const Offset(10, 10));

    final picture = recorder.endRecording();
    return await picture.toImage(size.width.toInt(), size.height.toInt());
  }

  /// 缁樺埗璋冭瘯缃戞牸
  static void _drawGrid(Canvas canvas, Size size) {
    final paint = Paint()
      ..color = Colors.grey.withOpacity(0.2)
      ..strokeWidth = 0.5;

    // 缁樺埗鍨傜洿绾?
    for (double x = 0; x <= size.width; x += 20) {
      canvas.drawLine(
        Offset(x, 0),
        Offset(x, size.height),
        paint,
      );
    }

    // 缁樺埗姘村钩绾?
    for (double y = 0; y <= size.height; y += 20) {
      canvas.drawLine(
        Offset(0, y),
        Offset(size.width, y),
        paint,
      );
    }
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\tools\erase\erase_controller.dart
-----------------------------------
import 'package:flutter/material.dart';

import '../../domain/models/character/path_info.dart';
import '../../utils/path/path_utils.dart';
import 'erase_state.dart';

/// 鎿﹂櫎宸ュ叿鎺у埗鍣紝绠＄悊鎿﹂櫎鐘舵€佸拰鎿嶄綔
class EraseController with ChangeNotifier {
  static const _notifyThreshold = 5;
  static const _maxNotifyInterval = Duration(milliseconds: 33);

  final EraseState _state = EraseState();
  PathInfo? _currentPath;
  List<PathInfo> _paths = [];
  List<PathInfo> _redoPaths = [];

  Offset? _lastPoint;
  bool _isInPanMode = false;
  DateTime _lastModeChangeTime = DateTime.now();
  int _pendingPointCount = 0;
  DateTime _lastNotifyTime = DateTime.now();

  // Get the brush color - based on invert and image invert modes
  Color get brushColor {
    final baseColor = _state.invertMode ? Colors.black : Colors.white;

    // If image is inverted, we need to invert the brush color too
    // to maintain the correct erasing behavior
    if (_state.imageInvertMode) {
      return baseColor == Colors.white ? Colors.black : Colors.white;
    }

    return baseColor;
  }

  double get brushSize => _state.brushSize;
  set brushSize(double value) {
    if (_state.brushSize != value) {
      _state.brushSize = value;
      notifyListeners();
    }
  }

  bool get canRedo => _redoPaths.isNotEmpty;
  bool get canUndo => _paths.isNotEmpty;
  bool get imageInvertMode => _state.imageInvertMode;

  // Override the existing imageInvertMode setter
  set imageInvertMode(bool value) {
    if (_state.imageInvertMode != value) {
      _state.imageInvertMode = value;
      // Only update the current path if it exists, don't refresh previous paths
      _updateCurrentPathColor();
      notifyListeners();
    }
  }

  bool get invertMode => _state.invertMode;

  // Override the existing invertMode setter
  set invertMode(bool value) {
    if (_state.invertMode != value) {
      _state.invertMode = value;
      // Only update the current path if it exists, don't refresh previous paths
      _updateCurrentPathColor();
      notifyListeners();
    }
  }

  bool get isInPanMode => _isInPanMode;

  bool get outlineMode => _state.outlineMode;

  set outlineMode(bool value) {
    _state.outlineMode = value;
    notifyListeners();
  }

  set panMode(bool value) {
    if (_isInPanMode != value) {
      _isInPanMode = value;
      _lastModeChangeTime = DateTime.now();
      if (!_isInPanMode && _currentPath != null) {
        endErase();
      }
      notifyListeners();
    }
  }

  void clearPaths() {
    if (_paths.isNotEmpty || _currentPath != null) {
      _paths = [];
      _redoPaths = [];
      _currentPath = null;
      notifyListeners();
    }
  }

  void endErase() {
    if (_currentPath != null) {
      print('缁撴潫褰撳墠鎿﹂櫎璺緞');
      try {
        final bounds = _currentPath!.path.getBounds();
        if (!bounds.isEmpty) {
          _paths.add(_currentPath!);
          _redoPaths.clear();
          print('娣诲姞鎿﹂櫎璺緞 - bounds: $bounds');
        }
      } catch (e) {
        print('缁撴潫鎿﹂櫎璺緞鍑洪敊: $e');
      }
      _currentPath = null;
      notifyListeners();
    }
  }

  dynamic getFinalResult() {
    final pathsData = _paths
        .map((pathInfo) => {
              'path': pathInfo.path,
              'brushSize': pathInfo.brushSize,
              'brushColor': pathInfo.brushColor.value, // 纭繚棰滆壊鍊兼纭繚瀛?
            })
        .toList();

    return {
      'paths': pathsData,
      'invertMode': invertMode,
      'imageInvertMode': imageInvertMode,
      'outlineMode': outlineMode,
    };
  }

  List<PathInfo> getPaths() {
    final result = List<PathInfo>.from(_paths);
    if (_currentPath != null) {
      result.add(_currentPath!);
    }
    return result;
  }

  void handleClickErase(Offset position) {
    if (_isInPanMode) return;

    try {
      final path = PathUtils.createSolidCircle(
        position,
        brushSize / 2,
      );

      _currentPath = PathInfo(
        path: path,
        brushSize: brushSize,
        brushColor: brushColor,
      );

      _paths.add(_currentPath!);
      _redoPaths.clear();
      _currentPath = null;

      notifyListeners();
    } catch (e) {
      print('鍗曞嚮鎿﹂櫎鍑洪敊: $e');
    }
  }

  void redo() {
    if (_redoPaths.isNotEmpty) {
      final path = _redoPaths.removeLast();
      _paths.add(path);
      notifyListeners();
    }
  }

  // Replace the existing refreshPathColors method with a simpler version
  // that only logs the change but doesn't modify existing paths
  void refreshPathColors() {
    print('Brush color changed to: $brushColor');
    // No longer modifying existing paths
  }

  void startErase(Offset position) {
    if (_isInPanMode) return;

    if (_currentPath != null) {
      endErase();
    }

    try {
      final path = PathUtils.createSolidCircle(
        position,
        brushSize / 2,
      );

      _currentPath = PathInfo(
        path: path,
        brushSize: brushSize,
        brushColor: brushColor,
      );

      _lastPoint = position;
      notifyListeners();
    } catch (e) {
      print('寮€濮嬫摝闄ゅ嚭閿? $e');
    }
  }

  void undo() {
    if (_paths.isNotEmpty) {
      final path = _paths.removeLast();
      _redoPaths.add(path);
      notifyListeners();
    }
  }

  void updateErase(Offset position) {
    if (_isInPanMode || _currentPath == null || _lastPoint == null) return;

    try {
      // 杩炴帴涓婁竴涓偣鍜屽綋鍓嶇偣浣嶇疆锛岀敓鎴愬疄蹇冭矾寰?
      final gapPath = PathUtils.createSolidGap(
        _lastPoint!,
        position,
        brushSize,
      );

      // 鍚堝苟鍒板綋鍓嶈矾寰?
      _currentPath!.path.addPath(gapPath, Offset.zero);
      _lastPoint = position;

      _pendingPointCount++;

      final now = DateTime.now();
      if (_pendingPointCount >= _notifyThreshold ||
          now.difference(_lastNotifyTime) >= _maxNotifyInterval) {
        _lastNotifyTime = now;
        _pendingPointCount = 0;
        notifyListeners();
      }
    } catch (e) {
      print('鏇存柊鎿﹂櫎璺緞鏃跺嚭閿? $e');
    }
  }

  // New method to update only the current path color if needed
  void _updateCurrentPathColor() {
    // Only update current path if it exists
    if (_currentPath != null) {
      final currentColor = brushColor;

      if (_currentPath!.brushColor != currentColor) {
        _currentPath = PathInfo(
          path: _currentPath!.path,
          brushSize: _currentPath!.brushSize,
          brushColor: currentColor,
        );
      }
    }
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\tools\erase\erase_state.dart
-----------------------------------
import 'package:flutter/material.dart';

/// 鎿﹂櫎妯″紡鏋氫妇
enum EraseMode {
  normal, // 鏅€氭摝闄?
  outline, // 鎻忚竟妯″紡
  invert, // 鍙嶈浆妯″紡
}

/// 鎿﹂櫎宸ュ叿鐘舵€?
class EraseState {
  // 鐢荤瑪澶у皬
  double brushSize = 10.0;

  // 绗斿埛棰滆壊鍙嶈浆锛堟摝鐧藉彉鎴愭摝榛戯級
  bool invertMode = false;

  // 鍥惧儚鍙嶈浆
  bool imageInvertMode = false;

  // 鏄惁鎻忚竟妯″紡
  bool outlineMode = false;

  // 褰撳墠娲诲姩妯″紡
  EraseMode mode = EraseMode.normal;

  // 鑾峰彇褰撳墠鐢荤瑪棰滆壊 - 鍩轰簬妯″紡
  Color get brushColor => invertMode ? Colors.black : Colors.white;

  // 澶嶅埗鐘舵€?
  EraseState copy() {
    final newState = EraseState()
      ..brushSize = brushSize
      ..invertMode = invertMode
      ..outlineMode = outlineMode
      ..imageInvertMode = imageInvertMode
      ..mode = mode;

    return newState;
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\tools\image\image_utils.dart
-----------------------------------
import 'dart:async';
import 'dart:math' as math;
import 'dart:ui' as ui;

import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';

/// 鍥惧儚澶勭悊宸ュ叿绫?
class ImageUtils {
  /// 灏嗗瓧鑺傛暟鎹浆鎹负UI Image
  static Future<ui.Image> bytesToImage(Uint8List bytes) async {
    final Completer<ui.Image> completer = Completer();
    ui.decodeImageFromList(bytes, completer.complete);
    return completer.future;
  }

  /// 瑁佸壀鍥惧儚鍖哄煙
  static Future<ui.Image> cropImage(ui.Image source, Rect rect) async {
    // 纭繚鍖哄煙鏈夋晥
    final safeRect = Rect.fromLTRB(
        math.max(0, rect.left),
        math.max(0, rect.top),
        math.min(source.width.toDouble(), rect.right),
        math.min(source.height.toDouble(), rect.bottom));

    // 浣跨敤Canvas鍜孭ictureRecorder杩涜瑁佸壀
    final recorder = ui.PictureRecorder();
    final canvas = Canvas(recorder);

    canvas.drawImageRect(source, safeRect,
        Rect.fromLTWH(0, 0, safeRect.width, safeRect.height), Paint());

    final picture = recorder.endRecording();
    return await picture.toImage(
        safeRect.width.round(), safeRect.height.round());
  }

  /// 灏哢I Image杞崲涓哄瓧鑺傛暟鎹?
  static Future<Uint8List?> imageToBytes(ui.Image image,
      {ui.ImageByteFormat format = ui.ImageByteFormat.png}) async {
    final ByteData? byteData = await image.toByteData(format: format);
    if (byteData == null) return null;
    return byteData.buffer.asUint8List();
  }

  /// 鍦ㄥ紓姝ユ搷浣滀腑澶勭悊鍥惧儚锛岄伩鍏嶉樆濉濽I绾跨▼
  static Future<ui.Image> processImageAsync(
      ui.Image image, Future<ui.Image> Function(ui.Image) processor) async {
    // 灏嗗浘鍍忚浆鎹负瀛楄妭
    final bytes = await imageToBytes(image);
    if (bytes == null) throw Exception('Failed to convert image to bytes');

    // 鍦╥solate涓鐞?
    final processedImage = await compute((Uint8List imageBytes) async {
      // 鍦╥solate涓浆鎹㈠洖鍥惧儚
      final img = await bytesToImage(imageBytes);
      // 澶勭悊鍥惧儚
      return await processor(img);
    }, bytes);

    return processedImage;
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\utils\chinese_helper.dart
-----------------------------------
/// Utility class for handling Chinese character operations
class ChineseHelper {
  /// The regular expression pattern for matching Chinese characters using Unicode ranges
  static final RegExp _chineseRegex = RegExp(
    r'[\u{4E00}-\u{9FFF}\u{3400}-\u{4DBF}\u{20000}-\u{2A6DF}\u{2A700}-\u{2B73F}\u{2B740}-\u{2B81F}\u{2B820}-\u{2CEAF}]',
    unicode: true,
  );

  /// Checks if a string contains Chinese characters
  static bool containsChinese(String text) {
    if (text.isEmpty) return false;
    return _chineseRegex.hasMatch(text);
  }

  /// Counts the number of Chinese characters in a string
  static int countChineseCharacters(String text) {
    if (text.isEmpty) return 0;
    return _chineseRegex.allMatches(text).length;
  }

  /// Extracts Chinese characters from the given text
  /// Returns a string containing only Chinese characters
  static String extractChineseCharacters(String text) {
    if (text.isEmpty) return '';

    StringBuffer result = StringBuffer();
    Iterable<Match> matches = _chineseRegex.allMatches(text);

    for (Match match in matches) {
      result.write(match.group(0));
    }

    return result.toString();
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\utils\coordinate_transformer.dart
-----------------------------------
import 'dart:math' as math;

import 'package:flutter/material.dart';
import 'package:vector_math/vector_math_64.dart';

import '../infrastructure/logging/logger.dart';

/// 鍧愭爣杞崲宸ュ叿绫?- 浣跨敤宸︿笂瑙掍綔涓哄師鐐圭殑瀹炵幇
class CoordinateTransformer {
  final TransformationController transformationController;
  final Size imageSize;
  final Size viewportSize;
  final bool enableLogging;

  // 缂撳瓨鍙橀噺
  late double _baseScale;
  late final Offset _viewportCenter;

  CoordinateTransformer({
    required this.transformationController,
    required this.imageSize,
    required this.viewportSize,
    this.enableLogging = false,
  }) {
    _viewportCenter = Offset(viewportSize.width / 2, viewportSize.height / 2);
    _calculateBaseScale();
    if (enableLogging) {
      _logInitialization();
    }
  }

  /// 鏇存柊瀹為檯鍋忕Щ閲?- 鑰冭檻瀹為檯缂╂斁姣旂殑褰卞搷
  Offset get actualOffset {
    final offset = currentOffset;
    final acScale = actualScale;
    return Offset(offset.dx / acScale, offset.dy / acScale);
  }

  /// 鏇存柊瀹為檯缂╂斁姣?
  double get actualScale => currentScale * baseScale;

  /// 鑾峰彇鍩虹缂╂斁姣斾緥 - 浣垮浘鍍忓垰濂介€傚簲瑙嗗彛
  double get baseScale => _baseScale;

  /// 鑾峰彇褰撳墠鍋忕Щ閲?- 鐩存帴浠庡彉鎹㈢煩闃垫彁鍙?
  Offset get currentOffset {
    final matrix = transformationController.value;
    return Offset(matrix.entry(0, 3), matrix.entry(1, 3));
  }

  /// 鑾峰彇褰撳墠缂╂斁姣斾緥 - 浠庡彉鎹㈢煩闃典腑鎻愬彇
  double get currentScale {
    final matrix = transformationController.value;
    return matrix.getMaxScaleOnAxis();
  }

  /// 鑾峰彇鍥惧儚鍦ㄨ鍙ｄ腑鐨勬樉绀哄尯鍩?
  Rect get displayRect {
    final matrix = transformationController.value;

    // 浣跨敤鐭╅樀鍙樻崲璁＄畻鍥涗釜瑙掔殑浣嶇疆
    final topLeft = _transformPoint(Offset.zero, matrix);
    final topRight = _transformPoint(Offset(imageSize.width, 0), matrix);
    final bottomLeft = _transformPoint(Offset(0, imageSize.height), matrix);
    final bottomRight =
        _transformPoint(Offset(imageSize.width, imageSize.height), matrix);

    // 鎵惧嚭杈圭晫
    final left = math.min(math.min(topLeft.dx, topRight.dx),
        math.min(bottomLeft.dx, bottomRight.dx));
    final top = math.min(math.min(topLeft.dy, topRight.dy),
        math.min(bottomLeft.dy, bottomRight.dy));
    final right = math.max(math.max(topLeft.dx, topRight.dx),
        math.max(bottomLeft.dx, bottomRight.dx));
    final bottom = math.max(math.max(topLeft.dy, topRight.dy),
        math.max(bottomLeft.dy, bottomRight.dy));

    return Rect.fromLTRB(left, top, right, bottom);
  }

  /// 璁＄畻缃戞牸绾?
  /// 杩斿洖涓€涓亸绉婚噺鍒楄〃锛屾瘡涓や釜鐐规瀯鎴愪竴鏉＄嚎
  /// gridSize: 缃戞牸澶у皬(鍍忕礌)
  List<Offset> calculateGridLines(double gridSize) {
    final List<Offset> lines = [];
    final scale = currentScale;
    final scaledGridSize = gridSize * scale;
    final rect = displayRect;

    // 璁＄畻缃戞牸鑼冨洿
    final startX = (rect.left / scaledGridSize).floor() * scaledGridSize;
    final endX = (rect.right / scaledGridSize).ceil() * scaledGridSize;
    final startY = (rect.top / scaledGridSize).floor() * scaledGridSize;
    final endY = (rect.bottom / scaledGridSize).ceil() * scaledGridSize;

    // 鍨傜洿绾?
    for (double x = startX; x <= endX; x += scaledGridSize) {
      lines.add(Offset(x, startY));
      lines.add(Offset(x, endY));
    }

    // 姘村钩绾?
    for (double y = startY; y <= endY; y += scaledGridSize) {
      lines.add(Offset(startX, y));
      lines.add(Offset(endX, y));
    }

    if (enableLogging) {
      AppLogger.debug('鐢熸垚缃戞牸绾?, data: {
        'gridSize': gridSize,
        'scaledGridSize': scaledGridSize.toStringAsFixed(2),
        'lineCount': (lines.length ~/ 2).toInt(),
      });
    }

    return lines;
  }

  /// 浠嶱reviewCanvas涓縼绉荤殑璁＄畻鍥惧儚鍦ㄨ鍙ｄ腑鏄剧ず鍖哄煙鐨勬柟娉?
  Rect calculateImageRectInViewport() {
    // 璁＄畻鍥惧儚鍦ㄨ鍙ｄ腑鐨勬樉绀哄尯鍩?
    final matrix = transformationController.value;
    final topLeft = imageToViewportCoordinate(Offset.zero);
    final bottomRight = imageToViewportCoordinate(
      Offset(imageSize.width, imageSize.height),
    );

    return Rect.fromPoints(topLeft, bottomRight);
  }

  /// 鍥惧儚鐭╁舰杞崲涓鸿鍙ｇ煩褰?
  Rect imageRectToViewportRect(Rect imageRect) {
    if (enableLogging) {
      AppLogger.debug('銆愬潗鏍囪浆鎹€戝皢鍥惧儚鐭╁舰杞崲涓鸿鍙ｇ煩褰?, data: {
        'imageRect':
            '${imageRect.left},${imageRect.top},${imageRect.width}x${imageRect.height}',
        'imageSize': '${imageSize.width}x${imageSize.height}',
        'viewportSize': '${viewportSize.width}x${viewportSize.height}',
      });
    }

    try {
      // 1. 妫€鏌ヨ緭鍏ョ煩褰㈡槸鍚︽湁鏁?
      if (imageRect.isEmpty || imageRect.width < 0 || imageRect.height < 0) {
        throw ArgumentError('鏃犳晥鐨勮緭鍏ョ煩褰? $imageRect');
      }

      // 2. 纭繚杈撳叆鐭╁舰鍦ㄥ浘鍍忚寖鍥村唴
      final clampedImageRect = Rect.fromLTRB(
        imageRect.left.clamp(0.0, imageSize.width),
        imageRect.top.clamp(0.0, imageSize.height),
        imageRect.right.clamp(0.0, imageSize.width),
        imageRect.bottom.clamp(0.0, imageSize.height),
      );

      // 3. 杞崲鐭╁舰鐨勮鐐?
      final topLeft = imageToViewportCoordinate(clampedImageRect.topLeft);
      final bottomRight =
          imageToViewportCoordinate(clampedImageRect.bottomRight);

      // 4. 鍒涘缓瑙嗗彛鐭╁舰骞剁‘淇濆湪瑙嗗彛鑼冨洿鍐?
      final viewportRect = Rect.fromPoints(topLeft, bottomRight)
          .intersect(Offset.zero & viewportSize);

      if (enableLogging) {
        AppLogger.debug('銆愬潗鏍囪浆鎹€戣浆鎹㈢粨鏋?, data: {
          'viewportRect':
              '${viewportRect.left},${viewportRect.top},${viewportRect.width}x${viewportRect.height}',
          'actualScale': actualScale.toStringAsFixed(3),
        });
      }

      return viewportRect;
    } catch (e) {
      AppLogger.error('銆愬潗鏍囪浆鎹€戝浘鍍忕煩褰㈣浆鎹㈠け璐?, error: e);
      // 鍙戠敓閿欒鏃惰繑鍥炰竴涓畨鍏ㄧ殑榛樿鍊?- 瑙嗗彛涓績鐨?x1鐭╁舰
      return Rect.fromCenter(
        center: Offset(viewportSize.width / 2, viewportSize.height / 2),
        width: 1,
        height: 1,
      );
    }
  }

  /// 鍥惧儚鍧愭爣杞崲涓鸿鍙ｅ潗鏍?
  Offset imageToViewportCoordinate(Offset imageCoord) {
    if (enableLogging) {
      AppLogger.debug('銆愬潗鏍囪浆鎹€戝皢鍥惧儚鍧愭爣杞崲涓鸿鍙ｅ潗鏍? ${imageCoord.dx},${imageCoord.dy}');
    }

    // 1. 搴旂敤缂╂斁
    final acScale = actualScale;
    final scaledOffset = Offset(
      imageCoord.dx * acScale,
      imageCoord.dy * acScale,
    );

    // 2. 搴旂敤骞崇Щ锛屽緱鍒版渶缁堣鍙ｅ潗鏍?
    final viewportRect = Offset(
        scaledOffset.dx + currentOffset.dx, scaledOffset.dy + currentOffset.dy);

    if (enableLogging) {
      AppLogger.debug('銆愬潗鏍囪浆鎹€戣鍥锯啋瑙嗗彛: '
          '(${imageCoord.dx.toStringAsFixed(1)},${imageCoord.dy.toStringAsFixed(1)}) 鈫?'
          '(${viewportRect.dx.toStringAsFixed(1)},${viewportRect.dy.toStringAsFixed(1)})'
          ' [scale=$acScale, offset=${currentOffset.dx.toStringAsFixed(1)},${currentOffset.dy.toStringAsFixed(1)}]');
    }

    return viewportRect;
  }

  /// 璁板綍鍧愭爣杞崲杩囩▼ - 鐢ㄤ簬璋冭瘯
  void logCoordinateConversion(Offset viewportPoint) {
    if (!enableLogging) return;

    final imagePoint = viewportToViewCoordinate(viewportPoint);
    final scale = actualScale;

    AppLogger.debug('鍧愭爣杞崲璇︽儏', data: {
      'viewport': '${viewportPoint.dx.toInt()},${viewportPoint.dy.toInt()}',
      'image': '${imagePoint.dx.toInt()},${imagePoint.dy.toInt()}',
      'currentScale': currentScale.toStringAsFixed(2),
      'baseScale': baseScale.toStringAsFixed(2),
      'actualScale': scale.toStringAsFixed(2),
      'offset':
          '${currentOffset.dx.toStringAsFixed(1)},${currentOffset.dy.toStringAsFixed(1)}',
    });
  }

  /// 榧犳爣鐐瑰嚮鍧愭爣锛堢浉瀵圭粍浠跺乏涓婅锛夌洿鎺ヨ浆鎹负鍥惧儚鍧愭爣
  Offset mouseToViewCoordinate(Offset mousePoint) {
    try {
      if (enableLogging) {
        AppLogger.debug(
            '銆愬潗鏍囪浆鎹€戝皢榧犳爣鍧愭爣杞崲涓哄浘鍍忓潗鏍? ${mousePoint.dx},${mousePoint.dy}');
      }

      // 鐩存帴浣跨敤榧犳爣鍧愭爣浣滀负瑙嗗彛鍧愭爣
      final adjustedPoint = mousePoint;

      AppLogger.debug('銆愬潗鏍囪浆鎹€戦紶鏍囧潗鏍囪浆鎹负瑙嗗彛鍧愭爣(鐩稿涓績鐐?: '
          '(${mousePoint.dx},${mousePoint.dy}) 鈫?'
          '(${adjustedPoint.dx},${adjustedPoint.dy})');

      return viewportToViewCoordinate(adjustedPoint);
    } catch (e) {
      AppLogger.error('銆愬潗鏍囪浆鎹€戦紶鏍囧潗鏍囪浆鎹负鍥惧儚鍧愭爣澶辫触', error: e);
      return Offset.zero;
    }
  }

  /// 閲嶆柊璁＄畻鍩虹缂╂斁姣斾緥 - 鐢ㄤ簬瑙嗗彛灏哄鍙樺寲鏃?
  void recalculateBaseScale() {
    _calculateBaseScale();
    if (enableLogging) {
      AppLogger.debug('閲嶆柊璁＄畻鍩虹缂╂斁姣斾緥', data: {
        'newBaseScale': _baseScale.toStringAsFixed(3),
      });
    }
  }

  Rect viewportRectToImageRect(Rect viewportRect) {
    if (enableLogging) {
      AppLogger.debug(
          '銆愮煩褰㈣浆鎹€戝皢瑙嗗彛鐭╁舰杞崲涓哄浘鍍忕煩褰? ${viewportRect.left},${viewportRect.top},${viewportRect.width}x${viewportRect.height}');
    }
    final topLeft = viewportToViewCoordinate(viewportRect.topLeft);
    final bottomRight = viewportToViewCoordinate(viewportRect.bottomRight);

    final viewRect = Rect.fromPoints(topLeft, bottomRight);
    final imageRect = viewRectToImageRect(viewRect);
    if (enableLogging) {
      AppLogger.debug(
          '銆愮煩褰㈣浆鎹€戣浆鎹㈢粨鏋? ${imageRect.left},${imageRect.top},${imageRect.width}x${imageRect.height}');
    }

    return imageRect;
  }

  /// 浠嶱reviewCanvas._transformToImageCoordinates杩佺Щ
  /// 灏嗚鍙ｅ潗鏍囪浆鎹负鍥惧儚鍧愭爣锛岃€冭檻浜嗗綋鍓嶅彉鎹㈠拰璁惧鍍忕礌姣?
  Offset viewportToImageCoordinate(Offset viewportOffset) {
    // 1. 鍩虹杞崲 - 浠嶱reviewCanvas杩佺Щ
    final matrix = transformationController.value.clone();
    final vector = Matrix4.inverted(matrix)
        .transform3(Vector3(viewportOffset.dx, viewportOffset.dy, 0));
    final basicTransform = Offset(vector.x, vector.y);

    // 2. 澧炲己鍔熻兘 - 璁惧鍍忕礌姣斿鐞?
    return basicTransform;
  }

  /// 瑙嗗彛鍧愭爣杞崲涓哄浘鍍忓潗鏍?
  /// 鎸夌収鍏紡: Xview = (Xviewport/ActualScaleX) - ActualOffsetX
  Offset viewportToViewCoordinate(Offset viewportPoint) {
    try {
      if (enableLogging) {
        AppLogger.debug(
            '銆愬潗鏍囪浆鎹€戝皢瑙嗗彛鍧愭爣杞崲涓哄浘鍍忓潗鏍? ${viewportPoint.dx},${viewportPoint.dy}');
      }

      // 璁＄畻瀹為檯缂╂斁姣斾緥
      final actualScale = currentScale * baseScale;

      // 璁＄畻瀹為檯鍋忕Щ閲?
      final actualOffset = Offset(
        currentOffset.dx / actualScale,
        currentOffset.dy / actualScale,
      );

      AppLogger.debug('銆愬潗鏍囪浆鎹€戣绠楀弬鏁?, data: {
        'currentScale': currentScale.toStringAsFixed(3),
        'baseScale': baseScale.toStringAsFixed(3),
        'actualScale': actualScale.toStringAsFixed(3),
        'currentOffset': '${currentOffset.dx},${currentOffset.dy}',
        'actualOffset': '${actualOffset.dx},${actualOffset.dy}',
      });

      // 搴旂敤杞崲鍏紡: Xview = (Xviewport/ActualScaleX) - ActualOffsetX
      final viewCoordinate = Offset(
        viewportPoint.dx / actualScale - actualOffset.dx,
        viewportPoint.dy / actualScale - actualOffset.dy,
      );

      AppLogger.debug('銆愬潗鏍囪浆鎹€戣浆鎹㈢粨鏋?, data: {
        'viewportPoint': '${viewportPoint.dx},${viewportPoint.dy}',
        'viewCoordinate': '${viewCoordinate.dx},${viewCoordinate.dy}',
      });

      return viewCoordinate;
    } catch (e) {
      AppLogger.error('銆愬潗鏍囪浆鎹€戣鍙ｅ潗鏍囪浆鎹负鍥惧儚鍧愭爣澶辫触', error: e);
      return Offset.zero;
    }
  }

  Rect viewRectToImageRect(Rect viewRect) {
    if (enableLogging) {
      AppLogger.debug(
          '銆愬潗鏍囪浆鎹€戝皢瑙嗗浘鐭╁舰杞崲涓哄浘鍍忕煩褰? ${viewRect.left},${viewRect.top},${viewRect.width}x${viewRect.height}');
    }

    // 鐩存帴浣跨敤瑙嗗浘鍧愭爣浣滀负鍥惧儚鍧愭爣
    return Rect.fromLTWH(
        viewRect.left, viewRect.top, viewRect.width, viewRect.height);
  }

  /// 璁＄畻鍩虹缂╂斁姣斾緥
  /// 鏍规嵁鍏紡:
  /// if (ViewportHeight/ViewportWidth < ImageHeight/ImageWidth):
  ///     BaseScale = ViewportWidth/ImageWidth
  /// else:
  ///     BaseScale = ViewportHeight/ImageHeight
  void _calculateBaseScale() {
    final viewportRatio = viewportSize.width / viewportSize.height;
    final imageRatio = imageSize.width / imageSize.height;

    if (viewportRatio < imageRatio) {
      // 瀹藉害閫傞厤 - 鍥惧儚瀹藉害鍏呮弧瑙嗗彛瀹藉害
      _baseScale = viewportSize.width / imageSize.width;
    } else {
      // 楂樺害閫傞厤 - 鍥惧儚楂樺害鍏呮弧瑙嗗彛楂樺害
      _baseScale = viewportSize.height / imageSize.height;
    }

    if (enableLogging) {
      AppLogger.debug('鍩虹缂╂斁璁＄畻', data: {
        'viewportRatio': viewportRatio.toStringAsFixed(3),
        'imageRatio': imageRatio.toStringAsFixed(3),
        'mode': viewportRatio < imageRatio ? '瀹藉害閫傞厤' : '楂樺害閫傞厤',
        'baseScale': _baseScale.toStringAsFixed(3),
      });
    }
  }

  /// 璁板綍鍒濆鍖栦俊鎭?
  void _logInitialization() {
    AppLogger.debug('鍧愭爣杞崲鍣ㄥ垵濮嬪寲', data: {
      'imageSize': '${imageSize.width}x${imageSize.height}',
      'viewportSize': '${viewportSize.width}x${viewportSize.height}',
      'baseScale': _baseScale.toStringAsFixed(3),
      'viewportCenter': '${_viewportCenter.dx},${_viewportCenter.dy}',
    });
  }

  /// 搴旂敤鐭╅樀鍙樻崲鍒扮偣 - 杈呭姪鏂规硶
  Offset _transformPoint(Offset point, Matrix4 transform) {
    // 鐩存帴浣跨敤鐐瑰潗鏍?
    final vector = Vector3(point.dx, point.dy, 0.0);

    // 搴旂敤鍙樻崲
    final transformed = transform.transform3(vector);

    // 杩斿洖鍙樻崲鍚庣殑鍧愭爣
    return Offset(transformed.x, transformed.y);
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\utils\date_formatter.dart
-----------------------------------
import 'package:intl/intl.dart';

class DateFormatter {
  static final _compactFormatter = DateFormat('yyyy/MM/dd');
  static final _fullFormatter = DateFormat('yyyy骞碝M鏈坉d鏃?);
  static final _timeFormatter = DateFormat('HH:mm');

  /// Format date to compact format: 2024/02/22
  static String formatCompact(DateTime date) {
    return _compactFormatter.format(date);
  }

  /// Format date to full format: 2024骞?2鏈?2鏃?
  static String formatFull(DateTime date) {
    return _fullFormatter.format(date);
  }

  /// Format date with time: 2024/02/22 14:30
  static String formatWithTime(DateTime date) {
    return '${formatCompact(date)} ${_timeFormatter.format(date)}';
  }

  /// Format relative date: 浠婂ぉ/鏄ㄥぉ/鍓嶅ぉ/鏃ユ湡
  static String formatRelative(DateTime date) {
    final now = DateTime.now();
    final difference = now.difference(date);

    if (difference.inDays == 0) {
      return '浠婂ぉ';
    } else if (difference.inDays == 1) {
      return '鏄ㄥぉ';
    } else if (difference.inDays == 2) {
      return '鍓嶅ぉ';
    } else {
      return formatCompact(date);
    }
  }
}


C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\utils\date_time_helper.dart
-----------------------------------
/// UTC鏃ユ湡鏃堕棿澶勭悊宸ュ叿绫?
class DateTimeHelper {
  /// 鏍煎紡鍖栨棩鏈熻寖鍥存煡璇㈡潯浠?
  static Map<String, String> formatDateRange(DateTime start, DateTime end) {
    return {
      'start': toStorageFormat(start)!,
      'end': toStorageFormat(end)!,
    };
  }

  /// 浠庡瓨鍌ㄦ牸寮忚В鏋?
  static DateTime? fromStorageFormat(String? utcString) {
    if (utcString == null) return null;
    return DateTime.parse(utcString).toLocal();
  }

  /// 鑾峰彇褰撳墠UTC鏃堕棿瀛楃涓?
  static String getCurrentUtc() {
    return DateTime.now().toUtc().toIso8601String();
  }

  /// 妫€鏌ユ槸鍚︿负鏈夋晥鐨刄TC ISO8601瀛楃涓?
  static bool isValidUtcString(String? value) {
    if (value == null) return false;
    try {
      DateTime.parse(value);
      return value.endsWith('Z');
    } catch (e) {
      return false;
    }
  }

  /// 鏃堕棿鎴宠浆UTC瀛楃涓?
  static String? timestampToUtc(int? timestamp) {
    if (timestamp == null) return null;
    return DateTime.fromMillisecondsSinceEpoch(timestamp)
        .toUtc()
        .toIso8601String();
  }

  /// 杞崲涓哄瓨鍌ㄦ牸寮?UTC ISO8601)
  static String? toStorageFormat(DateTime? dateTime) {
    if (dateTime == null) return null;
    return dateTime.toUtc().toIso8601String();
  }

  /// UTC瀛楃涓茶浆鏃堕棿鎴?
  static int? utcToTimestamp(String? utcString) {
    if (utcString == null) return null;
    return DateTime.parse(utcString).millisecondsSinceEpoch;
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\utils\diagnostic_helper.dart
-----------------------------------
import 'dart:async';

import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../infrastructure/logging/logger.dart';
import '../presentation/providers/work_browse_provider.dart';

/// 甯姪璇婃柇搴旂敤绋嬪簭闂鐨勫伐鍏风被
class DiagnosticHelper {
  /// 璇婃柇WorkBrowseProvider鐨勭姸鎬?
  static void diagnoseWorkBrowseState(WidgetRef ref) {
    final state = ref.read(workBrowseProvider);

    AppLogger.info('WorkBrowseState璇婃柇', tag: 'Diagnostics', data: {
      'isLoading': state.isLoading,
      'hasError': state.error != null,
      'errorMsg': state.error,
      'worksCount': state.works.length,
      'viewMode': state.viewMode.toString(),
      'isSidebarOpen': state.isSidebarOpen,
      'searchQuery': state.searchQuery,
    });

    // 灏濊瘯妫€鏌ユ暟鎹姞杞介棶棰?
    try {
      // 灏濊瘯鐩存帴鍔犺浇
      ref.read(workBrowseProvider.notifier).loadWorks(forceRefresh: true);
    } catch (e, stack) {
      AppLogger.error('璇婃柇鏃堕噸鏂板姞杞藉け璐?,
          tag: 'Diagnostics', error: e, stackTrace: stack);
    }
  }

  /// 鑾峰彇搴旂敤鐘舵€佸揩鐓?
  static Map<String, dynamic> getAppStateSnapshot(WidgetRef ref) {
    final snapshot = <String, dynamic>{};

    try {
      final browseState = ref.read(workBrowseProvider);
      snapshot['workBrowseState'] = {
        'isLoading': browseState.isLoading,
        'hasError': browseState.error != null,
        'worksCount': browseState.works.length,
      };
    } catch (e) {
      snapshot['workBrowseStateError'] = e.toString();
    }

    return snapshot;
  }

  /// 杩愯璇婃柇浠诲姟锛屽寘鍚秴鏃朵繚鎶?
  static Future<T> runWithDiagnostics<T>(
    Future<T> Function() task, {
    String taskName = '鏈懡鍚嶄换鍔?,
    Duration timeout = const Duration(seconds: 10),
  }) async {
    try {
      AppLogger.debug('寮€濮嬩换鍔? $taskName', tag: 'Diagnostics');
      final Stopwatch stopwatch = Stopwatch()..start();

      final result = await task().timeout(timeout, onTimeout: () {
        AppLogger.warning('浠诲姟瓒呮椂: $taskName', tag: 'Diagnostics');
        throw TimeoutException('浠诲姟 $taskName 瓒呮椂');
      });

      stopwatch.stop();
      AppLogger.debug('瀹屾垚浠诲姟: $taskName',
          tag: 'Diagnostics', data: {'鑰楁椂(ms)': stopwatch.elapsedMilliseconds});

      return result;
    } catch (e, stack) {
      AppLogger.error('浠诲姟鎵ц澶辫触: $taskName',
          tag: 'Diagnostics', error: e, stackTrace: stack);
      rethrow;
    }
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\utils\file_size_formatter.dart
-----------------------------------
import 'dart:math' as math;

/// 鏂囦欢澶у皬鏍煎紡鍖栧伐鍏?
class FileSizeFormatter {
  /// 鏍煎紡鍖栨枃浠跺ぇ灏?
  ///
  /// [bytes] 瀛楄妭鏁?
  /// [decimals] 灏忔暟浣嶆暟
  static String format(int bytes, [int decimals = 2]) {
    if (bytes <= 0) return '0 B';

    const suffixes = ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];
    var i = (math.log(bytes) / math.log(1024)).floor();
    i = i < suffixes.length ? i : suffixes.length - 1;

    return '${(bytes / math.pow(1024, i)).toStringAsFixed(decimals)} ${suffixes[i]}';
  }

  /// 浠ュ瓧鑺備负鍗曚綅鏍煎紡鍖?
  static String formatBytes(int bytes) => '$bytes B';

  /// 浠B涓哄崟浣嶆牸寮忓寲
  static String formatGB(int bytes) =>
      '${(bytes / (1024 * 1024 * 1024)).toStringAsFixed(2)} GB';

  /// 浠B涓哄崟浣嶆牸寮忓寲
  static String formatKB(int bytes) =>
      '${(bytes / 1024).toStringAsFixed(2)} KB';

  /// 浠B涓哄崟浣嶆牸寮忓寲
  static String formatMB(int bytes) =>
      '${(bytes / (1024 * 1024)).toStringAsFixed(2)} MB';
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\utils\route_observer_helper.dart
-----------------------------------
import 'package:flutter/material.dart';

import '../infrastructure/logging/logger.dart';

/// 璺敱瑙傚療鑰咃紝鐢ㄤ簬璇婃柇瀵艰埅闂
class AppRouteObserver extends NavigatorObserver {
  @override
  void didPop(Route<dynamic> route, Route<dynamic>? previousRoute) {
    AppLogger.debug('璺敱琚脊鍑?, tag: 'Navigation', data: {
      'route': route.settings.name ?? route.toString(),
      'previousRoute': previousRoute?.settings.name ?? previousRoute.toString(),
    });
    super.didPop(route, previousRoute);
  }

  @override
  void didPush(Route<dynamic> route, Route<dynamic>? previousRoute) {
    AppLogger.debug('璺敱琚帹鍏?, tag: 'Navigation', data: {
      'route': route.settings.name ?? route.toString(),
      'previousRoute': previousRoute?.settings.name ?? previousRoute.toString(),
    });
    super.didPush(route, previousRoute);
  }

  @override
  void didRemove(Route<dynamic> route, Route<dynamic>? previousRoute) {
    AppLogger.debug('璺敱琚Щ闄?, tag: 'Navigation', data: {
      'route': route.settings.name ?? route.toString(),
      'previousRoute': previousRoute?.settings.name ?? previousRoute.toString(),
    });
    super.didRemove(route, previousRoute);
  }

  @override
  void didReplace({Route<dynamic>? newRoute, Route<dynamic>? oldRoute}) {
    AppLogger.debug('璺敱琚浛鎹?, tag: 'Navigation', data: {
      'newRoute': newRoute?.settings.name ?? newRoute.toString(),
      'oldRoute': oldRoute?.settings.name ?? oldRoute.toString(),
    });
    super.didReplace(newRoute: newRoute, oldRoute: oldRoute);
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\utils\safe_metadata_helper.dart
-----------------------------------
import 'dart:convert';

import 'package:flutter/foundation.dart';

/// 鐢ㄤ簬瀹夊叏澶勭悊鍏冩暟鎹殑宸ュ叿绫?
class SafeMetadataHelper {
  /// 瀹夊叏鍦拌幏鍙栨爣绛惧垪琛?
  static List<String> getTags(dynamic metadata) {
    try {
      if (metadata == null) {
        return [];
      }

      Map<String, dynamic> metadataMap;

      if (metadata is String) {
        metadataMap = parseMetadata(metadata);
      } else if (metadata is Map) {
        metadataMap = Map<String, dynamic>.from(metadata);
      } else {
        return [];
      }

      if (metadataMap.containsKey('tags') && metadataMap['tags'] is List) {
        final dynamicTags = metadataMap['tags'] as List;
        // 鏄惧紡杞崲涓?List<String>
        return dynamicTags.map<String>((item) => item.toString()).toList();
      }
    } catch (e) {
      debugPrint('Error getting tags: $e');
    }

    return [];
  }

  /// 瀹夊叏鍦拌В鏋愬厓鏁版嵁 JSON 瀛楃涓?
  static Map<String, dynamic> parseMetadata(dynamic rawMetadata) {
    if (rawMetadata == null) {
      return {'tags': []};
    }

    try {
      if (rawMetadata is String) {
        if (rawMetadata.isEmpty || rawMetadata == 'null') {
          return {'tags': []};
        }
        return jsonDecode(rawMetadata) as Map<String, dynamic>;
      } else if (rawMetadata is Map) {
        return Map<String, dynamic>.from(rawMetadata);
      }
    } catch (e) {
      debugPrint('Error parsing metadata: $e');
    }

    return {'tags': []};
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\utils\throttle_helper.dart
-----------------------------------
import 'dart:async';

/// 鐢ㄤ簬鎺у埗棰戠箒鎿嶄綔鐨勮妭娴佸姪鎵嬬被
class ThrottleHelper {
  Timer? _throttleTimer;
  DateTime _lastExecutionTime =
      DateTime.now().subtract(const Duration(minutes: 1));
  bool _isExecuting = false;
  final Duration _minInterval;

  ThrottleHelper({Duration minInterval = const Duration(milliseconds: 300)})
      : _minInterval = minInterval;

  /// 鍙栨秷褰撳墠棰勫畾鐨勮妭娴佹搷浣?
  void cancel() {
    _throttleTimer?.cancel();
  }

  /// 閲嶇疆鑺傛祦鍣ㄧ姸鎬?
  void reset() {
    _throttleTimer?.cancel();
    _lastExecutionTime = DateTime.now().subtract(const Duration(minutes: 1));
    _isExecuting = false;
  }

  /// 鎵ц鑺傛祦鎿嶄綔锛岄槻姝㈢煭鏃堕棿鍐呴噸澶嶆墽琛?
  ///
  /// [operation] 瑕佹墽琛岀殑鎿嶄綔
  /// [priority] 浼樺厛绾э紝杈冮珮鐨勪紭鍏堢骇鍙互鎵撴柇浣庝紭鍏堢骇
  /// [forceExecute] 鏄惁寮哄埗鎵ц锛屽拷鐣ヨ妭娴侀檺鍒?
  Future<T> throttle<T>(
    Future<T> Function() operation, {
    int priority = 0,
    bool forceExecute = false,
    String? operationName,
  }) async {
    // 鍙栨秷浠讳綍鐜版湁鐨勫畾鏃跺櫒
    _throttleTimer?.cancel();

    // 妫€鏌ユ槸鍚﹀彲浠ョ珛鍗虫墽琛?
    final now = DateTime.now();
    final timeSinceLastExecution = now.difference(_lastExecutionTime);
    final canExecuteNow = forceExecute ||
        (!_isExecuting && timeSinceLastExecution > _minInterval);

    if (canExecuteNow) {
      try {
        _isExecuting = true;
        _lastExecutionTime = now;
        return await operation();
      } finally {
        _isExecuting = false;
      }
    } else {
      // 濡傛灉涓嶈兘绔嬪嵆鎵ц锛岃缃畾鏃跺櫒
      final completer = Completer<T>();
      final remainingTime = _minInterval - timeSinceLastExecution;

      _throttleTimer = Timer(remainingTime, () async {
        try {
          if (!completer.isCompleted) {
            _isExecuting = true;
            _lastExecutionTime = DateTime.now();
            final result = await operation();
            completer.complete(result);
          }
        } catch (e) {
          if (!completer.isCompleted) {
            completer.completeError(e);
          }
        } finally {
          _isExecuting = false;
        }
      });

      return completer.future;
    }
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\utils\color\color_extensions.dart
-----------------------------------
import 'dart:ui';

import 'package:image/image.dart' as img;

/// 棰滆壊杞崲鎵╁睍鏂规硶
extension ColorConversionExt on img.ColorRgb8 {
  /// 浠嶤olor鍒涘缓ColorRgb8
  static img.ColorRgb8 fromColor(Color color) {
    return img.ColorRgb8(color.red, color.green, color.blue);
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\utils\color\color_utils.dart
-----------------------------------
import 'package:flutter/material.dart';

/// Utility class for color operations
class ColorUtils {
  /// Gets a contrasting color (for text/borders against a background)
  static Color getContrastingColor(Color backgroundColor) {
    // Calculate luminance - if the background is light, return dark text color and vice versa
    return backgroundColor.computeLuminance() > 0.5
        ? Colors.black.withOpacity(0.8)
        : Colors.white.withOpacity(0.8);
  }

  /// Get the appropriate foreground color for a given background
  static Color getForegroundColor(Color backgroundColor) {
    return isLightColor(backgroundColor) ? Colors.black : Colors.white;
  }

  /// Inverts a color
  static Color invertColor(Color color) {
    return Color.fromARGB(
      color.alpha,
      255 - color.red,
      255 - color.green,
      255 - color.blue,
    );
  }

  /// Checks if a color is considered "light"
  static bool isLightColor(Color color) {
    return color.computeLuminance() > 0.5;
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\utils\debug\contour_analyzer.dart
-----------------------------------
import 'dart:math' as math;
import 'dart:ui';

import 'package:flutter/foundation.dart';
import 'package:image/image.dart' as img;

/// 杞粨鍒嗘瀽宸ュ叿 - 鐢ㄤ簬璋冭瘯杞粨妫€娴嬬畻娉?
class ContourAnalyzer {
  /// 鍒嗘瀽杞粨骞剁敓鎴愯皟璇曞浘鍍?
  static Uint8List analyzeContour(List<List<Offset>> contours, Size imageSize,
      {String? title, Map<int, String>? endpointReasons}) {
    if (kDebugMode) {
      print('寮€濮嬪垎鏋愯疆寤?..');
      print('鍥惧儚灏哄: ${imageSize.width} x ${imageSize.height}');
      print('杞粨鏁伴噺: ${contours.length}');
    }

    // 鍒涘缓鍥惧儚
    final image = img.Image(
        width: imageSize.width.toInt(), height: imageSize.height.toInt());

    // 濉厖鐧借壊鑳屾櫙
    img.fill(image, color: img.ColorRgba8(255, 255, 255, 255));

    // 缁樺埗杞粨
    for (int i = 0; i < contours.length; i++) {
      final contour = contours[i];

      // 閫夋嫨涓嶅悓鐨勯鑹?
      final hue = (i * 45) % 360;
      final color = _hsvToRgb(hue.toDouble(), 1.0, 1.0);

      // 璁板綍杩欐潯杞粨鐨勪俊鎭?
      if (kDebugMode) {
        print('杞粨 #$i: ${contour.length} 涓偣');

        if (contour.isNotEmpty) {
          print('  璧风偣: (${contour.first.dx}, ${contour.first.dy})');
          print('  缁堢偣: (${contour.last.dx}, ${contour.last.dy})');

          // 鏄剧ず缁堢偣鍘熷洜锛堝鏋滄彁渚涳級
          final reason = endpointReasons?[i];
          if (reason != null) {
            print('  缁堢偣鍘熷洜: $reason');
          }
        }
      }

      // 缁樺埗杞粨绾?
      if (contour.length > 1) {
        for (int j = 1; j < contour.length; j++) {
          final p1 = contour[j - 1];
          final p2 = contour[j];
          _drawLine(image, p1.dx, p1.dy, p2.dx, p2.dy, color);
        }

        // 鏍囪璧风偣鍜岀粓鐐?
        _drawStartPoint(
            image, contour.first.dx.toInt(), contour.first.dy.toInt());
        _drawEndPoint(image, contour.last.dx.toInt(), contour.last.dy.toInt());

        // 缁樺埗杞粨缂栧彿
        _drawNumber(image, i, contour.first.dx.toInt() + 5,
            contour.first.dy.toInt() + 5, img.ColorRgba8(0, 0, 0, 255));

        // 娣诲姞缁堢偣鍘熷洜鏍囩锛堝鏋滄彁渚涳級
        final reason = endpointReasons?[i];
        if (reason != null) {
          _drawText(
              image,
              '鍘熷洜: ${reason.substring(0, math.min(reason.length, 20))}',
              contour.last.dx.toInt() + 5,
              contour.last.dy.toInt() + 5,
              img.ColorRgba8(255, 0, 0, 255));
        }
      }
    }

    // 濡傛灉鏈夋爣棰橈紝缁樺埗鍦ㄥ浘鍍忛《閮?
    if (title != null) {
      _drawText(image, title, 10, 10, img.ColorRgba8(0, 0, 0, 255));
    }

    // 灏嗗浘鍍忕紪鐮佷负PNG
    return Uint8List.fromList(img.encodePng(image));
  }

  // 缁樺埗瀛楃
  static void _drawChar(
      img.Image image, String char, int x, int y, img.Color color) {
    // 杩欓噷鍙槸涓€涓畝鍗曠殑瀹炵幇锛屽彲浠ユ墿灞曚负鏇村畬鏁寸殑瀛楃闆?
    final String pattern = {
          'A': '01100100110011111001100110',
          'B': '11110100101111010010111100',
          'C': '01110100010001000100011100',
          'D': '11110100101001010010111100',
          'E': '11111000011110100001111100',
          'F': '11111000011110100001000000',
          '0': '01100100110011001100101100',
          '1': '00100011000010000100011100',
          '2': '01100100100001000100011110',
          '3': '01100100100001001001001100',
          '4': '10001000110001111000010000',
          '5': '11110100001110000011111000',
          '6': '01110100001111010001001110',
          '7': '11110000100010001000100000',
          '8': '01100100100110010010011000',
          '9': '01100100100111000010011000',
          ':': '00000010000000001000000000',
          ' ': '00000000000000000000000000',
          '-': '00000000001110000000000000',
          '_': '00000000000000000000111110',
        }[char.toUpperCase()] ??
        '00100010001000000001000000'; // 榛樿涓?i'

    int index = 0;
    for (int row = 0; row < 5; row++) {
      for (int col = 0; col < 5; col++) {
        if (pattern[index] == '1') {
          final px = x + col;
          final py = y + row;
          if (px >= 0 && px < image.width && py >= 0 && py < image.height) {
            image.setPixel(px, py, color);
          }
        }
        index++;
      }
    }
  }

  // 缁樺埗缁堢偣鏍囪锛堢孩鑹瞂锛?
  static void _drawEndPoint(img.Image image, int x, int y) {
    const size = 3;
    final color = img.ColorRgba8(255, 0, 0, 255); // 绾㈣壊

    // 缁樺埗X
    for (int i = -size; i <= size; i++) {
      final px1 = x + i;
      final py1 = y + i;
      final px2 = x + i;
      final py2 = y - i;

      if (px1 >= 0 && px1 < image.width && py1 >= 0 && py1 < image.height) {
        image.setPixel(px1, py1, color);
      }

      if (px2 >= 0 && px2 < image.width && py2 >= 0 && py2 < image.height) {
        image.setPixel(px2, py2, color);
      }
    }
  }

  // 缁樺埗绾挎潯
  static void _drawLine(img.Image image, double x1, double y1, double x2,
      double y2, img.Color color) {
    // 浣跨敤Bresenham绠楁硶缁樺埗绾挎
    int x1Int = x1.round(), y1Int = y1.round();
    int x2Int = x2.round(), y2Int = y2.round();

    int dx = (x2Int - x1Int).abs();
    int dy = (y2Int - y1Int).abs();
    int sx = x1Int < x2Int ? 1 : -1;
    int sy = y1Int < y2Int ? 1 : -1;
    int err = dx - dy;

    while (true) {
      // 妫€鏌ヨ竟鐣屽苟璁剧疆鍍忕礌
      if (x1Int >= 0 &&
          x1Int < image.width &&
          y1Int >= 0 &&
          y1Int < image.height) {
        image.setPixel(x1Int, y1Int, color);
      }

      if (x1Int == x2Int && y1Int == y2Int) break;

      int e2 = 2 * err;
      if (e2 > -dy) {
        err -= dy;
        x1Int += sx;
      }

      if (e2 < dx) {
        err += dx;
        y1Int += sy;
      }
    }
  }

  // 缁樺埗鏍囪鐐?
  static void _drawMarker(img.Image image, int x, int y, img.Color color) {
    const radius = 2;
    for (int dy = -radius; dy <= radius; dy++) {
      for (int dx = -radius; dx <= radius; dx++) {
        if (dx * dx + dy * dy <= radius * radius) {
          final px = x + dx;
          final py = y + dy;
          if (px >= 0 && px < image.width && py >= 0 && py < image.height) {
            image.setPixel(px, py, color);
          }
        }
      }
    }
  }

  // 鍦ㄥ浘鍍忎笂缁樺埗鏁板瓧
  static void _drawNumber(
      img.Image image, int number, int x, int y, img.Color color) {
    _drawText(image, number.toString(), x, y, color);
  }

  // 缁樺埗璧风偣鏍囪锛堢豢鑹插渾鍦堬級
  static void _drawStartPoint(img.Image image, int x, int y) {
    const radius = 3;
    final color = img.ColorRgba8(0, 255, 0, 255); // 缁胯壊

    // 缁樺埗鍦嗗湀
    for (int dy = -radius; dy <= radius; dy++) {
      for (int dx = -radius; dx <= radius; dx++) {
        if ((dx * dx + dy * dy <= radius * radius) &&
            (dx * dx + dy * dy > (radius - 1) * (radius - 1))) {
          final px = x + dx;
          final py = y + dy;
          if (px >= 0 && px < image.width && py >= 0 && py < image.height) {
            image.setPixel(px, py, color);
          }
        }
      }
    }
  }

  // 缁樺埗鏂囨湰
  static void _drawText(
      img.Image image, String text, int x, int y, img.Color color) {
    const charWidth = 6; // 姣忎釜瀛楃鐨勫搴?
    int offsetX = 0;

    for (int i = 0; i < text.length; i++) {
      _drawChar(image, text[i], x + offsetX, y, color);
      offsetX += charWidth;
    }
  }

  // HSV杞琑GB
  static img.Color _hsvToRgb(double h, double s, double v) {
    h = h % 360;
    double c = v * s;
    double x = c * (1 - (((h / 60) % 2) - 1).abs());
    double m = v - c;

    double r, g, b;
    if (h < 60) {
      r = c;
      g = x;
      b = 0;
    } else if (h < 120) {
      r = x;
      g = c;
      b = 0;
    } else if (h < 180) {
      r = 0;
      g = c;
      b = x;
    } else if (h < 240) {
      r = 0;
      g = x;
      b = c;
    } else if (h < 300) {
      r = x;
      g = 0;
      b = c;
    } else {
      r = c;
      g = 0;
      b = x;
    }

    int red = ((r + m) * 255).round();
    int green = ((g + m) * 255).round();
    int blue = ((b + m) * 255).round();

    return img.ColorRgba8(red, green, blue, 255);
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\utils\debug\coordinate_debug.dart
-----------------------------------
import 'package:flutter/material.dart';

/// 鍧愭爣绯荤粺璋冭瘯宸ュ叿绫?
class CoordinateDebug {
  // 鍚敤鎴栫鐢ㄦ棩蹇?
  static bool enabled = true;

  // 鍦ㄧ敾甯冧笂鏄剧ず璋冭瘯鍧愭爣
  static void drawDebugPoint(Canvas canvas, Offset position,
      {Color color = Colors.red}) {
    if (!enabled) return;

    final paint = Paint()
      ..color = color
      ..style = PaintingStyle.fill;

    // 缁樺埗涓€涓皬鍦嗙偣鏍囪浣嶇疆
    canvas.drawCircle(position, 5.0, paint);

    // 缁樺埗鍧愭爣鏂囧瓧
    final textPainter = TextPainter(
      text: TextSpan(
        text: '(${position.dx.toInt()},${position.dy.toInt()})',
        style: const TextStyle(color: Colors.black, fontSize: 10),
      ),
      textDirection: TextDirection.ltr,
    );
    textPainter.layout();
    textPainter.paint(canvas, position + const Offset(10, -10));
  }

  // 璁板綍鐐瑰嚮浜嬩欢
  static void logPointerEvent(String action, Offset position, [Offset? delta]) {
    if (!enabled) return;

    String message = '[$action] 浣嶇疆: $position';
    if (delta != null) {
      message += ', 澧為噺: $delta';
    }
    print(message);
  }

  // 鏃ュ織鍧愭爣杞崲
  static void logTransform(String tag, Offset from, Offset to) {
    if (!enabled) return;

    print(
        '[$tag] 鍧愭爣杞崲: $from -> $to (宸紓: ${(to - from).distance.toStringAsFixed(2)})');
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\utils\debug\debug_flags.dart
-----------------------------------
import 'dart:ui';

/// 搴旂敤绋嬪簭璋冭瘯鏍囧織宸ュ叿
class DebugFlags {
  /// 鏄惁鍚敤鎿﹂櫎璋冭瘯
  static bool enableEraseDebug = false;

  /// 鏄惁鍚敤鍧愭爣杞崲璋冭瘯
  static bool enableCoordinateDebug = false;

  /// 鏄惁鍚敤鎬ц兘鐩戞帶
  static bool enablePerformanceMonitoring = false;

  /// 鏄惁鍚敤浜嬩欢杩借釜
  static bool enableEventTracing = false;

  /// 鍚敤妯″紡鐘舵€佽窡韪?
  static bool enableModeTracking = true;

  /// 鍚敤鐒︾偣璋冭瘯
  static bool enableFocusDebug = true;

  /// 娣诲姞褰撳墠搴旂敤涓墍鏈堿ltKey鐘舵€佺洃鎺х偣
  static final Map<String, bool> _altKeyStates = {};

  /// 璁板綍璋冭瘯淇℃伅
  static void log(String tag, String message) {
    print('馃攳 [$tag] $message');
  }

  /// 璁板綍鎿﹂櫎浜嬩欢
  static void logErase(String action, Offset position, [Offset? delta]) {
    if (!enableEraseDebug) return;

    String msg = '$action - 浣嶇疆: $position';
    if (delta != null) {
      msg += ', delta: $delta';
    }
    log('鎿﹂櫎', msg);
  }

  /// 璁板綍鐒︾偣鐘舵€佸彉鍖?
  static void logFocusChange(String source, bool hasFocus) {
    if (!enableFocusDebug) return;
    log('鐒︾偣', '$source ${hasFocus ? "鑾峰緱鐒︾偣" : "澶卞幓鐒︾偣"}');
  }

  /// 璁板綍妯″紡鍒囨崲
  static void logModeChange(bool altKeyPressed) {
    if (!enableEraseDebug) return;

    final mode = altKeyPressed ? '骞崇Щ妯″紡' : '鎿﹂櫎妯″紡';
    log('妯″紡鍒囨崲', '褰撳墠涓?mode');
  }

  /// Log paint operation details
  static void logPaintOperation(String type, Rect bounds, {String? details}) {
    if (!enableEraseDebug) return;

    log(
        'Paint',
        '$type at ${bounds.left.toInt()},${bounds.top.toInt()} '
            'size ${bounds.width.toInt()}x${bounds.height.toInt()} '
            '${details != null ? '- $details' : ''}');
  }

  /// 璁板綍骞崇Щ浜嬩欢
  static void logPan(Offset position, Offset delta) {
    if (!enableEraseDebug) return;

    log('骞崇Щ', '浣嶇疆: $position, 澧為噺: $delta');
  }

  /// 璁板綍AltKey鐘舵€佸彉鍖?
  static void trackAltKeyState(String source, bool isPressed) {
    if (!enableModeTracking) return;

    _altKeyStates[source] = isPressed;
    log('AltKey', '$source 璁剧疆涓? ${isPressed ? "鎸変笅" : "閲婃斁"}');

    // 妫€鏌ユ槸鍚﹀瓨鍦ㄤ笉涓€鑷寸殑鐘舵€?
    _checkConsistency();
  }

  /// 妫€鏌ュ悇澶凙lt鐘舵€佹槸鍚︿竴鑷?
  static void _checkConsistency() {
    if (_altKeyStates.isEmpty || _altKeyStates.length < 2) return;

    // 鑾峰彇绗竴涓€间綔涓哄弬鑰?
    final firstValue = _altKeyStates.values.first;

    // 妫€鏌ユ槸鍚︽墍鏈夊€奸兘涓庣涓€涓€间竴鑷?
    bool allConsistent = _altKeyStates.values.every((v) => v == firstValue);

    if (!allConsistent) {
      log('AltKey', '鈿狅笍 鐘舵€佷笉涓€鑷? $_altKeyStates');
    }
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\utils\debug\event_log_analyzer.dart
-----------------------------------
/// 浜嬩欢鏃ュ織鍒嗘瀽宸ュ叿 - 甯姪杩借釜鍜屽垎鏋愪簨浠舵祦
class EventLogAnalyzer {
  static const int maxLogs = 100;
  static final List<EventLogEntry> _eventLogs = [];
  static bool enabled = true;

  /// 鍒嗘瀽鏈€杩戠殑浜嬩欢搴忓垪锛屽鎵鹃棶棰?
  static void analyzeEventSequence() {
    if (!enabled || _eventLogs.isEmpty) return;

    print('===== 浜嬩欢搴忓垪鍒嗘瀽 =====');

    // 妫€鏌ラ紶鏍囦簨浠跺簭鍒?
    bool foundStartWithoutEnd = false;
    bool foundUpdateWithoutStart = false;
    bool foundInvalidSequence = false;

    String? lastEventType;
    for (final log in _eventLogs) {
      if (log.eventType == 'pointerDown') {
        if (lastEventType == 'pointerDown') {
          print('鈿狅笍 妫€娴嬪埌杩炵画鐨刾ointerDown浜嬩欢锛屽彲鑳界己灏憄ointerUp');
          foundInvalidSequence = true;
        }
        lastEventType = 'pointerDown';
      } else if (log.eventType == 'pointerMove') {
        if (lastEventType == null) {
          print('鈿狅笍 妫€娴嬪埌pointerMove娌℃湁鍓嶇疆pointerDown');
          foundUpdateWithoutStart = true;
        }
      } else if (log.eventType == 'pointerUp') {
        if (lastEventType == null) {
          print('鈿狅笍 妫€娴嬪埌pointerUp娌℃湁鍓嶇疆pointerDown');
          foundInvalidSequence = true;
        }
        lastEventType = null;
      }
    }

    // 鍒嗘瀽浜嬩欢寤惰繜
    if (_eventLogs.length >= 2) {
      final delays = <Duration>[];
      for (int i = 1; i < _eventLogs.length; i++) {
        delays.add(
            _eventLogs[i].timestamp.difference(_eventLogs[i - 1].timestamp));
      }

      final avgDelay = delays.fold<Duration>(
              Duration.zero,
              (a, b) => Duration(
                  microseconds: a.inMicroseconds + b.inMicroseconds)) ~/
          delays.length;

      print('骞冲潎浜嬩欢闂撮殧: ${avgDelay.inMilliseconds}ms');
      if (avgDelay.inMilliseconds > 20) {
        print('鈿狅笍 浜嬩欢闂撮殧杩囬暱锛屽彲鑳藉奖鍝嶅搷搴旀€?);
      }
    }

    print('======== 鍒嗘瀽缁撴潫 ========');
  }

  /// 娓呯┖鏃ュ織
  static void clearLogs() {
    _eventLogs.clear();
  }

  /// 鑾峰彇浜嬩欢鏃ュ織
  static List<EventLogEntry> getLogs() {
    return List.from(_eventLogs);
  }

  /// 娣诲姞浜嬩欢鏃ュ織
  static void logEvent(String eventType, Map<String, dynamic> data) {
    if (!enabled) return;

    final log = EventLogEntry(
      timestamp: DateTime.now(),
      eventType: eventType,
      data: Map.from(data),
    );

    _eventLogs.add(log);
    if (_eventLogs.length > maxLogs) {
      _eventLogs.removeAt(0);
    }

    print('馃摑 浜嬩欢: $eventType, 鏁版嵁: ${data.toString()}');
  }
}

/// 浜嬩欢鏃ュ織鏉＄洰
class EventLogEntry {
  final DateTime timestamp;
  final String eventType;
  final Map<String, dynamic> data;

  const EventLogEntry({
    required this.timestamp,
    required this.eventType,
    required this.data,
  });

  @override
  String toString() {
    return '[${timestamp.hour}:${timestamp.minute}:${timestamp.second}.${timestamp.millisecond}] $eventType: $data';
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\utils\debug\path_debug_utils.dart
-----------------------------------
import 'dart:ui' as ui;

import 'package:flutter/material.dart';

/// 璺緞璋冭瘯宸ュ叿绫?
class PathDebugUtils {
  static bool debugEnabled = true;

  /// 鎵撳嵃璺緞淇℃伅
  static void printPathsInfo(List<Map<String, dynamic>> paths) {
    if (!debugEnabled) return;

    print('==== 璺緞淇℃伅 ====');
    print('璺緞鎬绘暟: ${paths.length}');

    for (int i = 0; i < paths.length; i++) {
      final pathData = paths[i];
      final points = pathData['points'] as List<Offset>;
      final brushSize = (pathData['brushSize'] as num).toDouble();

      print('璺緞 #$i:');
      print('  鐐规暟: ${points.length}');
      print('  绗斿埛澶у皬: $brushSize');

      if (points.isNotEmpty) {
        print('  璧风偣: ${points.first}');
        print('  缁堢偣: ${points.last}');

        // 璁＄畻璺緞鎬婚暱搴?
        double totalLength = 0;
        for (int j = 1; j < points.length; j++) {
          totalLength += (points[j] - points[j - 1]).distance;
        }
        print('  闀垮害: ${totalLength.toStringAsFixed(1)}');
      }
    }

    print('================');
  }

  /// 鍥惧儚璋冭瘯 - 鍦ㄧ嫭绔嬬敾甯冧笂缁樺埗璺緞鐢ㄤ簬璋冭瘯
  static Future<ui.Image> visualizePaths(
      List<Map<String, dynamic>> paths, Size size,
      {Color background = Colors.white}) async {
    if (!debugEnabled) return _createEmptyImage(1, 1);

    final recorder = ui.PictureRecorder();
    final canvas = Canvas(recorder);

    // 缁樺埗鑳屾櫙
    canvas.drawRect(Offset.zero & size, Paint()..color = background);

    // 缁樺埗姣忎釜璺緞
    for (final pathData in paths) {
      final points = pathData['points'] as List<Offset>;
      final brushSize = (pathData['brushSize'] as num).toDouble();

      if (points.length < 2) continue;

      final path = Path();
      path.moveTo(points.first.dx, points.first.dy);

      for (int i = 1; i < points.length; i++) {
        path.lineTo(points[i].dx, points[i].dy);
      }

      canvas.drawPath(
          path,
          Paint()
            ..color = Colors.red
            ..style = PaintingStyle.stroke
            ..strokeWidth = brushSize
            ..strokeCap = StrokeCap.round
            ..strokeJoin = StrokeJoin.round);

      // 缁樺埗璧风偣鍜岀粓鐐规爣璁?
      _drawPointMarker(canvas, points.first, Colors.green);
      _drawPointMarker(canvas, points.last, Colors.blue);
    }

    // 杞崲涓哄浘鍍?
    final picture = recorder.endRecording();
    return await picture.toImage(size.width.ceil(), size.height.ceil());
  }

  /// 鍒涘缓绌哄浘鍍?
  static Future<ui.Image> _createEmptyImage(int width, int height) async {
    final recorder = ui.PictureRecorder();
    final canvas = Canvas(recorder);
    final picture = recorder.endRecording();
    return picture.toImage(width, height);
  }

  /// 缁樺埗鐐规爣璁?
  static void _drawPointMarker(Canvas canvas, Offset point, Color color) {
    canvas.drawCircle(point, 3.0, Paint()..color = color);
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\utils\debug\path_tracer.dart
-----------------------------------
import 'dart:ui';

import 'package:flutter/material.dart';

/// 璺緞璋冭瘯璺熻釜鍣?- 甯姪妫€娴嬭矾寰勫垱寤哄拰浣跨敤涓殑闂
class PathTracer {
  static bool enabled = true;
  static int _counter = 0;
  static final Map<int, _PathInfo> _trackedPaths = {};

  /// 娣诲姞璺緞鎿嶄綔
  static void addOperation(Path path, String operation, {dynamic data}) {
    if (!enabled) return;

    final id = path.hashCode;
    final info = _trackedPaths[id];
    if (info != null) {
      info.operations.add('$operation: $data');
      info.pointCount++;

      if (info.pointCount % 10 == 0) {
        print('馃攳 璺緞鏇存柊 #$id - 鐐规暟: ${info.pointCount} - $operation');
      }
    }
  }

  /// 寮€濮嬭窡韪柊璺緞
  static void beginPath(Path path, {String? source}) {
    if (!enabled) return;

    final id = path.hashCode;
    _trackedPaths[id] = _PathInfo(
      id: id,
      createdAt: DateTime.now(),
      source: source ?? 'unknown',
      pointCount: 0,
      operations: [],
    );

    _counter++;
    print('馃攳 璺緞鍒涘缓 #$id (鎬绘暟: $_counter) - 鏉ユ簮: ${source ?? "鏈煡"}');
  }

  /// 缁撴潫璺緞璺熻釜
  static void endPath(Path path, {String? reason}) {
    if (!enabled) return;

    final id = path.hashCode;
    final info = _trackedPaths[id];
    if (info != null) {
      final duration = DateTime.now().difference(info.createdAt);
      print('馃攳 璺緞缁撴潫 #$id - 鐐规暟: ${info.pointCount} - '
          '鎸佺画鏃堕棿: ${duration.inMilliseconds}ms - '
          '鍘熷洜: ${reason ?? "瀹屾垚"}');

      _trackedPaths.remove(id);
    }
  }

  /// 鎵撳嵃褰撳墠璺熻釜鐨勬墍鏈夎矾寰?
  static void printStatus() {
    if (!enabled) return;

    print('===== 璺緞璺熻釜鐘舵€?=====');
    print('璺熻釜涓殑璺緞鏁? ${_trackedPaths.length}');

    _trackedPaths.forEach((id, info) {
      final duration = DateTime.now().difference(info.createdAt);
      print('璺緞 #$id - 鏉ユ簮: ${info.source} - 鐐规暟: ${info.pointCount} - '
          '宸插瓨鍦? ${duration.inSeconds}s');
    });

    print('=======================');
  }
}

class _PathInfo {
  final int id;
  final DateTime createdAt;
  final String source;
  int pointCount;
  final List<String> operations;

  _PathInfo({
    required this.id,
    required this.createdAt,
    required this.source,
    this.pointCount = 0,
    required this.operations,
  });
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\utils\focus\focus_persistence.dart
-----------------------------------
import 'package:flutter/material.dart';

/// 鐒︾偣鎸佷箙鎬ц緟鍔╃被 - 鐢ㄤ簬绠＄悊鐒︾偣鐘舵€佸拰鎭㈠涓㈠け鐨勭劍鐐?
class FocusPersistence {
  // 杩借釜搴旂敤涓紭鍏堢骇鐒︾偣鑺傜偣
  static final List<FocusNode> _priorityFocusNodes = [];

  /// 娣诲姞浼樺厛绾х劍鐐硅妭鐐?
  static void addPriorityFocusNode(FocusNode node) {
    if (!_priorityFocusNodes.contains(node)) {
      _priorityFocusNodes.add(node);
    }
  }

  /// 鑾峰彇褰撳墠鐒︾偣鐘舵€佷俊鎭?
  static String getFocusInfo() {
    final focusedNodes = _priorityFocusNodes.where((node) => node.hasFocus);
    if (focusedNodes.isEmpty) {
      return '鏃犱紭鍏堢骇鑺傜偣鎷ユ湁鐒︾偣';
    }

    return '宸茶幏寰楃劍鐐圭殑鑺傜偣: ${focusedNodes.map((n) => n.debugLabel ?? '鏈懡鍚?).join(', ')}';
  }

  /// 绉婚櫎浼樺厛绾х劍鐐硅妭鐐?
  static void removePriorityFocusNode(FocusNode node) {
    _priorityFocusNodes.remove(node);
  }

  /// 鎭㈠浼樺厛绾х劍鐐?
  static void restorePriorityFocus() {
    // 濡傛灉褰撳墠娌℃湁鐒︾偣锛屽皾璇曞皢鐒︾偣杩樼粰鏈€鍚庝竴涓紭鍏堢骇鑺傜偣
    if (_priorityFocusNodes.isNotEmpty &&
        !_priorityFocusNodes.any((node) => node.hasFocus)) {
      final node = _priorityFocusNodes.last;
      if (node.canRequestFocus) {
        node.requestFocus();
        debugPrint('宸叉仮澶嶄紭鍏堢骇鐒︾偣鍒? ${node.debugLabel ?? '鏈懡鍚嶈妭鐐?}');
      }
    }
  }
}

/// 鐒︾偣鎸佷箙鎬ф贩鍏?- 鐢ㄤ簬StatefulWidget鑷姩澶勭悊鐒︾偣
mixin FocusPersistenceMixin<T extends StatefulWidget> on State<T> {
  late final FocusNode _persistentFocus =
      FocusNode(debugLabel: widget.runtimeType.toString());

  FocusNode get focusNode => _persistentFocus;

  @override
  void dispose() {
    FocusPersistence.removePriorityFocusNode(_persistentFocus);
    _persistentFocus.dispose();
    super.dispose();
  }

  @override
  void initState() {
    super.initState();
    FocusPersistence.addPriorityFocusNode(_persistentFocus);

    // 鑷姩璇锋眰鐒︾偣
    WidgetsBinding.instance.addPostFrameCallback((_) {
      _persistentFocus.requestFocus();
    });
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\utils\image\image_utils.dart
-----------------------------------
import 'dart:typed_data';
import 'dart:ui' as ui;

/// 鍥惧儚澶勭悊宸ュ叿绫?
class ImageUtils {
  /// 灏嗗瓧鑺傛暟缁勮浆鎹负Flutter鐨処mage瀵硅薄
  static Future<ui.Image?> bytesToImage(Uint8List bytes) async {
    try {
      final codec = await ui.instantiateImageCodec(bytes);
      final frame = await codec.getNextFrame();
      return frame.image;
    } catch (e) {
      print('瀛楄妭鏁扮粍杞崲涓哄浘鍍忓け璐? $e');
      return null;
    }
  }

  /// 瑁佸壀鍥惧儚
  static Future<ui.Image?> cropImage(ui.Image image, ui.Rect rect) async {
    try {
      final pictureRecorder = ui.PictureRecorder();
      final canvas = ui.Canvas(pictureRecorder);

      canvas.drawImageRect(
        image,
        rect,
        rect.shift(ui.Offset(-rect.left, -rect.top)),
        ui.Paint(),
      );

      final picture = pictureRecorder.endRecording();
      return picture.toImage(
        rect.width.toInt(),
        rect.height.toInt(),
      );
    } catch (e) {
      print('鍥惧儚瑁佸壀澶辫触: $e');
      return null;
    }
  }

  /// 璁＄畻鍥惧儚鐨勫疄闄呰竟鐣岋紙鍘婚櫎閫忔槑閮ㄥ垎锛?
  static ui.Rect getImageBounds(ui.Image image) {
    // TODO: 瀹炵幇姝ゆ柟娉曚互璁＄畻鍥惧儚鐨勫疄闄呰竟鐣?
    // 鏆傛椂杩斿洖鏁翠釜鍥惧儚鐨勮竟鐣?
    return ui.Rect.fromLTWH(
      0,
      0,
      image.width.toDouble(),
      image.height.toDouble(),
    );
  }

  /// 灏咶lutter鐨処mage瀵硅薄杞崲涓哄瓧鑺傛暟缁?
  static Future<Uint8List?> imageToBytes(ui.Image image) async {
    try {
      final byteData = await image.toByteData(format: ui.ImageByteFormat.png);
      return byteData?.buffer.asUint8List();
    } catch (e) {
      print('鍥惧儚杞崲澶辫触: $e');
      return null;
    }
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\utils\keyboard\keyboard_monitor.dart
-----------------------------------
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';

import '../debug/debug_flags.dart';
import '../focus/focus_persistence.dart';
import 'keyboard_utils.dart';

/// 閿洏鐘舵€佺洃鎺у櫒 - 鐢ㄤ簬杩借釜閿洏鐘舵€佸彉鍖栵紝甯姪璋冭瘯
class KeyboardMonitor {
  static final instance = KeyboardMonitor._();

  // 绉佹湁鏋勯€犲嚱鏁?
  KeyboardMonitor._() {
    // 娉ㄥ唽閿洏鐘舵€佺洃鍚櫒
    KeyboardUtils.addKeyStateListener(_onKeyStateChanged);
  }

  // 杈撳嚭褰撳墠Alt閿姸鎬?
  void debugLogAltKeyState() {
    final isAltPressed = KeyboardUtils.isAltKeyPressed();
    print('鈱笍 褰撳墠Alt閿姸鎬? $isAltPressed');
  }

  // 澶勭悊閿洏鐘舵€佸彉鍖?
  void _onKeyStateChanged(LogicalKeyboardKey key, bool isDown) {
    // 鐗瑰埆鍏虫敞Alt閿?
    if (key == LogicalKeyboardKey.alt ||
        key == LogicalKeyboardKey.altLeft ||
        key == LogicalKeyboardKey.altRight) {
      DebugFlags.trackAltKeyState('KeyboardMonitor', isDown);
      print('鈱笍 Alt閿姸鎬佹洿鏂? ${key.keyLabel} = $isDown');
    }
  }

  // 娣诲姞鍒板簲鐢ㄦ牴Widget
  static Widget wrapApp(Widget app) {
    return KeyboardMonitorWidget(child: app);
  }
}

/// 閿洏鐩戞帶鍣╓idget - 鐩戝惉搴旂敤鑼冨洿鍐呯殑閿洏浜嬩欢
class KeyboardMonitorWidget extends StatefulWidget {
  final Widget child;

  const KeyboardMonitorWidget({
    Key? key,
    required this.child,
  }) : super(key: key);

  @override
  State<KeyboardMonitorWidget> createState() => _KeyboardMonitorWidgetState();
}

class _KeyboardMonitorWidgetState extends State<KeyboardMonitorWidget> {
  final FocusNode _rootFocusNode = FocusNode(debugLabel: 'RootMonitor');

  @override
  Widget build(BuildContext context) {
    return Listener(
      onPointerDown: (_) {
        // 纭繚鐐瑰嚮浜嬩欢鑳藉浼犻€掑埌瀛愰儴浠?
        if (!_rootFocusNode.hasFocus &&
            !FocusManager.instance.primaryFocus!.ancestors
                .contains(_rootFocusNode)) {
          // 濡傛灉鏍圭劍鐐规湭鑾峰彇鐒︾偣涓斿綋鍓嶇劍鐐逛笉鏄牴鐒︾偣鐨勫瓙浠ｏ紝灏濊瘯鎭㈠鐒︾偣
          WidgetsBinding.instance.addPostFrameCallback((_) {
            // 寤惰繜鎵ц浠ラ伩鍏嶅共鎵板綋鍓嶄簨浠?
            FocusPersistence.restorePriorityFocus();
          });
        }
      },
      child: Focus(
        focusNode: _rootFocusNode,
        onKeyEvent: (node, event) {
          // 璁板綍鎵€鏈夐敭鐩樹簨浠?
          if (DebugFlags.enableEventTracing) {
            print(
                '馃攽 閿洏浜嬩欢: ${event.runtimeType} - ${event.logicalKey.keyLabel}');
          }
          return KeyEventResult.ignored;
        },
        child: widget.child,
      ),
    );
  }

  @override
  void dispose() {
    _rootFocusNode.dispose();
    super.dispose();
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\utils\keyboard\keyboard_utils.dart
-----------------------------------
import 'dart:async';

import 'package:flutter/services.dart';

/// 閿洏鐘舵€佽緟鍔╁伐鍏风被
class KeyboardUtils {
  // 璺熻釜鎸夐敭鐘舵€?
  static final Map<LogicalKeyboardKey, bool> _keyStates = {};

  // 閿洏鐘舵€佺洃鍚櫒
  static final _keyStateListeners =
      <Function(LogicalKeyboardKey key, bool isDown)>[];

  // 闃叉姈瀹氭椂鍣?
  static Timer? _altDebounceTimer;

  /// 娣诲姞閿洏鐘舵€佺洃鍚櫒
  static void addKeyStateListener(
      Function(LogicalKeyboardKey key, bool isDown) listener) {
    _keyStateListeners.add(listener);
  }

  /// 鍒濆鍖栭敭鐩樼洃鍚?
  static void initialize() {
    // 鍙互鍦ㄥ簲鐢ㄥ惎鍔ㄦ椂璋冪敤姝ゆ柟娉曡缃叏灞€閿洏鐩戝惉
    ServicesBinding.instance.keyboard.addHandler(_handleKeyEvent);
  }

  /// 妫€鏌lt閿槸鍚﹁鎸変笅
  static bool isAltKeyPressed() {
    return isKeyPressed(LogicalKeyboardKey.alt) ||
        isKeyPressed(LogicalKeyboardKey.altLeft) ||
        isKeyPressed(LogicalKeyboardKey.altRight);
  }

  /// 鑾峰彇鐗瑰畾閿殑褰撳墠鐘舵€?
  static bool isKeyPressed(LogicalKeyboardKey key) {
    return _keyStates[key] ?? false;
  }

  /// 绉婚櫎閿洏鐘舵€佺洃鍚櫒
  static void removeKeyStateListener(
      Function(LogicalKeyboardKey key, bool isDown) listener) {
    _keyStateListeners.remove(listener);
  }

  /// 鍏ㄥ眬閿洏浜嬩欢澶勭悊鍣?
  static bool _handleKeyEvent(KeyEvent event) {
    LogicalKeyboardKey key = event.logicalKey;

    // 澶勭悊閿洏浜嬩欢
    if (event is KeyDownEvent) {
      _updateKeyState(key, true);
    } else if (event is KeyUpEvent) {
      _updateKeyState(key, false);
    } else if (event is KeyRepeatEvent) {
      // 瀵逛簬閲嶅浜嬩欢锛屼繚鎸佸綋鍓嶇姸鎬?
      // 涓嶅仛浠讳綍鐘舵€佹洿鏀?
    }

    // 杩斿洖false璁╀簨浠剁户缁紶閫?
    return false;
  }

  /// 鏇存柊鎸夐敭鐘舵€?
  static void _updateKeyState(LogicalKeyboardKey key, bool isDown) {
    bool oldState = _keyStates[key] ?? false;

    // 濡傛灉鐘舵€佸彂鐢熷彉鍖?
    if (oldState != isDown) {
      _keyStates[key] = isDown;

      // 瀵逛簬Alt閿紝浣跨敤闃叉姈澶勭悊
      if (key == LogicalKeyboardKey.alt ||
          key == LogicalKeyboardKey.altLeft ||
          key == LogicalKeyboardKey.altRight) {
        _altDebounceTimer?.cancel();

        // 鐭殏寤惰繜浠ラ伩鍏嶅揩閫熷垏鎹?
        _altDebounceTimer = Timer(const Duration(milliseconds: 50), () {
          // 閫氱煡鎵€鏈夌洃鍚櫒
          for (var listener in _keyStateListeners) {
            listener(key, isDown);
          }
        });
      } else {
        // 绔嬪嵆閫氱煡鍏朵粬閿殑鍙樺寲
        for (var listener in _keyStateListeners) {
          listener(key, isDown);
        }
      }
    }
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\utils\path\path_smoothing.dart
-----------------------------------
import 'dart:ui';

/// 璺緞骞虫粦澶勭悊宸ュ叿绫?
class PathSmoothing {
  /// 瀵硅矾寰勭偣杩涜鎻掑€硷紝鍒涘缓鏇村钩婊戠殑璺緞
  static Path createSmoothPath(List<Offset> points, {double tension = 0.5}) {
    if (points.length < 2) {
      final path = Path();
      if (points.isNotEmpty) {
        path.moveTo(points[0].dx, points[0].dy);
      }
      return path;
    }

    final path = Path();
    path.moveTo(points[0].dx, points[0].dy);

    if (points.length == 2) {
      // 鍙湁涓や釜鐐规椂锛岀洿鎺ヨ繛绾?
      path.lineTo(points[1].dx, points[1].dy);
      return path;
    }

    // 浣跨敤涓夋璐濆灏旀洸绾垮垱寤哄钩婊戞洸绾?
    for (int i = 0; i < points.length - 1; i++) {
      final p0 = i > 0 ? points[i - 1] : points[i];
      final p1 = points[i];
      final p2 = points[i + 1];
      final p3 = i < points.length - 2 ? points[i + 2] : p2;

      // 璁＄畻鎺у埗鐐?
      final c1 = Offset(
        p1.dx + (p2.dx - p0.dx) * tension,
        p1.dy + (p2.dy - p0.dy) * tension,
      );
      final c2 = Offset(
        p2.dx - (p3.dx - p1.dx) * tension,
        p2.dy - (p3.dy - p1.dy) * tension,
      );

      // 娣诲姞涓夋璐濆灏旀洸绾?
      path.cubicTo(c1.dx, c1.dy, c2.dx, c2.dy, p2.dx, p2.dy);
    }

    return path;
  }

  /// 鍦ㄤ袱鐐逛箣闂存彃鍏ラ澶栫殑鐐癸紝浣胯矾寰勬洿杩炵画
  static List<Offset> interpolatePoints(List<Offset> points,
      {double maxDistance = 5.0}) {
    if (points.length < 2) return List.from(points);

    final result = <Offset>[];
    result.add(points.first);

    for (int i = 1; i < points.length; i++) {
      final start = points[i - 1];
      final end = points[i];
      final distance = (end - start).distance;

      if (distance > maxDistance) {
        // 鍦ㄤ袱鐐归棿鎻掑叆棰濆鐨勭偣
        final count = (distance / maxDistance).ceil();
        for (int j = 1; j < count; j++) {
          final t = j / count;
          result.add(Offset(
            start.dx + (end.dx - start.dx) * t,
            start.dy + (end.dy - start.dy) * t,
          ));
        }
      }

      result.add(end);
    }

    return result;
  }

  /// 瀵硅矾寰勮繘琛岀偣閲囨牱锛屽噺灏戜笉蹇呰鐨勭偣
  static List<Offset> samplePoints(List<Offset> points,
      {double minDistance = 2.0}) {
    if (points.length < 3) return List.from(points);

    final result = <Offset>[];
    result.add(points.first);

    Offset lastPoint = points.first;
    for (int i = 1; i < points.length - 1; i++) {
      final current = points[i];
      if ((current - lastPoint).distance >= minDistance) {
        result.add(current);
        lastPoint = current;
      }
    }

    result.add(points.last);
    return result;
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\utils\path\path_utils.dart
-----------------------------------
import 'dart:math' as math;
import 'dart:ui';

import 'package:flutter/material.dart';

/// 璺緞澶勭悊宸ュ叿绫?
class PathUtils {
  /// 鍏嬮殕璺緞骞剁‘淇濋棴鍚?
  static Path clonePath(Path source, {bool close = true}) {
    final result = Path()..addPath(source, Offset.zero);
    if (close) result.close();
    return result;
  }

  /// 灏嗗涓矾寰勫悎骞朵负涓€涓疄蹇冨尯鍩?
  static Path combineToSolidPath(List<Path> paths, double strokeWidth) {
    if (paths.isEmpty) return Path();

    final result = Path();
    for (final path in paths) {
      // 涓烘瘡涓矾寰勭偣鍒涘缓涓€涓渾褰㈠尯鍩?
      for (final metric in path.computeMetrics()) {
        var distance = 0.0;
        while (distance < metric.length) {
          final tangent = metric.getTangentForOffset(distance);
          if (tangent != null) {
            result.addOval(
              Rect.fromCircle(
                center: tangent.position,
                radius: strokeWidth / 2,
              ),
            );
          }
          // 姣忔绉诲姩涓€灏忔璺濈锛岀‘淇濆渾褰箣闂存湁閲嶅彔
          distance += strokeWidth / 4;
        }
      }
    }
    return result..close();
  }

  /// 浣跨敤骞虫粦杩炴帴鍒涘缓璺緞
  static Path createSmoothPath(List<Offset> points, double width) {
    if (points.isEmpty) return Path();
    if (points.length == 1) {
      return createSolidCircle(points[0], width / 2);
    }

    final path = Path();

    // 娣诲姞绗竴涓偣鐨勫渾褰?
    path.addOval(Rect.fromCircle(center: points.first, radius: width / 2));

    // 娣诲姞杩炴帴鐨勭嚎娈碉紝纭繚骞虫粦杩炴帴
    for (int i = 1; i < points.length; i++) {
      final gap = createSolidGap(points[i - 1], points[i], width);
      path.addPath(gap, Offset.zero);
    }

    return path;
  }

  /// 鍒涘缓瀹炲績鍦嗗舰璺緞
  static Path createSolidCircle(Offset center, double radius) {
    // 纭繚浣跨敤鍑嗙‘鐨勫渾褰㈠崐寰勶紝涓嶈繘琛屽洓鑸嶄簲鍏?
    return Path()..addOval(Rect.fromCircle(center: center, radius: radius));
  }

  /// 鍒涘缓涓ょ偣涔嬮棿鐨勫疄蹇冭繛鎺ヨ矾寰勶紝鏀硅繘鐗?
  static Path createSolidGap(Offset start, Offset end, double width) {
    final dx = end.dx - start.dx;
    final dy = end.dy - start.dy;
    final distance = math.sqrt(dx * dx + dy * dy);

    if (distance < 0.001) {
      // 濡傛灉鐐瑰嚑涔庨噸鍚堬紝杩斿洖涓€涓皬鍦?
      return createSolidCircle(start, width / 2);
    }

    // 璁＄畻鍨傜洿浜庤繛绾跨殑鍗曚綅鍚戦噺
    final nx = -dy / distance;
    final ny = dx / distance;

    // 璁＄畻鍥涗釜瑙掔偣锛岀‘淇濈簿纭〃绀?
    final halfWidth = width / 2;
    final p1 = Offset(start.dx + nx * halfWidth, start.dy + ny * halfWidth);
    final p2 = Offset(start.dx - nx * halfWidth, start.dy - ny * halfWidth);
    final p3 = Offset(end.dx - nx * halfWidth, end.dy - ny * halfWidth);
    final p4 = Offset(end.dx + nx * halfWidth, end.dy + ny * halfWidth);

    // 鍒涘缓璺緞锛屼娇鐢ㄦ洿绮剧‘鐨勬帶鍒?
    final path = Path();

    // 浣跨敤鏇寸簿纭殑鏂瑰紡缁樺埗鍥涜竟褰紝纭繚杈硅澶勭悊姝ｇ‘
    path.moveTo(p1.dx, p1.dy);
    path.lineTo(p2.dx, p2.dy);
    path.lineTo(p3.dx, p3.dy);
    path.lineTo(p4.dx, p4.dy);

    // 纭繚璺緞闂悎锛岄槻姝㈣竟瑙掓硠婕?
    path.close();

    // 涓轰繚璇佸渾褰㈢殑绔偣锛屾坊鍔犱袱涓崐鍦?
    final startCircle = createSolidCircle(start, halfWidth);
    final endCircle = createSolidCircle(end, halfWidth);

    // 鍚堝苟鎵€鏈夐儴鍒嗭紝纭繚瀹屾暣瑕嗙洊
    path.addPath(startCircle, Offset.zero);
    path.addPath(endCircle, Offset.zero);

    return path;
  }

  /// 鑾峰彇璺緞鐨勮竟鐣岀煩褰紝瀹夊叏澶勭悊
  static Rect? getPathBounds(Path path) {
    try {
      return path.getBounds();
    } catch (e) {
      print('鑾峰彇璺緞杈圭晫鍑洪敊: $e');
      return null;
    }
  }

  /// 妫€鏌ヨ矾寰勬槸鍚︿负绌?
  static bool isPathEmpty(Path path) {
    try {
      final bounds = path.getBounds();
      return bounds.isEmpty || (bounds.width < 0.1 && bounds.height < 0.1);
    } catch (e) {
      return true;
    }
  }

  /// 鍚堝苟澶氭潯璺緞
  static Path mergePaths(List<Path> paths) {
    if (paths.isEmpty) return Path();
    if (paths.length == 1) return paths.first;

    final result = Path();
    for (final path in paths) {
      result.addPath(path, Offset.zero);
    }
    return result;
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\utils\performance\frame_logger.dart
-----------------------------------
import 'package:flutter/foundation.dart';
import 'package:flutter/scheduler.dart';

/// 甯х巼鐩戞帶宸ュ叿
class FrameLogger {
  static bool _isRunning = false;
  static int _frameCount = 0;
  static Duration _lastReportTime = Duration.zero;
  static const _reportInterval = Duration(seconds: 1);

  // 鍚姩甯х巼鐩戞帶
  static void start() {
    if (_isRunning) return;

    _isRunning = true;
    _frameCount = 0;
    _lastReportTime = Duration(
        milliseconds:
            SchedulerBinding.instance.currentFrameTimeStamp.inMilliseconds);

    SchedulerBinding.instance.addTimingsCallback(_onTimingsCallback);

    if (kDebugMode) {
      print('馃柤锔?鍚姩甯х巼鐩戞帶');
    }
  }

  // 鍋滄甯х巼鐩戞帶
  static void stop() {
    if (!_isRunning) return;

    _isRunning = false;
    SchedulerBinding.instance.removeTimingsCallback(_onTimingsCallback);

    if (kDebugMode) {
      print('馃柤锔?鍋滄甯х巼鐩戞帶');
    }
  }

  // 鍒嗘瀽甯у畾鏃朵俊鎭?
  static void _analyzeFrameTiming(FrameTiming timing) {
    if (!kDebugMode) return;

    final buildTime = _microsToMs(timing.buildDuration.inMicroseconds);
    final rasterTime = _microsToMs(timing.rasterDuration.inMicroseconds);
    final totalTime = buildTime + rasterTime;

    if (totalTime > 16.0) {
      print('鈿狅笍 甯у鐞嗘椂闂磋繃闀? ${totalTime.toStringAsFixed(1)}ms '
          '(鏋勫缓: ${buildTime.toStringAsFixed(1)}ms, '
          '娓叉煋: ${rasterTime.toStringAsFixed(1)}ms)');

      // 鍒嗘瀽鍝釜闃舵鏈夐棶棰?
      if (buildTime > 10.0) {
        print('   - 鏋勫缓闃舵鑰楁椂杩囬暱锛岃妫€鏌etState璋冪敤鍜屽鏉傚竷灞€');
      }
      if (rasterTime > 10.0) {
        print('   - 娓叉煋闃舵鑰楁椂杩囬暱锛岃妫€鏌ョ粯鍒舵搷浣滃拰鍥惧儚澶勭悊');
      }
    }
  }

  // 寰杞绉?
  static double _microsToMs(int micros) {
    return micros / 1000.0;
  }

  // 澶勭悊姣忎竴甯у洖璋?
  static void _onTimingsCallback(List<FrameTiming> timings) {
    if (!_isRunning) return;

    _frameCount += timings.length;

    final now = Duration(
        milliseconds:
            SchedulerBinding.instance.currentFrameTimeStamp.inMilliseconds);
    final elapsed = now - _lastReportTime;

    if (elapsed >= _reportInterval) {
      final fps = _frameCount * 1000 / elapsed.inMilliseconds;
      if (kDebugMode) {
        print('馃柤锔?FPS: ${fps.toStringAsFixed(1)}');

        // 妫€鏌ユ槸鍚︿綆浜庣洰鏍囧抚鐜?
        if (fps < 55) {
          print('鈿狅笍 甯х巼杩囦綆: ${fps.toStringAsFixed(1)} FPS');
        }
      }

      _frameCount = 0;
      _lastReportTime = now;

      // 鍒嗘瀽甯т俊鎭?
      if (timings.isNotEmpty) {
        _analyzeFrameTiming(timings.last);
      }
    }
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\utils\performance\memory_tracker.dart
-----------------------------------
import 'dart:async';
import 'dart:math' as math;

import 'package:flutter/foundation.dart';

/// 鍐呭瓨浣跨敤鐩戞帶宸ュ叿
class MemoryTracker {
  static Timer? _timer;
  static bool _isRunning = false;
  static const _checkInterval = Duration(seconds: 5);

  // 鏍锋湰闆?
  static final List<double> _memorySamples = [];
  static const _maxSamples = 20;

  // 绔嬪嵆妫€鏌ュ唴瀛樹娇鐢?
  static void checkNow() {
    if (!_isRunning) {
      print('馃捑 鍐呭瓨鐩戞帶鏈惎鍔紝鎵ц鍗曟妫€鏌?);
    }
    _checkMemoryUsage();
  }

  // 鍚姩鍐呭瓨鐩戞帶
  static void start() {
    if (_isRunning) return;

    _isRunning = true;
    _memorySamples.clear();

    // 瀹氭椂妫€鏌ュ唴瀛樹娇鐢ㄦ儏鍐?
    _timer = Timer.periodic(_checkInterval, (_) {
      _checkMemoryUsage();
    });

    if (kDebugMode) {
      print('馃捑 鍚姩鍐呭瓨鐩戞帶');
    }
  }

  // 鍋滄鍐呭瓨鐩戞帶
  static void stop() {
    if (!_isRunning) return;

    _isRunning = false;
    _timer?.cancel();
    _timer = null;

    if (kDebugMode) {
      print('馃捑 鍋滄鍐呭瓨鐩戞帶');
      if (_memorySamples.isNotEmpty) {
        _printMemorySummary();
      }
    }
  }

  // 妫€鏌ュ唴瀛樹娇鐢ㄨ秼鍔?
  static void _checkMemoryTrend() {
    if (_memorySamples.length < 5) return; // 鑷冲皯闇€瑕?涓牱鏈?

    final recentSamples = _memorySamples.sublist(_memorySamples.length - 5);
    final firstSample = recentSamples.first;
    final lastSample = recentSamples.last;
    final growthRate = (lastSample - firstSample) / firstSample * 100;

    if (growthRate > 20) {
      print('鈿狅笍 鍐呭瓨浣跨敤蹇€熷闀? ${growthRate.toStringAsFixed(1)}%锛屽彲鑳藉瓨鍦ㄥ唴瀛樻硠婕?);
    }
  }

  // 妫€鏌ュ綋鍓嶅唴瀛樹娇鐢?
  static void _checkMemoryUsage() {
    // 瀹為檯搴旂敤涓紝杩欓噷鍙互閫氳繃骞冲彴鐗瑰畾鐨凙PI鑾峰彇鐪熷疄鍐呭瓨浣跨敤鏁版嵁
    // 杩欓噷浣跨敤妯℃嫙鏁版嵁浣滀负绀轰緥
    final usage = _getCurrentMemoryUsage();
    final usageMB = usage / 1024 / 1024; // 杞崲涓篗B

    // 璁板綍鏍锋湰
    _memorySamples.add(usageMB);
    if (_memorySamples.length > _maxSamples) {
      _memorySamples.removeAt(0);
    }

    if (kDebugMode) {
      print('馃捑 褰撳墠鍐呭瓨浣跨敤: ${usageMB.toStringAsFixed(1)} MB');

      // 妫€鏌ユ槸鍚﹁秴杩囬槇鍊?
      if (usageMB > 200) {
        print('鈿狅笍 鍐呭瓨浣跨敤瓒呰繃璀︽垝绾? ${usageMB.toStringAsFixed(1)} MB');
      }

      // 妫€鏌ュ唴瀛樺闀胯秼鍔?
      _checkMemoryTrend();
    }
  }

  // 鑾峰彇褰撳墠鍐呭瓨浣跨敤鎯呭喌
  // 鍦ㄥ疄闄呭簲鐢ㄤ腑锛屽簲浣跨敤骞冲彴鐗瑰畾API鑾峰彇鐪熷疄鏁版嵁
  static double _getCurrentMemoryUsage() {
    // 妯℃嫙鏁版嵁 - 瀹為檯搴旂敤涓浛鎹负鐪熷疄瀹炵幇
    // 鍩虹鍐呭瓨 + 闅忔満娉㈠姩 + 鏍锋湰鏁伴噺褰卞搷(妯℃嫙鍐呭瓨娉勬紡)
    return 100 * 1024 * 1024 + // 鍩虹100MB
        math.Random().nextDouble() * 50 * 1024 * 1024 + // 闅忔満娉㈠姩50MB
        _memorySamples.length * 2 * 1024 * 1024; // 姣忎釜鏍锋湰澧炲姞2MB(妯℃嫙娉勬紡)
  }

  // 鎵撳嵃鍐呭瓨浣跨敤鎽樿
  static void _printMemorySummary() {
    if (_memorySamples.isEmpty) return;

    final avg = _memorySamples.reduce((a, b) => a + b) / _memorySamples.length;
    final min = _memorySamples.reduce(math.min);
    final max = _memorySamples.reduce(math.max);

    print('馃捑 鍐呭瓨浣跨敤鎽樿:');
    print('   - 骞冲潎: ${avg.toStringAsFixed(1)} MB');
    print('   - 鏈€灏? ${min.toStringAsFixed(1)} MB');
    print('   - 鏈€澶? ${max.toStringAsFixed(1)} MB');
    print('   - 娉㈠姩: ${(max - min).toStringAsFixed(1)} MB');

    // 寤鸿
    if (max > 200) {
      print('   - 寤鸿: 鍐呭瓨宄板€艰秴杩?00MB锛岃€冭檻浼樺寲鍐呭瓨浣跨敤');
    }
    if (max - min > 50) {
      print('   - 寤鸿: 鍐呭瓨娉㈠姩杈冨ぇ锛屾鏌ヨ祫婧愰噴鏀?);
    }
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\utils\performance\performance_monitor.dart
-----------------------------------
import 'package:flutter/foundation.dart';

/// 鎬ц兘鐩戞帶宸ュ叿绫?
class PerformanceMonitor {
  // 璁板綍浜嬩欢寤惰繜
  static void logEventLatency(String tag, Duration latency) {
    if (kDebugMode) {
      print('鈱?$tag: ${latency.inMilliseconds}ms');

      // 妫€鏌ユ槸鍚﹁秴杩囬槇鍊?
      if (latency.inMilliseconds > 16) {
        print('鈿狅笍 $tag: Event latency exceeded frame budget (16ms)');
      }
    }
  }

  // 璁板綍鎿嶄綔鑰楁椂
  static void logFrameTime(String tag, Duration duration) {
    if (kDebugMode) {
      print('鈴憋笍 $tag: ${duration.inMilliseconds}ms');
    }
  }

  // 璁板綍鍐呭瓨浣跨敤鎯呭喌
  static void logMemoryUsage(String tag) {
    if (kDebugMode) {
      print('馃捑 $tag: Memory monitoring');
      // 鍦ㄥ疄闄呭簲鐢ㄤ腑锛屽彲浠ヨ皟鐢ㄥ钩鍙扮壒瀹欰PI鑾峰彇鍐呭瓨浣跨敤鎯呭喌
    }
  }

  // 寮傛鎿嶄綔璺熻釜
  static Future<T> trackAsyncOperation<T>(
      String tag, Future<T> Function() operation) async {
    final stopwatch = Stopwatch()..start();
    final result = await operation();
    stopwatch.stop();

    logFrameTime(tag, stopwatch.elapsed);
    return result;
  }

  // 璺熻釜鎿嶄綔鎵ц鏃堕棿
  static T trackOperation<T>(String tag, T Function() operation) {
    final stopwatch = Stopwatch()..start();
    final result = operation();
    stopwatch.stop();

    logFrameTime(tag, stopwatch.elapsed);
    return result;
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\widgets\character_edit\character_edit_canvas.dart
-----------------------------------
import 'dart:async';
import 'dart:math' as math;
import 'dart:ui' as ui;

import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../application/services/image/character_image_processor.dart';
import '../../domain/models/character/character_region.dart';
import '../../domain/models/character/detected_outline.dart';
import '../../domain/models/character/processing_options.dart';
import '../../infrastructure/logging/logger.dart';
import '../../presentation/providers/character/erase_providers.dart';
import '../../utils/coordinate_transformer.dart';
import '../../utils/debug/debug_flags.dart';
import '../../utils/focus/focus_persistence.dart';
import '../../utils/image/image_utils.dart';
import 'layers/erase_layer_stack.dart';

/// 缂栬緫鐢诲竷缁勪欢
class CharacterEditCanvas extends ConsumerStatefulWidget {
  final ui.Image image;
  final bool showOutline;
  final bool invertMode;
  final bool imageInvertMode;
  final Function(Offset)? onEraseStart;
  final Function(Offset, Offset)? onEraseUpdate;
  final Function()? onEraseEnd;
  final double brushSize;
  final Color brushColor;
  final double? rotation;
  final CharacterRegion? region;

  const CharacterEditCanvas({
    Key? key,
    required this.image,
    this.showOutline = false,
    this.invertMode = false,
    this.imageInvertMode = false,
    this.onEraseStart,
    this.onEraseUpdate,
    this.onEraseEnd,
    this.brushSize = 10.0,
    required this.brushColor,
    this.rotation,
    this.region,
  }) : super(key: key);

  @override
  ConsumerState<CharacterEditCanvas> createState() =>
      CharacterEditCanvasState();
}

class CharacterEditCanvasState extends ConsumerState<CharacterEditCanvas>
    with FocusPersistenceMixin {
  static const _altToggleDebounce = Duration(milliseconds: 100);
  final TransformationController _transformationController =
      TransformationController();
  late CoordinateTransformer _transformer;

  final GlobalKey<EraseLayerStackState> _layerStackKey = GlobalKey();

  bool _isProcessing = false;

  bool _isAltKeyPressed = false;
  DateTime _lastAltToggleTime = DateTime.now();

  DetectedOutline? _outline;

  /// 杩斿洖褰撳墠鐨勫潗鏍囪浆鎹㈠櫒
  CoordinateTransformer get transformer => _transformer;
  @override
  Widget build(BuildContext context) {
    if (kDebugMode && DebugFlags.enableEraseDebug) {
      print(
          '鐢诲竷鏋勫缓 - showOutline: ${widget.showOutline}, isProcessing: $_isProcessing');
    }

    final eraseState = ref.watch(eraseStateProvider);
    final pathRenderData = ref.watch(pathRenderDataProvider);
    final showContour =
        ref.watch(eraseStateProvider.select((state) => state.showContour));

    ref.listen(eraseStateProvider.select((state) => state.showContour),
        (previous, current) {
      if (current) {
        print('杞粨鐘舵€佸彉鍖栵紝寮哄埗鏇存柊杞粨鏄剧ず锛屽綋鍓嶅€? $current');
        _updateOutline();
      }
    });

    ref.listen(pathRenderDataProvider, (previous, current) {
      final showContour = ref.read(eraseStateProvider).showContour;
      if (showContour) {
        final prevPaths = previous?.completedPaths ?? [];
        final currentPaths = current.completedPaths ?? [];
        if (prevPaths.length != currentPaths.length) {
          print('璺緞鍙樺寲妫€娴嬶細浠?${prevPaths.length} 鍒?${currentPaths.length} 涓矾寰?);
          _updateOutline();
        }
      }
    });

    ref.listen(eraseStateProvider.select((state) => state.imageInvertMode),
        (previous, current) {
      if (previous != current && ref.read(eraseStateProvider).showContour) {
        print('鍥惧儚鍙嶈浆鐘舵€佸彉鍖栵紝寮哄埗鏇存柊杞粨');
        Future.delayed(const Duration(milliseconds: 100), () {
          _updateOutline();
        });
      }
    });

    return Focus(
      focusNode: focusNode,
      autofocus: true,
      onKeyEvent: _handleKeyEvent,
      child: GestureDetector(
        behavior: HitTestBehavior.opaque,
        onTap: () {
          if (!focusNode.hasFocus) focusNode.requestFocus();
        },
        child: LayoutBuilder(
          builder: (context, constraints) {
            _updateTransformer(constraints.biggest);

            return InteractiveViewer(
              transformationController: _transformationController,
              constrained: false,
              boundaryMargin: const EdgeInsets.all(double.infinity),
              minScale: 0.1,
              maxScale: 5.0,
              panEnabled: _isAltKeyPressed,
              onInteractionUpdate: (details) {
                _updateTransformer(constraints.biggest);
              },
              child: SizedBox(
                width: widget.image.width.toDouble(),
                height: widget.image.height.toDouble(),
                child: EraseLayerStack(
                  key: _layerStackKey,
                  image: widget.image,
                  transformationController: _transformationController,
                  onEraseStart: _handleEraseStart,
                  onEraseUpdate: _handleEraseUpdate,
                  onEraseEnd: _handleEraseEnd,
                  altKeyPressed: _isAltKeyPressed,
                  brushSize: widget.brushSize,
                  brushColor: widget.brushColor,
                  imageInvertMode: widget.imageInvertMode,
                  showOutline: widget.showOutline,
                  onPan: (delta) {
                    if (_isAltKeyPressed) {
                      final matrix = _transformationController.value.clone();
                      matrix.translate(delta.dx, delta.dy);
                      _transformationController.value = matrix;
                    }
                  },
                  onTap: _handleTap,
                ),
              ),
            );
          },
        ),
      ),
    );
  }

  @override
  void didUpdateWidget(CharacterEditCanvas oldWidget) {
    super.didUpdateWidget(oldWidget);
    // transformer鐨勬洿鏂板凡缁忕Щ鍒癓ayoutBuilder涓鐞?
  }

  @override
  void dispose() {
    focusNode.removeListener(_onFocusChange);
    _transformationController.dispose();
    super.dispose();
  }

  /// 鑾峰彇澶勭悊鍚庣殑鍥惧儚
  Future<ui.Image?> getProcessedImage() async {
    if (_layerStackKey.currentState == null) return null;

    try {
      // 鍒涘缓涓€涓甫鏈夊綋鍓嶅ぇ灏忕殑鍥剧墖璁板綍鍣?
      final recorder = ui.PictureRecorder();
      final canvas = Canvas(recorder);
      final size = Size(
        widget.image.width.toDouble(),
        widget.image.height.toDouble(),
      );

      // 璋冪敤EraseLayerStack鐨勬覆鏌撴柟娉?
      await _layerStackKey.currentState!.renderToCanvas(canvas, size);

      // 鍒涘缓鏈€缁堝浘鍍?
      final picture = recorder.endRecording();
      final processedImage = await picture.toImage(
        widget.image.width,
        widget.image.height,
      );

      return processedImage;
    } catch (e) {
      print('鑾峰彇澶勭悊鍚庡浘鍍忓け璐? $e');
      return null;
    }
  }

  @override
  void initState() {
    super.initState();
    focusNode.addListener(_onFocusChange);

    // 鍒濆鍖栧潗鏍囪浆鎹㈠櫒
    _transformer = CoordinateTransformer(
      transformationController: _transformationController,
      imageSize: Size(
        widget.image.width.toDouble(),
        widget.image.height.toDouble(),
      ),
      viewportSize: const Size(800, 600), // 鍒濆榛樿鍊硷紝灏嗗湪LayoutBuilder涓洿鏂?
      enableLogging: false,
    );

    WidgetsBinding.instance.addPostFrameCallback((_) {
      _fitToScreen();
      if (widget.showOutline) {
        _updateOutline();
      }

      // 璁╁竷灞€瀹屾垚鍚庡啀杩涜transformer鐨勬洿鏂?
      if (mounted && context.size != null) {
        _updateTransformer(context.size!);
      }
    });
  }

  @override
  void reassemble() {
    super.reassemble();
    // 鐑噸杞芥椂鏇存柊transformer
    if (mounted && context.size != null) {
      _updateTransformer(context.size!);
    }
  }

  Future<void> _exportContourDebugImage() async {
    if (!kDebugMode) return;

    setState(() => _isProcessing = true);

    try {
      final imageBytes = await ImageUtils.imageToBytes(widget.image);
      if (imageBytes == null) {
        throw Exception('鏃犳硶灏嗗浘鍍忚浆鎹负瀛楄妭鏁扮粍');
      }

      final imageProcessor = ref.read(characterImageProcessorProvider);
      final eraseState = ref.read(eraseStateProvider);

      final options = ProcessingOptions(
        inverted: eraseState.imageInvertMode,
        threshold: 128.0,
        noiseReduction: 0.5,
        showContour: true,
      );

      final fullImageRect = Rect.fromLTWH(
        0,
        0,
        widget.image.width.toDouble(),
        widget.image.height.toDouble(),
      );

      final timestamp = DateTime.now().millisecondsSinceEpoch;
      final filename = 'contour_debug_$timestamp.png';

      print('杞粨璋冭瘯鍥惧凡鐢熸垚锛屾枃浠跺悕: $filename');
      print('杞粨鍥炬樉绀轰簡姣忔潯杞粨鐨勮捣鐐?缁胯壊)鍜岀粓鐐?绾㈣壊)锛屼互鍙婄粓姝㈠師鍥?);
    } catch (e) {
      print('瀵煎嚭杞粨璋冭瘯鍥惧け璐? $e');
    } finally {
      setState(() => _isProcessing = false);
    }
  }

  List<Offset> _extractPointsFromPath(Path path) {
    List<Offset> points = [];
    try {
      for (final metric in path.computeMetrics()) {
        if (metric.length == 0) {
          final pathBounds = path.getBounds();
          points.add(pathBounds.center);
          continue;
        }

        final stepLength = math.max(1.0, metric.length / 100);

        for (double distance = 0;
            distance <= metric.length;
            distance += stepLength) {
          final tangent = metric.getTangentForOffset(distance);
          if (tangent != null) {
            points.add(tangent.position);
          }
        }

        if (metric.length > 0) {
          final lastTangent = metric.getTangentForOffset(metric.length);
          if (lastTangent != null) {
            points.add(lastTangent.position);
          }
        }
      }

      if (points.isEmpty) {
        print('璀﹀憡锛氫粠璺緞涓湭鎻愬彇鍒扮偣锛屽皾璇曚娇鐢ㄨ矾寰勮竟鐣?);
        final bounds = path.getBounds();
        points.add(bounds.center);
      }
    } catch (e) {
      print('鎻愬彇璺緞鐐瑰嚭閿? $e');
      try {
        final bounds = path.getBounds();
        points.add(bounds.center);
        print('鎻愬彇澶辫触锛屼娇鐢ㄨ矾寰勪腑蹇冪偣浠ｆ浛');
      } catch (e2) {
        print('鏃犳硶鑾峰彇璺緞杈圭晫: $e2');
      }
    }
    return points;
  }

  void _fitToScreen() {
    if (!mounted) return;

    final RenderBox? renderBox = context.findRenderObject() as RenderBox?;
    if (renderBox == null) return;

    final Size viewportSize = renderBox.size;
    final double imageWidth = widget.image.width.toDouble();
    final double imageHeight = widget.image.height.toDouble();

    final double scaleX = viewportSize.width / imageWidth;
    final double scaleY = viewportSize.height / imageHeight;
    final double scale = scaleX < scaleY ? scaleX : scaleY;

    final double dx = (viewportSize.width - imageWidth * scale) / 2;
    final double dy = (viewportSize.height - imageHeight * scale) / 2;

    final Matrix4 matrix = Matrix4.identity()
      ..translate(dx, dy)
      ..scale(scale, scale);

    _transformationController.value = matrix;
  }

  void _handleEraseEnd() {
    widget.onEraseEnd?.call();
    if (!_isAltKeyPressed) {
      ref.read(eraseStateProvider.notifier).completePath();
    }
  }

  void _handleEraseStart(Offset position) {
    widget.onEraseStart?.call(position);
    if (!_isAltKeyPressed) {
      ref.read(eraseStateProvider.notifier).startPath(position);
    }
  }

  void _handleEraseUpdate(Offset position, Offset delta) {
    widget.onEraseUpdate?.call(position, delta);
    if (!_isAltKeyPressed) {
      ref.read(eraseStateProvider.notifier).updatePath(position);
    }
  }

  KeyEventResult _handleKeyEvent(FocusNode node, KeyEvent event) {
    if (event.logicalKey == LogicalKeyboardKey.alt ||
        event.logicalKey == LogicalKeyboardKey.altLeft ||
        event.logicalKey == LogicalKeyboardKey.altRight) {
      final now = DateTime.now();
      bool isDown;

      if (event is KeyDownEvent) {
        isDown = true;
      } else if (event is KeyUpEvent) {
        isDown = false;
      } else if (event is KeyRepeatEvent) {
        isDown = _isAltKeyPressed;
        return KeyEventResult.handled;
      } else {
        return KeyEventResult.ignored;
      }

      if (_isAltKeyPressed != isDown &&
          now.difference(_lastAltToggleTime) > _altToggleDebounce) {
        setState(() {
          _isAltKeyPressed = isDown;
          _lastAltToggleTime = now;
        });
      }

      return KeyEventResult.handled;
    }

    if (kDebugMode &&
        event is KeyDownEvent &&
        event.logicalKey == LogicalKeyboardKey.keyD) {
      print('鎸変笅D閿紝瀵煎嚭杞粨璋冭瘯鍥?);
      _exportContourDebugImage();
      return KeyEventResult.handled;
    }

    return KeyEventResult.ignored;
  }

  void _handleTap(Offset position) {
    if (_isAltKeyPressed) return;

    ref.read(eraseStateProvider.notifier).startPath(position);
    ref.read(eraseStateProvider.notifier).completePath();

    widget.onEraseStart?.call(position);
    widget.onEraseEnd?.call();
  }

  void _onFocusChange() {
    if (!focusNode.hasFocus && _isAltKeyPressed) {
      setState(() {
        _isAltKeyPressed = false;
      });
    }
  }

  Future<void> _updateOutline() async {
    if (_isProcessing) {
      print('杞粨姝ｅ湪澶勭悊涓紝璺宠繃鏇存柊');
      return;
    }

    setState(() => _isProcessing = true);

    try {
      final imageBytes = await ImageUtils.imageToBytes(widget.image);
      if (imageBytes == null) {
        throw Exception('鏃犳硶灏嗗浘鍍忚浆鎹负瀛楄妭鏁扮粍');
      }

      final imageProcessor = ref.read(characterImageProcessorProvider);
      final pathRenderData = ref.read(pathRenderDataProvider);
      final eraseState = ref.read(eraseStateProvider);

      final options = ProcessingOptions(
        inverted: eraseState.imageInvertMode,
        threshold: 128.0,
        noiseReduction: 0.5,
        showContour: true,
      );

      final fullImageRect = Rect.fromLTWH(
        0,
        0,
        widget.image.width.toDouble(),
        widget.image.height.toDouble(),
      );

      if (kDebugMode) {
        print(
            '杞粨澶勭悊閫夐」: inverted=${options.inverted}, showContour=${options.showContour}');
      }

      List<Map<String, dynamic>> erasePaths = [];
      if (pathRenderData.completedPaths.isNotEmpty) {
        erasePaths = pathRenderData.completedPaths.map((p) {
          final points = _extractPointsFromPath(p.path);
          return {
            'brushSize': p.brushSize,
            'brushColor': p.brushColor.value,
            'points': points,
            'pathId': p.hashCode.toString(),
          };
        }).toList();
      }

      print('寮€濮嬪鐞嗚疆寤擄紝浼犻€?${erasePaths.length} 涓矾寰?..');
      final result = await imageProcessor.previewProcessing(
        imageBytes,
        fullImageRect,
        options,
        erasePaths,
        rotation: widget.region?.rotation ?? 0.0,
      );
      print('杞粨澶勭悊瀹屾垚');

      if (mounted) {
        setState(() {
          _outline = result.outline;
          _isProcessing = false;
        });

        if (_layerStackKey.currentState != null) {
          final showContour = ref.read(eraseStateProvider).showContour;
          print('浼犻€掕疆寤撴暟鎹埌 EraseLayerStack, 鏄剧ず=$showContour');
          _layerStackKey.currentState!
              .setOutline(showContour ? _outline : null);
        }
      }
    } catch (e) {
      print('杞粨妫€娴嬪け璐? $e');
      if (kDebugMode) {
        print('閿欒鍫嗘爤: ${StackTrace.current}');
      }
      setState(() => _isProcessing = false);
    }
  }

  /// 鏇存柊鍧愭爣杞崲鍣?
  /// [viewportSize] 瑙嗗彛灏哄
  void _updateTransformer(Size viewportSize) {
    if (!mounted) {
      AppLogger.warning('鏃犳硶鏇存柊鍧愭爣杞崲鍣細缁勪欢鏈寕杞?);
      return;
    }

    try {
      final imageSize = Size(
        widget.image.width.toDouble(),
        widget.image.height.toDouble(),
      );

      _transformer = CoordinateTransformer(
        transformationController: _transformationController,
        imageSize: imageSize,
        viewportSize: viewportSize,
        enableLogging: kDebugMode,
      );

      // if (kDebugMode) {
      //   AppLogger.debug('鍧愭爣杞崲鍣ㄦ洿鏂板畬鎴?, data: {
      //     'imageSize': '${imageSize.width}x${imageSize.height}',
      //     'viewportSize': '${viewportSize.width}x${viewportSize.height}',
      //     'scale': _transformer.currentScale.toStringAsFixed(3),
      //   });
      // }
    } catch (e, stack) {
      AppLogger.error('鏇存柊鍧愭爣杞崲鍣ㄥけ璐?, error: e, stackTrace: stack, data: {
        'imageSize': '${widget.image.width}x${widget.image.height}',
        'viewportSize': '${viewportSize.width}x${viewportSize.height}',
      });
    }
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\widgets\character_edit\character_edit_panel.dart
-----------------------------------
import 'dart:async';
import 'dart:ui' as ui;
import 'dart:io';

import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:image/image.dart' as img;

import '../../application/services/character/character_service.dart';
import '../../application/services/image/character_image_processor.dart';
import '../../domain/models/character/character_region.dart';
import '../../domain/models/character/processing_options.dart';
import '../../domain/models/character/processing_result.dart';
import '../../infrastructure/logging/logger.dart';
import '../../presentation/providers/character/character_collection_provider.dart';
import '../../presentation/providers/character/character_edit_providers.dart';
import '../../presentation/providers/character/character_save_notifier.dart';
import '../../presentation/providers/character/erase_providers.dart' as erase;
import '../../presentation/providers/character/selected_region_provider.dart';
import 'character_edit_canvas.dart';
import 'dialogs/save_confirmation_dialog.dart';
import 'keyboard/shortcut_handler.dart';

/// 瀛楃缂栬緫闈㈡澘缁勪欢
///
/// 鐢ㄤ簬缂栬緫浣滃搧鍥剧墖涓殑瀛楃鍖哄煙銆?
///
/// [selectedRegion] - 閫変腑鐨勫瓧绗﹀尯鍩?
/// [imageData] - 鍥惧儚鏁版嵁
/// [processingOptions] - 澶勭悊閫夐」
/// [workId] - 浣滃搧ID
/// [pageId] - 浣滃搧鍥剧墖ID
/// [onEditComplete] - 缂栬緫瀹屾垚鏃剁殑鍥炶皟鍑芥暟
class CharacterEditPanel extends ConsumerStatefulWidget {
  final CharacterRegion selectedRegion;
  final Uint8List? imageData;
  final ProcessingOptions processingOptions;
  final String workId;
  final String pageId;
  final Function(Map<String, dynamic>) onEditComplete;

  const CharacterEditPanel({
    super.key,
    required this.selectedRegion,
    required this.imageData,
    required this.processingOptions,
    required this.workId,
    required this.pageId,
    required this.onEditComplete,
  });

  @override
  ConsumerState<CharacterEditPanel> createState() => _CharacterEditPanelState();
}

class _CharacterEditPanelState extends ConsumerState<CharacterEditPanel> {
  final GlobalKey<CharacterEditCanvasState> _canvasKey = GlobalKey();
  final TextEditingController _characterController = TextEditingController();
  bool _isEditing = false;

  // State for internal image loading
  Future<ui.Image?>? _imageLoadingFuture;
  ui.Image? _loadedImage;

  Map<Type, Action<Intent>> get _actions => {
        _SaveIntent: CallbackAction(onInvoke: (_) => _handleSave()),
        _UndoIntent: CallbackAction(
            onInvoke: (_) =>
                ref.read(erase.eraseStateProvider.notifier).undo()),
        _RedoIntent: CallbackAction(
            onInvoke: (_) =>
                ref.read(erase.eraseStateProvider.notifier).redo()),
        _OpenInputIntent:
            CallbackAction(onInvoke: (_) => setState(() => _isEditing = true)),
        _ToggleInvertIntent: CallbackAction(
            onInvoke: (_) =>
                ref.read(erase.eraseStateProvider.notifier).toggleReverse()),
        _ToggleImageInvertIntent: CallbackAction(
            onInvoke: (_) => ref
                .read(erase.eraseStateProvider.notifier)
                .toggleImageInvert()),
        _ToggleContourIntent: CallbackAction(
            onInvoke: (_) =>
                ref.read(erase.eraseStateProvider.notifier).toggleContour()),
        _TogglePanModeIntent: CallbackAction(
            onInvoke: (_) =>
                ref.read(erase.eraseStateProvider.notifier).togglePanMode()),
        _SetBrushSizeIntent: CallbackAction(
          onInvoke: (intent) => ref
              .read(erase.eraseStateProvider.notifier)
              .setBrushSize((intent as _SetBrushSizeIntent).size),
        ),
      };

  Map<SingleActivator, Intent> get _shortcuts => {
        EditorShortcuts.save: _SaveIntent(),
        EditorShortcuts.undo: _UndoIntent(),
        EditorShortcuts.redo: _RedoIntent(),
        EditorShortcuts.openInput: _OpenInputIntent(),
        EditorShortcuts.toggleInvert: _ToggleInvertIntent(),
        EditorShortcuts.toggleImageInvert: _ToggleImageInvertIntent(),
        EditorShortcuts.toggleContour: _ToggleContourIntent(),
        EditorShortcuts.togglePanMode: _TogglePanModeIntent(),
        for (var i = 0; i < EditorShortcuts.brushSizePresets.length; i++)
          EditorShortcuts.brushSizePresets[i]:
              _SetBrushSizeIntent(EditorShortcuts.brushSizes[i]),
      };

  @override
  Widget build(BuildContext context) {
    return Shortcuts(
      shortcuts: _shortcuts,
      child: Actions(
        actions: _actions,
        child: Focus(
          autofocus: true,
          child: _buildContent(),
        ),
      ),
    );
  }

  @override
  void didUpdateWidget(CharacterEditPanel oldWidget) {
    super.didUpdateWidget(oldWidget);
    // Update character input if region character changes externally
    if (widget.selectedRegion.character != _characterController.text) {
      _characterController.text = widget.selectedRegion.character;
    }
    // Reload image if selected region or image data changes
    if (widget.selectedRegion.id != oldWidget.selectedRegion.id ||
        widget.imageData != oldWidget.imageData ||
        widget.processingOptions != oldWidget.processingOptions) {
      _initiateImageLoading();
      // Clear erase state when region changes
      WidgetsBinding.instance.addPostFrameCallback((_) {
        ref.read(erase.eraseStateProvider.notifier).clear();
      });
    }
  }

  @override
  void dispose() {
    try {
      _loadedImage?.dispose();
      _characterController.dispose();
      // Consider clearing providers related to THIS panel instance if needed
    } catch (e) {
      AppLogger.error('Character edit panel dispose error: $e');
    } finally {
      super.dispose();
    }
  }

  @override
  void initState() {
    super.initState();
    _characterController.text = widget.selectedRegion.character;
    _initiateImageLoading();
    // Clear erase state on init
    WidgetsBinding.instance.addPostFrameCallback((_) {
      ref.read(erase.eraseStateProvider.notifier).clear();
    });
  }

  Widget _buildContent() {
    final saveState = ref.watch(characterSaveNotifierProvider);
    final eraseState = ref.watch(erase.eraseStateProvider);
    final processedImageNotifier = ref.watch(processedImageProvider.notifier);

    return FutureBuilder<ui.Image?>(
      future: _imageLoadingFuture,
      builder: (context, snapshot) {
        if (snapshot.connectionState == ConnectionState.waiting) {
          return _buildLoadingState();
        }

        if (snapshot.hasError || !snapshot.hasData || snapshot.data == null) {
          processedImageNotifier
              .setError('鍥惧儚鍔犺浇澶辫触: ${snapshot.error ?? "鏈煡閿欒"}');
          return Center(
            child: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                const Icon(Icons.error_outline, color: Colors.red, size: 48),
                const SizedBox(height: 16),
                Text(
                  '鏃犳硶鍔犺浇鎴栧鐞嗗瓧绗﹀浘鍍?,
                  style: TextStyle(color: Colors.red.shade700),
                ),
                const SizedBox(height: 8),
                Text(
                  '${snapshot.error ?? "鏈煡閿欒"}',
                  style: TextStyle(color: Colors.grey.shade600, fontSize: 12),
                  textAlign: TextAlign.center,
                ),
              ],
            ),
          );
        }

        final loadedImageForCanvas = snapshot.data!;
        final region = ref.watch(selectedRegionProvider);

        return Column(
          children: [
            // 椤堕儴宸ュ叿鏍?
            _buildToolbar(),

            // 涓昏鍐呭鍖哄煙
            Expanded(
              child: Stack(
                children: [
                  // 鐢诲竷
                  CharacterEditCanvas(
                    key: _canvasKey,
                    image: loadedImageForCanvas,
                    showOutline: eraseState.showContour,
                    invertMode: eraseState.isReversed,
                    imageInvertMode: eraseState.imageInvertMode,
                    brushSize: eraseState.brushSize,
                    brushColor: eraseState.brushColor,
                    onEraseStart: _handleEraseStart,
                    onEraseUpdate: _handleEraseUpdate,
                    onEraseEnd: _handleEraseEnd,
                  ),

                  // 缂╃暐鍥鹃瑙?
                  if (region != null && region.id != null)
                    Positioned(
                      right: 16,
                      top: 16,
                      child: _buildThumbnailPreview(),
                    ),

                  // 瀛楃杈撳叆鎮诞绐?
                  if (_isEditing)
                    Positioned(
                      left: 16,
                      top: 16,
                      child: _buildCharacterInput(),
                    ),
                ],
              ),
            ),

            // 搴曢儴鎸夐挳
            _buildBottomButtons(saveState),
          ],
        );
      },
    );
  }

  Widget _buildToolbar() {
    final eraseState = ref.watch(erase.eraseStateProvider);

    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
      color: Theme.of(context).colorScheme.surface,
      child: Row(
        children: [
          // 鎾ら攢/閲嶅仛鎸夐挳缁?
          _buildToolbarButtonGroup([
            _ToolbarButton(
              icon: Icons.undo,
              tooltip: '鎾ら攢',
              onPressed: eraseState.canUndo
                  ? () => ref.read(erase.eraseStateProvider.notifier).undo()
                  : null,
              shortcut: EditorShortcuts.undo,
            ),
            _ToolbarButton(
              icon: Icons.redo,
              tooltip: '閲嶅仛',
              onPressed: eraseState.canRedo
                  ? () => ref.read(erase.eraseStateProvider.notifier).redo()
                  : null,
              shortcut: EditorShortcuts.redo,
            ),
          ]),

          const SizedBox(width: 16),

          // 绗斿埛澶у皬鎺у埗
          Expanded(
            child: Row(
              children: [
                const Icon(Icons.brush, size: 16, color: Colors.grey),
                const SizedBox(width: 8),
                Expanded(
                  child: Slider(
                    value: eraseState.brushSize,
                    min: 1.0,
                    max: 50.0,
                    onChanged: (value) {
                      ref
                          .read(erase.eraseStateProvider.notifier)
                          .setBrushSize(value);
                    },
                  ),
                ),
                Text(
                  eraseState.brushSize.toStringAsFixed(1),
                  style: const TextStyle(fontSize: 12, color: Colors.grey),
                ),
              ],
            ),
          ),

          const SizedBox(width: 16),

          // 宸ュ叿鎸夐挳缁?
          _buildToolbarButtonGroup([
            _ToolbarButton(
              icon: Icons.invert_colors,
              tooltip: '鍙嶈浆妯″紡',
              onPressed: () {
                ref.read(erase.eraseStateProvider.notifier).toggleReverse();
              },
              isActive: eraseState.isReversed,
              shortcut: EditorShortcuts.toggleInvert,
            ),
            _ToolbarButton(
              icon: Icons.flip,
              tooltip: '鍥惧儚鍙嶈浆',
              onPressed: () {
                ref.read(erase.eraseStateProvider.notifier).toggleImageInvert();
              },
              isActive: eraseState.imageInvertMode,
              shortcut: EditorShortcuts.toggleImageInvert,
            ),
            _ToolbarButton(
              icon: Icons.border_all,
              tooltip: '杞粨鏄剧ず',
              onPressed: () {
                ref.read(erase.eraseStateProvider.notifier).toggleContour();
              },
              isActive: eraseState.showContour,
              shortcut: EditorShortcuts.toggleContour,
            ),
          ]),
        ],
      ),
    );
  }

  Widget _buildToolbarButtonGroup(List<_ToolbarButton> buttons) {
    return Container(
      decoration: BoxDecoration(
        color: Colors.grey.shade100,
        borderRadius: BorderRadius.circular(4),
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: buttons.map((button) {
          final isFirst = buttons.indexOf(button) == 0;
          final isLast = buttons.indexOf(button) == buttons.length - 1;

          return Container(
            decoration: BoxDecoration(
              border: Border(
                left: isFirst
                    ? BorderSide.none
                    : BorderSide(color: Colors.grey.shade300),
              ),
            ),
            child: Tooltip(
              message:
                  ShortcutTooltipBuilder.build(button.tooltip, button.shortcut),
              child: IconButton(
                icon: Icon(
                  button.icon,
                  size: 20,
                  color: button.isActive
                      ? Theme.of(context).colorScheme.primary
                      : Colors.grey.shade700,
                ),
                onPressed: button.onPressed,
                padding: const EdgeInsets.all(8),
                constraints: const BoxConstraints(),
                style: IconButton.styleFrom(
                  backgroundColor: button.isActive
                      ? Theme.of(context).colorScheme.primary.withOpacity(0.1)
                      : null,
                  shape: RoundedRectangleBorder(
                    borderRadius: BorderRadius.horizontal(
                      left: Radius.circular(isFirst ? 4 : 0),
                      right: Radius.circular(isLast ? 4 : 0),
                    ),
                  ),
                ),
              ),
            ),
          );
        }).toList(),
      ),
    );
  }

  Widget _buildCharacterInput() {
    return Container(
      width: 200,
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: Theme.of(context).colorScheme.surface,
        borderRadius: BorderRadius.circular(8),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.1),
            blurRadius: 8,
            offset: const Offset(0, 2),
          ),
        ],
      ),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          Row(
            children: [
              const Icon(Icons.edit, size: 16, color: Colors.grey),
              const SizedBox(width: 8),
              const Text(
                '杈撳叆姹夊瓧',
                style: TextStyle(
                  fontSize: 14,
                  fontWeight: FontWeight.w500,
                ),
              ),
              const Spacer(),
              IconButton(
                icon: const Icon(Icons.close, size: 16),
                onPressed: () => setState(() => _isEditing = false),
                padding: EdgeInsets.zero,
                constraints: const BoxConstraints(),
              ),
            ],
          ),
          const SizedBox(height: 12),
          TextField(
            controller: _characterController,
            autofocus: true,
            maxLength: 1,
            textAlign: TextAlign.center,
            style: const TextStyle(fontSize: 24),
            decoration: const InputDecoration(
              hintText: '璇疯緭鍏?,
              counterText: '',
              border: OutlineInputBorder(),
            ),
            onSubmitted: (_) => setState(() => _isEditing = false),
          ),
        ],
      ),
    );
  }

  Widget _buildThumbnailPreview() {
    // 妫€鏌egion鏄惁瀛樺湪锛屽鏋滀笉瀛樺湪鍒欎笉鏄剧ず缂╃暐鍥?
    final region = ref.watch(selectedRegionProvider);
    if (region == null) {
      print('CharacterEditPanel - 娌℃湁閫変腑鐨勫尯鍩燂紝涓嶆樉绀虹缉鐣ュ浘');
      return const SizedBox.shrink();
    }

    // 妫€鏌egion鐨刬d鏄惁瀛樺湪锛屽鏋滀笉瀛樺湪鍒欎笉鏄剧ず缂╃暐鍥?
    if (region.id == null) {
      print('CharacterEditPanel - 鍖哄煙ID涓虹┖锛屼笉鏄剧ず缂╃暐鍥?);
      return const SizedBox.shrink();
    }

    // 妫€鏌egion鐨刢haracterId鏄惁瀛樺湪锛屽鏋滀笉瀛樺湪璇存槑鏄柊寤洪€夊尯锛屼笉鏄剧ず缂╃暐鍥?
    if (region.characterId == null) {
      print('CharacterEditPanel - 鍖哄煙鏈叧鑱斿瓧绗︼紝涓嶆樉绀虹缉鐣ュ浘');
      return const SizedBox.shrink();
    }

    return FutureBuilder<String?>(
      future: _getThumbnailPath(),
      builder: (context, snapshot) {
        print('CharacterEditPanel - 鏋勫缓缂╃暐鍥鹃瑙?);

        if (snapshot.hasError) {
          print('CharacterEditPanel - 鑾峰彇缂╃暐鍥捐矾寰勫け璐? ${snapshot.error}');
          return _buildErrorWidget('鍔犺浇缂╃暐鍥惧け璐?);
        }

        if (!snapshot.hasData) {
          print('CharacterEditPanel - 绛夊緟缂╃暐鍥捐矾寰?..');
          return _buildLoadingWidget();
        }

        final thumbnailPath = snapshot.data!;
        print('CharacterEditPanel - 鑾峰彇鍒扮缉鐣ュ浘璺緞: $thumbnailPath');

        return FutureBuilder<bool>(
          future: File(thumbnailPath).exists(),
          builder: (context, existsSnapshot) {
            if (existsSnapshot.hasError) {
              print(
                  'CharacterEditPanel - 妫€鏌ョ缉鐣ュ浘鏂囦欢瀛樺湪澶辫触: ${existsSnapshot.error}');
              return _buildErrorWidget('妫€鏌ユ枃浠跺け璐?);
            }

            if (!existsSnapshot.hasData) {
              print('CharacterEditPanel - 妫€鏌ョ缉鐣ュ浘鏂囦欢鏄惁瀛樺湪...');
              return _buildLoadingWidget();
            }

            final exists = existsSnapshot.data!;
            print(
                'CharacterEditPanel - 缂╃暐鍥炬枃浠?{exists ? "瀛樺湪" : "涓嶅瓨鍦?}: $thumbnailPath');

            if (!exists) {
              print('CharacterEditPanel - 缂╃暐鍥炬枃浠朵笉瀛樺湪');
              return _buildErrorWidget('缂╃暐鍥句笉瀛樺湪');
            }

            return FutureBuilder<int>(
              future: File(thumbnailPath).length(),
              builder: (context, sizeSnapshot) {
                if (sizeSnapshot.hasError) {
                  print(
                      'CharacterEditPanel - 鑾峰彇缂╃暐鍥炬枃浠跺ぇ灏忓け璐? ${sizeSnapshot.error}');
                  return _buildErrorWidget('鑾峰彇鏂囦欢澶у皬澶辫触');
                }

                if (!sizeSnapshot.hasData) {
                  print('CharacterEditPanel - 鑾峰彇缂╃暐鍥炬枃浠跺ぇ灏?..');
                  return _buildLoadingWidget();
                }

                final fileSize = sizeSnapshot.data!;
                print('CharacterEditPanel - 缂╃暐鍥炬枃浠跺ぇ灏? $fileSize 瀛楄妭');

                if (fileSize == 0) {
                  print('CharacterEditPanel - 缂╃暐鍥炬枃浠跺ぇ灏忎负0');
                  return _buildErrorWidget('缂╃暐鍥炬枃浠朵负绌?);
                }

                return Image.file(
                  File(thumbnailPath),
                  width: 100,
                  height: 100,
                  fit: BoxFit.cover,
                  errorBuilder: (context, error, stackTrace) {
                    print('CharacterEditPanel - 鍔犺浇缂╃暐鍥惧け璐? $error');
                    print('$stackTrace');
                    return _buildErrorWidget('鍔犺浇鍥剧墖澶辫触');
                  },
                );
              },
            );
          },
        );
      },
    );
  }

  Widget _buildErrorWidget(String message) {
    return Container(
      width: 100,
      height: 100,
      decoration: BoxDecoration(
        color: Colors.grey[200],
        borderRadius: BorderRadius.circular(8),
      ),
      child: Center(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Icon(Icons.error_outline, color: Colors.red),
            SizedBox(height: 4),
            Text(
              message,
              style: TextStyle(fontSize: 12),
              textAlign: TextAlign.center,
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildLoadingWidget() {
    return Container(
      width: 100,
      height: 100,
      decoration: BoxDecoration(
        color: Colors.grey[200],
        borderRadius: BorderRadius.circular(8),
      ),
      child: Center(
        child: CircularProgressIndicator(),
      ),
    );
  }

  Widget _buildBottomButtons(SaveState saveState) {
    final bool isSaving = saveState.isSaving;
    final String? errorMessage = saveState.error;

    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
      color: Theme.of(context).colorScheme.surface,
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          if (errorMessage != null)
            Container(
              margin: const EdgeInsets.only(bottom: 12),
              padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
              decoration: BoxDecoration(
                color: Theme.of(context).colorScheme.error.withOpacity(0.1),
                borderRadius: BorderRadius.circular(4),
              ),
              child: Row(
                children: [
                  Icon(
                    Icons.error_outline,
                    size: 16,
                    color: Theme.of(context).colorScheme.error,
                  ),
                  const SizedBox(width: 8),
                  Expanded(
                    child: Text(
                      errorMessage,
                      style: TextStyle(
                        color: Theme.of(context).colorScheme.error,
                        fontSize: 12,
                      ),
                    ),
                  ),
                ],
              ),
            ),
          Row(
            mainAxisAlignment: MainAxisAlignment.end,
            children: [
              if (!_isEditing)
                TextButton.icon(
                  onPressed:
                      isSaving ? null : () => setState(() => _isEditing = true),
                  icon: const Icon(Icons.edit, size: 18),
                  label: Text(ShortcutTooltipBuilder.build(
                    '杈撳叆姹夊瓧',
                    EditorShortcuts.openInput,
                  )),
                  style: TextButton.styleFrom(
                    padding:
                        const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
                  ),
                ),
              const SizedBox(width: 12),
              ElevatedButton.icon(
                onPressed: isSaving ? null : () => _handleSave(),
                icon: isSaving
                    ? const SizedBox(
                        width: 16,
                        height: 16,
                        child: CircularProgressIndicator(strokeWidth: 2),
                      )
                    : const Icon(Icons.save, size: 18),
                label: Text(ShortcutTooltipBuilder.build(
                  '淇濆瓨',
                  EditorShortcuts.save,
                )),
                style: ElevatedButton.styleFrom(
                  padding:
                      const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
                ),
              ),
            ],
          ),
        ],
      ),
    );
  }

  void _handleEraseEnd() {
    ref.read(erase.eraseStateProvider.notifier).completePath();
  }

  void _handleEraseStart(Offset position) {
    ref.read(erase.eraseStateProvider.notifier).startPath(position);
  }

  void _handleEraseUpdate(Offset position, Offset delta) {
    ref.read(erase.eraseStateProvider.notifier).updatePath(position);
  }

  Future<void> _handleSave() async {
    // 杈撳叆楠岃瘉
    final validation =
        _CharacterInputValidator.validateCharacter(_characterController.text);
    if (!validation.isValid) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text(validation.error!)),
      );
      setState(() {
        _isEditing = true;
      });
      return;
    }

    // 鏄剧ず纭瀵硅瘽妗?
    final confirmed = await showSaveConfirmationDialog(
      context,
      character: _characterController.text,
    );

    if (confirmed != true) return;
    if (!mounted) return;

    try {
      // 鑾峰彇澶勭悊鍚庣殑鍥惧儚锛堝甫閲嶈瘯鏈哄埗锛?
      final processedImage = await _RetryStrategy.run(
        operation: () async {
          final canvasState = _canvasKey.currentState;
          if (canvasState == null) {
            throw _SaveError('鐢诲竷鐘舵€佽幏鍙栧け璐?);
          }

          final image = await canvasState.getProcessedImage();
          if (image == null) {
            throw _SaveError('鑾峰彇澶勭悊缁撴灉澶辫触');
          }
          return image;
        },
        operationName: '鍥惧儚澶勭悊',
      );
      if (!mounted) return;

      // 鍒涘缓澶勭悊缁撴灉
      final pathRenderData = ref.read(erase.pathRenderDataProvider);
      final eraseState = ref.read(erase.eraseStateProvider);

      final processingOptions = ProcessingOptions(
        inverted: eraseState.isReversed,
        threshold: 128.0,
        noiseReduction: 0.5,
        showContour: eraseState.showContour,
      );

      // 浠巗electedRegionProvider鑾峰彇褰撳墠閫夊尯
      final selectedRegion = ref.read(selectedRegionProvider);
      if (selectedRegion == null) {
        throw _SaveError('鏈€夋嫨浠讳綍鍖哄煙');
      }

      // 鑾峰彇澶勭悊鎵€闇€鐨勭敾甯冪姸鎬?
      final canvasState = _canvasKey.currentState;
      if (canvasState == null) {
        throw _SaveError('鏃犳硶鑾峰彇鐢诲竷鐘舵€?);
      }

      // 鑾峰彇鍥惧儚鏁版嵁锛堝甫閲嶈瘯鏈哄埗锛?
      final imageData = await _RetryStrategy.run(
        operation: () async {
          final data =
              await processedImage.toByteData(format: ui.ImageByteFormat.png);
          if (data == null) {
            throw _SaveError('鍥惧儚鏁版嵁鑾峰彇澶辫触');
          }
          return data;
        },
        operationName: '鍥惧儚鏁版嵁杞崲',
      );

      final uint8List = imageData.buffer.asUint8List();

      // 鏇存柊閫夊尯淇℃伅
      final updatedRegion = selectedRegion.copyWith(
        pageId: widget.pageId,
        character: _characterController.text,
        options: processingOptions,
      );

      // 鍒涘缓澶勭悊缁撴灉
      final processingResult = ProcessingResult(
        originalCrop: uint8List,
        binaryImage: uint8List,
        thumbnail: uint8List,
        boundingBox: selectedRegion.rect,
      );

      // 淇濆瓨锛堝甫閲嶈瘯鏈哄埗锛?
      final saveNotifier = ref.read(characterSaveNotifierProvider.notifier);
      final saveResult = await _RetryStrategy.run(
        operation: () async {
          if (!mounted) throw _SaveError('鎿嶄綔宸插彇娑?);

          final result = await saveNotifier.save(
              updatedRegion, processingResult, widget.workId);

          if (!mounted) throw _SaveError('鎿嶄綔宸插彇娑?);

          if (!result.isSuccess) {
            throw _SaveError(result.error?.toString() ?? '淇濆瓨澶辫触');
          }

          return result;
        },
        operationName: '淇濆瓨瀛楃',
      );

      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('淇濆瓨鎴愬姛'),
            backgroundColor: Colors.green,
          ),
        );
        // 鏇存柊閫夊尯鐘舵€?
        final collectionNotifier =
            ref.read(characterCollectionProvider.notifier);
        final finalRegionId = saveResult.data!;
        final finalRegion = updatedRegion.copyWith(
          id: finalRegionId,
          isSaved: true,
          characterId: finalRegionId,
        );
        collectionNotifier.updateSelectedRegion(finalRegion);
        collectionNotifier.markAsSaved(finalRegionId);

        widget.onEditComplete({
          'characterId': finalRegionId,
          'paths': pathRenderData.completedPaths ?? [],
          'processingOptions': processingOptions,
          'character': _characterController.text,
        });
      }
    } catch (e) {
      if (!mounted) return;

      try {
        final errorMessage = e is _SaveError ? e.toString() : '淇濆瓨澶辫触锛?e';
        ref.read(characterSaveNotifierProvider.notifier).state = ref
            .read(characterSaveNotifierProvider)
            .copyWith(error: errorMessage);

        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text(errorMessage),
            backgroundColor: Colors.red,
            action: SnackBarAction(
              label: '閲嶈瘯',
              textColor: Colors.white,
              onPressed: _handleSave,
            ),
          ),
        );
      } catch (e) {
        // 蹇界暐鍦ㄦ樉绀洪敊璇秷鎭椂鍙兘鍙戠敓鐨勫紓甯?
      }
    }
  }

  void _initiateImageLoading() {
    if (widget.imageData != null) {
      setState(() {
        // Cancel previous future?
        _loadedImage = null; // Clear current image while loading
        _imageLoadingFuture = _loadAndProcessImage(
          widget.selectedRegion,
          widget.imageData!,
          widget.processingOptions,
        );
      });
    } else {
      setState(() {
        _imageLoadingFuture = Future.value(null); // Set future to null result
        _loadedImage = null;
      });
    }
  }

  Future<ui.Image?> _loadAndProcessImage(
    CharacterRegion region,
    Uint8List imageData,
    ProcessingOptions processingOptions,
  ) async {
    try {
      final imageProcessor = ref.read(characterImageProcessorProvider);
      final preview = await imageProcessor.previewProcessing(
        imageData,
        region.rect,
        processingOptions,
        null,
        rotation: region.rotation,
      );

      final bytes = Uint8List.fromList(img.encodePng(preview.processedImage));
      final completer = Completer<ui.Image>();
      ui.decodeImageFromList(bytes, completer.complete);
      _loadedImage?.dispose(); // Dispose previous loaded image
      _loadedImage = await completer.future;
      return _loadedImage;
    } catch (e, stack) {
      AppLogger.error('Error loading/processing character image in panel',
          error: e, stackTrace: stack);
      return null;
    }
  }

  // 鏋勫缓鍔犺浇鐘舵€?
  Widget _buildLoadingState() {
    return const Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          CircularProgressIndicator(strokeWidth: 2),
          SizedBox(height: 16),
          Text('姝ｅ湪鍔犺浇瀛楃鍥惧儚...', style: TextStyle(color: Colors.grey)),
        ],
      ),
    );
  }

  // 鑾峰彇缂╃暐鍥捐矾寰?
  Future<String?> _getThumbnailPath() async {
    try {
      print('鑾峰彇缂╃暐鍥捐矾寰?);

      // 鑾峰彇characterId锛屽鏋滀负绌哄垯浣跨敤region鐨刬d
      final String? characterId =
          widget.selectedRegion.characterId ?? widget.selectedRegion.id;
      print('浣跨敤鐨刢haracterId: $characterId');

      if (characterId == null) {
        print('characterId涓虹┖锛屾棤娉曡幏鍙栫缉鐣ュ浘');
        throw Exception('characterId涓虹┖锛屾棤娉曡幏鍙栫缉鐣ュ浘');
      }

      final path = await ref
          .read(characterCollectionProvider.notifier)
          .getThumbnailPath(characterId);
      print('鑾峰彇鍒扮缉鐣ュ浘璺緞: $path');

      if (path == null) {
        throw Exception('缂╃暐鍥捐矾寰勪负绌?);
      }

      final file = File(path);
      final exists = await file.exists();
      if (!exists) {
        AppLogger.error('缂╃暐鍥炬枃浠朵笉瀛樺湪',
            data: {'path': path, 'characterId': characterId});
        throw Exception('缂╃暐鍥炬枃浠朵笉瀛樺湪');
      }

      final fileSize = await file.length();
      if (fileSize == 0) {
        AppLogger.error('缂╃暐鍥炬枃浠跺ぇ灏忎负0',
            data: {'path': path, 'characterId': characterId});
        throw Exception('缂╃暐鍥炬枃浠跺ぇ灏忎负0');
      }

      return path;
    } catch (e) {
      print('鑾峰彇缂╃暐鍥捐矾寰勫け璐? $e');
      AppLogger.error('鑾峰彇缂╃暐鍥捐矾寰勫け璐?, error: e, data: {
        'characterId':
            widget.selectedRegion.characterId ?? widget.selectedRegion.id
      });
      return null;
    }
  }
}

/// 瀛楃缂栬緫闈㈡澘鐨勮緭鍏ラ獙璇佸櫒
class _CharacterInputValidator {
  static _ValidationResult validateCharacter(String? input) {
    if (input == null || input.isEmpty) {
      return _ValidationResult.failure('璇疯緭鍏ユ眽瀛?);
    }

    if (input.length > 1) {
      return _ValidationResult.failure('鍙兘杈撳叆涓€涓眽瀛?);
    }

    // 楠岃瘉鏄惁涓烘眽瀛?
    final RegExp hanziRegExp = RegExp(r'[\u4e00-\u9fa5]');
    if (!hanziRegExp.hasMatch(input)) {
      return _ValidationResult.failure('璇疯緭鍏ユ湁鏁堢殑姹夊瓧');
    }

    return _ValidationResult.success;
  }
}

class _OpenInputIntent extends Intent {}

class _RedoIntent extends Intent {}

// 閲嶈瘯鏈哄埗
class _RetryStrategy {
  static const int maxAttempts = 3;
  static const Duration delayBetweenAttempts = Duration(seconds: 1);

  static Future<T> run<T>({
    required Future<T> Function() operation,
    String? operationName,
  }) async {
    var attempt = 0;
    while (true) {
      try {
        attempt++;
        return await operation();
      } catch (e) {
        if (attempt >= maxAttempts) {
          throw _SaveError(
            '${operationName ?? '鎿嶄綔'}澶辫触锛屽凡閲嶈瘯$maxAttempts娆?,
            e is Exception ? e : Exception(e.toString()),
          );
        }
        await Future.delayed(delayBetweenAttempts);
      }
    }
  }
}

class _SaveError implements Exception {
  final String message;
  final Exception? cause;

  _SaveError(this.message, [this.cause]);

  @override
  String toString() => cause != null ? '$message: $cause' : message;
}

// Intent绫诲畾涔?
class _SaveIntent extends Intent {}

class _SetBrushSizeIntent extends Intent {
  final double size;
  const _SetBrushSizeIntent(this.size);
}

class _ToggleContourIntent extends Intent {}

class _ToggleImageInvertIntent extends Intent {}

class _ToggleInvertIntent extends Intent {}

class _TogglePanModeIntent extends Intent {}

class _UndoIntent extends Intent {}

// 楠岃瘉鍣?
class _ValidationResult {
  static const _ValidationResult success = _ValidationResult(isValid: true);
  final bool isValid;

  final String? error;

  const _ValidationResult({
    required this.isValid,
    this.error,
  });

  static _ValidationResult failure(String error) => _ValidationResult(
        isValid: false,
        error: error,
      );
}

class _ToolbarButton {
  final IconData icon;
  final String tooltip;
  final VoidCallback? onPressed;
  final bool isActive;
  final SingleActivator shortcut;

  const _ToolbarButton({
    required this.icon,
    required this.tooltip,
    required this.onPressed,
    this.isActive = false,
    required this.shortcut,
  });
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\widgets\character_edit\dialogs\save_confirmation_dialog.dart
-----------------------------------
import 'package:flutter/material.dart';

Future<bool?> showSaveConfirmationDialog(
  BuildContext context, {
  required String character,
  Widget? previewWidget,
}) {
  return showDialog<bool>(
    context: context,
    builder: (context) => SaveConfirmationDialog(
      character: character,
      showPreview: previewWidget != null,
      previewWidget: previewWidget,
      onConfirm: () => Navigator.of(context).pop(true),
      onCancel: () => Navigator.of(context).pop(false),
    ),
  );
}

class SaveConfirmationDialog extends StatelessWidget {
  final String character;
  final VoidCallback onConfirm;
  final VoidCallback onCancel;
  final bool showPreview;
  final Widget? previewWidget;

  const SaveConfirmationDialog({
    super.key,
    required this.character,
    required this.onConfirm,
    required this.onCancel,
    this.showPreview = false,
    this.previewWidget,
  });

  @override
  Widget build(BuildContext context) {
    return AlertDialog(
      title: const Text('纭淇濆瓨'),
      content: Column(
        mainAxisSize: MainAxisSize.min,
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text('纭畾瑕佷繚瀛樻眽瀛?$character"鍚楋紵'),
          if (showPreview && previewWidget != null) ...[
            const SizedBox(height: 16),
            const Text('棰勮鏁堟灉锛?),
            const SizedBox(height: 8),
            SizedBox(
              width: 200,
              height: 200,
              child: previewWidget!,
            ),
          ],
        ],
      ),
      actions: [
        TextButton(
          onPressed: onCancel,
          child: const Text('鍙栨秷'),
        ),
        ElevatedButton(
          onPressed: onConfirm,
          child: const Text('纭畾'),
        ),
      ],
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\widgets\character_edit\dialogs\shortcuts_help_dialog.dart
-----------------------------------
import 'package:flutter/material.dart';

Future<void> showShortcutsHelp(BuildContext context) {
  return showDialog(
    context: context,
    builder: (context) => const ShortcutsHelpDialog(),
  );
}

class ShortcutsHelpDialog extends StatelessWidget {
  const ShortcutsHelpDialog({super.key});

  @override
  Widget build(BuildContext context) {
    return Dialog(
      child: Container(
        width: 400,
        padding: const EdgeInsets.all(24),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // 鏍囬
            const Row(
              children: [
                Icon(Icons.keyboard, size: 24),
                SizedBox(width: 8),
                Text(
                  '蹇嵎閿府鍔?,
                  style: TextStyle(
                    fontSize: 18,
                    fontWeight: FontWeight.bold,
                  ),
                ),
              ],
            ),
            const SizedBox(height: 16),

            // 宸ュ叿鍒囨崲
            _buildSection('宸ュ叿鍒囨崲', [
              const _ShortcutItem(
                shortcut: 'V',
                description: '鎷栨嫿宸ュ叿锛氱Щ鍔ㄥ拰缂╂斁鍥剧墖',
                icon: Icons.pan_tool,
              ),
              const _ShortcutItem(
                shortcut: 'R',
                description: '妗嗛€夊伐鍏凤細鍒涘缓鍜岃皟鏁村瓧绗︽',
                icon: Icons.crop_square,
              ),
              const _ShortcutItem(
                shortcut: 'M',
                description: '澶氶€夊伐鍏凤細閫夋嫨澶氫釜瀛楃妗?,
                icon: Icons.select_all,
              ),
            ]),

            const Divider(height: 32),

            // 閫夊尯鎿嶄綔
            _buildSection('閫夊尯鎿嶄綔', [
              const _ShortcutItem(
                shortcut: '鈫?鈫?鈫?鈫?,
                description: '寰皟閫夊尯浣嶇疆',
                icon: Icons.move_down,
              ),
              const _ShortcutItem(
                shortcut: 'Shift + 鏂瑰悜閿?,
                description: '澶у箙璋冩暣閫夊尯浣嶇疆',
                icon: Icons.expand,
              ),
              const _ShortcutItem(
                shortcut: 'Enter',
                description: '纭閫夊尯璋冩暣',
                icon: Icons.check_circle_outline,
              ),
              const _ShortcutItem(
                shortcut: 'Esc',
                description: '鍙栨秷閫夊尯璋冩暣',
                icon: Icons.cancel_outlined,
              ),
              const _ShortcutItem(
                shortcut: 'Delete / Backspace',
                description: '鍒犻櫎閫変腑鐨勫瓧绗︽',
                icon: Icons.delete_outline,
              ),
            ]),

            const Divider(height: 32),

            // 鍏朵粬鎿嶄綔
            _buildSection('鍏朵粬鎿嶄綔', [
              const _ShortcutItem(
                shortcut: 'Alt + D',
                description: '鍒囨崲璋冭瘯妯″紡',
                icon: Icons.bug_report_outlined,
              ),
              const _ShortcutItem(
                shortcut: '榧犳爣婊氳疆',
                description: '缂╂斁鍥剧墖',
                icon: Icons.zoom_in,
              ),
            ]),

            const SizedBox(height: 24),

            // 纭畾鎸夐挳
            Align(
              alignment: Alignment.centerRight,
              child: TextButton(
                onPressed: () => Navigator.of(context).pop(),
                child: const Text('纭畾'),
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildSection(String title, List<_ShortcutItem> items) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(
          title,
          style: const TextStyle(
            fontSize: 16,
            fontWeight: FontWeight.bold,
          ),
        ),
        const SizedBox(height: 8),
        ...items,
      ],
    );
  }
}

class _ShortcutItem extends StatelessWidget {
  final String shortcut;
  final String description;
  final IconData icon;

  const _ShortcutItem({
    required this.shortcut,
    required this.description,
    required this.icon,
  });

  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 4),
      child: Row(
        children: [
          Icon(icon, size: 18, color: Colors.black54),
          const SizedBox(width: 8),
          Container(
            padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 2),
            decoration: BoxDecoration(
              color: Colors.grey.shade200,
              borderRadius: BorderRadius.circular(4),
            ),
            child: Text(
              shortcut,
              style: const TextStyle(
                fontFamily: 'monospace',
                fontWeight: FontWeight.bold,
              ),
            ),
          ),
          const SizedBox(width: 12),
          Expanded(
            child: Text(
              description,
              style: const TextStyle(color: Colors.black87),
            ),
          ),
        ],
      ),
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\widgets\character_edit\keyboard\shortcut_handler.dart
-----------------------------------
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';

/// 缂栬緫鍣ㄥ揩鎹烽敭瀹氫箟
class EditorShortcuts {
  // 淇濆瓨蹇嵎閿?
  static const save = SingleActivator(
    LogicalKeyboardKey.keyS,
    control: true,
  );

  // 鎾ら攢蹇嵎閿?
  static const undo = SingleActivator(
    LogicalKeyboardKey.keyZ,
    control: true,
  );

  // 閲嶅仛蹇嵎閿?
  static const redo = SingleActivator(
    LogicalKeyboardKey.keyZ,
    control: true,
    shift: true,
  );

  // 鎵撳紑姹夊瓧杈撳叆妗嗗揩鎹烽敭
  static const openInput = SingleActivator(
    LogicalKeyboardKey.keyE,
    control: true,
  );

  // 鍒囨崲鍙嶈浆妯″紡蹇嵎閿?
  static const toggleInvert = SingleActivator(
    LogicalKeyboardKey.keyI,
    control: true,
  );

  // 鍒囨崲鍥惧儚鍙嶈浆蹇嵎閿?
  static const toggleImageInvert = SingleActivator(
    LogicalKeyboardKey.keyI,
    control: true,
    shift: true,
  );

  // 鍒囨崲杞粨鏄剧ず蹇嵎閿?
  static const toggleContour = SingleActivator(
    LogicalKeyboardKey.keyO,
    control: true,
  );

  // 鍒囨崲骞崇Щ妯″紡蹇嵎閿?
  static const togglePanMode = SingleActivator(
    LogicalKeyboardKey.keyP,
    control: true,
  );

  // 鍒囨崲绗斿埛澶у皬棰勮蹇嵎閿?
  static const List<SingleActivator> brushSizePresets = [
    SingleActivator(LogicalKeyboardKey.digit1, control: true),
    SingleActivator(LogicalKeyboardKey.digit2, control: true),
    SingleActivator(LogicalKeyboardKey.digit3, control: true),
  ];

  // 绗斿埛澶у皬棰勮鍊?
  static const List<double> brushSizes = [5.0, 15.0, 30.0];

  // 鑾峰彇蹇嵎閿枃鏈弿杩?
  static String getShortcutLabel(SingleActivator shortcut) {
    final List<String> parts = [];

    if (shortcut.control) parts.add('Ctrl');
    if (shortcut.shift) parts.add('Shift');
    if (shortcut.alt) parts.add('Alt');

    String key = shortcut.trigger.keyLabel;
    if (key.length == 1) key = key.toUpperCase();
    parts.add(key);

    return parts.join('+');
  }
}

/// 蹇嵎閿彁绀烘瀯寤哄櫒
class ShortcutTooltipBuilder {
  static String build(String action, SingleActivator shortcut) {
    return '$action (${EditorShortcuts.getShortcutLabel(shortcut)})';
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\widgets\character_edit\layers\background_layer.dart
-----------------------------------
import 'dart:ui' as ui;

import 'package:flutter/material.dart';

import 'base_layer.dart';

/// 鑳屾櫙鍥惧眰锛屾樉绀哄師濮嬪浘鍍?
class BackgroundLayer extends BaseLayer {
  final ui.Image image;
  final bool hasChanged;
  final bool invertMode;

  const BackgroundLayer({
    Key? key,
    required this.image,
    this.hasChanged = false,
    this.invertMode = false,
  }) : super(key: key);

  @override
  bool get isComplexPainting => false; // 闈欐€佸唴瀹癸紝涓嶅鏉?

  @override
  bool get willChangePainting => false; // 闈欐€佸唴瀹癸紝涓嶉绻佸彉鍖?

  @override
  CustomPainter createPainter() => _BackgroundPainter(
        // Changed from _createPainter to createPainter
        image: image,
        hasChanged: hasChanged,
        invertMode: invertMode,
      );
}

class _BackgroundPainter extends CustomPainter {
  final ui.Image image;
  final bool hasChanged;
  final bool invertMode;

  ui.Picture? _cachedPicture;
  Size? _cachedSize;

  _BackgroundPainter({
    required this.image,
    required this.hasChanged,
    required this.invertMode,
  });

  @override
  void paint(Canvas canvas, Size size) {
    if (_cachedPicture == null || _cachedSize != size || hasChanged) {
      _renderCache(size);
    }

    // 浣跨敤缂撳瓨鐩存帴缁樺埗
    if (_cachedPicture != null) {
      canvas.drawPicture(_cachedPicture!);
    }
  }

  @override
  bool shouldRepaint(_BackgroundPainter oldDelegate) {
    return image != oldDelegate.image ||
        invertMode != oldDelegate.invertMode ||
        hasChanged != oldDelegate.hasChanged ||
        _cachedSize == null;
  }

  void _renderCache(Size size) {
    final recorder = ui.PictureRecorder();
    final cacheCanvas = Canvas(recorder);

    // 璁＄畻缁樺埗鍖哄煙锛屼娇鍥惧儚灞呬腑涓旈€傚簲鐢诲竷
    final imageRatio = image.width / image.height;
    final canvasRatio = size.width / size.height;

    double targetWidth, targetHeight;
    if (imageRatio > canvasRatio) {
      // 鍥惧儚杈冨锛屽搴﹂€傚簲鐢诲竷
      targetWidth = size.width;
      targetHeight = size.width / imageRatio;
    } else {
      // 鍥惧儚杈冮珮锛岄珮搴﹂€傚簲鐢诲竷
      targetHeight = size.height;
      targetWidth = size.height * imageRatio;
    }

    final left = (size.width - targetWidth) / 2;
    final top = (size.height - targetHeight) / 2;

    final rect = Rect.fromLTWH(left, top, targetWidth, targetHeight);

    // 缁樺埗鍥惧儚
    final paint = Paint()
      ..filterQuality = FilterQuality.high
      ..isAntiAlias = true;

    // 濡傛灉鏄弽杞ā寮忥紝璁剧疆鍙嶈浆棰滆壊鐨凜olorFilter
    if (invertMode) {
      paint.colorFilter = const ColorFilter.matrix([
        -1, 0, 0, 0, 255, // 绾㈣壊閫氶亾鍙嶈浆
        0, -1, 0, 0, 255, // 缁胯壊閫氶亾鍙嶈浆
        0, 0, -1, 0, 255, // 钃濊壊閫氶亾鍙嶈浆
        0, 0, 0, 1, 0 // alpha閫氶亾淇濇寔涓嶅彉
      ]);
    }

    cacheCanvas.drawImageRect(
      image,
      Rect.fromLTWH(0, 0, image.width.toDouble(), image.height.toDouble()),
      rect,
      paint,
    );

    _cachedPicture = recorder.endRecording();
    _cachedSize = size;
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\widgets\character_edit\layers\base_layer.dart
-----------------------------------
import 'package:flutter/material.dart';

/// 鎵€鏈夊浘灞傜殑鍩虹被锛屾彁渚涘叕鍏卞姛鑳藉拰鎺ュ彛
abstract class BaseLayer extends StatelessWidget {
  const BaseLayer({Key? key}) : super(key: key);

  /// 鏄惁鏄鏉傜粯鍒讹紙鎻愮ずFlutter鍙兘闇€瑕佹洿澶氳祫婧愶級
  bool get isComplexPainting => false;

  /// 鏄惁浼氶绻佸彉鍖栵紙鎻愮ずFlutter鍑嗗鏇撮绻佺殑閲嶇粯锛?
  bool get willChangePainting => false;

  @override
  Widget build(BuildContext context) {
    return RepaintBoundary(
      child: CustomPaint(
        painter: createPainter(),
        isComplex: isComplexPainting,
        willChange: willChangePainting,
        size: Size.infinite,
      ),
    );
  }

  /// 鍒涘缓鍥惧眰浣跨敤鐨勭粯鍒跺櫒 - 鍏紑鏂规硶浠ヤ究瀛愮被鍙互閲嶅啓
  CustomPainter createPainter();
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\widgets\character_edit\layers\erase_layer_stack.dart
-----------------------------------
import 'dart:math' as math;
import 'dart:ui' as ui;

import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../domain/models/character/detected_outline.dart';
import '../../../domain/models/character/path_info.dart';
import '../../../presentation/providers/character/erase_providers.dart';
import 'background_layer.dart';
import 'preview_layer.dart';
import 'ui_layer.dart';

/// 鎿﹂櫎鍥惧眰鏍堢粍浠讹紝绠＄悊鎵€鏈夊浘灞?
class EraseLayerStack extends ConsumerStatefulWidget {
  final ui.Image image;
  final TransformationController transformationController;
  final Function(Offset)? onEraseStart;
  final Function(Offset, Offset)? onEraseUpdate;
  final Function()? onEraseEnd;
  final Function(Offset)? onPan;
  final Function(Offset)? onTap;
  final bool altKeyPressed;
  final double brushSize;
  final Color brushColor;
  final bool imageInvertMode;
  final bool showOutline;

  const EraseLayerStack({
    Key? key,
    required this.image,
    required this.transformationController,
    this.onEraseStart,
    this.onEraseUpdate,
    this.onEraseEnd,
    this.onPan,
    this.onTap,
    this.altKeyPressed = false,
    this.brushSize = 10.0,
    this.brushColor = Colors.white,
    this.imageInvertMode = false,
    this.showOutline = false,
  }) : super(key: key);

  @override
  ConsumerState<EraseLayerStack> createState() => EraseLayerStackState();
}

class EraseLayerStackState extends ConsumerState<EraseLayerStack> {
  DetectedOutline? _outline;
  List<PathInfo> _paths = [];
  PathInfo? _currentPath;
  Rect? _dirtyBounds;

  @override
  Widget build(BuildContext context) {
    final renderData = ref.watch(pathRenderDataProvider);
    final eraseState = ref.watch(eraseStateProvider);
    final showContour = eraseState.showContour;

    if (_outline != null) {
      print('EraseLayerStack 杞粨鏁版嵁瀛樺湪, 璺緞鏁伴噺: ${_outline!.contourPoints.length}');
    } else {
      print('EraseLayerStack 杞粨鏁版嵁涓嶅瓨鍦?);
    }

    final displayPaths = renderData.completedPaths ?? _paths;
    final displayCurrentPath = renderData.currentPath;
    final displayDirtyRect = renderData.dirtyBounds;

    return RepaintBoundary(
      child: Stack(
        fit: StackFit.expand,
        children: [
          BackgroundLayer(
            image: widget.image,
            invertMode: widget.imageInvertMode,
          ),
          PreviewLayer(
            paths: displayPaths,
            currentPath: displayCurrentPath,
            dirtyRect: displayDirtyRect,
          ),
          UILayer(
            onPointerDown: _handlePointerDown,
            onPointerMove: _handlePointerMove,
            onPointerUp: _handlePointerUp,
            onPan: widget.onPan,
            onTap: _handleTap,
            outline: showContour ? _outline : null,
            imageSize: Size(
              widget.image.width.toDouble(),
              widget.image.height.toDouble(),
            ),
            altKeyPressed: widget.altKeyPressed,
            brushSize: widget.brushSize,
            cursorPosition: _getCursorPosition(),
          ),
        ],
      ),
    );
  }

  /// 灏嗗綋鍓嶇姸鎬佹覆鏌撳埌鐢诲竷涓?
  Future<void> renderToCanvas(Canvas canvas, Size size) async {
    // 缁樺埗鑳屾櫙灞?
    canvas.drawImage(widget.image, Offset.zero, Paint());

    // 缁樺埗棰勮灞?
    final renderData = ref.read(pathRenderDataProvider);
    final paths = renderData.completedPaths ?? _paths;

    // 浣跨敤涓嶱reviewLayer鐩稿悓鐨勭粯鍒堕€昏緫
    final paint = Paint()..blendMode = BlendMode.srcOver;
    canvas.saveLayer(null, paint);

    try {
      // 缁樺埗鎵€鏈夊凡瀹屾垚鐨勮矾寰?
      for (final pathInfo in paths) {
        if (pathInfo.path.getBounds().isEmpty ||
            !pathInfo.path.getBounds().isFinite) {
          continue;
        }

        paint
          ..color = pathInfo.brushColor
          ..style = PaintingStyle.stroke
          ..strokeWidth = pathInfo.brushSize;

        canvas.drawPath(pathInfo.path, paint);
      }

      // 缁樺埗褰撳墠璺緞
      if (renderData.currentPath != null) {
        paint
          ..color = renderData.currentPath!.brushColor
          ..style = PaintingStyle.stroke
          ..strokeWidth = renderData.currentPath!.brushSize;

        canvas.drawPath(renderData.currentPath!.path, paint);
      }
    } finally {
      canvas.restore();
    }
  }

  void setOutline(DetectedOutline? outline) {
    print('EraseLayerStack 鏀跺埌杞粨璁剧疆: ${outline != null}');
    if (outline != null) {
      print('杞粨鍖呭惈 ${outline.contourPoints.length} 鏉¤矾寰?);
      if (outline.contourPoints.isNotEmpty &&
          outline.contourPoints[0].isNotEmpty) {
        double minX = double.infinity, minY = double.infinity;
        double maxX = -double.infinity, maxY = -double.infinity;

        for (var point in outline.contourPoints[0]) {
          minX = math.min(minX, point.dx);
          minY = math.min(minY, point.dy);
          maxX = math.max(maxX, point.dx);
          maxY = math.max(maxY, point.dy);
        }

        print('绗竴鏉¤疆寤撹竟鐣? ($minX,$minY) - ($maxX,$maxY)');
        print('鍥惧儚澶у皬: ${widget.image.width}x${widget.image.height}');
      }
    }

    if (mounted) {
      setState(() {
        _outline = outline;
      });
    }
  }

  void updateCurrentPath(PathInfo? path) {
    setState(() {
      _currentPath = path;
    });
  }

  void updateDirtyRect(Rect? rect) {
    setState(() {
      _dirtyBounds = rect;
    });
  }

  void updatePaths(List<PathInfo> paths) {
    setState(() {
      _paths = paths;
    });
  }

  Offset? _getCursorPosition() {
    final state = ref.read(eraseStateProvider);
    if (state.currentPath == null) return null;

    final bounds = state.currentPath!.path.getBounds();
    return bounds.center;
  }

  void _handlePointerDown(Offset position) {
    if (widget.altKeyPressed) return;
    widget.onEraseStart?.call(position);
  }

  void _handlePointerMove(Offset position, Offset delta) {
    if (widget.altKeyPressed) {
      widget.onPan?.call(delta);
      return;
    }
    widget.onEraseUpdate?.call(position, delta);
  }

  void _handlePointerUp(Offset position) {
    widget.onEraseEnd?.call();
  }

  void _handleTap(Offset position) {
    if (widget.altKeyPressed) return;

    widget.onEraseStart?.call(position);
    widget.onEraseEnd?.call();
    widget.onTap?.call(position);
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\widgets\character_edit\layers\preview_layer.dart
-----------------------------------
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';

import '../../../domain/models/character/path_info.dart';
import '../../../utils/debug/debug_flags.dart';
import 'base_layer.dart';

/// 棰勮鍥惧眰锛屾樉绀烘摝闄ら瑙堟晥鏋?
class PreviewLayer extends BaseLayer {
  final List<PathInfo> paths;
  final PathInfo? currentPath;
  final Rect? dirtyRect;

  const PreviewLayer({
    Key? key,
    this.paths = const [],
    this.currentPath,
    this.dirtyRect,
  }) : super(key: key);

  @override
  bool get isComplexPainting => false;

  @override
  bool get willChangePainting => true;

  @override
  CustomPainter createPainter() => _PreviewPainter(
        paths: paths,
        currentPath: currentPath,
        dirtyRect: dirtyRect,
      );
}

class _PreviewPainter extends CustomPainter {
  final List<PathInfo> paths;
  final PathInfo? currentPath;
  final Rect? dirtyRect;

  _PreviewPainter({
    required this.paths,
    this.currentPath,
    this.dirtyRect,
  });

  @override
  void paint(Canvas canvas, Size size) {
    if (kDebugMode) {
      print('缁樺埗棰勮灞?- 璺緞鏁伴噺: ${paths.length}, 褰撳墠璺緞: ${currentPath != null}');
    }

    // Apply global color blend mode - ensure erased areas display correctly
    final compositeMode = Paint()..blendMode = BlendMode.srcOver;
    canvas.saveLayer(null, compositeMode);

    try {
      // Draw all completed paths
      _drawAllPaths(canvas);

      // Draw current path if exists
      if (currentPath != null) {
        _drawCurrentPath(canvas);
      }
    } finally {
      canvas.restore(); // Ensure canvas state is restored
    }

    // 鍦ㄨ皟璇曟ā寮忎笅缁樺埗杈圭晫妗?
    if (kDebugMode && DebugFlags.enableEraseDebug && dirtyRect != null) {
      canvas.drawRect(
        dirtyRect!,
        Paint()
          ..style = PaintingStyle.stroke
          ..color = Colors.red
          ..strokeWidth = 1,
      );
    }
  }

  @override
  bool shouldRepaint(_PreviewPainter oldDelegate) {
    final shouldRepaint = paths != oldDelegate.paths ||
        currentPath?.path != oldDelegate.currentPath?.path ||
        dirtyRect != oldDelegate.dirtyRect;

    if (shouldRepaint && kDebugMode) {
      print('閲嶇粯棰勮灞?);
    }

    return shouldRepaint;
  }

  /// 缁樺埗鎵€鏈夊凡瀹屾垚鐨勮矾寰?
  void _drawAllPaths(Canvas canvas) {
    if (paths.isNotEmpty) {
      // 鍒涘缓鍙噸鐢ㄧ殑Paint瀵硅薄浠ユ彁楂樻€ц兘
      final paint = Paint();

      try {
        _drawPathsWithPaint(canvas, paint);
      } catch (e) {
        debugPrint('缁樺埗璺緞澶辫触: ${e.toString()}');
      }
    }
  }

  /// 缁樺埗褰撳墠娲诲姩璺緞
  void _drawCurrentPath(Canvas canvas) {
    if (currentPath != null) {
      try {
        final paint = Paint()
          ..color = currentPath!.brushColor
          ..style = PaintingStyle.stroke
          ..strokeWidth = currentPath!.brushSize;

        canvas.drawPath(currentPath!.path, paint);
      } catch (e) {
        debugPrint('缁樺埗褰撳墠璺緞澶辫触: ${e.toString()}');
      }
    }
  }

  /// 浣跨敤缁欏畾鐨凱aint瀵硅薄缁樺埗鎵€鏈夎矾寰?
  ///
  /// 灏嗙粯鍒堕€昏緫鍒嗙鍑烘潵浠ユ彁楂樹唬鐮佸彲璇绘€у拰鍙淮鎶ゆ€?
  void _drawPathsWithPaint(Canvas canvas, Paint paint) {
    for (final pathInfo in paths) {
      if (pathInfo.path.getBounds().isEmpty ||
          !pathInfo.path.getBounds().isFinite) {
        debugPrint('璺宠繃鏃犳晥璺緞');
        continue;
      }

      try {
        paint
          ..color = pathInfo.brushColor
          ..style = PaintingStyle.stroke // 浣跨敤鎻忚竟鏍峰紡鏉ュ簲鐢ㄧ嚎鏉＄矖缁?
          ..strokeWidth = pathInfo.brushSize;

        canvas.drawPath(pathInfo.path, paint);
      } catch (e) {
        debugPrint('缁樺埗鍗曚釜璺緞澶辫触: ${e.toString()}');
        // 缁х画缁樺埗鍏朵粬璺緞
      }
    }
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\widgets\character_edit\layers\ui_layer.dart
-----------------------------------
import 'dart:math' as math;

import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

import '../../../domain/models/character/detected_outline.dart';
import '../../../presentation/providers/character/erase_providers.dart';
import '../../../utils/debug/debug_flags.dart';

class BrushCursorPainter extends CustomPainter {
  final Offset position;
  final double size;
  final Color color;

  BrushCursorPainter({
    required this.position,
    required this.size,
    required this.color,
  });

  @override
  void paint(Canvas canvas, Size canvasSize) {
    final paint = Paint()
      ..color = color
      ..style = PaintingStyle.stroke
      ..strokeWidth = 1.0;

    canvas.drawCircle(position, size / 2, paint);
  }

  @override
  bool shouldRepaint(BrushCursorPainter oldDelegate) {
    return position != oldDelegate.position ||
        size != oldDelegate.size ||
        color != oldDelegate.color;
  }
}

/// UI鍥惧眰锛屽鐞嗙敤鎴蜂氦浜掑拰鏄剧ず鍏夋爣
class UILayer extends ConsumerStatefulWidget {
  final Function(Offset)? onPointerDown;
  final Function(Offset, Offset)? onPointerMove;
  final Function(Offset)? onPointerUp;
  final Function(Offset)? onPan;
  final Function(Offset)? onTap;
  final MouseCursor cursor;
  final DetectedOutline? outline;
  final Size? imageSize;
  final bool altKeyPressed;
  final double brushSize;
  final Offset? cursorPosition;

  const UILayer({
    Key? key,
    this.onPointerDown,
    this.onPointerMove,
    this.onPointerUp,
    this.onPan,
    this.onTap,
    this.cursor = SystemMouseCursors.precise,
    this.outline,
    this.imageSize,
    this.altKeyPressed = false,
    this.brushSize = 10.0,
    this.cursorPosition,
  }) : super(key: key);

  @override
  ConsumerState<UILayer> createState() => _UILayerState();
}

class _UILayerState extends ConsumerState<UILayer> {
  Offset? _mousePosition;
  int _updateCounter = 0;

  @override
  Widget build(BuildContext context) {
    final eraseState = ref.watch(eraseStateProvider);
    final currentCursor =
        widget.altKeyPressed ? SystemMouseCursors.move : widget.cursor;

    return MouseRegion(
      cursor: currentCursor,
      onHover: _handleMouseHover,
      child: Stack(
        children: [
          // 灏咰ustomPaint绉诲埌Stack椤跺眰锛岀‘淇濆畠鑳界粯鍒惰疆寤?
          CustomPaint(
            painter: _UIPainter(
              outline: widget.outline,
              imageSize: widget.imageSize,
              brushSize: widget.brushSize,
              cursorPosition: _mousePosition ?? widget.cursorPosition,
              altKeyPressed: widget.altKeyPressed,
            ),
            size: Size.infinite,
          ),

          GestureDetector(
            onTapUp: (details) {
              if (widget.onTap != null) {
                print('UI灞傛墽琛岀偣鍑诲洖璋? ${details.localPosition}');
                widget.onTap!(details.localPosition);
              }
            },
            onPanStart: (details) {
              if (kDebugMode && DebugFlags.enableEraseDebug) {
                print(
                    '鎵嬪娍寮€濮? ${details.localPosition}, Alt閿? ${widget.altKeyPressed}');
              }
              if (widget.onPointerDown != null) {
                widget.onPointerDown!(details.localPosition);
              }
            },
            onPanUpdate: (details) {
              if (kDebugMode &&
                  DebugFlags.enableEraseDebug &&
                  _updateCounter++ % 15 == 0) {
                print(
                    '鎵嬪娍鏇存柊: ${details.localPosition}, 澧為噺: ${details.delta}, Alt閿? ${widget.altKeyPressed}');
              }
              if (widget.onPointerMove != null) {
                widget.onPointerMove!(details.localPosition, details.delta);
              }
            },
            onPanEnd: (_) {
              if (kDebugMode && DebugFlags.enableEraseDebug) {
                print('鎵嬪娍缁撴潫, Alt閿? ${widget.altKeyPressed}');
              }
              if (widget.cursorPosition != null && widget.onPointerUp != null) {
                widget.onPointerUp!(widget.cursorPosition!);
              }
            },
            behavior: HitTestBehavior.opaque,
            child: Container(
              color: Colors.transparent,
            ),
          ),

          // 榧犳爣鍏夋爣缁樺埗
          if (_mousePosition != null && !widget.altKeyPressed)
            CustomPaint(
              painter: BrushCursorPainter(
                position: _mousePosition!,
                size: eraseState.brushSize,
                color: eraseState.brushColor.withOpacity(0.5),
              ),
            ),
        ],
      ),
    );
  }

  void _handleMouseHover(PointerHoverEvent event) {
    setState(() {
      _mousePosition = event.localPosition;
    });

    ref.read(cursorPositionProvider.notifier).state = event.localPosition;
  }
}

class _UIPainter extends CustomPainter {
  final DetectedOutline? outline;
  final Size? imageSize;
  final double brushSize;
  final Offset? cursorPosition;
  final bool altKeyPressed;

  _UIPainter({
    this.outline,
    this.imageSize,
    this.brushSize = 10.0,
    this.cursorPosition,
    this.altKeyPressed = false,
  });

  @override
  void paint(Canvas canvas, Size size) {
    // Only print in extreme debug mode
    if (kDebugMode && DebugFlags.enableEraseDebug && false) {
      print(
          'UILayer缁樺埗 - outline: ${outline != null}, imageSize: ${imageSize != null}');
    }

    if (outline != null && imageSize != null) {
      _drawOutline(canvas, size);
    }

    if (cursorPosition != null) {
      if (altKeyPressed) {
        _drawPanCursor(canvas, cursorPosition!);
      } else {
        _drawBrushCursor(canvas, cursorPosition!);
      }
    }
  }

  @override
  bool shouldRepaint(_UIPainter oldDelegate) =>
      outline != oldDelegate.outline ||
      imageSize != oldDelegate.imageSize ||
      brushSize != oldDelegate.brushSize ||
      cursorPosition != oldDelegate.cursorPosition ||
      altKeyPressed != oldDelegate.altKeyPressed;

  void _drawArrow(Canvas canvas, Offset start, Offset end, Paint paint) {
    canvas.drawLine(start, end, paint);

    final dx = end.dx - start.dx;
    final dy = end.dy - start.dy;
    final length = math.sqrt(dx * dx + dy * dy);
    final unitX = dx / length;
    final unitY = dy / length;

    final perpX = -unitY;
    final perpY = unitX;

    const arrowSize = 4.0;
    final arrowPoint1 = Offset(
      end.dx - unitX * arrowSize + perpX * arrowSize,
      end.dy - unitY * arrowSize + perpY * arrowSize,
    );
    final arrowPoint2 = Offset(
      end.dx - unitX * arrowSize - perpX * arrowSize,
      end.dy - unitY * arrowSize - perpY * arrowSize,
    );

    final path = Path()
      ..moveTo(end.dx, end.dy)
      ..lineTo(arrowPoint1.dx, arrowPoint1.dy)
      ..lineTo(arrowPoint2.dx, arrowPoint2.dy)
      ..close();
    canvas.drawPath(path, Paint()..color = Colors.blue);
  }

  void _drawBrushCursor(Canvas canvas, Offset position) {
    final outlinePaint = Paint()
      ..color = Colors.white.withOpacity(0.7)
      ..style = PaintingStyle.stroke
      ..strokeWidth = 1.5;

    final innerPaint = Paint()
      ..color = Colors.black.withOpacity(0.4)
      ..style = PaintingStyle.stroke
      ..strokeWidth = 1.0;

    final erasePaint = Paint()
      ..color = Colors.white.withOpacity(0.2)
      ..style = PaintingStyle.fill;

    canvas.drawCircle(position, brushSize / 2, erasePaint);
    canvas.drawCircle(position, brushSize / 2, outlinePaint);
    canvas.drawCircle(position, brushSize / 2 - 1.5, innerPaint);

    final crosshairPaint = Paint()
      ..color = Colors.white.withOpacity(0.9)
      ..style = PaintingStyle.stroke
      ..strokeWidth = 1.0;

    canvas.drawLine(
      Offset(position.dx - brushSize / 4, position.dy),
      Offset(position.dx + brushSize / 4, position.dy),
      crosshairPaint,
    );

    canvas.drawLine(
      Offset(position.dx, position.dy - brushSize / 4),
      Offset(position.dx, position.dy + brushSize / 4),
      crosshairPaint,
    );

    if (brushSize > 15) {
      final textPainter = TextPainter(
        text: TextSpan(
          text: brushSize.round().toString(),
          style: TextStyle(
            color: Colors.white.withOpacity(0.9),
            fontSize: 10,
            fontWeight: FontWeight.bold,
          ),
        ),
        textDirection: TextDirection.ltr,
      );
      textPainter.layout();
      textPainter.paint(
        canvas,
        position.translate(-textPainter.width / 2, -textPainter.height / 2),
      );
    }
  }

  void _drawOutline(Canvas canvas, Size size) {
    if (outline == null || imageSize == null) {
      if (kDebugMode && DebugFlags.enableEraseDebug) {
        print('_drawOutline: 鏃犺疆寤撴暟鎹垨鍥惧儚灏哄');
      }
      return;
    }

    // 鍑忓皯鏃ュ織鍐楅暱搴?
    if (kDebugMode && DebugFlags.enableEraseDebug) {
      print('寮€濮嬬粯鍒惰疆寤?);
    }

    if (outline!.contourPoints.isEmpty) {
      print('_drawOutline: 杞粨鐐归泦涓虹┖');
      return;
    }

    print('寮€濮嬬粯鍒惰疆寤? 鍏?${outline!.contourPoints.length} 鏉¤矾寰?);

    // 璁＄畻姝ｇ‘鐨勭缉鏀惧拰鍋忕Щ浠ョ‘淇濊疆寤撲笌鍥惧儚瀵归綈
    final scaleX = size.width / imageSize!.width;
    final scaleY = size.height / imageSize!.height;

    // 浣跨敤缁熶竴缂╂斁姣斾緥閬垮厤鍙樺舰
    final scale = math.min(scaleX, scaleY);

    // 璁＄畻灞呬腑鍋忕Щ
    final offsetX = (size.width - imageSize!.width * scale) / 2;
    final offsetY = (size.height - imageSize!.height * scale) / 2;

    // 澧炲己杞粨绾挎潯娓呮櫚搴?
    final mainStrokePaint = Paint()
      ..color = Colors.blue.withOpacity(0.8) // 鎻愰珮涓嶉€忔槑搴?
      ..style = PaintingStyle.stroke
      ..strokeWidth = 1.2 / scale // 寰井鍔犵矖杞粨绾?
      ..strokeCap = StrokeCap.round
      ..strokeJoin = StrokeJoin.round
      ..isAntiAlias = true; // 纭繚鎶楅敮榻?

    final outerStrokePaint = Paint()
      ..color = Colors.white.withOpacity(0.8) // 鎻愰珮涓嶉€忔槑搴?
      ..style = PaintingStyle.stroke
      ..strokeWidth = 2.2 / scale // 鍔犵矖澶栬竟妗?
      ..strokeCap = StrokeCap.round
      ..strokeJoin = StrokeJoin.round
      ..isAntiAlias = true; // 纭繚鎶楅敮榻?

    canvas.save();
    // 搴旂敤姝ｇ‘鐨勫彉鎹?
    canvas.translate(offsetX, offsetY);
    canvas.scale(scale);

    int contourCount = 0;
    int pointCount = 0;

    for (final contour in outline!.contourPoints) {
      if (contour.length < 2) {
        continue;
      }

      pointCount += contour.length;

      // 浣跨敤path鏉ョ粯鍒跺鏉傝疆寤撳彲鑾峰緱鏇村ソ鐨勬€ц兘鍜岃川閲?
      final path = Path();
      path.moveTo(contour[0].dx, contour[0].dy);

      for (int i = 1; i < contour.length; i++) {
        path.lineTo(contour[i].dx, contour[i].dy);
      }
      path.close();

      // 鍏堢粯鍒跺鎻忚竟鍐嶇粯鍒跺唴鎻忚竟锛岀‘淇濆彲瑙佹€?
      canvas.drawPath(path, outerStrokePaint);
      canvas.drawPath(path, mainStrokePaint);

      contourCount++;
    }

    print('鎴愬姛缁樺埗浜?$contourCount 涓疆寤擄紝鍏?$pointCount 涓疆寤撶偣');

    canvas.restore();
  }

  void _drawPanCursor(Canvas canvas, Offset position) {
    final paint = Paint()
      ..color = Colors.blue.withOpacity(0.7)
      ..strokeWidth = 2.0
      ..style = PaintingStyle.stroke;

    canvas.drawCircle(
      position,
      15.0,
      Paint()
        ..color = Colors.blue.withOpacity(0.2)
        ..style = PaintingStyle.fill,
    );

    canvas.drawCircle(position, 14.0, paint);

    _drawArrow(canvas, position, Offset(position.dx, position.dy - 12), paint);
    _drawArrow(canvas, position, Offset(position.dx, position.dy + 12), paint);
    _drawArrow(canvas, position, Offset(position.dx - 12, position.dy), paint);
    _drawArrow(canvas, position, Offset(position.dx + 12, position.dy), paint);

    final textPainter = TextPainter(
      text: const TextSpan(
        text: 'Pan',
        style: TextStyle(
          color: Colors.blue,
          fontSize: 10,
          fontWeight: FontWeight.bold,
        ),
      ),
      textDirection: TextDirection.ltr,
    );
    textPainter.layout();
    textPainter.paint(
      canvas,
      position.translate(-textPainter.width / 2, 16),
    );
  }
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\widgets\character_edit\layers\events\event_dispatcher.dart
-----------------------------------
import 'layer_event.dart';

/// 浜嬩欢鍒嗗彂鍣ㄧ被
class EventDispatcher {
  final Map<LayerType, LayerEventHandler> _handlers = {};

  /// 鍒嗗彂浜嬩欢鍒版敞鍐岀殑澶勭悊鍣?
  /// 杩斿洖鏄惁鏈夊鐞嗗櫒澶勭悊浜嗚浜嬩欢
  bool dispatchEvent(LayerEvent event) {
    if (event.isHandled) return true;

    // 鎸変紭鍏堢骇椤哄簭灏濊瘯澶勭悊浜嬩欢
    final handlerTypes = [
      LayerType.ui, // UI灞備紭鍏堝鐞?
      LayerType.preview, // 鐒跺悗鏄瑙堝眰
      LayerType.background, // 鏈€鍚庢槸鑳屾櫙灞?
    ];

    for (final type in handlerTypes) {
      final handler = _handlers[type];
      if (handler != null && handler.handleEvent(event)) {
        event.markHandled();
        return true;
      }
    }

    return false;
  }

  /// 娉ㄥ唽鍥惧眰浜嬩欢澶勭悊鍣?
  void registerHandler(LayerType type, LayerEventHandler handler) {
    _handlers[type] = handler;
  }

  /// 绉婚櫎鍥惧眰浜嬩欢澶勭悊鍣?
  void removeHandler(LayerType type) {
    _handlers.remove(type);
  }
}

/// 鍥惧眰浜嬩欢澶勭悊鍣ㄦ帴鍙?
abstract class LayerEventHandler {
  bool handleEvent(LayerEvent event);
}

/// 瀹氫箟鍥惧眰绫诲瀷鏋氫妇
enum LayerType {
  background,
  preview,
  ui,
}



C:\Users\wailik\Documents\Code\Flutter\demo\demo\lib\widgets\character_edit\layers\events\layer_event.dart
-----------------------------------
import 'package:flutter/material.dart';

/// 鎷栧姩缁撴潫浜嬩欢
class DragEndEvent extends LayerEvent {
  DragEndEvent({required super.position});
}

/// 鎷栧姩寮€濮嬩簨浠?
class DragStartEvent extends LayerEvent {
  DragStartEvent({required super.position});
}

/// 鎷栧姩鏇存柊浜嬩欢
class DragUpdateEvent extends LayerEvent {
  final Offset delta;

  DragUpdateEvent({
    required super.position,
    required this.delta,
  });
}

/// 鍥惧眰浜嬩欢鍩虹被
abstract class LayerEvent {
  /// 浜嬩欢鍙戠敓鐨勪綅缃?
  final Offset position;

  /// 鏄惁宸茶澶勭悊
  bool _handled = false;

  LayerEvent({required this.position});

  /// 妫€鏌ヤ簨浠舵槸鍚﹀凡琚鐞?
  bool get isHandled => _handled;

  /// 鏍囪浜嬩欢宸茶澶勭悊
  void markHandled() {
    _handled = true;
  }
}

/// 鐐瑰嚮浜嬩欢
class TapEvent extends LayerEvent {
  TapEvent({required super.position});
}



