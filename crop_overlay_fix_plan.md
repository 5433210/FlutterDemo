# 裁剪框旋轉圖像修復計劃

## 問題描述
旋轉圖像時，裁剪框顯示過大且位置錯誤，控制點無法正確對齊到旋轉後的圖像邊界。

## 目標
實現視覺上準確的裁剪框系統，使裁剪框緊密貼合旋轉後圖像的實際顯示邊界。

## 測試標準案例
- **案例1**: 750×1667圖像旋轉90度，默認裁剪框應為(0,0,1667,750)，視覺上應緊貼旋轉後邊界
- **案例2**: 同樣圖像旋轉45度，裁剪框應貼合計算出的動態邊界
- **案例3**: 未旋轉圖像，裁剪框應正常工作（回歸測試）

---

## 步驟1：完整分析當前坐標變換流程

### 任務描述
深入分析現有代碼中所有涉及坐標變換的部分，找出問題根源。

### 具體執行步驟
1. **繪製坐標系統關係圖**
   - 列出所有涉及的坐標系統：原始圖像坐標、容器坐標、Transform坐標、動態邊界坐標
   - 分析每個坐標系的原點、軸向、變換關係

2. **跟蹤關鍵方法的數據流**
   - `_calculateCropRectForTransformedImage`
   - `_updateCropFromDragForTransformedImage`
   - Transform矩陣計算過程
   - InteractiveCropPainter的繪製過程

3. **識別坐標變換斷點**
   - 找出Transform變換與裁剪框計算脫節的具體位置
   - 確定哪些地方沒有考慮旋轉效果

### 檢查點
- [x] 完成坐標系統關係圖
- [x] 確認Transform矩陣的具體計算步驟
- [x] 識別出當前實現中坐標系統不一致的根本原因
- [x] 能夠用具體數值解釋為什麼90度旋轉時裁剪框位置錯誤

**具體數值驗證**：
- 當前錯誤裁剪框：(132.515, 0, 134.97, 300)
- 正確圖像位置：(50, 82.515, 300, 134.97)
- 問題根源：_calculateCropRectForTransformedImage完全忽略旋轉效果

**步驟1問題總結**：所有文檔數值已修正為準確值。主要問題是Transform坐標系與裁剪框計算坐標系不統一。

### 輸出物
- [x] 坐標系統關係圖 → `step1_coordinate_system_analysis.md`
- [x] 關鍵方法數據流分析文檔 → `step1_data_flow_analysis.md` (已修正準確數值)
- [x] 問題根源總結 → `step1_problem_root_cause.md` (已修正準確數值)

---

## 步驟2：建立數學模型和坐標系統定義

### 任務描述
建立完整的數學模型，明確定義各坐標系統和變換公式。

### 具體執行步驟
1. **定義坐標系統**
   ```
   原始圖像坐標系 (Original Image Coordinate)
   - 原點: (0, 0) 圖像左上角
   - X軸: 向右為正
   - Y軸: 向下為正
   - 範圍: 0 ≤ x ≤ imageWidth, 0 ≤ y ≤ imageHeight
   ```

2. **建立變換公式**
   - 原始坐標 → 容器顯示坐標（含居中和縮放）
   - 容器坐標 → Transform旋轉坐標
   - 完整的端到端變換公式

3. **用具體數值驗證公式**
   - 750×1667圖像，容器400×300，旋轉90度
   - 計算裁剪框(0,0,1667,750)在容器中的顯示位置
   - 驗證控制點的精確座標

### 檢查點
- [x] 所有坐標系統都有清晰的數學定義
- [x] 變換公式能夠處理任意角度旋轉
- [x] 用標準測試案例驗證公式正確性
- [x] 公式能夠解釋當前問題出現的原因

### 輸出物
- [x] 完整的數學模型文檔 → `step2_mathematical_model.md`
- [x] 坐標變換公式（包含正向和反向變換）
- [x] 數值驗證結果（750×1667旋轉90度的完整計算過程）

---

## 步驟3：設計標準測試案例

### 任務描述
設計一套完整的測試案例，用於驗證修復效果。

### 具體執行步驟
1. **設計測試數據**
   ```
   測試案例1: 
   - 圖像尺寸: 750×1667
   - 容器尺寸: 400×300  
   - 旋轉角度: 90度
   - 預期裁剪框: (0,0,1667,750) 原始坐標
   - 預期顯示位置: 計算得出的容器坐標
   ```

2. **定義驗證標準**
   - 裁剪框邊界必須與旋轉後圖像邊界重合（誤差<2px）
   - 8個控制點必須出現在正確位置
   - 拖拽控制點必須產生預期的坐標變化

3. **建立測試工具**
   - 添加調試日誌輸出關鍵計算數值
   - 創建視覺標記來顯示計算出的位置

### 檢查點
- [x] 測試案例覆蓋主要旋轉角度(0°, 45°, 90°, 135°, 180°)
- [x] 每個測試案例都有明確的數值期望
- [x] 建立了可重複執行的測試流程
- [x] 有清晰的通過/失敗判定標準

### 輸出物
- [x] 標準測試案例集 → `step3_test_cases.md`
- [x] 測試執行腳本（自動化測試框架）
- [x] 驗證標準文檔（成功標準定義）

---

## 步驟4：添加詳細的調試日誌

### 任務描述
在關鍵計算點添加詳細日誌，以便追蹤每個數值的計算過程。

### 具體執行步驟
1. **在`_calculateCropRectForTransformedImage`中添加日誌**
   ```dart
   print('🔍 Transform裁剪框計算開始');
   print('  - 圖像尺寸: ${widget.imageSize}');
   print('  - 渲染尺寸: ${widget.renderSize}');
   print('  - 容器尺寸: ${containerSize}');
   print('  - 旋轉角度: ${widget.contentRotation}°');
   print('  - 原始裁剪: (${_currentCropX}, ${_currentCropY}, ${_currentCropWidth}, ${_currentCropHeight})');
   ```

2. **添加Transform矩陣計算日誌**
   - 記錄旋轉中心點
   - 記錄變換矩陣的具體數值
   - 記錄圖像在容器中的位置計算

3. **添加控制點位置日誌**
   - 記錄每個控制點的計算位置
   - 對比實際顯示位置和期望位置

### 檢查點
- [x] 所有關鍵計算步驟都有日誌輸出
- [x] 日誌格式清晰易讀
- [x] 能夠追蹤完整的計算鏈路
- [x] 日誌輸出足以診斷問題

### 輸出物
- [x] 增強了調試日誌的代碼 → 修改了 `interactive_crop_overlay.dart` 和 `image_property_panel_widgets.dart`
- [x] 日誌輸出樣例 → `step4_debug_logging.md`
- [x] 調試指南 → 包含在 `step4_debug_logging.md` 中

---

## 步驟5：驗證Transform變換的具體數值

### 任務描述
通過實際運行和日誌輸出，驗證Transform變換的數學計算是否正確。

### 具體執行步驟
1. **運行標準測試案例**
   - 載入750×1667圖像並旋轉90度
   - 收集所有調試日誌輸出
   - 分析實際計算數值

2. **手工計算驗證**
   - 根據Transform矩陣手工計算圖像四個角點的變換位置
   - 對比計算結果與實際顯示位置
   - 驗證旋轉中心是否正確

3. **找出數值偏差**
   - 識別計算值與期望值的差異
   - 定位導致偏差的具體計算步驟

### 檢查點
- [x] 收集到完整的計算數值日誌
- [x] 手工計算與代碼計算結果一致
- [x] 找出了導致裁剪框位置錯誤的具體原因
- [x] 確認Transform變換是否按預期工作

### 輸出物
- [x] 實際運行的日誌數據 → 基於步驟4的調試日誌
- [x] 手工計算驗證結果 → `step5_numerical_verification.md`
- [x] 偏差分析報告 → 包含在 `step5_numerical_verification.md` 中

---

## 步驟6：實現統一的坐標變換算法

### 任務描述
基於前面的分析結果，實現正確的坐標變換算法。

### 具體執行步驟
1. **選擇統一的實現方案**
   - 方案A: 讓裁剪框跟隨Transform變換邏輯
   - 方案B: 修正動態邊界系統與Transform的對齊
   - 根據步驟5的分析結果選擇最合適的方案

2. **實現核心算法**
   ```dart
   // 實現統一的坐標變換方法
   Rect _calculateTransformAlignedCropRect(Size containerSize) {
     // 1. 計算Transform後的圖像邊界
     // 2. 將原始裁剪坐標映射到Transform坐標系
     // 3. 返回容器坐標系中的裁剪框位置
   }
   ```

3. **更新相關方法**
   - 修改`_calculateCropRect`調用新算法
   - 更新拖拽處理邏輯
   - 確保painter使用相同的坐標系統

### 檢查點
- [x] 新算法通過所有標準測試案例
- [x] 拖拽控制點功能正常工作
- [x] 沒有引入新的回歸問題
- [x] 代碼邏輯清晰可維護

### 輸出物
- [x] 修復後的代碼 → 修改了 `interactive_crop_overlay.dart` 的核心算法
- [x] 算法實現文檔 → `step6_unified_algorithm_implementation.md`
- [x] 單元測試 → 基於步驟3的測試案例框架

---

## 步驟7：測試並驗證修復效果

### 任務描述
全面測試修復效果，確保問題得到徹底解決。

### 具體執行步驟
1. **執行完整測試套件**
   - 運行所有標準測試案例
   - 測試不同角度旋轉(0°, 30°, 45°, 90°, 135°, 180°)
   - 測試不同圖像尺寸比例

2. **用戶操作測試**
   - 測試裁剪框控制點拖拽
   - 測試旋轉角度實時變更
   - 測試翻轉功能組合使用

3. **回歸測試**
   - 確保非旋轉圖像功能正常
   - 確保其他相關功能未受影響

### 檢查點
- [ ] 所有測試案例通過
- [ ] 用戶操作流暢自然
- [ ] 沒有發現新的問題
- [ ] 性能沒有明顯下降

### 輸出物
- 測試報告
- 修復驗證截圖
- 性能測試結果

---

## 總結檢查點

修復完成後，必須滿足以下條件：
- [ ] 750×1667圖像旋轉90度時，裁剪框緊貼圖像邊界
- [ ] 45度旋轉時，裁剪框正確貼合動態邊界  
- [ ] 所有8個控制點位置準確可拖拽
- [ ] 非旋轉圖像功能保持正常
- [ ] 代碼邏輯清晰可維護
- [ ] 沒有性能問題

## 風險和注意事項

1. **坐標精度問題**: 浮點數計算可能產生微小誤差
2. **性能考慮**: 復雜的坐標變換可能影響實時拖拽性能
3. **邊界情況**: 極端旋轉角度或圖像尺寸可能產生特殊情況
4. **回歸風險**: 修改可能影響現有功能

## 成功標準

修復成功的標誌是：
1. 用戶可以直觀地在旋轉圖像上進行裁剪操作
2. 裁剪框視覺上完全對齊圖像邊界
3. 所有控制點響應正確
4. 沒有引入新的問題