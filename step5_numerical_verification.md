# 步驟5輸出物：Transform變換數值驗證

## 數值驗證策略

基於步驟2的數學模型和步驟4的調試日誌，我們需要驗證Transform變換的實際計算結果是否與理論預期一致。

## 手工數學驗證

### 測試案例：750×1667圖像，90度旋轉，400×300容器

#### 階段1：未旋轉時的基礎計算

```dart
// 輸入參數
imageSize = Size(750, 1667)
containerSize = Size(400, 300)
rotationDegrees = 90.0

// 步驟1：計算renderSize
imageRatio = imageSize.width / imageSize.height 
          = 750 / 1667 
          = 0.4499

containerRatio = containerSize.width / containerSize.height
               = 400 / 300 
               = 1.3333

// 因為 imageRatio < containerRatio (0.4499 < 1.3333)
// 所以以容器高度為準（contain模式）
renderSize = Size(
  containerSize.height * imageRatio,  // 300 * 0.4499 = 134.97
  containerSize.height                // 300
) = Size(134.97, 300)

// 步驟2：計算圖像居中位置
imagePosition = Offset(
  (containerSize.width - renderSize.width) / 2,   // (400 - 134.97) / 2 = 132.515
  (containerSize.height - renderSize.height) / 2  // (300 - 300) / 2 = 0
) = Offset(132.515, 0)

// 步驟3：未旋轉時的圖像區域
unrotatedImageRect = Rect.fromLTWH(132.515, 0, 134.97, 300)
```

#### 階段2：Transform變換計算

```dart
// Transform變換參數
centerX = containerSize.width / 2 = 400 / 2 = 200
centerY = containerSize.height / 2 = 300 / 2 = 150
rotationRadians = 90 * (π / 180) = π/2 = 1.5708

// Transform矩陣操作順序：
// 1. translate(200, 150)  - 移動到容器中心
// 2. rotateZ(π/2)         - 順時針旋轉90度
// 3. translate(-200, -150) - 移回原位

// 四個角點變換計算
corners = [
  topLeft:     (132.515, 0),
  topRight:    (267.485, 0),    // 132.515 + 134.97
  bottomRight: (267.485, 300),  // 132.515 + 134.97, 0 + 300
  bottomLeft:  (132.515, 300)   // 132.515, 0 + 300
]

// 90度順時針旋轉變換公式：
// 對於點 (x, y)，圍繞中心 (cx, cy) 旋轉90度：
// x' = -(y - cy) + cx
// y' = (x - cx) + cy

transformedCorners = [
  topLeft:     (-(0 - 150) + 200, (132.515 - 200) + 150) = (350, 82.515),
  topRight:    (-(0 - 150) + 200, (267.485 - 200) + 150) = (350, 217.485),
  bottomRight: (-(300 - 150) + 200, (267.485 - 200) + 150) = (50, 217.485),
  bottomLeft:  (-(300 - 150) + 200, (132.515 - 200) + 150) = (50, 82.515)
]

// 計算變換後的邊界框
minX = min(350, 350, 50, 50) = 50
maxX = max(350, 350, 50, 50) = 350
minY = min(82.515, 217.485, 217.485, 82.515) = 82.515
maxY = max(82.515, 217.485, 217.485, 82.515) = 217.485

// 最終變換後的邊界框
transformedBounds = Rect.fromLTRB(50, 82.515, 350, 217.485)
                  = Rect.fromLTWH(50, 82.515, 300, 134.97)
```

#### 階段3：裁剪框計算驗證

```dart
// 全圖裁剪的情況
cropParams = (x: 0, y: 0, width: 750, height: 1667)

// 裁剪比例
cropRatioX = 0 / 750 = 0
cropRatioY = 0 / 1667 = 0
cropRatioWidth = 750 / 750 = 1.0
cropRatioHeight = 1667 / 1667 = 1.0

// 正確的統一計算（應該匹配Transform結果）
correctCropRect = transformedBounds = Rect.fromLTWH(50, 82.515, 300, 134.97)

// 當前錯誤的計算（忽略旋轉）
currentWrongCropRect = Rect.fromLTWH(
  132.515 + (0 * 134.97),  // 132.515
  0 + (0 * 300),           // 0
  1.0 * 134.97,            // 134.97
  1.0 * 300                // 300
) = Rect.fromLTWH(132.515, 0, 134.97, 300)
```

## 預期日誌驗證

根據步驟4添加的調試日誌，運行應用時應該看到以下輸出：

### Transform變換日誌
```
🔍 === Transform矩陣構建 ===
  - 容器尺寸: 400.0×300.0
  - 旋轉中心: (200.0, 150.0)
  - 旋轉角度: 90° = 1.5708 radians
  - 📍 原始圖像區域: Rect.fromLTWH(132.5, 0.0, 135.0, 300.0)
  - 🔄 角點變換計算:
    - 左上: (132.5, 0.0) → (350.0, 82.5)
    - 右上: (267.5, 0.0) → (350.0, 217.5)
    - 右下: (267.5, 300.0) → (50.0, 217.5)
    - 左下: (132.5, 300.0) → (50.0, 82.5)
  - 📍 變換後邊界框: Rect.fromLTRB(50.0, 82.5, 350.0, 217.5)
  - 📍 變換後尺寸: 300.0×135.0
```

### 裁剪框計算日誌
```
🔍 === _calculateCropRectForTransformedImage 开始 ===
  - containerSize: 400.0×300.0
  - imageSize: 750.0×1667.0
  - renderSize: 134.97×300.0
  - contentRotation: 90°
  - ⚠️ 警告：当前算法忽略了90°旋转！
  - 📍 90度旋转后的预期位置: left=50.0, top=82.5
  - 📍 90度旋转后的预期尺寸: 300.0×135.0
  - ✅ 最终结果（忽略旋转的错误结果）: Rect.fromLTWH(132.5, 0.0, 135.0, 300.0)
  - ❌ 问题：此结果未考虑旋转，与实际显示不匹配！
```

## 數值偏差分析

### 關鍵差異對比
```
項目                     | 正確值(Transform)        | 錯誤值(當前計算)         | 差異
------------------------|-------------------------|-------------------------|------------------
左上角X坐標              | 50.0                    | 132.515                 | 82.515像素偏移
左上角Y坐標              | 82.515                  | 0.0                     | 82.515像素偏移  
寬度                    | 300.0                   | 134.97                  | 165.03像素差異
高度                    | 134.97                  | 300.0                   | 165.03像素差異
中心點X                 | 200.0                   | 200.0                   | 0（巧合正確）
中心點Y                 | 150.0                   | 150.0                   | 0（巧合正確）
```

### 視覺影響分析
```
錯誤的裁剪框：
┌─────────────────────────────────────────┐ 400×300容器
│                   ┌──────┐              │
│                   │ 錯誤 │              │ 134.97×300
│                   │ 的   │              │ 位置：(132.515, 0)
│                   │ 裁剪 │              │
│                   │ 框   │              │
│                   │      │              │
│                   └──────┘              │
└─────────────────────────────────────────┘

正確的裁剪框（應該匹配旋轉後的圖像）：
┌─────────────────────────────────────────┐ 400×300容器
│                                         │
│    ┌─────────────────────────────┐      │ 300×134.97
│    │        正確的裁剪框          │      │ 位置：(50, 82.515)
│    └─────────────────────────────┘      │
│                                         │
└─────────────────────────────────────────┘
```

## 其他角度驗證

### 45度旋轉計算
```dart
// 45度旋轉更複雜，需要使用三角函數
rotationRadians = 45 * (π / 180) = π/4 = 0.7854
cos(π/4) = sin(π/4) = √2/2 ≈ 0.7071

// 對於原始圖像區域 134.97×300
// 旋轉後的包圍盒尺寸計算：
newWidth = |134.97 * cos(π/4)| + |300 * sin(π/4)|
         = 134.97 * 0.7071 + 300 * 0.7071
         = 95.44 + 212.13
         = 307.57

newHeight = |134.97 * sin(π/4)| + |300 * cos(π/4)|
          = 134.97 * 0.7071 + 300 * 0.7071  
          = 95.44 + 212.13
          = 307.57

// 45度旋轉後的邊界框將會是正方形：307.57×307.57
// 但這會超出300高度的容器限制，所以會被裁剪
```

### 0度旋轉驗證（回歸測試）
```dart
// 0度旋轉應該與未旋轉完全一致
rotationDegrees = 0
transformedBounds = unrotatedImageRect = Rect.fromLTWH(132.515, 0, 134.97, 300)

// 這種情況下，當前錯誤的算法碰巧會得到正確結果
// 這就是為什麼非旋轉圖像工作正常的原因
```

## 測試執行計劃

### 1. 實際運行驗證
```
步驟：
1. 載入750×1667圖像
2. 旋轉90度  
3. 檢查控制台日誌
4. 對比實際數值與預期數值

預期驗證點：
✓ renderSize: 134.97×300
✓ imagePosition: (132.515, 0)
✓ Transform中心: (200, 150)
✓ 變換後邊界: (50, 82.515, 300, 134.97)
✗ 當前裁剪框: (132.515, 0, 134.97, 300) - 錯誤
```

### 2. 邊界情況測試
```
測試案例：
- 0度：應該匹配
- 45度：應該有明顯差異
- 90度：應該寬高互換
- 180度：應該有180度對稱
- 270度：應該與90度相似但方向相反
```

### 3. 精度驗證
```
允許誤差範圍：
- 位置誤差: < 0.5像素
- 尺寸誤差: < 0.5像素  
- 角度精度: < 0.01度
```

## 驗證結果預期

### 成功標準
1. **Transform計算正確**：角點變換數值與手工計算一致
2. **問題確認**：當前裁剪框計算確實忽略旋轉
3. **數值精確**：所有關鍵數值在誤差範圍內
4. **日誌完整**：能夠追蹤完整的計算過程

### 失敗情況處理
如果驗證發現：
1. **Transform計算錯誤**：需要修正Transform矩陣構建
2. **數值精度問題**：需要調整計算精度
3. **邊界情況異常**：需要添加邊界檢查

## 手工計算表格驗證

### 90度旋轉完整計算表
| 步驟 | 計算項目 | 公式 | 輸入值 | 計算過程 | 結果 |
|-----|---------|------|-------|---------|------|
| 1 | imageRatio | width/height | 750,1667 | 750/1667 | 0.4499 |
| 2 | containerRatio | width/height | 400,300 | 400/300 | 1.3333 |
| 3 | renderSize.width | height×ratio | 300,0.4499 | 300×0.4499 | 134.97 |
| 4 | renderSize.height | height | 300 | 300 | 300 |
| 5 | imageLeft | (cW-rW)/2 | 400,134.97 | (400-134.97)/2 | 132.515 |
| 6 | imageTop | (cH-rH)/2 | 300,300 | (300-300)/2 | 0 |
| 7 | 旋轉中心X | containerW/2 | 400 | 400/2 | 200 |
| 8 | 旋轉中心Y | containerH/2 | 300 | 300/2 | 150 |
| 9 | 左上角變換X | -(y-cy)+cx | 0,150,200 | -(0-150)+200 | 350 |
| 10 | 左上角變換Y | (x-cx)+cy | 132.515,200,150 | (132.515-200)+150 | 82.515 |
| 11 | 變換後left | min(corners.x) | 350,350,50,50 | min(...) | 50 |
| 12 | 變換後top | min(corners.y) | 82.515,217.485,... | min(...) | 82.515 |
| 13 | 變換後width | max(x)-min(x) | 350,50 | 350-50 | 300 |
| 14 | 變換後height | max(y)-min(y) | 217.485,82.515 | 217.485-82.515 | 134.97 |

### 驗證檢查點
- [ ] renderSize計算：134.97×300 ✓
- [ ] 圖像位置：(132.515, 0) ✓  
- [ ] 旋轉中心：(200, 150) ✓
- [ ] 變換後位置：(50, 82.515) ✓
- [ ] 變換後尺寸：300×134.97 ✓
- [ ] 當前錯誤結果：(132.515, 0, 134.97, 300) ✓

這個詳細的數值驗證為步驟6的統一算法實現提供了精確的目標值和驗證標準。